This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.agent/rules/tradingbot.md
.claude/settings.local.json
.env.example
.gitignore
analysis_report.md
CLAUDE.md
client/.gitignore
client/eslint.config.js
client/index.html
client/package.json
client/public/header_full.png
client/public/header_logo.png
client/public/logo.png
client/public/vite.svg
client/README.md
client/repomix-output.xml
client/src/App.css
client/src/App.tsx
client/src/assets/react.svg
client/src/components/AIStatus.tsx
client/src/components/ChallengeCard.tsx
client/src/components/EquityChart.tsx
client/src/components/Header.tsx
client/src/components/NarrativeStream.tsx
client/src/components/Positions.tsx
client/src/components/StatsGrid.tsx
client/src/components/TokenScanner.tsx
client/src/components/TradeList.tsx
client/src/components/Watchlist.tsx
client/src/hooks/useSocket.ts
client/src/index.css
client/src/main.tsx
client/src/types.ts
client/tsconfig.app.json
client/tsconfig.json
client/tsconfig.node.json
client/vite.config.ts
compass_artifact_wf-5de4dceb-d091-494d-8f41-98c8abdc8dd6_text_markdown.md
FLOWCHART.md
jest.config.js
package.json
Procfile
public/1 - 100 (1).png
public/1 to 100 Sol Challenge.png
public/index.html
public/Untitled design (48).png
src/__tests__/position-manager.test.ts
src/__tests__/setup.ts
src/__tests__/token-watchlist.test.ts
src/ai/ddqn-agent.ts
src/ai/index.ts
src/ai/position-sizer.ts
src/ai/regime-detector.ts
src/ai/types.ts
src/api/index.ts
src/api/routes.ts
src/api/server.ts
src/api/websocket.ts
src/config/settings.ts
src/db/repository.ts
src/db/schema.ts
src/db/types.ts
src/execution/index.ts
src/execution/jito-bundle.ts
src/execution/jupiter-swap.ts
src/execution/pumpfun-swap.ts
src/execution/tx-manager.ts
src/execution/types.ts
src/index.ts
src/learning/index.ts
src/learning/model-trainer.ts
src/learning/performance.ts
src/learning/trade-logger.ts
src/learning/types.ts
src/risk/capital-allocator.ts
src/risk/drawdown-guard.ts
src/risk/index.ts
src/risk/position-manager.ts
src/risk/types.ts
src/scripts/analyze-wallets.ts
src/scripts/discover-whales.ts
src/scripts/find-smart-wallets.ts
src/services/equity-tracker.ts
src/services/index.ts
src/services/position-reconciler.ts
src/services/wallet-sync.ts
src/signals/axiom-sensor.ts
src/signals/entry-evaluator.ts
src/signals/feature-extractor.ts
src/signals/index.ts
src/signals/narrative-sensor.ts
src/signals/news-sensor.ts
src/signals/pump-detector.ts
src/signals/rug-detector.ts
src/signals/rug-monitor.ts
src/signals/token-watchlist.ts
src/signals/types.ts
src/signals/velocity-tracker.ts
src/test-velocity.ts
src/utils/logger.ts
tsconfig.json
wallet.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="analysis_report.md">
# ðŸ“Š Wallet Analysis Report

**Generated:** 2026-01-22T17:50:52.050Z
**Total Wallets Analyzed:** 14
**Keepers Found:** 6

| Address | Score | Verdict | Win Rate | ROI | PnL | Tokens | Est. Hold Time | Flags |
|---------|-------|---------|----------|-----|-----|--------|----------------|-------|
| `5NszqQ4X78p7gVVJCRj9heobwHhiPFNAw23Xn8t8swn9` | **66** | âœ… KEEP | 67% | 1092% | 59.32 SOL | 2/3 | 2189s | Fresh Wallet |
| `2573AbP8EUacZZqx5TAkv4XFUkubmRGee2nScjYpMGFg` | **55** | âœ… KEEP | 75% | 152% | 3.44 SOL | 3/4 | 2024s | Fresh Wallet |
| `GTUFPqUSkv3emUSJXjsBMfJMx6R6abNNzaPnLnkNckhu` | **54** | âœ… KEEP | 27% | 213% | 36.83 SOL | 3/11 | 738s | Fresh Wallet |
| `HQYLrckNnctASrmqh4u6nSCqPSQdmjgUVJqb2EZc64V` | **53** | âœ… KEEP | 67% | 32% | 6.31 SOL | 4/6 | 414s | Fresh Wallet |
| `ApeiTAjq3V9grbN2jVbmpLb59wffYmwCBKZnugyuerLZ` | **52** | âœ… KEEP | 49% | 21% | 11.36 SOL | 18/37 | 1374s | Fresh Wallet |
| `Hzrc9hdpkvrMK8GXyHsZCt1B4E5DAkSLWa4pszFVWDXC` | **51** | âœ… KEEP | 42% | 86% | 3.48 SOL | 5/12 | 1196s | Fresh Wallet |
| `CapMjGxH3oa6XCjQVQq2Y8VvHz4PeC7uuYvYoA2GLVzu` | **50** | Xu274 DISCARD | 67% | 11% | 1.01 SOL | 6/9 | 15089s | Fresh Wallet |
| `HguEXBKHhBbLuPhoGLtzww27abKXZvCFu5JkcYiLEeSm` | **47** | Xu274 DISCARD | 38% | 4% | 0.45 SOL | 6/16 | 1448s | Fresh Wallet |
| `CPhA4xZPBhGX1guCPPCJb7Xo3zvzCuiQwAQzCrc95HYY` | **47** | Xu274 DISCARD | 39% | -5% | -1.36 SOL | 7/18 | 28039s | Fresh Wallet |
| `3W4zaACZYjebwGPmxjkgXCUHeHJNBjb2kDAGohT1Wahx` | **46** | Xu274 DISCARD | 50% | -11% | -1.95 SOL | 6/12 | 5410s | Fresh Wallet |
| `7BNaxx6KdUYrjACNQZ9He26NBFoFxujQMAfNLnArLGH5` | **43** | Xu274 DISCARD | 20% | -49% | -50.00 SOL | 12/60 | 251s | Fresh Wallet |
| `Ar2Y6o1QmrRAskjii1cRfijeKugHH13ycxW5cd7rro1x` | **41** | Xu274 DISCARD | 15% | -64% | -63.01 SOL | 10/67 | 346s | Fresh Wallet |
| `3HEihqmG22iZfVTAfAZjeqr5qm2mCJZz2iLvWdGZxvG2` | **40** | Xu274 DISCARD | 33% | -19% | -6.69 SOL | 4/12 | 9872s | Fresh Wallet |
| `AnrR8mHZJuePcsuAEoXp1ugEZMgfjCK5nqE4JJct4KfS` | **31** | Xu274 DISCARD | 33% | 41% | 1.77 SOL | 1/3 | 1130s | Fresh Wallet |

## Metric Explanations
- **Score:** Composite rating (0-100) based on Win Rate, ROI, Consistency, and Profit.
- **Verdict:** KEEP if Score > 40 per user criteria.
- **Win Rate:** Percentage of tokens traded that resulted in profit.
- **ROI:** Total Profit / Total Cost (capped at 300% for scoring).
</file>

<file path="compass_artifact_wf-5de4dceb-d091-494d-8f41-98c8abdc8dd6_text_markdown.md">
# Building an AI Trading Bot on Solana: APIs, Repos, and Strategy

**Only 0.4% of Pump.fun traders profit over $10,000**â€”that sobering statistic from on-chain analysis sets the context for this guide. The Solana meme coin ecosystem generates extraordinary stories (2 SOL to $1 million in 3 hours has happened), but 60-90% of traders lose money. This comprehensive guide provides the technical infrastructure to build an AI trading bot while acknowledging the brutal statistical reality. If you proceed, you'll do so with working code, real APIs, and proven risk managementâ€”not false hope.

---

## Part 1: Free Solana APIs and endpoints

The Solana ecosystem offers surprisingly robust free API access. These endpoints form the data and execution backbone for any trading bot.

### RPC providers with free tiers

| Provider | Free Tier | Rate Limit | Endpoint Format |
|----------|-----------|------------|-----------------|
| **Helius** | 1M credits/month | 10 RPS | `https://mainnet.helius-rpc.com/?api-key=YOUR_KEY` |
| **QuickNode** | 10M credits | 15 RPS | Custom endpoint after signup |
| **dRPC** | Unlimited basic | No strict limit | `https://solana.drpc.org` |
| **Chainstack** | Free tier | Geo-balanced | Custom after signup |
| **Alchemy** | Limited free | Rate-limited | `https://solana-mainnet.g.alchemy.com/v2/:apiKey` |

The official Solana public RPC (`https://api.mainnet.solana.com`) exists but **should never be used for production trading**â€”it's rate-limited to 100 requests per 10 seconds and can block your IP without notice. Helius offers the best free balance of speed and reliability, with WebSocket support at `wss://atlas-mainnet.helius-rpc.com/?api-key=YOUR_KEY`.

### DEX and swap APIs (all free, no authentication required)

**Jupiter Aggregator** dominates Solana DeFi with >90% of aggregator volume. Their API requires no authentication and provides optimal swap routing:

```javascript
// Jupiter Quote API (FREE)
const quote = await fetch(
  'https://api.jup.ag/v6/quote?' + 
  'inputMint=So11111111111111111111111111111111111111112&' +  // SOL
  'outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&' + // USDC
  'amount=1000000'  // 0.001 SOL in lamports
);

// Jupiter Swap Execution
const swap = await fetch('https://api.jup.ag/v6/swap', {
  method: 'POST',
  body: JSON.stringify({ quoteResponse: quote, userPublicKey: wallet })
});
```

**Raydium V3 API** provides direct pool access without aggregation overhead:
- Base URL: `https://api-v3.raydium.io/`
- Pool list: `/pools/info/list`
- Token data: `https://api.raydium.io/v2/sdk/token/solana.mainnet.json`
- Full documentation at `https://api-v3.raydium.io/docs/`

**Orca Whirlpools** concentrated liquidity pools use their TypeScript SDK (`@orca-so/whirlpools`) rather than REST endpointsâ€”install via npm for programmatic access.

### Token data and price APIs

**DexScreener** offers the most generous free tier with no API key required:
- Search pairs: `GET https://api.dexscreener.com/latest/dex/search?q={query}`
- Token pairs: `GET https://api.dexscreener.com/token-pairs/v1/solana/{tokenAddress}`
- Boosted/trending: `GET https://api.dexscreener.com/token-boosts/top/v1`
- Rate limit: **300 requests/minute**

**Birdeye** requires a free API key but limits free tier to token price and token list endpoints only (30,000 credits/month). Premium features (OHLCV, trade data, WebSocket streaming) require paid plans starting at $49/month.

**GeckoTerminal** (CoinGecko's on-chain arm) provides free OHLCV data across 250+ networks without authentication: `https://api.geckoterminal.com/api/v2/`

### Specialized infrastructure APIs

**Jito Bundles** for MEV protection is technically freeâ€”you only pay tips (minimum **1,000 lamports** or 0.000001 SOL) for atomic transaction execution. This protects against sandwich attacks and ensures transaction ordering:

```python
# Jito bundle submission pattern
from jito_sdk import JitoClient

client = JitoClient()
bundle = [swap_transaction, take_profit_transaction]
result = await client.send_bundle(bundle, tip_lamports=10000)
```

**Pump.fun** has no official API, but community documentation exists at `github.com/BankkRoll/pumpfun-apis`. Most bots monitor launches via Solana's `logsSubscribe` WebSocket rather than HTTP endpoints. Bitquery offers GraphQL subscriptions for Pump.fun events if you need structured data.

---

## Part 2: GitHub repositories worth using

After reviewing dozens of repositories, these represent the most actively maintained, functional codebases as of January 2025.

### The essential starting point: chainstacklabs/pumpfun-bonkfun-bot

This Python-based bot (**874 stars, actively maintained**) represents the most production-ready open-source implementation for meme coin trading:

```
GitHub: github.com/chainstacklabs/pumpfun-bonkfun-bot
Language: Python 100%
License: Apache-2.0
Features:
- New token sniping via logsSubscribe and blockSubscribe
- Bonding curve tracking and PumpSwap migration listening
- Take profit/stop loss automation
- Dynamic priority fees
- Geyser gRPC integration for low-latency data
```

The repository includes excellent documentation with full walkthrough tutorials at docs.chainstack.com.

### Trading infrastructure repositories

| Repository | Purpose | Language | Best For |
|------------|---------|----------|----------|
| **warp-id/solana-trading-bot** | Automated trading with pool burn detection, mint checks | TypeScript | Full trading automation |
| **outsmartchad/solana-trading-cli** | High-performance library supporting Raydium, Orca, Meteora, Pump.fun | TypeScript | Building custom strategies |
| **ARBProtocol/solana-jupiter-bot** | Arbitrage with config wizard and CLI dashboard | JavaScript | Cross-DEX arbitrage |
| **fdundjer/solana-sniper-bot** | Raydium pool sniping with Jito executors | TypeScript | New pool sniping |
| **DracoR22/handi-cat_wallet-tracker** | Telegram bot for real-time wallet tracking | TypeScript | Copy trading infrastructure |

### AI/ML integration toolkit

**sendaifun/solana-agent-kit** stands out as the most comprehensive AI integration framework, connecting any AI agent to 60+ Solana actions with LangChain/LangGraph integration. The Python version (`solana-agent-kit-py`) is available for those preferring Python over TypeScript.

For reinforcement learning specifically, **sadighian/crypto-rl** provides a complete toolkit including data recording, Gym environments, and DDQN training pipelines designed for limit order book data.

### Essential SDKs you'll need

```bash
# JavaScript/TypeScript
npm install @solana/web3.js @raydium-io/raydium-sdk-v2 @orca-so/whirlpools

# Python
pip install solana solders
```

The official **raydium-io/raydium-sdk-V2** and **jup-ag/jupiter-swap-api-client** repositories provide the canonical implementations for DEX interactions.

---

## Part 3: Strategy framework for 1 SOL to 100 SOL

The math requires a **100x return**â€”achievable in theory but statistically improbable. Only 293 wallets (0.00217% of 13.55 million) have made over $1 million on Pump.fun. Your strategy must acknowledge this reality while optimizing for the slim possibility of success.

### Realistic pathways and their odds

**Meme coin sniping** offers the highest potential returns but worst odds. The bonding curve mechanics of Pump.fun mean earliest buyers get exponentially better pricesâ€”but **98.6% of tokens collapse** into pump-and-dump schemes, and only **1.29% graduate to Raydium**.

Successful snipers use three detection methods:
1. **Twitter/X scraping** for contract addresses dropped by non-crypto influencers
2. **On-chain monitoring** of developer wallets with successful launch histories
3. **Volume/social velocity tracking** for narrative breaks (AI themes, political events)

**Copy trading** successful wallets provides learning opportunities but faces structural problems: by the time you execute, price has moved; "farmer wallets" deliberately exploit copiers by making initial buys, waiting for copy volume, then dumping.

**DEX arbitrage** with 1 SOL is **not viable**â€”the technical infrastructure costs and competition from professional MEV bots eliminate any edge small capital might have.

### Position sizing that survives losing streaks

With 1 SOL (~$150-250 at recent prices), the Kelly Criterion suggests risking **1-5% per trade** (0.01-0.05 SOL) to survive the inevitable losing streaks. A practical framework:

```
Core reserve (40%): 0.4 SOL - Never trade, provides recovery capital
Active trading (40%): 0.4 SOL - Split across 3-5 positions max
High-risk allocation (20%): 0.2 SOL - Meme coin/speculative plays
```

This structure allows approximately **20-40 learning trades** before depletion, assuming average losses of 50% per failed trade.

### Entry and exit discipline

**Entry signals worth acting on:**
- Volume spike >200% in short timeframe with price confirmation
- Whale accumulation visible on Solscan (large wallets buying)
- Locked liquidity + revoked mint authority (verifiable via RugCheck.xyz)
- Top 10 holders controlling <30% of supply

**Exit strategy that captures gains:**
Most meme coins die within 30 seconds to 24 hours. The staged exit approach protects profits:
- At **2x**: Sell 25% (recover partial initial)
- At **3x**: Sell 25% (guarantee profit)
- Remaining **50%**: Trail with 15-20% stop loss

### Pre-trade rug pull checklist

Before every entry, verify:
- [ ] Liquidity locked (check GeckoTerminal, RugCheck.xyz)
- [ ] Mint authority revoked (prevents infinite token creation)
- [ ] Freeze authority revoked (prevents wallet freezing)
- [ ] No bundled buys at launch (coordinated manipulation)
- [ ] Developer wallet has no rug pull history
- [ ] Top 10 holders <30% of supply

---

## Part 4: AI/ML component architecture

Machine learning adds value primarily through **risk management and pattern recognition**â€”not price prediction. Markets are too efficient for simple ML models to consistently predict direction.

### Reinforcement learning implementation

The RL paradigm fits trading naturally: the agent receives market state, takes actions (buy/sell/hold), and receives rewards (PnL). Research shows **DDQN with Sharpe ratio as reward function** outperforms other Q-learning variants.

```python
import gym
import numpy as np
from stable_baselines3 import DQN

# State representation
state = np.array([
    unrealized_pnl,
    available_cash / initial_capital,  # Normalized
    current_position,
    rsi_14,
    volume_relative_to_average,
    price_relative_to_ema_20
])

# Action space: Discrete (0=hold, 1=buy, 2=sell)
env = TradingEnv(state_shape=(6,), action_space=3)
model = DQN('MlpPolicy', env, verbose=1)
model.learn(total_timesteps=100000)
```

The critical insight from research: **even with limited prediction ability, RL agents can react to market changes** rather than predict themâ€”a more tractable problem.

### Sentiment analysis that provides signal

Twitter sentiment correlates with trading volume and short-term volatility. A practical implementation using VADER:

```python
from nltk.sentiment.vader import SentimentIntensityAnalyzer

sia = SentimentIntensityAnalyzer()

def get_sentiment_signal(tweets: list) -> str:
    scores = [sia.polarity_scores(t)['compound'] for t in tweets]
    avg = sum(scores) / len(scores) if scores else 0
    
    if avg > 0.05: return 'bullish'
    elif avg < -0.05: return 'bearish'
    return 'neutral'
```

For crypto-specific accuracy, fine-tuned models like **CryptoBERT** achieve 83.5% classification accuracy versus VADER's ~70%. However, sentiment works best as an **additional signal**, not primaryâ€”combining it with price/volume data improves forecasts by approximately 20%.

### Pump detection algorithm

Z-score based anomaly detection correctly identifies pump-and-dump targets **55.81% of the time** (top 5 ranking). The key features:

```python
def calculate_pump_score(token_data):
    return {
        'price_z': (current_price - rolling_mean) / rolling_std,
        'volume_z': (volume - avg_volume) / volume_std,
        'order_imbalance': bid_volume / ask_volume,
        'trade_intensity': trades_per_minute / avg_trades
    }
    
# Alert threshold: combined z-score > 3
```

For real-time implementation, Random Forest achieves **94.5% F1-score** detecting pump-and-dump events within 25 seconds of startâ€”potentially actionable for exit timing.

### Market regime detection

Hidden Markov Models effectively identify volatility regimes (high/low/crash), enabling dynamic position sizing:

```python
from hmmlearn import hmm

model = hmm.GaussianHMM(n_components=3, covariance_type='full')
model.fit(returns.reshape(-1, 1))

# Regime interpretation
# 0: Low volatility â†’ Trade normally
# 1: High volatility â†’ Reduce position sizes 50%
# 2: Crash regime â†’ Exit positions or short
```

---

## Part 5: What real traders experienced

On-chain data reveals the uncomfortable truth about meme coin trading outcomes.

### The statistical reality

From **13.55 million wallet addresses** that traded on Pump.fun:
- **60% lost money** (Dune Analytics, May 2025)
- **88% either lost money or made less than $100**
- Only **55,296 wallets (0.4%)** profited over $10,000
- Only **293 wallets (0.00217%)** made over $1 million
- **1,700 wallets** lost more than $100,000

The Solana meme coin market follows severe power law distributionâ€”a tiny fraction captures nearly all profits while the majority provides exit liquidity.

### Patterns from successful traders

The rare winners share common characteristics:
1. **Extreme speed**: Using sniping bots (Trojan, BONKbot) for sub-second entry after launch
2. **Early profit-taking**: Selling 50% at 2x to guarantee return of initial capital
3. **Smart money following**: Identifying and tracking profitable wallets via KOLSCAN and Dune Analytics
4. **Small, frequent bets**: Risking 0.5-2 SOL per trade across many opportunities

One documented case: a trader turned **2 SOL into $1 million in 3 hours** during the Gen Z Quant controversyâ€”a 2,141x return representing the extreme right tail of outcomes.

### Common failure patterns

Trader losses cluster around predictable mistakes:
- **FOMO entry after pump**: By the time retail notices, insiders have already bought
- **Holding through reversal**: "Diamond hands" mentality turning gains into losses
- **Copying compromised wallets**: "Farmer wallets" deliberately exploit copy traders
- **Ignoring rug pull signals**: Anonymous teams, unlocked liquidity, concentrated holdings

A crypto influencer publicly shared losing **nearly $1 million** to meme coins after "greed kicked in and I used only max leverage. Left with 460 bucks."

---

## Complete implementation roadmap

### Week 1-2: Infrastructure setup

```bash
# 1. Create dedicated trading wallet (never use main wallet)
# 2. Fund with test amount (0.1 SOL to start)
# 3. Set up development environment

pip install solana solders pandas numpy scikit-learn
npm install @solana/web3.js @raydium-io/raydium-sdk-v2

# 4. Get free API keys
# - Helius: helius.dev
# - Birdeye: birdeye.so (limited free tier)

# 5. Clone reference implementation
git clone https://github.com/chainstacklabs/pumpfun-bonkfun-bot
```

### Week 3-4: Data collection and backtesting

Build your training dataset before deploying capital:
- Collect 3+ months of OHLCV data via GeckoTerminal API
- Scrape Twitter for token mentions (sentiment baseline)
- Record Pump.fun launches and outcomes (graduation rate, price action)
- Implement basic backtesting with `backtesting.py` library

### Month 2: Paper trading and validation

Run the bot in simulation mode:
- Execute 50+ paper trades across different market conditions
- Track win rate, average gain, average loss, maximum drawdown
- Validate that the strategy survives walk-forward testing (not just in-sample)

### Month 3+: Gradual live deployment

Begin with minimal capital (0.1-0.2 SOL):
- Execute real trades with 0.01 SOL position sizes
- Compare live results to backtest expectations
- Scale position sizes only after 30+ profitable trades demonstrate edge

---

## Risk acknowledgment and realistic expectations

**The expected value of meme coin trading is negative for most participants.** The data is unambiguous: 60-90% lose money, and the 0.4% who profit significantly possess advantages in speed, information, and capital that this guide cannot fully replicate.

If you proceed, do so with these principles:

1. **Use only capital you can lose entirely**â€”100% loss is the modal outcome
2. **Treat early attempts as paid education**, not investment
3. **The bot is a tool, not a money printer**â€”no code compensates for unfavorable odds
4. **Take profits aggressively**â€”most tokens die within hours
5. **Study the statistics regularly** to avoid survivorship bias from social media success stories

The APIs work. The code executes. The strategies have internal logic. Whether the mathematics of risk/reward ultimately favors you remains a function of skill, timing, and significant luck. Build the system, run the experiments, and let the dataâ€”not hopeâ€”guide your decisions.
</file>

<file path="jest.config.js">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.test.ts', '**/*.test.ts'],
  moduleFileExtensions: ['ts', 'js', 'json'],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/index.ts',
  ],
  coverageDirectory: 'coverage',
  verbose: true,
  // Mock environment variables for testing
  setupFiles: ['<rootDir>/src/__tests__/setup.ts'],
  // Increase timeout for async operations
  testTimeout: 10000,
};
</file>

<file path="src/__tests__/position-manager.test.ts">
/**
 * Position Manager TP/SL Logic Tests
 *
 * Tests the critical profit-taking and stop-loss logic:
 * - 12% stop loss
 * - +50% initial recovery (sell to recover cost)
 * - 15% trailing stop after recovery
 * - Scaled exits every +50% after recovery
 */

import { config } from '../config/settings';

// Helper to calculate profit percent
function calcProfitPercent(currentPrice: number, entryPrice: number): number {
  return (currentPrice - entryPrice) / entryPrice;
}

// Helper to check if stop loss should trigger
function shouldTriggerStopLoss(currentPrice: number, entryPrice: number): boolean {
  const profitPercent = calcProfitPercent(currentPrice, entryPrice);
  return profitPercent <= -config.stopLossPercent;
}

// Helper to check if trailing stop should trigger
function shouldTriggerTrailingStop(currentPrice: number, trailingStop: number | undefined): boolean {
  return trailingStop !== undefined && currentPrice <= trailingStop;
}

// Helper to check if initial recovery should trigger
function shouldTriggerInitialRecovery(
  currentPrice: number,
  entryPrice: number,
  initialRecovered: boolean
): boolean {
  if (initialRecovered) return false;
  const profitPercent = calcProfitPercent(currentPrice, entryPrice);
  return profitPercent >= config.takeProfitStrategy.initialRecovery.triggerPercent;
}

// Helper to calculate trailing stop price
function calcTrailingStop(currentPrice: number): number {
  return currentPrice * (1 - config.takeProfitStrategy.trailingStopPercent);
}

// Helper to calculate how many scaled exits should have been taken
function calcScaledExits(currentPrice: number, entryPrice: number): number {
  const profitPercent = calcProfitPercent(currentPrice, entryPrice);
  const profitSinceRecovery = profitPercent - config.takeProfitStrategy.initialRecovery.triggerPercent;
  if (profitSinceRecovery < 0) return 0;
  return Math.floor(profitSinceRecovery / config.takeProfitStrategy.scaledExits.intervalPercent);
}

describe('Position Manager TP/SL Logic', () => {
  // Verify config is correct
  describe('Config Verification', () => {
    it('should have 12% stop loss', () => {
      expect(config.stopLossPercent).toBe(0.12);
    });

    it('should have 15% trailing stop', () => {
      expect(config.takeProfitStrategy.trailingStopPercent).toBe(0.15);
    });

    it('should have +50% initial recovery trigger', () => {
      expect(config.takeProfitStrategy.initialRecovery.triggerPercent).toBe(0.50);
    });

    it('should have 20% scaled exit sell percent', () => {
      expect(config.takeProfitStrategy.scaledExits.sellPercent).toBe(0.20);
    });
  });

  describe('Stop Loss', () => {
    const entryPrice = 0.001; // 0.001 SOL per token

    it('should NOT trigger at -11% loss', () => {
      const currentPrice = entryPrice * 0.89; // -11%
      expect(shouldTriggerStopLoss(currentPrice, entryPrice)).toBe(false);
    });

    it('should trigger at exactly -12% loss', () => {
      const currentPrice = entryPrice * 0.88; // -12%
      expect(shouldTriggerStopLoss(currentPrice, entryPrice)).toBe(true);
    });

    it('should trigger at -20% loss', () => {
      const currentPrice = entryPrice * 0.80; // -20%
      expect(shouldTriggerStopLoss(currentPrice, entryPrice)).toBe(true);
    });

    it('should NOT trigger when in profit', () => {
      const currentPrice = entryPrice * 1.5; // +50%
      expect(shouldTriggerStopLoss(currentPrice, entryPrice)).toBe(false);
    });
  });

  describe('Initial Recovery (+50%)', () => {
    const entryPrice = 0.001;

    it('should NOT trigger at +40%', () => {
      const currentPrice = entryPrice * 1.40;
      expect(shouldTriggerInitialRecovery(currentPrice, entryPrice, false)).toBe(false);
    });

    it('should trigger at exactly +50%', () => {
      const currentPrice = entryPrice * 1.50;
      expect(shouldTriggerInitialRecovery(currentPrice, entryPrice, false)).toBe(true);
    });

    it('should trigger at +60%', () => {
      const currentPrice = entryPrice * 1.60;
      expect(shouldTriggerInitialRecovery(currentPrice, entryPrice, false)).toBe(true);
    });

    it('should NOT trigger if already recovered', () => {
      const currentPrice = entryPrice * 1.50;
      expect(shouldTriggerInitialRecovery(currentPrice, entryPrice, true)).toBe(false);
    });
  });

  describe('Trailing Stop', () => {
    it('should calculate 15% below current price', () => {
      const currentPrice = 0.002;
      const expectedStop = 0.002 * 0.85; // 15% below
      expect(calcTrailingStop(currentPrice)).toBeCloseTo(expectedStop, 10);
    });

    it('should trigger when price drops to trailing stop', () => {
      const trailingStop = 0.0017; // Set at $0.002 * 0.85
      const currentPrice = 0.0017;
      expect(shouldTriggerTrailingStop(currentPrice, trailingStop)).toBe(true);
    });

    it('should trigger when price drops below trailing stop', () => {
      const trailingStop = 0.0017;
      const currentPrice = 0.0015;
      expect(shouldTriggerTrailingStop(currentPrice, trailingStop)).toBe(true);
    });

    it('should NOT trigger when price is above trailing stop', () => {
      const trailingStop = 0.0017;
      const currentPrice = 0.0020;
      expect(shouldTriggerTrailingStop(currentPrice, trailingStop)).toBe(false);
    });

    it('should NOT trigger if trailing stop not set', () => {
      const currentPrice = 0.0010;
      expect(shouldTriggerTrailingStop(currentPrice, undefined)).toBe(false);
    });
  });

  describe('Scaled Exits', () => {
    const entryPrice = 0.001;

    it('should have 0 exits at +50% (just recovered)', () => {
      const currentPrice = entryPrice * 1.50; // +50%
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(0);
    });

    it('should have 0 exits at +90% (not yet +100%)', () => {
      const currentPrice = entryPrice * 1.90; // +90%
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(0);
    });

    it('should have 1 exit at +100% (50% + 50%)', () => {
      const currentPrice = entryPrice * 2.00; // +100%
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(1);
    });

    it('should have 2 exits at +150% (50% + 50% + 50%)', () => {
      const currentPrice = entryPrice * 2.50; // +150%
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(2);
    });

    it('should have 3 exits at +200%', () => {
      const currentPrice = entryPrice * 3.00; // +200%
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(3);
    });
  });

  describe('Full Scenario: Moon Mission', () => {
    const entryPrice = 0.001;
    const initialAmount = 1000000; // 1M tokens
    const initialInvestment = 1.0; // 1 SOL

    it('should properly handle a 3x pump', () => {
      // Start: entry at 0.001
      let currentPrice = entryPrice;
      let amount = initialAmount;
      let initialRecovered = false;
      let trailingStop: number | undefined;
      let scaledExitsTaken = 0;

      // Price pumps to +50% (1.5x)
      currentPrice = entryPrice * 1.50;
      expect(shouldTriggerStopLoss(currentPrice, entryPrice)).toBe(false);
      expect(shouldTriggerInitialRecovery(currentPrice, entryPrice, initialRecovered)).toBe(true);

      // Simulate recovery: sell enough to recover 1 SOL
      const sellAmount = initialInvestment / currentPrice; // 666,666 tokens
      amount -= sellAmount;
      initialRecovered = true;
      trailingStop = calcTrailingStop(currentPrice);

      expect(amount).toBeCloseTo(333333.33, 0);
      expect(trailingStop).toBeCloseTo(0.001275, 6);

      // Price continues to +100% (2x)
      currentPrice = entryPrice * 2.00;
      trailingStop = calcTrailingStop(currentPrice); // Update trailing
      expect(shouldTriggerTrailingStop(currentPrice, trailingStop)).toBe(false);
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(1);

      // Take scaled exit: sell 20% of remaining
      const scaledSellAmount = amount * 0.20;
      amount -= scaledSellAmount;
      scaledExitsTaken++;

      expect(amount).toBeCloseTo(266666.67, 0);
      expect(scaledExitsTaken).toBe(1);

      // Price dumps to trailing stop
      trailingStop = calcTrailingStop(entryPrice * 2.00); // 0.0017
      currentPrice = 0.0016; // Below trailing stop
      expect(shouldTriggerTrailingStop(currentPrice, trailingStop)).toBe(true);
    });
  });
});
</file>

<file path="src/__tests__/token-watchlist.test.ts">
/**
 * Token Watchlist Hard Filter Tests
 *
 * Tests the critical rejection logic:
 * - 30% max drawdown rejection
 * - Dev sold rejection (2% early, 5% normal)
 * - Minimum data points requirement
 * - Minimum age requirement
 */

import { config } from '../config/settings';

// Simulated WatchedToken for testing
interface TestWatchedToken {
  mint: string;
  firstSeen: number;
  priceHistory: Array<{ price: number; timestamp: number }>;
  devSold: boolean;
  devSoldPercent: number;
  peakPrice: number;
}

// Helper to check drawdown filter
function failsDrawdownFilter(token: TestWatchedToken): { fails: boolean; reason: string } {
  const maxDrawdown = config.watchlist?.maxDrawdown || 0.30;

  if (token.peakPrice <= 0 || token.priceHistory.length === 0) {
    return { fails: false, reason: 'No price data' };
  }

  const currentPrice = token.priceHistory[token.priceHistory.length - 1].price;
  const drawdown = (token.peakPrice - currentPrice) / token.peakPrice;

  if (drawdown > maxDrawdown) {
    return {
      fails: true,
      reason: `Crashed ${(drawdown * 100).toFixed(0)}% from peak (max ${(maxDrawdown * 100).toFixed(0)}%)`,
    };
  }

  return { fails: false, reason: 'Drawdown OK' };
}

// Helper to check dev sold filter
function failsDevSoldFilter(token: TestWatchedToken): { fails: boolean; reason: string } {
  if (token.devSold) {
    return {
      fails: true,
      reason: `Dev sold ${(token.devSoldPercent * 100).toFixed(1)}%`,
    };
  }
  return { fails: false, reason: 'Dev holding OK' };
}

// Helper to check minimum data points
function failsDataPointsFilter(token: TestWatchedToken): { fails: boolean; reason: string } {
  const minDataPoints = config.watchlist?.minDataPoints || 10;

  if (token.priceHistory.length < minDataPoints) {
    return {
      fails: true,
      reason: `Only ${token.priceHistory.length}/${minDataPoints} data points`,
    };
  }
  return { fails: false, reason: 'Data points OK' };
}

// Helper to check minimum age
function failsAgeFilter(token: TestWatchedToken): { fails: boolean; reason: string } {
  const minAgeSeconds = config.watchlist?.minAgeSeconds || 60;
  const ageSeconds = (Date.now() - token.firstSeen) / 1000;

  if (ageSeconds < minAgeSeconds) {
    return {
      fails: true,
      reason: `Token only ${ageSeconds.toFixed(0)}s old (min ${minAgeSeconds}s)`,
    };
  }
  return { fails: false, reason: 'Age OK' };
}

// Combined hard filter check
function passesHardFilters(token: TestWatchedToken): { passes: boolean; reason: string } {
  const devCheck = failsDevSoldFilter(token);
  if (devCheck.fails) return { passes: false, reason: devCheck.reason };

  const dataCheck = failsDataPointsFilter(token);
  if (dataCheck.fails) return { passes: false, reason: dataCheck.reason };

  const ageCheck = failsAgeFilter(token);
  if (ageCheck.fails) return { passes: false, reason: ageCheck.reason };

  const drawdownCheck = failsDrawdownFilter(token);
  if (drawdownCheck.fails) return { passes: false, reason: drawdownCheck.reason };

  return { passes: true, reason: 'Ready for AI analysis' };
}

// Helper to create a test token
function createTestToken(overrides: Partial<TestWatchedToken> = {}): TestWatchedToken {
  const now = Date.now();
  return {
    mint: 'TestToken123pump',
    firstSeen: now - 120000, // 2 minutes ago (passes 60s min age)
    priceHistory: Array(15).fill(null).map((_, i) => ({
      price: 0.001,
      timestamp: now - (15 - i) * 1000,
    })),
    devSold: false,
    devSoldPercent: 0,
    peakPrice: 0.001,
    ...overrides,
  };
}

describe('Token Watchlist Hard Filters', () => {
  // Verify config
  describe('Config Verification', () => {
    it('should have 30% max drawdown', () => {
      expect(config.watchlist?.maxDrawdown).toBe(0.30);
    });

    it('should have 10 min data points', () => {
      expect(config.watchlist?.minDataPoints).toBe(10);
    });

    it('should have 60s min age', () => {
      expect(config.watchlist?.minAgeSeconds).toBe(60);
    });
  });

  describe('Drawdown Filter (30% max)', () => {
    it('should PASS at 0% drawdown (at peak)', () => {
      const token = createTestToken({ peakPrice: 0.001 });
      expect(failsDrawdownFilter(token).fails).toBe(false);
    });

    it('should PASS at 20% drawdown', () => {
      const token = createTestToken({
        peakPrice: 0.001,
        priceHistory: [{ price: 0.0008, timestamp: Date.now() }], // -20%
      });
      expect(failsDrawdownFilter(token).fails).toBe(false);
    });

    it('should PASS at exactly 30% drawdown', () => {
      const token = createTestToken({
        peakPrice: 0.001,
        priceHistory: [{ price: 0.0007, timestamp: Date.now() }], // -30%
      });
      expect(failsDrawdownFilter(token).fails).toBe(false);
    });

    it('should FAIL at 31% drawdown', () => {
      const token = createTestToken({
        peakPrice: 0.001,
        priceHistory: [{ price: 0.00069, timestamp: Date.now() }], // -31%
      });
      expect(failsDrawdownFilter(token).fails).toBe(true);
    });

    it('should FAIL at 50% drawdown', () => {
      const token = createTestToken({
        peakPrice: 0.001,
        priceHistory: [{ price: 0.0005, timestamp: Date.now() }], // -50%
      });
      const result = failsDrawdownFilter(token);
      expect(result.fails).toBe(true);
      expect(result.reason).toContain('50%');
    });
  });

  describe('Dev Sold Filter', () => {
    it('should PASS if dev has not sold', () => {
      const token = createTestToken({ devSold: false, devSoldPercent: 0 });
      expect(failsDevSoldFilter(token).fails).toBe(false);
    });

    it('should PASS if dev sold within threshold (not flagged)', () => {
      const token = createTestToken({
        devSold: false, // Not flagged by threshold logic
        devSoldPercent: 0.01, // 1%
      });
      expect(failsDevSoldFilter(token).fails).toBe(false);
    });

    it('should FAIL if dev sold flag is true', () => {
      const token = createTestToken({
        devSold: true,
        devSoldPercent: 0.06, // 6%
      });
      const result = failsDevSoldFilter(token);
      expect(result.fails).toBe(true);
      expect(result.reason).toContain('Dev sold');
    });
  });

  describe('Data Points Filter', () => {
    it('should FAIL with 5 data points', () => {
      const token = createTestToken({
        priceHistory: Array(5).fill({ price: 0.001, timestamp: Date.now() }),
      });
      const result = failsDataPointsFilter(token);
      expect(result.fails).toBe(true);
      expect(result.reason).toContain('5/10');
    });

    it('should FAIL with 9 data points', () => {
      const token = createTestToken({
        priceHistory: Array(9).fill({ price: 0.001, timestamp: Date.now() }),
      });
      expect(failsDataPointsFilter(token).fails).toBe(true);
    });

    it('should PASS with 10 data points', () => {
      const token = createTestToken({
        priceHistory: Array(10).fill({ price: 0.001, timestamp: Date.now() }),
      });
      expect(failsDataPointsFilter(token).fails).toBe(false);
    });

    it('should PASS with 50 data points', () => {
      const token = createTestToken({
        priceHistory: Array(50).fill({ price: 0.001, timestamp: Date.now() }),
      });
      expect(failsDataPointsFilter(token).fails).toBe(false);
    });
  });

  describe('Age Filter', () => {
    it('should FAIL if token is 30 seconds old', () => {
      const token = createTestToken({
        firstSeen: Date.now() - 30000, // 30 seconds ago
      });
      expect(failsAgeFilter(token).fails).toBe(true);
    });

    it('should FAIL if token is 59 seconds old', () => {
      const token = createTestToken({
        firstSeen: Date.now() - 59000,
      });
      expect(failsAgeFilter(token).fails).toBe(true);
    });

    it('should PASS if token is 60 seconds old', () => {
      const token = createTestToken({
        firstSeen: Date.now() - 60000,
      });
      expect(failsAgeFilter(token).fails).toBe(false);
    });

    it('should PASS if token is 5 minutes old', () => {
      const token = createTestToken({
        firstSeen: Date.now() - 300000,
      });
      expect(failsAgeFilter(token).fails).toBe(false);
    });
  });

  describe('Combined Hard Filters', () => {
    it('should PASS a healthy token', () => {
      const token = createTestToken();
      const result = passesHardFilters(token);
      expect(result.passes).toBe(true);
      expect(result.reason).toBe('Ready for AI analysis');
    });

    it('should FAIL early on dev sold (first check)', () => {
      const token = createTestToken({ devSold: true, devSoldPercent: 0.10 });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(false);
      expect(result.reason).toContain('Dev sold');
    });

    it('should FAIL on data points if dev OK', () => {
      const token = createTestToken({
        priceHistory: Array(3).fill({ price: 0.001, timestamp: Date.now() }),
      });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(false);
      expect(result.reason).toContain('data points');
    });

    it('should FAIL on drawdown last', () => {
      const token = createTestToken({
        peakPrice: 0.001,
        priceHistory: Array(15).fill(null).map(() => ({
          price: 0.0005, // -50% drawdown
          timestamp: Date.now(),
        })),
      });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(false);
      expect(result.reason).toContain('Crashed');
    });
  });

  describe('Real-World Scenarios', () => {
    it('should reject a rug pull (dev dumps)', () => {
      const token = createTestToken({
        devSold: true,
        devSoldPercent: 0.50, // Dev dumped 50%
        peakPrice: 0.001,
        priceHistory: [{ price: 0.0003, timestamp: Date.now() }], // -70%
      });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(false);
    });

    it('should reject a dead token (crashed and no recovery)', () => {
      const token = createTestToken({
        peakPrice: 0.002, // Was 2x from start
        priceHistory: Array(20).fill(null).map(() => ({
          price: 0.0005, // Now at -75% from peak
          timestamp: Date.now(),
        })),
      });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(false);
      expect(result.reason).toContain('Crashed');
    });

    it('should accept a healthy pumping token', () => {
      const now = Date.now();
      const token = createTestToken({
        firstSeen: now - 180000, // 3 minutes old
        peakPrice: 0.0015, // Pumped to 1.5x
        priceHistory: Array(30).fill(null).map((_, i) => ({
          price: 0.001 + (i * 0.00001), // Gradually increasing
          timestamp: now - (30 - i) * 1000,
        })),
      });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(true);
    });
  });
});
</file>

<file path="wallet.md">
5NszqQ4X78p7gVVJCRj9heobwHhiPFNAw23Xn8t8swn9
2573AbP8EUacZZqx5TAkv4XFUkubmRGee2nScjYpMGFg
GTUFPqUSkv3emUSJXjsBMfJMx6R6abNNzaPnLnkNckhu
HQYLrckNnctASrmqh4u6nSCqPSQdmjgUVJqb2EZc64V
ApeiTAjq3V9grbN2jVbmpLb59wffYmwCBKZnugyuerLZ
Hzrc9hdpkvrMK8GXyHsZCt1B4E5DAkSLWa4pszFVWDXC
</file>

<file path="client/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="client/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="client/index.html">
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/png" href="/logo.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>client</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>
</file>

<file path="client/package.json">
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}
</file>

<file path="client/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="client/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="client/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
eslint.config.js
index.html
package.json
public/header_full.png
public/header_logo.png
public/logo.png
public/vite.svg
README.md
src/App.css
src/App.tsx
src/assets/react.svg
src/components/AIStatus.tsx
src/components/ChallengeCard.tsx
src/components/EquityChart.tsx
src/components/Header.tsx
src/components/NarrativeStream.tsx
src/components/Positions.tsx
src/components/StatsGrid.tsx
src/components/TokenScanner.tsx
src/components/TradeList.tsx
src/components/Watchlist.tsx
src/hooks/useSocket.ts
src/index.css
src/main.tsx
src/types.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="index.html">
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/png" href="/logo.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>client</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>
</file>

<file path="package.json">
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="src/App.tsx">
import { Header } from './components/Header';
import { StatsGrid } from './components/StatsGrid';
import { ChallengeCard } from './components/ChallengeCard';
import { TokenScanner } from './components/TokenScanner';
import { TradeList } from './components/TradeList';
import { AIStatus } from './components/AIStatus';
import { Watchlist } from './components/Watchlist';
import { Positions } from './components/Positions';
import { EquityChart } from './components/EquityChart';
import { useSocket } from './hooks/useSocket';

function App() {
  const {
    isConnected,
    stats,
    trades,
    positions,
    positionsSummary,
    walletState,
    equityHistory,
    scannerData,
    isScanning,
    toasts,
    aiDecision,
    watchlistTokens,
    watchlistStats
  } = useSocket();

  return (
    <>
      <div className="dashboard">
        <Header isConnected={isConnected} />
        
        <StatsGrid stats={stats} />

        <div className="main-grid">
          <div className="left-column">
            <ChallengeCard stats={stats} />
            <EquityChart history={equityHistory} walletBalance={walletState?.solBalance} />
            <Positions positions={positions} summary={positionsSummary} />
            <TokenScanner data={scannerData || undefined} isScanning={isScanning} />
          </div>

          <div className="right-column">
            <TradeList trades={trades} />
            <AIStatus stats={stats} decision={aiDecision} />
            <Watchlist tokens={watchlistTokens} stats={watchlistStats} />
          </div>
        </div>
      </div>

      <div className="toast-container">
        {toasts.map((toast, i) => (
          <div key={i} className={`toast ${toast.type}`}>
            <div className="toast-title">{toast.title}</div>
            <div className="toast-message">{toast.message}</div>
          </div>
        ))}
      </div>
    </>
  );
}

export default App;
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/AIStatus.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats, AIDecisionData } from '../types';

interface AIStatusProps {
  stats: Stats;
  decision: AIDecisionData | null;
}

export const AIStatus: React.FC<AIStatusProps> = ({ stats, decision }) => {
  const [statusText, setStatusText] = useState('Initializing AI Model...');
  const winRate = parseFloat(stats.winRate || "0");
  const winStreak = stats.winStreak || 0;

  useEffect(() => {
    if (!decision) return;

    // Map action to text
    const actions = ['HOLD', 'BUY', 'SELL'];
    const actionText = actions[decision.action];
    
    // Map regime to text
    const regimes = ['BULL MARKET', 'VOLATILE', 'CRASH DETECTED'];
    const regimeText = regimes[decision.regime];

    setStatusText(`${regimeText}: Considering ${actionText} on $${decision.symbol}`);
  }, [decision]);

  // Fallback animation if no decision yet
  useEffect(() => {
    if (decision) return;
    const statuses = ['Analyzing market structure', 'Calculating Q-values', 'Scanning liquidity'];
    let index = 0;
    const interval = setInterval(() => {
      index = (index + 1) % statuses.length;
      setStatusText(statuses[index]);
    }, 3000);
    return () => clearInterval(interval);
  }, [decision]);

  // Visualize Q-Values (Buy vs Hold vs Sell reward expectations)
  // Normalize for display: find max absolute value to scale bars
  const qValues = decision?.qValues || [0, 0, 0]; // [Hold, Buy, Sell] typically
  const maxQ = Math.max(...qValues.map(Math.abs), 1); // Avoid div by zero
  
  // Confidence for the bar
  // Scale factor: AI confidence is often raw difference in Q-values (0.01-0.1 range)
  // We apply a sigmoid-like scaling to make it visible on the 0-100% bar
  const rawConfidence = decision ? decision.confidence : (winRate / 100);
  const scaledConfidence = Math.min(100, Math.max(0, rawConfidence * 500)); // Boost factor
  
  const confidence = decision ? scaledConfidence : Math.min(100, Math.max(0, winRate * 1.2));

  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">AI Engine</span>
      </div>
      <div className="ai-content">
        <div className="ai-indicator">
          <div className="ai-ring-outer"></div>
          <div className="ai-ring" style={{ animationDuration: decision ? '0.5s' : '1.5s' }}></div>
          <div className="ai-ring-inner"></div>
          <div className="ai-center">
            <div className="ai-center-dot" style={{ 
              background: decision?.action === 1 ? 'var(--success)' : 
                          decision?.action === 2 ? 'var(--error)' : '#FAFAF9' 
            }}></div>
          </div>
        </div>
        
        <div className="ai-status" style={{ minHeight: '40px' }}>{statusText}</div>

        {/* Q-Value Visualization */}
        <div style={{ display: 'flex', gap: '8px', marginBottom: '20px', height: '60px', alignItems: 'flex-end' }}>
          {['HOLD', 'BUY', 'SELL'].map((label, i) => {
            const val = qValues[i] || 0;
            const height = Math.abs(val) / maxQ * 100;
            const color = val > 0 ? 'var(--success)' : 'var(--error)';
            const isSelected = decision?.action === i;
            
            return (
              <div key={label} style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', opacity: isSelected ? 1 : 0.5 }}>
                 <div style={{ 
                   width: '100%', 
                   height: `${Math.max(10, height)}%`, 
                   background: color,
                   borderRadius: '4px',
                   transition: 'all 0.3s ease'
                 }}></div>
                 <span style={{ fontSize: '10px', marginTop: '4px', color: 'var(--text-muted)' }}>{label}</span>
              </div>
            );
          })}
        </div>

        <div className="confidence-bar">
          <div className="confidence-header">
            <span>Confidence</span>
            <span>{confidence.toFixed(0)}%</span>
          </div>
          <div className="confidence-track">
            <div 
              className="confidence-fill" 
              style={{ width: `${confidence}%` }}
            ></div>
          </div>
        </div>
        <div className="win-streak-box">
          <div className="win-streak-value animate-number">{winStreak}</div>
          <div className="win-streak-label">Win streak</div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/ChallengeCard.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats } from '../types';

interface ChallengeCardProps {
  stats: Stats;
}

export const ChallengeCard: React.FC<ChallengeCardProps> = ({ stats }) => {
  const multiplier = parseFloat(stats.multiplier || "1");
  const equity = parseFloat(stats.currentEquity || stats.initialCapital || "1");
  const initial = parseFloat(stats.initialCapital || "1");
  
  // Progress calculation (logarithmic scale feels better but linear for now as per original)
  // Max at 100x
  const progress = Math.min(100, Math.max(1, multiplier));

  const [displayMultiplier, setDisplayMultiplier] = useState(multiplier);
  
  useEffect(() => {
    setDisplayMultiplier(multiplier);
  }, [multiplier]);

  return (
    <div className="card">
      <div className="challenge-card">
        <div className="challenge-label">THE 1 â†’ 100 CHALLENGE</div>
        <div className="challenge-value animate-number">
          {displayMultiplier.toFixed(2)}<span>x</span>
        </div>
        <div className="challenge-sub">
          {equity.toFixed(2)} SOL from {initial} SOL start
        </div>
        <div className="progress-bar-container">
          <div className="progress-bar">
            <div 
              className="progress-fill" 
              style={{ width: `${progress}%` }}
            ></div>
          </div>
          <div className="progress-markers">
            <span className={multiplier >= 1 ? 'active' : ''}>1x</span>
            <span className={multiplier >= 10 ? 'active' : ''}>10x</span>
            <span className={multiplier >= 25 ? 'active' : ''}>25x</span>
            <span className={multiplier >= 50 ? 'active' : ''}>50x</span>
            <span className={multiplier >= 100 ? 'active' : ''}>100x</span>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/EquityChart.tsx">
import React, { useMemo } from 'react';
import type { EquitySnapshot } from '../hooks/useSocket';

interface EquityChartProps {
  history: EquitySnapshot[];
  walletBalance?: number;
}

export const EquityChart: React.FC<EquityChartProps> = ({ history, walletBalance }) => {
  const chartData = useMemo(() => {
    if (history.length < 2) return null;

    const values = history.map(s => s.totalEquity);
    const minVal = Math.min(...values);
    const maxVal = Math.max(...values);
    const range = maxVal - minVal || 1;

    // Chart dimensions
    const width = 300;
    const height = 60;
    const padding = 4;

    // Calculate points
    const points = values.map((val, i) => {
      const x = padding + (i / (values.length - 1)) * (width - padding * 2);
      const y = height - padding - ((val - minVal) / range) * (height - padding * 2);
      return `${x},${y}`;
    }).join(' ');

    // Determine trend
    const firstVal = values[0];
    const lastVal = values[values.length - 1];
    const isUp = lastVal >= firstVal;
    const change = lastVal - firstVal;
    const changePercent = firstVal > 0 ? (change / firstVal) * 100 : 0;

    return {
      points,
      width,
      height,
      isUp,
      change,
      changePercent,
      current: lastVal,
      min: minVal,
      max: maxVal,
    };
  }, [history]);

  if (!chartData) {
    return (
      <div className="card equity-chart-card">
        <div className="card-header">
          <span className="card-title">Equity</span>
        </div>
        <div className="equity-chart-empty">
          <span>Collecting data...</span>
          {walletBalance !== undefined && (
            <span className="wallet-balance">{walletBalance.toFixed(4)} SOL</span>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="card equity-chart-card">
      <div className="card-header">
        <span className="card-title">Equity</span>
        <span className={`card-badge ${chartData.isUp ? 'positive' : 'negative'}`}>
          {chartData.isUp ? '+' : ''}{chartData.changePercent.toFixed(2)}%
        </span>
      </div>
      <div className="equity-chart-content">
        <div className="equity-current">
          <span className="equity-value">{chartData.current.toFixed(4)}</span>
          <span className="equity-label">SOL</span>
        </div>
        <svg
          className="equity-sparkline"
          viewBox={`0 0 ${chartData.width} ${chartData.height}`}
          preserveAspectRatio="none"
        >
          <defs>
            <linearGradient id="equityGradient" x1="0" y1="0" x2="0" y2="1">
              <stop
                offset="0%"
                stopColor={chartData.isUp ? '#10b981' : '#ef4444'}
                stopOpacity="0.3"
              />
              <stop
                offset="100%"
                stopColor={chartData.isUp ? '#10b981' : '#ef4444'}
                stopOpacity="0"
              />
            </linearGradient>
          </defs>
          <polygon
            points={`${4},${chartData.height - 4} ${chartData.points} ${chartData.width - 4},${chartData.height - 4}`}
            fill="url(#equityGradient)"
          />
          <polyline
            points={chartData.points}
            fill="none"
            stroke={chartData.isUp ? '#10b981' : '#ef4444'}
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
        </svg>
        <div className="equity-range">
          <span>{chartData.min.toFixed(2)}</span>
          <span>{chartData.max.toFixed(2)}</span>
        </div>
      </div>
      <div className="equity-footer">
        <span className={chartData.isUp ? 'positive' : 'negative'}>
          {chartData.isUp ? '+' : ''}{chartData.change.toFixed(4)} SOL (24h)
        </span>
        {walletBalance !== undefined && (
          <span className="wallet-indicator">
            Wallet: {walletBalance.toFixed(4)}
          </span>
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/components/Header.tsx">
import React from 'react';

interface HeaderProps {
  isConnected: boolean;
}

export const Header: React.FC<HeaderProps> = ({ isConnected }) => {
  return (
    <header className="header">
      <div style={{ position: 'absolute', left: '50%', transform: 'translateX(-50%)', width: '300px', height: '80px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
        <img src="/header_full.png" alt="1 to 100 Sol Challenge" style={{ width: '100%', height: '100%', objectFit: 'contain' }} />
      </div>
      <div 
        className="live-badge" 
        style={{
          background: isConnected ? 'var(--success-subtle)' : 'var(--error-subtle)',
          borderColor: isConnected ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)',
          color: isConnected ? 'var(--success)' : 'var(--error)'
        }}
      >
        {isConnected && <span className="live-dot"></span>}
        <span>{isConnected ? 'Live' : 'Disconnected'}</span>
      </div>
    </header>
  );
};
</file>

<file path="src/components/NarrativeStream.tsx">
import React from 'react';
import type { NarrativeSignal } from '../types';

interface NarrativeStreamProps {
  signal: NarrativeSignal | null;
}

export const NarrativeStream: React.FC<NarrativeStreamProps> = ({ signal }) => {
  if (!signal) return null;

  return (
    <div className="card" style={{ marginTop: '24px' }}>
      <div className="card-header">
        <span className="card-title">Narrative Stream</span>
        <div style={{
          padding: '4px 12px',
          borderRadius: '20px',
          fontSize: '11px',
          background: signal.sentiment === 'bullish' ? 'var(--success-subtle)' : 
                      signal.sentiment === 'bearish' ? 'var(--error-subtle)' : 'var(--bg-elevated)',
          color: signal.sentiment === 'bullish' ? 'var(--success)' :
                 signal.sentiment === 'bearish' ? 'var(--error)' : 'var(--text-muted)'
        }}>
          {signal.sentiment.toUpperCase()}
        </div>
      </div>
      <div style={{ padding: '24px' }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '16px' }}>
          <div>
            <div className="stat-label">Bullish Score</div>
            <div className="metric-value" style={{ fontSize: '18px' }}>
              {signal.bullishnessScore.toFixed(2)}
            </div>
          </div>
          <div>
            <div className="stat-label">Hype Score</div>
            <div className="metric-value" style={{ fontSize: '18px', color: 'var(--accent)' }}>
              {(signal.hypeScore * 100).toFixed(0)}%
            </div>
          </div>
        </div>

        <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
          {signal.keywords.map((k, i) => (
            <span key={i} style={{
              background: 'rgba(255,255,255,0.05)',
              padding: '6px 10px',
              borderRadius: '6px',
              fontSize: '12px',
              color: 'var(--text-secondary)'
            }}>
              #{k}
            </span>
          ))}
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/Positions.tsx">
import React from 'react';
import type { Position } from '../hooks/useSocket';

interface PositionsProps {
  positions: Position[];
  summary: { totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null;
}

const formatHoldTime = (ms: number): string => {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  }
  if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  }
  return `${seconds}s`;
};

export const Positions: React.FC<PositionsProps> = ({ positions, summary }) => {
  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">Open Positions</span>
        {summary && (
          <span className={`card-badge ${parseFloat(summary.totalUnrealizedPnl) >= 0 ? 'positive' : 'negative'}`}>
            {parseFloat(summary.totalUnrealizedPnl) >= 0 ? '+' : ''}{parseFloat(summary.totalUnrealizedPnl).toFixed(4)} SOL
          </span>
        )}
      </div>
      <div className="positions-list">
        {positions.length === 0 ? (
          <div className="empty-state">No open positions</div>
        ) : (
          positions.map((p) => {
            const unrealizedPnl = parseFloat(String(p.unrealizedPnl));
            const unrealizedPnlPercent = parseFloat(String(p.unrealizedPnlPercent));
            const realizedPnl = p.realizedPnl ? parseFloat(String(p.realizedPnl)) : 0;
            const isProfit = unrealizedPnl >= 0;
            const holdTime = formatHoldTime(p.holdTime);

            return (
              <div key={p.id} className="position-item">
                <div className={`position-indicator ${isProfit ? 'profit' : 'loss'}`} />
                <div className="position-info">
                  <div className="position-header">
                    <span className="position-symbol">${p.symbol || p.mint.substring(0, 6).toUpperCase()}</span>
                    <span className="position-pool">{p.poolType}</span>
                  </div>
                  <div className="position-details">
                    <span className="position-size">{p.amountSol.toFixed(4)} SOL</span>
                    <span className="position-hold">{holdTime}</span>
                  </div>
                </div>
                <div className="position-pnl">
                  <div className={`position-unrealized ${isProfit ? 'positive' : 'negative'}`}>
                    {isProfit ? '+' : ''}{unrealizedPnl.toFixed(4)}
                    <span className="position-pnl-percent">({unrealizedPnlPercent.toFixed(1)}%)</span>
                  </div>
                  {realizedPnl !== 0 && (
                    <div className="position-realized">
                      Realized: {realizedPnl >= 0 ? '+' : ''}{realizedPnl.toFixed(4)}
                    </div>
                  )}
                </div>
                <div className="position-status">
                  {p.initialRecovered && <span className="status-badge recovered">IR</span>}
                  {p.scaledExitsTaken && p.scaledExitsTaken > 0 && (
                    <span className="status-badge exits">x{p.scaledExitsTaken}</span>
                  )}
                  {p.trailingStop && <span className="status-badge trailing">TS</span>}
                </div>
              </div>
            );
          })
        )}
      </div>
      {summary && positions.length > 0 && (
        <div className="positions-footer">
          <span>Total Exposure: {summary.totalExposure} SOL</span>
          <span>{summary.positionCount} position{summary.positionCount !== 1 ? 's' : ''}</span>
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/StatsGrid.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats } from '../types';

interface StatsGridProps {
  stats: Stats;
}

const NumberDisplay: React.FC<{ value: string | number; className?: string }> = ({ value, className = "" }) => {
  const [displayValue, setDisplayValue] = useState(value);
  const [updating, setUpdating] = useState(false);

  useEffect(() => {
    if (value !== displayValue) {
      setUpdating(true);
      setDisplayValue(value);
      const timer = setTimeout(() => setUpdating(false), 300);
      return () => clearTimeout(timer);
    }
  }, [value, displayValue]);

  return (
    <div className={`animate-number ${updating ? 'updating' : ''} ${className}`}>
      {value}
    </div>
  );
};

export const StatsGrid: React.FC<StatsGridProps> = ({ stats }) => {
  const equity = parseFloat(stats.currentEquity || "0");
  const initial = parseFloat(stats.initialCapital || "0");
  const profit = equity - initial;
  const isProfit = profit >= 0;

  return (
    <div className="stats-grid">
      <div className="stat-card highlight">
        <div className="stat-label">Multiplier</div>
        <NumberDisplay value={`${parseFloat(stats.multiplier || "1").toFixed(2)}x`} className="stat-value accent" />
        <div className={`stat-sub ${isProfit ? 'positive' : ''}`}>
          <span className="arrow">â†‘</span>
          <span>{isProfit ? '+' : ''}{profit.toFixed(2)} SOL profit</span>
        </div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Win Rate</div>
        <NumberDisplay value={`${stats.winRate}%`} className="stat-value" />
        <div className="stat-sub positive">
          <span className="arrow">â†‘</span>
          <span>Creating alpha</span>
        </div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Total Trades</div>
        <NumberDisplay value={stats.totalTrades} className="stat-value" />
        <div className="stat-sub">Lifetime</div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Tokens Scanned</div>
        <NumberDisplay value={stats.tokensScanned} className="stat-value" />
        <div className="stat-sub">Last 24 hours</div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/TokenScanner.tsx">
import React, { useEffect, useState } from 'react';
import type { ScannerData } from '../types';

interface TokenScannerProps {
  data?: ScannerData;
  isScanning: boolean;
}

// Helper to generate chart bars
const MiniChart: React.FC = () => {
  const [bars, setBars] = useState<Array<{ height: number; isUp: boolean }>>([]);

  useEffect(() => {
    // Generate static random chart on mount, or could animate
    const newBars = Array.from({ length: 40 }, () => ({
      height: Math.random() * 70 + 20,
      isUp: Math.random() > 0.4
    }));
    setBars(newBars);
  }, []);

  return (
    <div className="mini-chart">
      {bars.map((bar, i) => (
        <div 
          key={i} 
          className={`chart-bar ${bar.isUp ? 'up' : 'down'}`}
          style={{ height: `${bar.height}%` }}
        />
      ))}
    </div>
  );
};

export const TokenScanner: React.FC<TokenScannerProps> = ({ data, isScanning }) => {
  // Simulating metrics for visual flair if data is generic
  // In real app, these should come from backend
  const [metrics, setMetrics] = useState({
    safetyScore: '--',
    sentiment: '--',
    volume: '--',
    holders: '--'
  });

  useEffect(() => {
    if (data && data.mint) {
      // Simulate "analysis" result display
      setMetrics({
        safetyScore: String(Math.floor(Math.random() * 30 + 70)),
        sentiment: '+' + (Math.random() * 0.8 + 0.2).toFixed(1),
        volume: '$' + (Math.random() * 900000 + 100000).toLocaleString(undefined, { maximumFractionDigits: 0 }),
        holders: (Math.random() * 5000 + 1000).toFixed(0)
      });
    } else {
      setMetrics({
        safetyScore: '--',
        sentiment: '--',
        volume: '--',
        holders: '--'
      });
    }
  }, [data]);

  const tokenName = data?.mint ? `$${data.mint.substring(0, 6).toUpperCase()}` : 'Waiting...';

  return (
    <div className="card scanner-card">
      <div className="card-header">
        <span className="card-title">Token Scanner</span>
      </div>
      <div className="scanner-content">
        <div className="scanner-token">
          <div className={`scanner-icon ${!isScanning && !data?.mint ? 'idle' : ''}`}>
            âŸ³
          </div>
          <div className="scanner-token-info">
            <h4>{tokenName}</h4>
            <p>{isScanning ? 'Scanning for tokens' : 'Analyzing...'}</p>
          </div>
        </div>
        <div className="scanner-metrics">
          <div className="metric-box">
            <div className="metric-value accent">{metrics.safetyScore}</div>
            <div className="metric-label">Safety Score</div>
          </div>
          <div className="metric-box">
            <div className="metric-value success">{metrics.sentiment}</div>
            <div className="metric-label">Sentiment</div>
          </div>
          <div className="metric-box">
            <div className="metric-value">{metrics.volume}</div>
            <div className="metric-label">24H Volume</div>
          </div>
          <div className="metric-box">
            <div className="metric-value">{metrics.holders}</div>
            <div className="metric-label">Holders</div>
          </div>
        </div>
        <MiniChart />
      </div>
    </div>
  );
};
</file>

<file path="src/components/TradeList.tsx">
import React from 'react';
import type { Trade } from '../types';

interface TradeListProps {
  trades: Trade[];
}

export const TradeList: React.FC<TradeListProps> = ({ trades }) => {
  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">Recent Trades</span>
      </div>
      <div className="trades-list">
        {trades.length === 0 ? (
          <div className="empty-state">No trades yet</div>
        ) : (
          trades.map((t, i) => {
            const pnl = parseFloat(t.pnlSol || "0");
            const pnlPercent = parseFloat(t.pnlPercent || "0");
            const isProfit = pnl >= 0;
            const time = new Date(t.exitTime || t.entryTime).toLocaleTimeString('en-US', {
              hour: 'numeric',
              minute: '2-digit',
              hour12: true
            });

            return (
              <div key={i} className="trade-item">
                <div className={`trade-arrow ${isProfit ? 'up' : 'down'}`}>
                  {isProfit ? 'â†‘' : 'â†“'}
                </div>
                <div className="trade-info">
                  <div className="trade-token">
                    ${t.symbol || t.mint.substring(0, 6).toUpperCase()}
                  </div>
                  <div className="trade-time">{time}</div>
                </div>
                <div className="trade-pnl">
                  <div className={`trade-pnl-value ${isProfit ? 'positive' : 'negative'}`}>
                    {isProfit ? '+' : ''}{pnl.toFixed(3)} SOL
                  </div>
                  {isProfit && (
                    <div className="trade-pnl-percent">+{pnlPercent.toFixed(0)}%</div>
                  )}
                </div>
              </div>
            );
          })
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/components/Watchlist.tsx">
import React from 'react';
import type { WatchlistToken, WatchlistStats } from '../types';

interface WatchlistProps {
  tokens: WatchlistToken[];
  stats: WatchlistStats;
}

const getStatusColor = (status: WatchlistToken['status']) => {
  switch (status) {
    case 'collecting': return 'var(--text-muted)';
    case 'ready': return 'var(--accent)';
    case 'analyzing': return 'var(--warning)';
    case 'rejected': return 'var(--error)';
    case 'bought': return 'var(--success)';
    default: return 'var(--text-muted)';
  }
};

const getStatusBg = (status: WatchlistToken['status']) => {
  switch (status) {
    case 'collecting': return 'rgba(255,255,255,0.05)';
    case 'ready': return 'var(--accent-subtle)';
    case 'analyzing': return 'var(--warning-subtle)';
    case 'rejected': return 'var(--error-subtle)';
    case 'bought': return 'var(--success-subtle)';
    default: return 'rgba(255,255,255,0.05)';
  }
};

const formatAge = (firstSeen: number) => {
  const ageMs = Date.now() - firstSeen;
  const ageSec = Math.floor(ageMs / 1000);
  if (ageSec < 60) return `${ageSec}s`;
  const ageMin = Math.floor(ageSec / 60);
  if (ageMin < 60) return `${ageMin}m`;
  return `${Math.floor(ageMin / 60)}h`;
};

export const Watchlist: React.FC<WatchlistProps> = ({ tokens, stats }) => {
  return (
    <div className="card" style={{ marginTop: '24px' }}>
      <div className="card-header">
        <span className="card-title">Token Watchlist</span>
        <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
          <div style={{
            padding: '4px 12px',
            borderRadius: '20px',
            fontSize: '11px',
            background: 'var(--bg-elevated)',
            color: 'var(--text-muted)'
          }}>
            {stats.total} watching
          </div>
          <div style={{
            padding: '4px 12px',
            borderRadius: '20px',
            fontSize: '11px',
            background: 'var(--accent-subtle)',
            color: 'var(--accent)'
          }}>
            {stats.ready} ready
          </div>
          {stats.devSold > 0 && (
            <div style={{
              padding: '4px 12px',
              borderRadius: '20px',
              fontSize: '11px',
              background: 'var(--error-subtle)',
              color: 'var(--error)'
            }}>
              {stats.devSold} dev sold
            </div>
          )}
        </div>
      </div>

      <div style={{ padding: '16px', maxHeight: '400px', overflowY: 'auto' }}>
        {tokens.length === 0 ? (
          <div style={{
            textAlign: 'center',
            color: 'var(--text-muted)',
            padding: '24px',
            fontSize: '13px'
          }}>
            Waiting for new tokens...
          </div>
        ) : (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
            {tokens.map((token) => (
              <div
                key={token.mint}
                style={{
                  background: 'var(--bg-elevated)',
                  borderRadius: '8px',
                  padding: '12px',
                  border: token.devSold ? '1px solid var(--error)' : '1px solid transparent'
                }}
              >
                {/* Header Row */}
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <span style={{ fontFamily: 'var(--font-mono)', fontSize: '12px', color: 'var(--text-primary)' }}>
                      {token.symbol || token.mint.substring(0, 8) + '...'}
                    </span>
                    <span style={{
                      padding: '2px 8px',
                      borderRadius: '4px',
                      fontSize: '10px',
                      background: getStatusBg(token.status),
                      color: getStatusColor(token.status),
                      textTransform: 'uppercase'
                    }}>
                      {token.status}
                    </span>
                  </div>
                  <span style={{ fontSize: '11px', color: 'var(--text-muted)' }}>
                    {formatAge(token.firstSeen)} old
                  </span>
                </div>

                {/* Progress Bar for Data Collection */}
                {token.status === 'collecting' && (
                  <div style={{ marginBottom: '8px' }}>
                    <div style={{
                      background: 'rgba(255,255,255,0.1)',
                      borderRadius: '4px',
                      height: '4px',
                      overflow: 'hidden'
                    }}>
                      <div style={{
                        background: 'var(--accent)',
                        height: '100%',
                        width: `${Math.min(token.dataPoints * 10, 100)}%`,
                        transition: 'width 0.3s ease'
                      }} />
                    </div>
                    <div style={{ fontSize: '10px', color: 'var(--text-muted)', marginTop: '4px' }}>
                      {token.dataPoints}/10 data points
                    </div>
                  </div>
                )}

                {/* Rejection Reason */}
                {token.status === 'rejected' && token.rejectReason && (
                  <div style={{
                    fontSize: '11px',
                    color: 'var(--error)',
                    marginBottom: '8px'
                  }}>
                    {token.rejectReason}
                  </div>
                )}

                {/* Metrics Row */}
                {(token.status === 'ready' || token.status === 'analyzing') && (
                  <div style={{ display: 'flex', gap: '16px', flexWrap: 'wrap' }}>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Price</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.priceChange >= 0 ? 'var(--success)' : 'var(--error)'
                      }}>
                        {token.priceChange >= 0 ? '+' : ''}{(token.priceChange * 100).toFixed(1)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Drawdown</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.drawdown > 0.2 ? 'var(--error)' : 'var(--text-secondary)'
                      }}>
                        -{(token.drawdown * 100).toFixed(1)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Buy Pressure</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.buyPressure > 0.6 ? 'var(--success)' : 'var(--text-secondary)'
                      }}>
                        {(token.buyPressure * 100).toFixed(0)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Traders</div>
                      <div style={{ fontSize: '12px', color: 'var(--text-secondary)' }}>
                        {token.uniqueTraders}
                      </div>
                    </div>
                  </div>
                )}

                {/* Dev Sold Warning */}
                {token.devSold && (
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    marginTop: '8px',
                    padding: '6px 10px',
                    background: 'var(--error-subtle)',
                    borderRadius: '4px'
                  }}>
                    <span style={{ fontSize: '14px' }}>!</span>
                    <span style={{ fontSize: '11px', color: 'var(--error)' }}>DEV SOLD</span>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/hooks/useSocket.ts">
import { useEffect, useState } from 'react';
import { io, type Socket } from 'socket.io-client';
import type { Stats, ScannerData, Trade, ToastData, AIDecisionData, NarrativeSignal, WatchlistToken, WatchlistStats } from '../types';

export interface Position {
  id: string;
  mint: string;
  symbol: string;
  amount: number;
  amountSol: number;
  entryPrice: number;
  currentPrice: number;
  highestPrice: number;
  unrealizedPnl: number;
  unrealizedPnlPercent: number;
  realizedPnl?: number;
  totalPnl?: number;
  totalPnlPercent?: number;
  stopLoss: number;
  trailingStop?: number;
  initialRecovered?: boolean;
  scaledExitsTaken?: number;
  status: string;
  poolType: string;
  entryTime: string;
  holdTime: number;
}

export interface WalletState {
  solBalance: number;
  lastSync: string | null;
  isHealthy: boolean;
  totalEquity?: number;
}

export interface EquitySnapshot {
  timestamp: string;
  totalEquity: number;
  walletBalance: number;
  positionsValue: number;
  unrealizedPnl: number;
  positionCount: number;
}

interface UseSocketReturn {
  socket: Socket | null;
  isConnected: boolean;
  stats: Stats;
  trades: Trade[];
  positions: Position[];
  positionsSummary: { totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null;
  walletState: WalletState | null;
  equityHistory: EquitySnapshot[];
  scannerData: ScannerData | null;
  isScanning: boolean;
  toasts: ToastData[];
  aiDecision: AIDecisionData | null;
  narrativeSignal: NarrativeSignal | null;
  watchlistTokens: WatchlistToken[];
  watchlistStats: WatchlistStats;
  removeToast: (index: number) => void;
}

export const useSocket = (): UseSocketReturn => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  
  // Data State
  const [stats, setStats] = useState<Stats>({
    multiplier: "1.00",
    currentEquity: "0",
    initialCapital: "0",
    winRate: "0",
    totalTrades: 0,
    tokensScanned: 0,
    winStreak: 0
  });
  const [trades, setTrades] = useState<Trade[]>([]);
  const [positions, setPositions] = useState<Position[]>([]);
  const [positionsSummary, setPositionsSummary] = useState<{ totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null>(null);
  const [walletState, setWalletState] = useState<WalletState | null>(null);
  const [equityHistory, setEquityHistory] = useState<EquitySnapshot[]>([]);
  const [scannerData, setScannerData] = useState<ScannerData | null>(null);
  const [isScanning, setIsScanning] = useState(true);
  const [toasts, setToasts] = useState<ToastData[]>([]);
  const [aiDecision, setAiDecision] = useState<AIDecisionData | null>(null);
  const [narrativeSignal, setNarrativeSignal] = useState<NarrativeSignal | null>(null);
  const [watchlistTokens, setWatchlistTokens] = useState<WatchlistToken[]>([]);
  const [watchlistStats, setWatchlistStats] = useState<WatchlistStats>({ total: 0, ready: 0, devSold: 0 });

  // Use ref to access latest functions in event callbacks if needed, 
  // but state setters are stable.

  const addToast = (toast: ToastData) => {
    setToasts(prev => [...prev, toast]);
    // Auto remove after 4s
    setTimeout(() => {
      setToasts(prev => prev.slice(1)); // Simple FIFO removal, might change reference index
    }, 4000);
  };

  const removeToast = (index: number) => {
    setToasts(prev => prev.filter((_, i) => i !== index));
  };

  useEffect(() => {
    // Initial fetch
    const fetchData = async () => {
      try {
        const [statsRes, tradesRes, positionsRes, walletRes, equityRes] = await Promise.all([
          fetch('/api/stats'),
          fetch('/api/trades?limit=10'),
          fetch('/api/positions/realtime'),
          fetch('/api/wallet'),
          fetch('/api/equity-history?hours=24')
        ]);
        if (statsRes.ok) setStats(await statsRes.json());
        if (tradesRes.ok) setTrades(await tradesRes.json());
        if (positionsRes.ok) {
          const posData = await positionsRes.json();
          setPositions(posData.positions || []);
          setPositionsSummary(posData.summary || null);
        }
        if (walletRes.ok) {
          const walletData = await walletRes.json();
          setWalletState({
            solBalance: walletData.solBalance,
            lastSync: walletData.lastSync,
            isHealthy: walletData.isHealthy,
            totalEquity: walletData.equity?.total
          });
        }
        if (equityRes.ok) {
          const equityData = await equityRes.json();
          setEquityHistory(equityData.history || []);
        }
      } catch (err) {
        console.error("Failed to fetch initial data", err);
      }
    };
    fetchData();

    // Socket Connection
    // Note: In development with Vite proxy, '/' works if proxy is set.
    // Otherwise might need absolute URL.
    const newSocket = io('/', {
      transports: ['websocket'],
      reconnectionAttempts: 5
    });

    newSocket.on('connect', () => {
      setIsConnected(true);
      fetchData(); // Refresh on reconnect
    });

    newSocket.on('disconnect', () => {
      setIsConnected(false);
    });

    // Event Handlers
    newSocket.on('stats:initial', (data: Stats) => setStats(data));
    newSocket.on('stats:update', (data: Stats) => setStats(data));
    
    // Trades
    newSocket.on('trades:initial', (data: Trade[]) => setTrades(data));
    
    newSocket.on('trade:open', (trade: Trade) => {
      addToast({
        type: 'info',
        title: 'Position Opened',
        message: `Bought ${trade.symbol || trade.mint.substring(0, 8)} for ${trade.amountSol} SOL`
      });
      // Trade list is usually updated via rest fetch or full list push? 
      // The original code didn't update the list on 'trade:open', only on 'trade:close'.
      // But let's verify if we should.
    });

    newSocket.on('trade:close', (trade: Trade) => {
      const pnl = parseFloat(trade.pnlSol || "0");
      if (pnl > 0) {
        addToast({
          type: 'success',
          title: `+${trade.pnlSol} SOL`,
          message: `${trade.symbol} closed at ${trade.pnlPercent}%`
        });
      } else {
        addToast({
          type: 'error',
          title: `${trade.pnlSol} SOL`,
          message: `${trade.symbol} stopped out`
        });
      }
      // Refresh trades list
      fetch('/api/trades?limit=10')
        .then(r => r.json())
        .then(data => setTrades(data));
    });

    // Scanner
    newSocket.on('scanner:token', (data: ScannerData) => {
      setScannerData(data);
      setIsScanning(false);
      // Also update tokenScanned count in stats immediately if provided in data
      if (data.tokensScanned) {
        setStats(prev => ({ ...prev, tokensScanned: data.tokensScanned }));
      }
    });

    newSocket.on('scanner:idle', (data: ScannerData) => {
      setScannerData(null);
      setIsScanning(true);
      if (data && data.tokensScanned) {
        setStats(prev => ({ ...prev, tokensScanned: data.tokensScanned }));
      }
    });

    newSocket.on('ai:decision', (data: AIDecisionData) => {
      setAiDecision(data);
    });

    newSocket.on('signal:narrative', (data: NarrativeSignal) => {
      setNarrativeSignal(data);
    });

    // Watchlist events
    newSocket.on('watchlist:update', (data: { tokens: WatchlistToken[]; stats: WatchlistStats }) => {
      setWatchlistTokens(data.tokens);
      setWatchlistStats(data.stats);
    });

    newSocket.on('watchlist:tokenAdded', (token: WatchlistToken) => {
      setWatchlistTokens(prev => {
        // Add or update token
        const exists = prev.findIndex(t => t.mint === token.mint);
        if (exists >= 0) {
          const updated = [...prev];
          updated[exists] = token;
          return updated;
        }
        return [token, ...prev].slice(0, 20); // Keep latest 20
      });
    });

    newSocket.on('watchlist:tokenRemoved', (data: { mint: string }) => {
      setWatchlistTokens(prev => prev.filter(t => t.mint !== data.mint));
    });

    newSocket.on('watchlist:devSold', (data: { mint: string }) => {
      setWatchlistTokens(prev => prev.map(t =>
        t.mint === data.mint ? { ...t, devSold: true, status: 'rejected' as const, rejectReason: 'Dev sold' } : t
      ));
    });

    newSocket.on('status:paused', (data: { reason: string }) => {
      addToast({
        type: 'warning',
        title: 'Trading Paused',
        message: data.reason
      });
    });

    newSocket.on('toast', (data: ToastData) => {
      addToast(data);
    });

    // Position updates (real-time PnL)
    newSocket.on('positions:initial', (data: { positions: Position[]; totalUnrealizedPnl: string; totalExposure: string; positionCount: number }) => {
      setPositions(data.positions || []);
      setPositionsSummary({ totalUnrealizedPnl: data.totalUnrealizedPnl, totalExposure: data.totalExposure, positionCount: data.positionCount });
    });

    newSocket.on('positions:update', (data: { positions: Position[]; totalUnrealizedPnl: string; totalExposure: string; positionCount: number }) => {
      setPositions(data.positions || []);
      setPositionsSummary({ totalUnrealizedPnl: data.totalUnrealizedPnl, totalExposure: data.totalExposure, positionCount: data.positionCount });
    });

    // Wallet updates
    newSocket.on('wallet:update', (data: WalletState) => {
      setWalletState(data);
    });

    // Equity snapshots
    newSocket.on('equity:snapshot', (snapshot: EquitySnapshot) => {
      setEquityHistory(prev => {
        const updated = [...prev, snapshot];
        // Keep last 1440 snapshots (24 hours at 1 min intervals)
        if (updated.length > 1440) {
          return updated.slice(-1440);
        }
        return updated;
      });
    });

    // Reconciliation notifications
    newSocket.on('reconciliation:phantoms', (data: { count: number; phantoms: any[] }) => {
      if (data.count > 0) {
        addToast({
          type: 'warning',
          title: 'Phantom Positions Detected',
          message: `Found ${data.count} position(s) with no tokens`
        });
      }
    });

    setSocket(newSocket);

    return () => {
      newSocket.disconnect();
    };
  }, []);

  return {
    socket,
    isConnected,
    stats,
    trades,
    positions,
    positionsSummary,
    walletState,
    equityHistory,
    scannerData,
    isScanning,
    toasts,
    aiDecision,
    narrativeSignal,
    watchlistTokens,
    watchlistStats,
    removeToast
  };
};
</file>

<file path="src/index.css">
:root {
  /* Claude dark mode inspired palette - warm browns */
  --bg-page: #1C1917;
  --bg-card: #262320;
  --bg-card-hover: #2E2A26;
  --bg-elevated: #33302C;
  --border: rgba(255, 245, 230, 0.08);
  --border-light: rgba(255, 245, 230, 0.12);
  --text-primary: #F5F5F4;
  --text-secondary: #A8A29E;
  --text-muted: #78716C;
  --accent: #D97706;
  --accent-secondary: #F59E0B;
  --accent-glow: rgba(217, 119, 6, 0.3);
  --accent-subtle: rgba(217, 119, 6, 0.12);
  --success: #22C55E;
  --success-glow: rgba(34, 197, 94, 0.25);
  --success-subtle: rgba(34, 197, 94, 0.12);
  --error: #EF4444;
  --error-subtle: rgba(239, 68, 68, 0.12);
  --warning: #F59E0B;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg-page);
  color: var(--text-primary);
  min-height: 100vh;
  padding: 24px 32px;
  -webkit-font-smoothing: antialiased;
}

/* Subtle warm noise texture */
body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image:
    radial-gradient(circle at 50% 50%, rgba(217, 119, 6, 0.03) 0%, transparent 50%);
  pointer-events: none;
  z-index: -1;
}

.dashboard {
  max-width: 1280px;
  margin: 0 auto;
}

/* Header */
.header {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin-bottom: 48px;
  position: relative;
  min-height: 80px;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 20px;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  width: max-content;
}

.logo-icon {
  width: 72px;
  height: 72px;
  border-radius: 20px;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 8px 32px var(--accent-glow);
}

.logo-icon svg {
  width: 26px;
  height: 26px;
  color: white;
}

.logo-text h1 {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  letter-spacing: -0.02em;
}

.logo-text p {
  font-size: 13px;
  color: var(--text-muted);
  margin-top: 2px;
}

.live-badge {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 18px;
  border-radius: 100px;
  background: var(--success-subtle);
  border: 1px solid rgba(16, 185, 129, 0.2);
  color: var(--success);
  font-size: 13px;
  font-weight: 500;
  backdrop-filter: blur(10px);
}

.live-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--success);
  box-shadow: 0 0 12px var(--success);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {

  0%,
  100% {
    opacity: 1;
    transform: scale(1);
  }

  50% {
    opacity: 0.6;
    transform: scale(0.9);
  }
}

/* Stats Grid */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
  margin-bottom: 24px;
}

.stat-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 20px 24px;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.stat-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.06), transparent);
}

.stat-card:hover {
  background: var(--bg-card-hover);
  border-color: var(--border-light);
  transform: translateY(-2px);
}

.stat-card.highlight {
  background: linear-gradient(135deg, rgba(255, 107, 53, 0.08), rgba(255, 143, 92, 0.04));
  border-color: rgba(255, 107, 53, 0.3);
}

.stat-card.highlight::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
  opacity: 0.3;
  pointer-events: none;
}

.stat-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 10px;
}

.stat-value {
  font-size: 32px;
  font-weight: 600;
  color: var(--text-primary);
  line-height: 1.1;
  letter-spacing: -0.02em;
}

.stat-value.accent {
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.stat-sub {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
  margin-top: 8px;
}

.stat-sub.positive {
  color: var(--success);
}

.stat-sub .arrow {
  font-size: 14px;
}

/* Main Layout */
.main-grid {
  display: grid;
  grid-template-columns: 1.6fr 1fr;
  gap: 24px;
}

.left-column {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.right-column {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

/* Card Base */
.card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 20px;
  overflow: hidden;
  position: relative;
}

.card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.05), transparent);
}

.card-header {
  padding: 20px 24px;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.card-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.01em;
}

/* Challenge Card */
.challenge-card {
  padding: 48px 32px;
  text-align: center;
  position: relative;
}

.challenge-card::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 400px;
  height: 400px;
  background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
  opacity: 0.4;
  pointer-events: none;
}

.challenge-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.15em;
  margin-bottom: 20px;
  position: relative;
  z-index: 1;
}

.challenge-value {
  font-size: 84px;
  font-weight: 300;
  line-height: 1;
  position: relative;
  z-index: 1;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: 0 0 80px var(--accent-glow);
}

.challenge-value span {
  font-size: 42px;
  background: linear-gradient(135deg, var(--text-muted), var(--text-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.challenge-sub {
  font-size: 14px;
  color: var(--text-secondary);
  margin-top: 12px;
  margin-bottom: 32px;
  position: relative;
  z-index: 1;
}

.progress-bar-container {
  position: relative;
  z-index: 1;
}

.progress-bar {
  height: 10px;
  background: #3D3835;
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
  border-radius: 10px;
  transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
}

.progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.2), transparent);
  animation: shimmer 2.5s infinite;
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%);
  }

  100% {
    transform: translateX(100%);
  }
}

.progress-markers {
  display: flex;
  justify-content: space-between;
  margin-top: 12px;
  font-size: 11px;
  font-weight: 500;
  color: var(--text-muted);
}

.progress-markers span.active {
  color: var(--accent);
}

/* Scanner Card */
.scanner-card .card-header {
  border-bottom: none;
  padding-bottom: 0;
}

.scanner-content {
  padding: 0 24px 24px;
}

.scanner-token {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 18px;
  background: var(--bg-elevated);
  border-radius: 14px;
  margin-bottom: 18px;
  border: 1px solid var(--border);
}

.scanner-icon {
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--accent-subtle), transparent);
  border: 1px solid rgba(255, 107, 53, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  color: var(--accent);
  animation: rotate 2s linear infinite;
}

@keyframes rotate {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}

.scanner-icon.idle {
  animation: none;
}

.scanner-token-info h4 {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.01em;
}

.scanner-token-info p {
  font-size: 12px;
  color: var(--accent);
  margin-top: 2px;
}

.scanner-metrics {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-bottom: 18px;
}

.metric-box {
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px;
  text-align: center;
  transition: all 0.2s ease;
}

.metric-box:hover {
  border-color: var(--border-light);
  background: var(--bg-card-hover);
}

.metric-value {
  font-size: 22px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.02em;
}

.metric-value.accent {
  color: var(--accent);
}

.metric-value.success {
  color: var(--success);
}

.metric-label {
  font-size: 10px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.06em;
  margin-top: 6px;
}

/* Mini Chart */
.mini-chart {
  height: 60px;
  display: flex;
  align-items: flex-end;
  gap: 2px;
  padding: 12px 0;
}

.chart-bar {
  flex: 1;
  border-radius: 3px;
  transition: all 0.3s ease;
  min-height: 4px;
}

.chart-bar.up {
  background: linear-gradient(to top, var(--success), rgba(34, 197, 94, 0.5));
}

.chart-bar.down {
  background: linear-gradient(to top, #A8A29E, #78716C);
}

.chart-bar:hover {
  opacity: 0.8;
  transform: scaleY(1.1);
}

/* Recent Trades */
.trades-list {
  max-height: 360px;
  overflow-y: auto;
}

.trades-list::-webkit-scrollbar {
  width: 4px;
}

.trades-list::-webkit-scrollbar-track {
  background: transparent;
}

.trades-list::-webkit-scrollbar-thumb {
  background: #44403C;
  border-radius: 4px;
}

.trades-list::-webkit-scrollbar-thumb:hover {
  background: #57534E;
}

.trade-item {
  display: flex;
  align-items: center;
  padding: 14px 24px;
  border-bottom: 1px solid var(--border);
  gap: 14px;
  transition: background 0.15s ease;
}

.trade-item:hover {
  background: var(--bg-elevated);
}

.trade-item:last-child {
  border-bottom: none;
}

.trade-arrow {
  width: 36px;
  height: 36px;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: 600;
}

.trade-arrow.up {
  background: var(--success-subtle);
  color: var(--success);
  box-shadow: 0 0 20px var(--success-glow);
}

.trade-arrow.down {
  background: var(--error-subtle);
  color: var(--error);
}

.trade-info {
  flex: 1;
}

.trade-token {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}

.trade-time {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

.trade-pnl {
  text-align: right;
}

.trade-pnl-value {
  font-size: 14px;
  font-weight: 600;
}

.trade-pnl-value.positive {
  color: var(--success);
}

.trade-pnl-value.negative {
  color: var(--text-secondary);
}

.trade-pnl-percent {
  font-size: 11px;
  color: var(--success);
  margin-top: 2px;
}

/* AI Engine */
.ai-content {
  padding: 28px 24px;
  text-align: center;
}

.ai-indicator {
  width: 100px;
  height: 100px;
  margin: 0 auto 20px;
  position: relative;
}

.ai-ring-outer {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  border: 2px solid #3D3835;
}

.ai-ring {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  border: 2px solid transparent;
  border-top-color: var(--accent);
  animation: spin 1.5s linear infinite;
}

.ai-ring-inner {
  position: absolute;
  width: 70%;
  height: 70%;
  top: 15%;
  left: 15%;
  border-radius: 50%;
  border: 2px solid transparent;
  border-top-color: var(--accent-secondary);
  animation: spin 2s linear infinite reverse;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.ai-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 30px var(--accent-glow);
}

.ai-center-dot {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #FAFAF9;
  animation: pulse 2s ease-in-out infinite;
}

.ai-status {
  font-size: 13px;
  color: var(--text-secondary);
  margin-bottom: 20px;
}

.confidence-bar {
  margin-bottom: 24px;
}

.confidence-header {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  margin-bottom: 8px;
}

.confidence-header span:first-child {
  color: var(--text-muted);
}

.confidence-header span:last-child {
  color: var(--accent);
  font-weight: 600;
}

.confidence-track {
  height: 6px;
  background: #3D3835;
  border-radius: 6px;
  overflow: hidden;
}

.confidence-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
  border-radius: 6px;
  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

.win-streak-box {
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 24px;
}

.win-streak-value {
  font-size: 48px;
  font-weight: 300;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  line-height: 1;
}

.win-streak-label {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 8px;
}

/* Toast Notifications */
.toast-container {
  position: fixed;
  top: 24px;
  right: 24px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  z-index: 1000;
}

.toast {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 16px 20px;
  min-width: 300px;
  animation: slideIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
  backdrop-filter: blur(20px);
}

.toast.success {
  border-left: 3px solid var(--success);
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), 0 0 40px var(--success-glow);
}

.toast.error {
  border-left: 3px solid var(--error);
}

.toast.warning {
  border-left: 3px solid var(--warning);
}

.toast.info {
  border-left: 3px solid var(--accent);
}

.toast-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 4px;
}

.toast.success .toast-title {
  color: var(--success);
}

.toast.error .toast-title {
  color: var(--error);
}

.toast-message {
  font-size: 13px;
  color: var(--text-secondary);
}

@keyframes slideIn {
  from {
    transform: translateX(100%) scale(0.9);
    opacity: 0;
  }

  to {
    transform: translateX(0) scale(1);
    opacity: 1;
  }
}

/* Empty State */
.empty-state {
  padding: 40px 24px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
}

/* Responsive */
@media (max-width: 1024px) {
  .stats-grid {
    grid-template-columns: repeat(2, 1fr);
  }

  .main-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 600px) {
  .stats-grid {
    grid-template-columns: 1fr;
  }

  body {
    padding: 16px;
  }

  .header {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
  }

  .header-left {
    width: 100%;
  }

  .live-badge {
    position: absolute;
    top: 16px;
    right: 16px;
  }

  .challenge-value {
    font-size: 56px;
  }
}

/* Number animation */
.animate-number {
  display: inline-block;
  transition: transform 0.3s ease;
}

.animate-number.updating {
  transform: scale(1.05);
}

/* Positions Component */
.positions-list {
  max-height: 300px;
  overflow-y: auto;
}

.positions-list::-webkit-scrollbar {
  width: 4px;
}

.positions-list::-webkit-scrollbar-track {
  background: transparent;
}

.positions-list::-webkit-scrollbar-thumb {
  background: #44403C;
  border-radius: 4px;
}

.position-item {
  display: flex;
  align-items: center;
  padding: 14px 24px;
  border-bottom: 1px solid var(--border);
  gap: 12px;
  transition: background 0.15s ease;
}

.position-item:hover {
  background: var(--bg-elevated);
}

.position-item:last-child {
  border-bottom: none;
}

.position-indicator {
  width: 4px;
  height: 40px;
  border-radius: 2px;
}

.position-indicator.profit {
  background: var(--success);
  box-shadow: 0 0 8px var(--success-glow);
}

.position-indicator.loss {
  background: var(--error);
}

.position-info {
  flex: 1;
  min-width: 0;
}

.position-header {
  display: flex;
  align-items: center;
  gap: 8px;
}

.position-symbol {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}

.position-pool {
  font-size: 10px;
  font-weight: 500;
  padding: 2px 6px;
  border-radius: 4px;
  background: var(--accent-subtle);
  color: var(--accent);
  text-transform: uppercase;
}

.position-details {
  display: flex;
  gap: 12px;
  margin-top: 4px;
  font-size: 11px;
  color: var(--text-muted);
}

.position-pnl {
  text-align: right;
}

.position-unrealized {
  font-size: 14px;
  font-weight: 600;
}

.position-unrealized.positive {
  color: var(--success);
}

.position-unrealized.negative {
  color: var(--error);
}

.position-pnl-percent {
  font-size: 11px;
  opacity: 0.8;
  margin-left: 4px;
}

.position-realized {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

.position-status {
  display: flex;
  gap: 4px;
}

.status-badge {
  font-size: 9px;
  font-weight: 600;
  padding: 2px 5px;
  border-radius: 3px;
  text-transform: uppercase;
}

.status-badge.recovered {
  background: var(--success-subtle);
  color: var(--success);
}

.status-badge.exits {
  background: var(--accent-subtle);
  color: var(--accent);
}

.status-badge.trailing {
  background: rgba(139, 92, 246, 0.12);
  color: #a78bfa;
}

.positions-footer {
  padding: 12px 24px;
  border-top: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  color: var(--text-muted);
}

.card-badge {
  font-size: 12px;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 6px;
}

.card-badge.positive {
  background: var(--success-subtle);
  color: var(--success);
}

.card-badge.negative {
  background: var(--error-subtle);
  color: var(--error);
}

/* Equity Chart Component */
.equity-chart-card {
  min-height: 180px;
}

.equity-chart-content {
  padding: 16px 24px;
}

.equity-chart-empty {
  padding: 40px 24px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.wallet-balance {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
}

.equity-current {
  display: flex;
  align-items: baseline;
  gap: 6px;
  margin-bottom: 12px;
}

.equity-value {
  font-size: 28px;
  font-weight: 600;
  color: var(--text-primary);
}

.equity-label {
  font-size: 14px;
  color: var(--text-muted);
}

.equity-sparkline {
  width: 100%;
  height: 60px;
  display: block;
}

.equity-range {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 4px;
}

.equity-footer {
  padding: 12px 24px;
  border-top: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  font-size: 12px;
}

.equity-footer .positive {
  color: var(--success);
}

.equity-footer .negative {
  color: var(--error);
}

.wallet-indicator {
  color: var(--text-muted);
}
</file>

<file path="src/main.tsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  // StrictMode disabled to prevent double-socket connection in dev
  // or handle cleanup carefully in useEffect (which we did).
  // Keeping it enabled is fine if cleanup is robust.
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
</file>

<file path="src/types.ts">
export interface Stats {
  multiplier: string;
  currentEquity: string;
  initialCapital: string;
  winRate: string;
  totalTrades: number;
  tokensScanned: number;
  winStreak: number;
}

export interface Trade {
  id?: string;
  mint: string;
  symbol: string;
  amountSol: number;
  amountTokens: number;
  entryPrice: number;
  exitPrice?: number;
  pnlSol?: string;
  pnlPercent?: string;
  isOpen: boolean;
  entryTime: string;
  exitTime?: string;
}

export interface ScannerData {
  mint: string;
  tokensScanned: number;
  timestamp: number;
}

export interface ToastData {
  type: 'success' | 'error' | 'warning' | 'info';
  title: string;
  message: string;
}

export interface AIDecisionData {
  action: 0 | 1 | 2; // HOLD=0, BUY=1, SELL=2
  confidence: number;
  regime: 0 | 1 | 2; // BULL=0, VOLATILE=1, CRASH=2
  qValues: number[];
  mint: string;
  symbol: string;
  timestamp: string;
}

export interface NarrativeSignal {
  sentiment: 'bullish' | 'bearish' | 'neutral';
  bullishnessScore: number;
  hypeScore: number;
  keywords: string[];
  mint?: string;
  symbol?: string;
}

// Token Watchlist Types
export interface WatchlistToken {
  mint: string;
  symbol?: string;
  firstSeen: number;
  dataPoints: number;
  priceChange: number;
  volatility: number;
  drawdown: number;
  buyPressure: number;
  uniqueTraders: number;
  devSold: boolean;
  status: 'collecting' | 'ready' | 'analyzing' | 'rejected' | 'bought';
  rejectReason?: string;
}

export interface WatchlistStats {
  total: number;
  ready: number;
  devSold: number;
}
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "types": [
      "vite/client"
    ],
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": [
    "src"
  ]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3500',
        changeOrigin: true,
      },
      '/socket.io': {
        target: 'http://localhost:3500',
        ws: true,
      },
    },
  },
})
</file>

</files>
</file>

<file path="client/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="client/src/App.tsx">
import { Header } from './components/Header';
import { StatsGrid } from './components/StatsGrid';
import { ChallengeCard } from './components/ChallengeCard';
import { TokenScanner } from './components/TokenScanner';
import { TradeList } from './components/TradeList';
import { AIStatus } from './components/AIStatus';
import { Watchlist } from './components/Watchlist';
import { Positions } from './components/Positions';
import { EquityChart } from './components/EquityChart';
import { useSocket } from './hooks/useSocket';

function App() {
  const {
    isConnected,
    stats,
    trades,
    positions,
    positionsSummary,
    walletState,
    equityHistory,
    scannerData,
    isScanning,
    toasts,
    aiDecision,
    watchlistTokens,
    watchlistStats
  } = useSocket();

  return (
    <>
      <div className="dashboard">
        <Header isConnected={isConnected} />
        
        <StatsGrid stats={stats} />

        <div className="main-grid">
          <div className="left-column">
            <ChallengeCard stats={stats} />
            <EquityChart history={equityHistory} walletBalance={walletState?.solBalance} />
            <Positions positions={positions} summary={positionsSummary} />
            <TokenScanner data={scannerData || undefined} isScanning={isScanning} />
          </div>

          <div className="right-column">
            <TradeList trades={trades} />
            <AIStatus stats={stats} decision={aiDecision} />
            <Watchlist tokens={watchlistTokens} stats={watchlistStats} />
          </div>
        </div>
      </div>

      <div className="toast-container">
        {toasts.map((toast, i) => (
          <div key={i} className={`toast ${toast.type}`}>
            <div className="toast-title">{toast.title}</div>
            <div className="toast-message">{toast.message}</div>
          </div>
        ))}
      </div>
    </>
  );
}

export default App;
</file>

<file path="client/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="client/src/components/AIStatus.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats, AIDecisionData } from '../types';

interface AIStatusProps {
  stats: Stats;
  decision: AIDecisionData | null;
}

export const AIStatus: React.FC<AIStatusProps> = ({ stats, decision }) => {
  const [statusText, setStatusText] = useState('Initializing AI Model...');
  const winRate = parseFloat(stats.winRate || "0");
  const winStreak = stats.winStreak || 0;

  useEffect(() => {
    if (!decision) return;

    // Map action to text
    const actions = ['HOLD', 'BUY', 'SELL'];
    const actionText = actions[decision.action];
    
    // Map regime to text
    const regimes = ['BULL MARKET', 'VOLATILE', 'CRASH DETECTED'];
    const regimeText = regimes[decision.regime];

    setStatusText(`${regimeText}: Considering ${actionText} on $${decision.symbol}`);
  }, [decision]);

  // Fallback animation if no decision yet
  useEffect(() => {
    if (decision) return;
    const statuses = ['Analyzing market structure', 'Calculating Q-values', 'Scanning liquidity'];
    let index = 0;
    const interval = setInterval(() => {
      index = (index + 1) % statuses.length;
      setStatusText(statuses[index]);
    }, 3000);
    return () => clearInterval(interval);
  }, [decision]);

  // Visualize Q-Values (Buy vs Hold vs Sell reward expectations)
  // Normalize for display: find max absolute value to scale bars
  const qValues = decision?.qValues || [0, 0, 0]; // [Hold, Buy, Sell] typically
  const maxQ = Math.max(...qValues.map(Math.abs), 1); // Avoid div by zero
  
  // Confidence for the bar
  // Scale factor: AI confidence is often raw difference in Q-values (0.01-0.1 range)
  // We apply a sigmoid-like scaling to make it visible on the 0-100% bar
  const rawConfidence = decision ? decision.confidence : (winRate / 100);
  const scaledConfidence = Math.min(100, Math.max(0, rawConfidence * 500)); // Boost factor
  
  const confidence = decision ? scaledConfidence : Math.min(100, Math.max(0, winRate * 1.2));

  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">AI Engine</span>
      </div>
      <div className="ai-content">
        <div className="ai-indicator">
          <div className="ai-ring-outer"></div>
          <div className="ai-ring" style={{ animationDuration: decision ? '0.5s' : '1.5s' }}></div>
          <div className="ai-ring-inner"></div>
          <div className="ai-center">
            <div className="ai-center-dot" style={{ 
              background: decision?.action === 1 ? 'var(--success)' : 
                          decision?.action === 2 ? 'var(--error)' : '#FAFAF9' 
            }}></div>
          </div>
        </div>
        
        <div className="ai-status" style={{ minHeight: '40px' }}>{statusText}</div>

        {/* Q-Value Visualization */}
        <div style={{ display: 'flex', gap: '8px', marginBottom: '20px', height: '60px', alignItems: 'flex-end' }}>
          {['HOLD', 'BUY', 'SELL'].map((label, i) => {
            const val = qValues[i] || 0;
            const height = Math.abs(val) / maxQ * 100;
            const color = val > 0 ? 'var(--success)' : 'var(--error)';
            const isSelected = decision?.action === i;
            
            return (
              <div key={label} style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', opacity: isSelected ? 1 : 0.5 }}>
                 <div style={{ 
                   width: '100%', 
                   height: `${Math.max(10, height)}%`, 
                   background: color,
                   borderRadius: '4px',
                   transition: 'all 0.3s ease'
                 }}></div>
                 <span style={{ fontSize: '10px', marginTop: '4px', color: 'var(--text-muted)' }}>{label}</span>
              </div>
            );
          })}
        </div>

        <div className="confidence-bar">
          <div className="confidence-header">
            <span>Confidence</span>
            <span>{confidence.toFixed(0)}%</span>
          </div>
          <div className="confidence-track">
            <div 
              className="confidence-fill" 
              style={{ width: `${confidence}%` }}
            ></div>
          </div>
        </div>
        <div className="win-streak-box">
          <div className="win-streak-value animate-number">{winStreak}</div>
          <div className="win-streak-label">Win streak</div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/ChallengeCard.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats } from '../types';

interface ChallengeCardProps {
  stats: Stats;
}

export const ChallengeCard: React.FC<ChallengeCardProps> = ({ stats }) => {
  const multiplier = parseFloat(stats.multiplier || "1");
  const equity = parseFloat(stats.currentEquity || stats.initialCapital || "1");
  const initial = parseFloat(stats.initialCapital || "1");
  
  // Progress calculation (logarithmic scale feels better but linear for now as per original)
  // Max at 100x
  const progress = Math.min(100, Math.max(1, multiplier));

  const [displayMultiplier, setDisplayMultiplier] = useState(multiplier);
  
  useEffect(() => {
    setDisplayMultiplier(multiplier);
  }, [multiplier]);

  return (
    <div className="card">
      <div className="challenge-card">
        <div className="challenge-label">THE 1 â†’ 100 CHALLENGE</div>
        <div className="challenge-value animate-number">
          {displayMultiplier.toFixed(2)}<span>x</span>
        </div>
        <div className="challenge-sub">
          {equity.toFixed(2)} SOL from {initial} SOL start
        </div>
        <div className="progress-bar-container">
          <div className="progress-bar">
            <div 
              className="progress-fill" 
              style={{ width: `${progress}%` }}
            ></div>
          </div>
          <div className="progress-markers">
            <span className={multiplier >= 1 ? 'active' : ''}>1x</span>
            <span className={multiplier >= 10 ? 'active' : ''}>10x</span>
            <span className={multiplier >= 25 ? 'active' : ''}>25x</span>
            <span className={multiplier >= 50 ? 'active' : ''}>50x</span>
            <span className={multiplier >= 100 ? 'active' : ''}>100x</span>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/EquityChart.tsx">
import React, { useMemo } from 'react';
import type { EquitySnapshot } from '../hooks/useSocket';

interface EquityChartProps {
  history: EquitySnapshot[];
  walletBalance?: number;
}

export const EquityChart: React.FC<EquityChartProps> = ({ history, walletBalance }) => {
  const chartData = useMemo(() => {
    if (history.length < 2) return null;

    const values = history.map(s => s.totalEquity);
    const minVal = Math.min(...values);
    const maxVal = Math.max(...values);
    const range = maxVal - minVal || 1;

    // Chart dimensions
    const width = 300;
    const height = 60;
    const padding = 4;

    // Calculate points
    const points = values.map((val, i) => {
      const x = padding + (i / (values.length - 1)) * (width - padding * 2);
      const y = height - padding - ((val - minVal) / range) * (height - padding * 2);
      return `${x},${y}`;
    }).join(' ');

    // Determine trend
    const firstVal = values[0];
    const lastVal = values[values.length - 1];
    const isUp = lastVal >= firstVal;
    const change = lastVal - firstVal;
    const changePercent = firstVal > 0 ? (change / firstVal) * 100 : 0;

    return {
      points,
      width,
      height,
      isUp,
      change,
      changePercent,
      current: lastVal,
      min: minVal,
      max: maxVal,
    };
  }, [history]);

  if (!chartData) {
    return (
      <div className="card equity-chart-card">
        <div className="card-header">
          <span className="card-title">Equity</span>
        </div>
        <div className="equity-chart-empty">
          <span>Collecting data...</span>
          {walletBalance !== undefined && (
            <span className="wallet-balance">{walletBalance.toFixed(4)} SOL</span>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="card equity-chart-card">
      <div className="card-header">
        <span className="card-title">Equity</span>
        <span className={`card-badge ${chartData.isUp ? 'positive' : 'negative'}`}>
          {chartData.isUp ? '+' : ''}{chartData.changePercent.toFixed(2)}%
        </span>
      </div>
      <div className="equity-chart-content">
        <div className="equity-current">
          <span className="equity-value">{chartData.current.toFixed(4)}</span>
          <span className="equity-label">SOL</span>
        </div>
        <svg
          className="equity-sparkline"
          viewBox={`0 0 ${chartData.width} ${chartData.height}`}
          preserveAspectRatio="none"
        >
          <defs>
            <linearGradient id="equityGradient" x1="0" y1="0" x2="0" y2="1">
              <stop
                offset="0%"
                stopColor={chartData.isUp ? '#10b981' : '#ef4444'}
                stopOpacity="0.3"
              />
              <stop
                offset="100%"
                stopColor={chartData.isUp ? '#10b981' : '#ef4444'}
                stopOpacity="0"
              />
            </linearGradient>
          </defs>
          <polygon
            points={`${4},${chartData.height - 4} ${chartData.points} ${chartData.width - 4},${chartData.height - 4}`}
            fill="url(#equityGradient)"
          />
          <polyline
            points={chartData.points}
            fill="none"
            stroke={chartData.isUp ? '#10b981' : '#ef4444'}
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
        </svg>
        <div className="equity-range">
          <span>{chartData.min.toFixed(2)}</span>
          <span>{chartData.max.toFixed(2)}</span>
        </div>
      </div>
      <div className="equity-footer">
        <span className={chartData.isUp ? 'positive' : 'negative'}>
          {chartData.isUp ? '+' : ''}{chartData.change.toFixed(4)} SOL (24h)
        </span>
        {walletBalance !== undefined && (
          <span className="wallet-indicator">
            Wallet: {walletBalance.toFixed(4)}
          </span>
        )}
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/Header.tsx">
import React from 'react';

interface HeaderProps {
  isConnected: boolean;
}

export const Header: React.FC<HeaderProps> = ({ isConnected }) => {
  return (
    <header className="header">
      <div style={{ position: 'absolute', left: '50%', transform: 'translateX(-50%)', width: '300px', height: '80px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
        <img src="/header_full.png" alt="1 to 100 Sol Challenge" style={{ width: '100%', height: '100%', objectFit: 'contain' }} />
      </div>
      <div 
        className="live-badge" 
        style={{
          background: isConnected ? 'var(--success-subtle)' : 'var(--error-subtle)',
          borderColor: isConnected ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)',
          color: isConnected ? 'var(--success)' : 'var(--error)'
        }}
      >
        {isConnected && <span className="live-dot"></span>}
        <span>{isConnected ? 'Live' : 'Disconnected'}</span>
      </div>
    </header>
  );
};
</file>

<file path="client/src/components/NarrativeStream.tsx">
import React from 'react';
import type { NarrativeSignal } from '../types';

interface NarrativeStreamProps {
  signal: NarrativeSignal | null;
}

export const NarrativeStream: React.FC<NarrativeStreamProps> = ({ signal }) => {
  if (!signal) return null;

  return (
    <div className="card" style={{ marginTop: '24px' }}>
      <div className="card-header">
        <span className="card-title">Narrative Stream</span>
        <div style={{
          padding: '4px 12px',
          borderRadius: '20px',
          fontSize: '11px',
          background: signal.sentiment === 'bullish' ? 'var(--success-subtle)' : 
                      signal.sentiment === 'bearish' ? 'var(--error-subtle)' : 'var(--bg-elevated)',
          color: signal.sentiment === 'bullish' ? 'var(--success)' :
                 signal.sentiment === 'bearish' ? 'var(--error)' : 'var(--text-muted)'
        }}>
          {signal.sentiment.toUpperCase()}
        </div>
      </div>
      <div style={{ padding: '24px' }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '16px' }}>
          <div>
            <div className="stat-label">Bullish Score</div>
            <div className="metric-value" style={{ fontSize: '18px' }}>
              {signal.bullishnessScore.toFixed(2)}
            </div>
          </div>
          <div>
            <div className="stat-label">Hype Score</div>
            <div className="metric-value" style={{ fontSize: '18px', color: 'var(--accent)' }}>
              {(signal.hypeScore * 100).toFixed(0)}%
            </div>
          </div>
        </div>

        <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
          {signal.keywords.map((k, i) => (
            <span key={i} style={{
              background: 'rgba(255,255,255,0.05)',
              padding: '6px 10px',
              borderRadius: '6px',
              fontSize: '12px',
              color: 'var(--text-secondary)'
            }}>
              #{k}
            </span>
          ))}
        </div>
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/Positions.tsx">
import React from 'react';
import type { Position } from '../hooks/useSocket';

interface PositionsProps {
  positions: Position[];
  summary: { totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null;
}

const formatHoldTime = (ms: number): string => {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  }
  if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  }
  return `${seconds}s`;
};

export const Positions: React.FC<PositionsProps> = ({ positions, summary }) => {
  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">Open Positions</span>
        {summary && (
          <span className={`card-badge ${parseFloat(summary.totalUnrealizedPnl) >= 0 ? 'positive' : 'negative'}`}>
            {parseFloat(summary.totalUnrealizedPnl) >= 0 ? '+' : ''}{parseFloat(summary.totalUnrealizedPnl).toFixed(4)} SOL
          </span>
        )}
      </div>
      <div className="positions-list">
        {positions.length === 0 ? (
          <div className="empty-state">No open positions</div>
        ) : (
          positions.map((p) => {
            const unrealizedPnl = parseFloat(String(p.unrealizedPnl));
            const unrealizedPnlPercent = parseFloat(String(p.unrealizedPnlPercent));
            const realizedPnl = p.realizedPnl ? parseFloat(String(p.realizedPnl)) : 0;
            const isProfit = unrealizedPnl >= 0;
            const holdTime = formatHoldTime(p.holdTime);

            return (
              <div key={p.id} className="position-item">
                <div className={`position-indicator ${isProfit ? 'profit' : 'loss'}`} />
                <div className="position-info">
                  <div className="position-header">
                    <span className="position-symbol">${p.symbol || p.mint.substring(0, 6).toUpperCase()}</span>
                    <span className="position-pool">{p.poolType}</span>
                  </div>
                  <div className="position-details">
                    <span className="position-size">{p.amountSol.toFixed(4)} SOL</span>
                    <span className="position-hold">{holdTime}</span>
                  </div>
                </div>
                <div className="position-pnl">
                  <div className={`position-unrealized ${isProfit ? 'positive' : 'negative'}`}>
                    {isProfit ? '+' : ''}{unrealizedPnl.toFixed(4)}
                    <span className="position-pnl-percent">({unrealizedPnlPercent.toFixed(1)}%)</span>
                  </div>
                  {realizedPnl !== 0 && (
                    <div className="position-realized">
                      Realized: {realizedPnl >= 0 ? '+' : ''}{realizedPnl.toFixed(4)}
                    </div>
                  )}
                </div>
                <div className="position-status">
                  {p.initialRecovered && <span className="status-badge recovered">IR</span>}
                  {p.scaledExitsTaken && p.scaledExitsTaken > 0 && (
                    <span className="status-badge exits">x{p.scaledExitsTaken}</span>
                  )}
                  {p.trailingStop && <span className="status-badge trailing">TS</span>}
                </div>
              </div>
            );
          })
        )}
      </div>
      {summary && positions.length > 0 && (
        <div className="positions-footer">
          <span>Total Exposure: {summary.totalExposure} SOL</span>
          <span>{summary.positionCount} position{summary.positionCount !== 1 ? 's' : ''}</span>
        </div>
      )}
    </div>
  );
};
</file>

<file path="client/src/components/StatsGrid.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats } from '../types';

interface StatsGridProps {
  stats: Stats;
}

const NumberDisplay: React.FC<{ value: string | number; className?: string }> = ({ value, className = "" }) => {
  const [displayValue, setDisplayValue] = useState(value);
  const [updating, setUpdating] = useState(false);

  useEffect(() => {
    if (value !== displayValue) {
      setUpdating(true);
      setDisplayValue(value);
      const timer = setTimeout(() => setUpdating(false), 300);
      return () => clearTimeout(timer);
    }
  }, [value, displayValue]);

  return (
    <div className={`animate-number ${updating ? 'updating' : ''} ${className}`}>
      {value}
    </div>
  );
};

export const StatsGrid: React.FC<StatsGridProps> = ({ stats }) => {
  const equity = parseFloat(stats.currentEquity || "0");
  const initial = parseFloat(stats.initialCapital || "0");
  const profit = equity - initial;
  const isProfit = profit >= 0;

  return (
    <div className="stats-grid">
      <div className="stat-card highlight">
        <div className="stat-label">Multiplier</div>
        <NumberDisplay value={`${parseFloat(stats.multiplier || "1").toFixed(2)}x`} className="stat-value accent" />
        <div className={`stat-sub ${isProfit ? 'positive' : ''}`}>
          <span className="arrow">â†‘</span>
          <span>{isProfit ? '+' : ''}{profit.toFixed(2)} SOL profit</span>
        </div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Win Rate</div>
        <NumberDisplay value={`${stats.winRate}%`} className="stat-value" />
        <div className="stat-sub positive">
          <span className="arrow">â†‘</span>
          <span>Creating alpha</span>
        </div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Total Trades</div>
        <NumberDisplay value={stats.totalTrades} className="stat-value" />
        <div className="stat-sub">Lifetime</div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Tokens Scanned</div>
        <NumberDisplay value={stats.tokensScanned} className="stat-value" />
        <div className="stat-sub">Last 24 hours</div>
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/TokenScanner.tsx">
import React, { useEffect, useState } from 'react';
import type { ScannerData } from '../types';

interface TokenScannerProps {
  data?: ScannerData;
  isScanning: boolean;
}

// Helper to generate chart bars
const MiniChart: React.FC = () => {
  const [bars, setBars] = useState<Array<{ height: number; isUp: boolean }>>([]);

  useEffect(() => {
    // Generate static random chart on mount, or could animate
    const newBars = Array.from({ length: 40 }, () => ({
      height: Math.random() * 70 + 20,
      isUp: Math.random() > 0.4
    }));
    setBars(newBars);
  }, []);

  return (
    <div className="mini-chart">
      {bars.map((bar, i) => (
        <div 
          key={i} 
          className={`chart-bar ${bar.isUp ? 'up' : 'down'}`}
          style={{ height: `${bar.height}%` }}
        />
      ))}
    </div>
  );
};

export const TokenScanner: React.FC<TokenScannerProps> = ({ data, isScanning }) => {
  // Simulating metrics for visual flair if data is generic
  // In real app, these should come from backend
  const [metrics, setMetrics] = useState({
    safetyScore: '--',
    sentiment: '--',
    volume: '--',
    holders: '--'
  });

  useEffect(() => {
    if (data && data.mint) {
      // Simulate "analysis" result display
      setMetrics({
        safetyScore: String(Math.floor(Math.random() * 30 + 70)),
        sentiment: '+' + (Math.random() * 0.8 + 0.2).toFixed(1),
        volume: '$' + (Math.random() * 900000 + 100000).toLocaleString(undefined, { maximumFractionDigits: 0 }),
        holders: (Math.random() * 5000 + 1000).toFixed(0)
      });
    } else {
      setMetrics({
        safetyScore: '--',
        sentiment: '--',
        volume: '--',
        holders: '--'
      });
    }
  }, [data]);

  const tokenName = data?.mint ? `$${data.mint.substring(0, 6).toUpperCase()}` : 'Waiting...';

  return (
    <div className="card scanner-card">
      <div className="card-header">
        <span className="card-title">Token Scanner</span>
      </div>
      <div className="scanner-content">
        <div className="scanner-token">
          <div className={`scanner-icon ${!isScanning && !data?.mint ? 'idle' : ''}`}>
            âŸ³
          </div>
          <div className="scanner-token-info">
            <h4>{tokenName}</h4>
            <p>{isScanning ? 'Scanning for tokens' : 'Analyzing...'}</p>
          </div>
        </div>
        <div className="scanner-metrics">
          <div className="metric-box">
            <div className="metric-value accent">{metrics.safetyScore}</div>
            <div className="metric-label">Safety Score</div>
          </div>
          <div className="metric-box">
            <div className="metric-value success">{metrics.sentiment}</div>
            <div className="metric-label">Sentiment</div>
          </div>
          <div className="metric-box">
            <div className="metric-value">{metrics.volume}</div>
            <div className="metric-label">24H Volume</div>
          </div>
          <div className="metric-box">
            <div className="metric-value">{metrics.holders}</div>
            <div className="metric-label">Holders</div>
          </div>
        </div>
        <MiniChart />
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/TradeList.tsx">
import React from 'react';
import type { Trade } from '../types';

interface TradeListProps {
  trades: Trade[];
}

export const TradeList: React.FC<TradeListProps> = ({ trades }) => {
  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">Recent Trades</span>
      </div>
      <div className="trades-list">
        {trades.length === 0 ? (
          <div className="empty-state">No trades yet</div>
        ) : (
          trades.map((t, i) => {
            const pnl = parseFloat(t.pnlSol || "0");
            const pnlPercent = parseFloat(t.pnlPercent || "0");
            const isProfit = pnl >= 0;
            const time = new Date(t.exitTime || t.entryTime).toLocaleTimeString('en-US', {
              hour: 'numeric',
              minute: '2-digit',
              hour12: true
            });

            return (
              <div key={i} className="trade-item">
                <div className={`trade-arrow ${isProfit ? 'up' : 'down'}`}>
                  {isProfit ? 'â†‘' : 'â†“'}
                </div>
                <div className="trade-info">
                  <div className="trade-token">
                    ${t.symbol || t.mint.substring(0, 6).toUpperCase()}
                  </div>
                  <div className="trade-time">{time}</div>
                </div>
                <div className="trade-pnl">
                  <div className={`trade-pnl-value ${isProfit ? 'positive' : 'negative'}`}>
                    {isProfit ? '+' : ''}{pnl.toFixed(3)} SOL
                  </div>
                  {isProfit && (
                    <div className="trade-pnl-percent">+{pnlPercent.toFixed(0)}%</div>
                  )}
                </div>
              </div>
            );
          })
        )}
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/Watchlist.tsx">
import React from 'react';
import type { WatchlistToken, WatchlistStats } from '../types';

interface WatchlistProps {
  tokens: WatchlistToken[];
  stats: WatchlistStats;
}

const getStatusColor = (status: WatchlistToken['status']) => {
  switch (status) {
    case 'collecting': return 'var(--text-muted)';
    case 'ready': return 'var(--accent)';
    case 'analyzing': return 'var(--warning)';
    case 'rejected': return 'var(--error)';
    case 'bought': return 'var(--success)';
    default: return 'var(--text-muted)';
  }
};

const getStatusBg = (status: WatchlistToken['status']) => {
  switch (status) {
    case 'collecting': return 'rgba(255,255,255,0.05)';
    case 'ready': return 'var(--accent-subtle)';
    case 'analyzing': return 'var(--warning-subtle)';
    case 'rejected': return 'var(--error-subtle)';
    case 'bought': return 'var(--success-subtle)';
    default: return 'rgba(255,255,255,0.05)';
  }
};

const formatAge = (firstSeen: number) => {
  const ageMs = Date.now() - firstSeen;
  const ageSec = Math.floor(ageMs / 1000);
  if (ageSec < 60) return `${ageSec}s`;
  const ageMin = Math.floor(ageSec / 60);
  if (ageMin < 60) return `${ageMin}m`;
  return `${Math.floor(ageMin / 60)}h`;
};

export const Watchlist: React.FC<WatchlistProps> = ({ tokens, stats }) => {
  return (
    <div className="card" style={{ marginTop: '24px' }}>
      <div className="card-header">
        <span className="card-title">Token Watchlist</span>
        <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
          <div style={{
            padding: '4px 12px',
            borderRadius: '20px',
            fontSize: '11px',
            background: 'var(--bg-elevated)',
            color: 'var(--text-muted)'
          }}>
            {stats.total} watching
          </div>
          <div style={{
            padding: '4px 12px',
            borderRadius: '20px',
            fontSize: '11px',
            background: 'var(--accent-subtle)',
            color: 'var(--accent)'
          }}>
            {stats.ready} ready
          </div>
          {stats.devSold > 0 && (
            <div style={{
              padding: '4px 12px',
              borderRadius: '20px',
              fontSize: '11px',
              background: 'var(--error-subtle)',
              color: 'var(--error)'
            }}>
              {stats.devSold} dev sold
            </div>
          )}
        </div>
      </div>

      <div style={{ padding: '16px', maxHeight: '400px', overflowY: 'auto' }}>
        {tokens.length === 0 ? (
          <div style={{
            textAlign: 'center',
            color: 'var(--text-muted)',
            padding: '24px',
            fontSize: '13px'
          }}>
            Waiting for new tokens...
          </div>
        ) : (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
            {tokens.map((token) => (
              <div
                key={token.mint}
                style={{
                  background: 'var(--bg-elevated)',
                  borderRadius: '8px',
                  padding: '12px',
                  border: token.devSold ? '1px solid var(--error)' : '1px solid transparent'
                }}
              >
                {/* Header Row */}
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <span style={{ fontFamily: 'var(--font-mono)', fontSize: '12px', color: 'var(--text-primary)' }}>
                      {token.symbol || token.mint.substring(0, 8) + '...'}
                    </span>
                    <span style={{
                      padding: '2px 8px',
                      borderRadius: '4px',
                      fontSize: '10px',
                      background: getStatusBg(token.status),
                      color: getStatusColor(token.status),
                      textTransform: 'uppercase'
                    }}>
                      {token.status}
                    </span>
                  </div>
                  <span style={{ fontSize: '11px', color: 'var(--text-muted)' }}>
                    {formatAge(token.firstSeen)} old
                  </span>
                </div>

                {/* Progress Bar for Data Collection */}
                {token.status === 'collecting' && (
                  <div style={{ marginBottom: '8px' }}>
                    <div style={{
                      background: 'rgba(255,255,255,0.1)',
                      borderRadius: '4px',
                      height: '4px',
                      overflow: 'hidden'
                    }}>
                      <div style={{
                        background: 'var(--accent)',
                        height: '100%',
                        width: `${Math.min(token.dataPoints * 10, 100)}%`,
                        transition: 'width 0.3s ease'
                      }} />
                    </div>
                    <div style={{ fontSize: '10px', color: 'var(--text-muted)', marginTop: '4px' }}>
                      {token.dataPoints}/10 data points
                    </div>
                  </div>
                )}

                {/* Rejection Reason */}
                {token.status === 'rejected' && token.rejectReason && (
                  <div style={{
                    fontSize: '11px',
                    color: 'var(--error)',
                    marginBottom: '8px'
                  }}>
                    {token.rejectReason}
                  </div>
                )}

                {/* Metrics Row */}
                {(token.status === 'ready' || token.status === 'analyzing') && (
                  <div style={{ display: 'flex', gap: '16px', flexWrap: 'wrap' }}>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Price</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.priceChange >= 0 ? 'var(--success)' : 'var(--error)'
                      }}>
                        {token.priceChange >= 0 ? '+' : ''}{(token.priceChange * 100).toFixed(1)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Drawdown</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.drawdown > 0.2 ? 'var(--error)' : 'var(--text-secondary)'
                      }}>
                        -{(token.drawdown * 100).toFixed(1)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Buy Pressure</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.buyPressure > 0.6 ? 'var(--success)' : 'var(--text-secondary)'
                      }}>
                        {(token.buyPressure * 100).toFixed(0)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Traders</div>
                      <div style={{ fontSize: '12px', color: 'var(--text-secondary)' }}>
                        {token.uniqueTraders}
                      </div>
                    </div>
                  </div>
                )}

                {/* Dev Sold Warning */}
                {token.devSold && (
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    marginTop: '8px',
                    padding: '6px 10px',
                    background: 'var(--error-subtle)',
                    borderRadius: '4px'
                  }}>
                    <span style={{ fontSize: '14px' }}>!</span>
                    <span style={{ fontSize: '11px', color: 'var(--error)' }}>DEV SOLD</span>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="client/src/hooks/useSocket.ts">
import { useEffect, useState } from 'react';
import { io, type Socket } from 'socket.io-client';
import type { Stats, ScannerData, Trade, ToastData, AIDecisionData, NarrativeSignal, WatchlistToken, WatchlistStats } from '../types';

export interface Position {
  id: string;
  mint: string;
  symbol: string;
  amount: number;
  amountSol: number;
  entryPrice: number;
  currentPrice: number;
  highestPrice: number;
  unrealizedPnl: number;
  unrealizedPnlPercent: number;
  realizedPnl?: number;
  totalPnl?: number;
  totalPnlPercent?: number;
  stopLoss: number;
  trailingStop?: number;
  initialRecovered?: boolean;
  scaledExitsTaken?: number;
  status: string;
  poolType: string;
  entryTime: string;
  holdTime: number;
}

export interface WalletState {
  solBalance: number;
  lastSync: string | null;
  isHealthy: boolean;
  totalEquity?: number;
}

export interface EquitySnapshot {
  timestamp: string;
  totalEquity: number;
  walletBalance: number;
  positionsValue: number;
  unrealizedPnl: number;
  positionCount: number;
}

interface UseSocketReturn {
  socket: Socket | null;
  isConnected: boolean;
  stats: Stats;
  trades: Trade[];
  positions: Position[];
  positionsSummary: { totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null;
  walletState: WalletState | null;
  equityHistory: EquitySnapshot[];
  scannerData: ScannerData | null;
  isScanning: boolean;
  toasts: ToastData[];
  aiDecision: AIDecisionData | null;
  narrativeSignal: NarrativeSignal | null;
  watchlistTokens: WatchlistToken[];
  watchlistStats: WatchlistStats;
  removeToast: (index: number) => void;
}

export const useSocket = (): UseSocketReturn => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  
  // Data State
  const [stats, setStats] = useState<Stats>({
    multiplier: "1.00",
    currentEquity: "0",
    initialCapital: "0",
    winRate: "0",
    totalTrades: 0,
    tokensScanned: 0,
    winStreak: 0
  });
  const [trades, setTrades] = useState<Trade[]>([]);
  const [positions, setPositions] = useState<Position[]>([]);
  const [positionsSummary, setPositionsSummary] = useState<{ totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null>(null);
  const [walletState, setWalletState] = useState<WalletState | null>(null);
  const [equityHistory, setEquityHistory] = useState<EquitySnapshot[]>([]);
  const [scannerData, setScannerData] = useState<ScannerData | null>(null);
  const [isScanning, setIsScanning] = useState(true);
  const [toasts, setToasts] = useState<ToastData[]>([]);
  const [aiDecision, setAiDecision] = useState<AIDecisionData | null>(null);
  const [narrativeSignal, setNarrativeSignal] = useState<NarrativeSignal | null>(null);
  const [watchlistTokens, setWatchlistTokens] = useState<WatchlistToken[]>([]);
  const [watchlistStats, setWatchlistStats] = useState<WatchlistStats>({ total: 0, ready: 0, devSold: 0 });

  // Use ref to access latest functions in event callbacks if needed, 
  // but state setters are stable.

  const addToast = (toast: ToastData) => {
    setToasts(prev => [...prev, toast]);
    // Auto remove after 4s
    setTimeout(() => {
      setToasts(prev => prev.slice(1)); // Simple FIFO removal, might change reference index
    }, 4000);
  };

  const removeToast = (index: number) => {
    setToasts(prev => prev.filter((_, i) => i !== index));
  };

  useEffect(() => {
    // Initial fetch
    const fetchData = async () => {
      try {
        const [statsRes, tradesRes, positionsRes, walletRes, equityRes] = await Promise.all([
          fetch('/api/stats'),
          fetch('/api/trades?limit=10'),
          fetch('/api/positions/realtime'),
          fetch('/api/wallet'),
          fetch('/api/equity-history?hours=24')
        ]);
        if (statsRes.ok) setStats(await statsRes.json());
        if (tradesRes.ok) setTrades(await tradesRes.json());
        if (positionsRes.ok) {
          const posData = await positionsRes.json();
          setPositions(posData.positions || []);
          setPositionsSummary(posData.summary || null);
        }
        if (walletRes.ok) {
          const walletData = await walletRes.json();
          setWalletState({
            solBalance: walletData.solBalance,
            lastSync: walletData.lastSync,
            isHealthy: walletData.isHealthy,
            totalEquity: walletData.equity?.total
          });
        }
        if (equityRes.ok) {
          const equityData = await equityRes.json();
          setEquityHistory(equityData.history || []);
        }
      } catch (err) {
        console.error("Failed to fetch initial data", err);
      }
    };
    fetchData();

    // Socket Connection
    // Note: In development with Vite proxy, '/' works if proxy is set.
    // Otherwise might need absolute URL.
    const newSocket = io('/', {
      transports: ['websocket'],
      reconnectionAttempts: 5
    });

    newSocket.on('connect', () => {
      setIsConnected(true);
      fetchData(); // Refresh on reconnect
    });

    newSocket.on('disconnect', () => {
      setIsConnected(false);
    });

    // Event Handlers
    newSocket.on('stats:initial', (data: Stats) => setStats(data));
    newSocket.on('stats:update', (data: Stats) => setStats(data));
    
    // Trades
    newSocket.on('trades:initial', (data: Trade[]) => setTrades(data));
    
    newSocket.on('trade:open', (trade: Trade) => {
      addToast({
        type: 'info',
        title: 'Position Opened',
        message: `Bought ${trade.symbol || trade.mint.substring(0, 8)} for ${trade.amountSol} SOL`
      });
      // Trade list is usually updated via rest fetch or full list push? 
      // The original code didn't update the list on 'trade:open', only on 'trade:close'.
      // But let's verify if we should.
    });

    newSocket.on('trade:close', (trade: Trade) => {
      const pnl = parseFloat(trade.pnlSol || "0");
      if (pnl > 0) {
        addToast({
          type: 'success',
          title: `+${trade.pnlSol} SOL`,
          message: `${trade.symbol} closed at ${trade.pnlPercent}%`
        });
      } else {
        addToast({
          type: 'error',
          title: `${trade.pnlSol} SOL`,
          message: `${trade.symbol} stopped out`
        });
      }
      // Refresh trades list
      fetch('/api/trades?limit=10')
        .then(r => r.json())
        .then(data => setTrades(data));
    });

    // Scanner
    newSocket.on('scanner:token', (data: ScannerData) => {
      setScannerData(data);
      setIsScanning(false);
      // Also update tokenScanned count in stats immediately if provided in data
      if (data.tokensScanned) {
        setStats(prev => ({ ...prev, tokensScanned: data.tokensScanned }));
      }
    });

    newSocket.on('scanner:idle', (data: ScannerData) => {
      setScannerData(null);
      setIsScanning(true);
      if (data && data.tokensScanned) {
        setStats(prev => ({ ...prev, tokensScanned: data.tokensScanned }));
      }
    });

    newSocket.on('ai:decision', (data: AIDecisionData) => {
      setAiDecision(data);
    });

    newSocket.on('signal:narrative', (data: NarrativeSignal) => {
      setNarrativeSignal(data);
    });

    // Watchlist events
    newSocket.on('watchlist:update', (data: { tokens: WatchlistToken[]; stats: WatchlistStats }) => {
      setWatchlistTokens(data.tokens);
      setWatchlistStats(data.stats);
    });

    newSocket.on('watchlist:tokenAdded', (token: WatchlistToken) => {
      setWatchlistTokens(prev => {
        // Add or update token
        const exists = prev.findIndex(t => t.mint === token.mint);
        if (exists >= 0) {
          const updated = [...prev];
          updated[exists] = token;
          return updated;
        }
        return [token, ...prev].slice(0, 20); // Keep latest 20
      });
    });

    newSocket.on('watchlist:tokenRemoved', (data: { mint: string }) => {
      setWatchlistTokens(prev => prev.filter(t => t.mint !== data.mint));
    });

    newSocket.on('watchlist:devSold', (data: { mint: string }) => {
      setWatchlistTokens(prev => prev.map(t =>
        t.mint === data.mint ? { ...t, devSold: true, status: 'rejected' as const, rejectReason: 'Dev sold' } : t
      ));
    });

    newSocket.on('status:paused', (data: { reason: string }) => {
      addToast({
        type: 'warning',
        title: 'Trading Paused',
        message: data.reason
      });
    });

    newSocket.on('toast', (data: ToastData) => {
      addToast(data);
    });

    // Position updates (real-time PnL)
    newSocket.on('positions:initial', (data: { positions: Position[]; totalUnrealizedPnl: string; totalExposure: string; positionCount: number }) => {
      setPositions(data.positions || []);
      setPositionsSummary({ totalUnrealizedPnl: data.totalUnrealizedPnl, totalExposure: data.totalExposure, positionCount: data.positionCount });
    });

    newSocket.on('positions:update', (data: { positions: Position[]; totalUnrealizedPnl: string; totalExposure: string; positionCount: number }) => {
      setPositions(data.positions || []);
      setPositionsSummary({ totalUnrealizedPnl: data.totalUnrealizedPnl, totalExposure: data.totalExposure, positionCount: data.positionCount });
    });

    // Wallet updates
    newSocket.on('wallet:update', (data: WalletState) => {
      setWalletState(data);
    });

    // Equity snapshots
    newSocket.on('equity:snapshot', (snapshot: EquitySnapshot) => {
      setEquityHistory(prev => {
        const updated = [...prev, snapshot];
        // Keep last 1440 snapshots (24 hours at 1 min intervals)
        if (updated.length > 1440) {
          return updated.slice(-1440);
        }
        return updated;
      });
    });

    // Reconciliation notifications
    newSocket.on('reconciliation:phantoms', (data: { count: number; phantoms: any[] }) => {
      if (data.count > 0) {
        addToast({
          type: 'warning',
          title: 'Phantom Positions Detected',
          message: `Found ${data.count} position(s) with no tokens`
        });
      }
    });

    setSocket(newSocket);

    return () => {
      newSocket.disconnect();
    };
  }, []);

  return {
    socket,
    isConnected,
    stats,
    trades,
    positions,
    positionsSummary,
    walletState,
    equityHistory,
    scannerData,
    isScanning,
    toasts,
    aiDecision,
    narrativeSignal,
    watchlistTokens,
    watchlistStats,
    removeToast
  };
};
</file>

<file path="client/src/index.css">
:root {
  /* Claude dark mode inspired palette - warm browns */
  --bg-page: #1C1917;
  --bg-card: #262320;
  --bg-card-hover: #2E2A26;
  --bg-elevated: #33302C;
  --border: rgba(255, 245, 230, 0.08);
  --border-light: rgba(255, 245, 230, 0.12);
  --text-primary: #F5F5F4;
  --text-secondary: #A8A29E;
  --text-muted: #78716C;
  --accent: #D97706;
  --accent-secondary: #F59E0B;
  --accent-glow: rgba(217, 119, 6, 0.3);
  --accent-subtle: rgba(217, 119, 6, 0.12);
  --success: #22C55E;
  --success-glow: rgba(34, 197, 94, 0.25);
  --success-subtle: rgba(34, 197, 94, 0.12);
  --error: #EF4444;
  --error-subtle: rgba(239, 68, 68, 0.12);
  --warning: #F59E0B;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg-page);
  color: var(--text-primary);
  min-height: 100vh;
  padding: 24px 32px;
  -webkit-font-smoothing: antialiased;
}

/* Subtle warm noise texture */
body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image:
    radial-gradient(circle at 50% 50%, rgba(217, 119, 6, 0.03) 0%, transparent 50%);
  pointer-events: none;
  z-index: -1;
}

.dashboard {
  max-width: 1280px;
  margin: 0 auto;
}

/* Header */
.header {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin-bottom: 48px;
  position: relative;
  min-height: 80px;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 20px;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  width: max-content;
}

.logo-icon {
  width: 72px;
  height: 72px;
  border-radius: 20px;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 8px 32px var(--accent-glow);
}

.logo-icon svg {
  width: 26px;
  height: 26px;
  color: white;
}

.logo-text h1 {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  letter-spacing: -0.02em;
}

.logo-text p {
  font-size: 13px;
  color: var(--text-muted);
  margin-top: 2px;
}

.live-badge {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 18px;
  border-radius: 100px;
  background: var(--success-subtle);
  border: 1px solid rgba(16, 185, 129, 0.2);
  color: var(--success);
  font-size: 13px;
  font-weight: 500;
  backdrop-filter: blur(10px);
}

.live-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--success);
  box-shadow: 0 0 12px var(--success);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {

  0%,
  100% {
    opacity: 1;
    transform: scale(1);
  }

  50% {
    opacity: 0.6;
    transform: scale(0.9);
  }
}

/* Stats Grid */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
  margin-bottom: 24px;
}

.stat-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 20px 24px;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.stat-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.06), transparent);
}

.stat-card:hover {
  background: var(--bg-card-hover);
  border-color: var(--border-light);
  transform: translateY(-2px);
}

.stat-card.highlight {
  background: linear-gradient(135deg, rgba(255, 107, 53, 0.08), rgba(255, 143, 92, 0.04));
  border-color: rgba(255, 107, 53, 0.3);
}

.stat-card.highlight::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
  opacity: 0.3;
  pointer-events: none;
}

.stat-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 10px;
}

.stat-value {
  font-size: 32px;
  font-weight: 600;
  color: var(--text-primary);
  line-height: 1.1;
  letter-spacing: -0.02em;
}

.stat-value.accent {
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.stat-sub {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
  margin-top: 8px;
}

.stat-sub.positive {
  color: var(--success);
}

.stat-sub .arrow {
  font-size: 14px;
}

/* Main Layout */
.main-grid {
  display: grid;
  grid-template-columns: 1.6fr 1fr;
  gap: 24px;
}

.left-column {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.right-column {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

/* Card Base */
.card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 20px;
  overflow: hidden;
  position: relative;
}

.card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.05), transparent);
}

.card-header {
  padding: 20px 24px;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.card-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.01em;
}

/* Challenge Card */
.challenge-card {
  padding: 48px 32px;
  text-align: center;
  position: relative;
}

.challenge-card::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 400px;
  height: 400px;
  background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
  opacity: 0.4;
  pointer-events: none;
}

.challenge-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.15em;
  margin-bottom: 20px;
  position: relative;
  z-index: 1;
}

.challenge-value {
  font-size: 84px;
  font-weight: 300;
  line-height: 1;
  position: relative;
  z-index: 1;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: 0 0 80px var(--accent-glow);
}

.challenge-value span {
  font-size: 42px;
  background: linear-gradient(135deg, var(--text-muted), var(--text-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.challenge-sub {
  font-size: 14px;
  color: var(--text-secondary);
  margin-top: 12px;
  margin-bottom: 32px;
  position: relative;
  z-index: 1;
}

.progress-bar-container {
  position: relative;
  z-index: 1;
}

.progress-bar {
  height: 10px;
  background: #3D3835;
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
  border-radius: 10px;
  transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
}

.progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.2), transparent);
  animation: shimmer 2.5s infinite;
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%);
  }

  100% {
    transform: translateX(100%);
  }
}

.progress-markers {
  display: flex;
  justify-content: space-between;
  margin-top: 12px;
  font-size: 11px;
  font-weight: 500;
  color: var(--text-muted);
}

.progress-markers span.active {
  color: var(--accent);
}

/* Scanner Card */
.scanner-card .card-header {
  border-bottom: none;
  padding-bottom: 0;
}

.scanner-content {
  padding: 0 24px 24px;
}

.scanner-token {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 18px;
  background: var(--bg-elevated);
  border-radius: 14px;
  margin-bottom: 18px;
  border: 1px solid var(--border);
}

.scanner-icon {
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--accent-subtle), transparent);
  border: 1px solid rgba(255, 107, 53, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  color: var(--accent);
  animation: rotate 2s linear infinite;
}

@keyframes rotate {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}

.scanner-icon.idle {
  animation: none;
}

.scanner-token-info h4 {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.01em;
}

.scanner-token-info p {
  font-size: 12px;
  color: var(--accent);
  margin-top: 2px;
}

.scanner-metrics {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-bottom: 18px;
}

.metric-box {
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px;
  text-align: center;
  transition: all 0.2s ease;
}

.metric-box:hover {
  border-color: var(--border-light);
  background: var(--bg-card-hover);
}

.metric-value {
  font-size: 22px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.02em;
}

.metric-value.accent {
  color: var(--accent);
}

.metric-value.success {
  color: var(--success);
}

.metric-label {
  font-size: 10px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.06em;
  margin-top: 6px;
}

/* Mini Chart */
.mini-chart {
  height: 60px;
  display: flex;
  align-items: flex-end;
  gap: 2px;
  padding: 12px 0;
}

.chart-bar {
  flex: 1;
  border-radius: 3px;
  transition: all 0.3s ease;
  min-height: 4px;
}

.chart-bar.up {
  background: linear-gradient(to top, var(--success), rgba(34, 197, 94, 0.5));
}

.chart-bar.down {
  background: linear-gradient(to top, #A8A29E, #78716C);
}

.chart-bar:hover {
  opacity: 0.8;
  transform: scaleY(1.1);
}

/* Recent Trades */
.trades-list {
  max-height: 360px;
  overflow-y: auto;
}

.trades-list::-webkit-scrollbar {
  width: 4px;
}

.trades-list::-webkit-scrollbar-track {
  background: transparent;
}

.trades-list::-webkit-scrollbar-thumb {
  background: #44403C;
  border-radius: 4px;
}

.trades-list::-webkit-scrollbar-thumb:hover {
  background: #57534E;
}

.trade-item {
  display: flex;
  align-items: center;
  padding: 14px 24px;
  border-bottom: 1px solid var(--border);
  gap: 14px;
  transition: background 0.15s ease;
}

.trade-item:hover {
  background: var(--bg-elevated);
}

.trade-item:last-child {
  border-bottom: none;
}

.trade-arrow {
  width: 36px;
  height: 36px;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: 600;
}

.trade-arrow.up {
  background: var(--success-subtle);
  color: var(--success);
  box-shadow: 0 0 20px var(--success-glow);
}

.trade-arrow.down {
  background: var(--error-subtle);
  color: var(--error);
}

.trade-info {
  flex: 1;
}

.trade-token {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}

.trade-time {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

.trade-pnl {
  text-align: right;
}

.trade-pnl-value {
  font-size: 14px;
  font-weight: 600;
}

.trade-pnl-value.positive {
  color: var(--success);
}

.trade-pnl-value.negative {
  color: var(--text-secondary);
}

.trade-pnl-percent {
  font-size: 11px;
  color: var(--success);
  margin-top: 2px;
}

/* AI Engine */
.ai-content {
  padding: 28px 24px;
  text-align: center;
}

.ai-indicator {
  width: 100px;
  height: 100px;
  margin: 0 auto 20px;
  position: relative;
}

.ai-ring-outer {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  border: 2px solid #3D3835;
}

.ai-ring {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  border: 2px solid transparent;
  border-top-color: var(--accent);
  animation: spin 1.5s linear infinite;
}

.ai-ring-inner {
  position: absolute;
  width: 70%;
  height: 70%;
  top: 15%;
  left: 15%;
  border-radius: 50%;
  border: 2px solid transparent;
  border-top-color: var(--accent-secondary);
  animation: spin 2s linear infinite reverse;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.ai-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 30px var(--accent-glow);
}

.ai-center-dot {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #FAFAF9;
  animation: pulse 2s ease-in-out infinite;
}

.ai-status {
  font-size: 13px;
  color: var(--text-secondary);
  margin-bottom: 20px;
}

.confidence-bar {
  margin-bottom: 24px;
}

.confidence-header {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  margin-bottom: 8px;
}

.confidence-header span:first-child {
  color: var(--text-muted);
}

.confidence-header span:last-child {
  color: var(--accent);
  font-weight: 600;
}

.confidence-track {
  height: 6px;
  background: #3D3835;
  border-radius: 6px;
  overflow: hidden;
}

.confidence-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
  border-radius: 6px;
  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

.win-streak-box {
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 24px;
}

.win-streak-value {
  font-size: 48px;
  font-weight: 300;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  line-height: 1;
}

.win-streak-label {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 8px;
}

/* Toast Notifications */
.toast-container {
  position: fixed;
  top: 24px;
  right: 24px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  z-index: 1000;
}

.toast {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 16px 20px;
  min-width: 300px;
  animation: slideIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
  backdrop-filter: blur(20px);
}

.toast.success {
  border-left: 3px solid var(--success);
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), 0 0 40px var(--success-glow);
}

.toast.error {
  border-left: 3px solid var(--error);
}

.toast.warning {
  border-left: 3px solid var(--warning);
}

.toast.info {
  border-left: 3px solid var(--accent);
}

.toast-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 4px;
}

.toast.success .toast-title {
  color: var(--success);
}

.toast.error .toast-title {
  color: var(--error);
}

.toast-message {
  font-size: 13px;
  color: var(--text-secondary);
}

@keyframes slideIn {
  from {
    transform: translateX(100%) scale(0.9);
    opacity: 0;
  }

  to {
    transform: translateX(0) scale(1);
    opacity: 1;
  }
}

/* Empty State */
.empty-state {
  padding: 40px 24px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
}

/* Responsive */
@media (max-width: 1024px) {
  .stats-grid {
    grid-template-columns: repeat(2, 1fr);
  }

  .main-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 600px) {
  .stats-grid {
    grid-template-columns: 1fr;
  }

  body {
    padding: 16px;
  }

  .header {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
  }

  .header-left {
    width: 100%;
  }

  .live-badge {
    position: absolute;
    top: 16px;
    right: 16px;
  }

  .challenge-value {
    font-size: 56px;
  }
}

/* Number animation */
.animate-number {
  display: inline-block;
  transition: transform 0.3s ease;
}

.animate-number.updating {
  transform: scale(1.05);
}

/* Positions Component */
.positions-list {
  max-height: 300px;
  overflow-y: auto;
}

.positions-list::-webkit-scrollbar {
  width: 4px;
}

.positions-list::-webkit-scrollbar-track {
  background: transparent;
}

.positions-list::-webkit-scrollbar-thumb {
  background: #44403C;
  border-radius: 4px;
}

.position-item {
  display: flex;
  align-items: center;
  padding: 14px 24px;
  border-bottom: 1px solid var(--border);
  gap: 12px;
  transition: background 0.15s ease;
}

.position-item:hover {
  background: var(--bg-elevated);
}

.position-item:last-child {
  border-bottom: none;
}

.position-indicator {
  width: 4px;
  height: 40px;
  border-radius: 2px;
}

.position-indicator.profit {
  background: var(--success);
  box-shadow: 0 0 8px var(--success-glow);
}

.position-indicator.loss {
  background: var(--error);
}

.position-info {
  flex: 1;
  min-width: 0;
}

.position-header {
  display: flex;
  align-items: center;
  gap: 8px;
}

.position-symbol {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}

.position-pool {
  font-size: 10px;
  font-weight: 500;
  padding: 2px 6px;
  border-radius: 4px;
  background: var(--accent-subtle);
  color: var(--accent);
  text-transform: uppercase;
}

.position-details {
  display: flex;
  gap: 12px;
  margin-top: 4px;
  font-size: 11px;
  color: var(--text-muted);
}

.position-pnl {
  text-align: right;
}

.position-unrealized {
  font-size: 14px;
  font-weight: 600;
}

.position-unrealized.positive {
  color: var(--success);
}

.position-unrealized.negative {
  color: var(--error);
}

.position-pnl-percent {
  font-size: 11px;
  opacity: 0.8;
  margin-left: 4px;
}

.position-realized {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

.position-status {
  display: flex;
  gap: 4px;
}

.status-badge {
  font-size: 9px;
  font-weight: 600;
  padding: 2px 5px;
  border-radius: 3px;
  text-transform: uppercase;
}

.status-badge.recovered {
  background: var(--success-subtle);
  color: var(--success);
}

.status-badge.exits {
  background: var(--accent-subtle);
  color: var(--accent);
}

.status-badge.trailing {
  background: rgba(139, 92, 246, 0.12);
  color: #a78bfa;
}

.positions-footer {
  padding: 12px 24px;
  border-top: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  color: var(--text-muted);
}

.card-badge {
  font-size: 12px;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 6px;
}

.card-badge.positive {
  background: var(--success-subtle);
  color: var(--success);
}

.card-badge.negative {
  background: var(--error-subtle);
  color: var(--error);
}

/* Equity Chart Component */
.equity-chart-card {
  min-height: 180px;
}

.equity-chart-content {
  padding: 16px 24px;
}

.equity-chart-empty {
  padding: 40px 24px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.wallet-balance {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
}

.equity-current {
  display: flex;
  align-items: baseline;
  gap: 6px;
  margin-bottom: 12px;
}

.equity-value {
  font-size: 28px;
  font-weight: 600;
  color: var(--text-primary);
}

.equity-label {
  font-size: 14px;
  color: var(--text-muted);
}

.equity-sparkline {
  width: 100%;
  height: 60px;
  display: block;
}

.equity-range {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 4px;
}

.equity-footer {
  padding: 12px 24px;
  border-top: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  font-size: 12px;
}

.equity-footer .positive {
  color: var(--success);
}

.equity-footer .negative {
  color: var(--error);
}

.wallet-indicator {
  color: var(--text-muted);
}
</file>

<file path="client/src/main.tsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  // StrictMode disabled to prevent double-socket connection in dev
  // or handle cleanup carefully in useEffect (which we did).
  // Keeping it enabled is fine if cleanup is robust.
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
</file>

<file path="client/src/types.ts">
export interface Stats {
  multiplier: string;
  currentEquity: string;
  initialCapital: string;
  winRate: string;
  totalTrades: number;
  tokensScanned: number;
  winStreak: number;
}

export interface Trade {
  id?: string;
  mint: string;
  symbol: string;
  amountSol: number;
  amountTokens: number;
  entryPrice: number;
  exitPrice?: number;
  pnlSol?: string;
  pnlPercent?: string;
  isOpen: boolean;
  entryTime: string;
  exitTime?: string;
}

export interface ScannerData {
  mint: string;
  tokensScanned: number;
  timestamp: number;
}

export interface ToastData {
  type: 'success' | 'error' | 'warning' | 'info';
  title: string;
  message: string;
}

export interface AIDecisionData {
  action: 0 | 1 | 2; // HOLD=0, BUY=1, SELL=2
  confidence: number;
  regime: 0 | 1 | 2; // BULL=0, VOLATILE=1, CRASH=2
  qValues: number[];
  mint: string;
  symbol: string;
  timestamp: string;
}

export interface NarrativeSignal {
  sentiment: 'bullish' | 'bearish' | 'neutral';
  bullishnessScore: number;
  hypeScore: number;
  keywords: string[];
  mint?: string;
  symbol?: string;
}

// Token Watchlist Types
export interface WatchlistToken {
  mint: string;
  symbol?: string;
  firstSeen: number;
  dataPoints: number;
  priceChange: number;
  volatility: number;
  drawdown: number;
  buyPressure: number;
  uniqueTraders: number;
  devSold: boolean;
  status: 'collecting' | 'ready' | 'analyzing' | 'rejected' | 'bought';
  rejectReason?: string;
}

export interface WatchlistStats {
  total: number;
  ready: number;
  devSold: number;
}
</file>

<file path="client/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "types": [
      "vite/client"
    ],
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": [
    "src"
  ]
}
</file>

<file path="client/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="client/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="client/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3500',
        changeOrigin: true,
      },
      '/socket.io': {
        target: 'http://localhost:3500',
        ws: true,
      },
    },
  },
})
</file>

<file path="FLOWCHART.md">
# Trading Bot Flow - AI-Driven Entry System

## High-Level Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           TRADING BOT FLOW                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  PumpPortal  â”‚â”€â”€â”€â–¶â”‚   WATCHLIST  â”‚â”€â”€â”€â–¶â”‚  AI ANALYSIS â”‚â”€â”€â”€â–¶â”‚   TRADE   â”‚ â”‚
â”‚  â”‚   WebSocket  â”‚    â”‚  (Collect    â”‚    â”‚  (DDQN Agent â”‚    â”‚ EXECUTION â”‚ â”‚
â”‚  â”‚              â”‚    â”‚   Data)      â”‚    â”‚   Decision)  â”‚    â”‚           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Detailed Flow

### 1. TOKEN DETECTION (PumpPortal WebSocket)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              NEW TOKEN DETECTED                      â”‚
â”‚                                                      â”‚
â”‚   PumpPortal WS â”€â”€â–¶ newToken event                  â”‚
â”‚        â”‚                                            â”‚
â”‚        â–¼                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ 1. Cache bonding curve data         â”‚          â”‚
â”‚   â”‚ 2. Subscribe to token trades        â”‚          â”‚
â”‚   â”‚ 3. Add to WATCHLIST                 â”‚          â”‚
â”‚   â”‚ 4. Record initial price point       â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                      â”‚
â”‚   OLD: Immediate snipe attempt                      â”‚
â”‚   NEW: Start data collection                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. DATA COLLECTION (Token Watchlist)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    WATCHLIST                         â”‚
â”‚                                                      â”‚
â”‚   For each token, collect:                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ â€¢ Price history (min 10 data points)â”‚          â”‚
â”‚   â”‚ â€¢ Trade data (buys/sells)           â”‚          â”‚
â”‚   â”‚ â€¢ Unique traders count              â”‚          â”‚
â”‚   â”‚ â€¢ Dev wallet activity               â”‚          â”‚
â”‚   â”‚ â€¢ Peak/lowest price                 â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                      â”‚
â”‚   Status progression:                               â”‚
â”‚   COLLECTING â”€â”€â–¶ READY â”€â”€â–¶ ANALYZING â”€â”€â–¶ BOUGHT    â”‚
â”‚        â”‚                        â”‚                   â”‚
â”‚        â””â”€â”€â”€â”€â”€â”€â–¶ REJECTED â—€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. HARD FILTERS (Instant Rejection)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 HARD FILTERS                         â”‚
â”‚         (Check every 5 seconds)                     â”‚
â”‚                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚   â”‚ Token Ready?    â”‚                               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚            â”‚                                        â”‚
â”‚            â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    NO     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ Dev sold?       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ Skip/Wait     â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚            â”‚ NO                                     â”‚
â”‚            â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    NO     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ 10+ data points?â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ Keep          â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚ Collecting    â”‚  â”‚
â”‚            â”‚ YES                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚            â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    YES    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ >30% drawdown?  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ REJECT        â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚ "Crashed"     â”‚  â”‚
â”‚            â”‚ NO                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚            â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚   â”‚ PASS TO AI      â”‚                               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. AI ANALYSIS (DDQN Agent)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  AI ANALYSIS                         â”‚
â”‚                                                      â”‚
â”‚   Extract Features:                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ â€¢ Price momentum                     â”‚          â”‚
â”‚   â”‚ â€¢ Volatility                         â”‚          â”‚
â”‚   â”‚ â€¢ Drawdown from peak                 â”‚          â”‚
â”‚   â”‚ â€¢ Buy pressure (% buys vs sells)     â”‚          â”‚
â”‚   â”‚ â€¢ Volume trend                       â”‚          â”‚
â”‚   â”‚ â€¢ Token age                          â”‚          â”‚
â”‚   â”‚ â€¢ Unique traders                     â”‚          â”‚
â”‚   â”‚ â€¢ Rug score                          â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚        DDQN Agent Decision          â”‚          â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”       â”‚          â”‚
â”‚   â”‚   â”‚HOLD â”‚  â”‚ BUY â”‚  â”‚ SELL â”‚       â”‚          â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜       â”‚          â”‚
â”‚   â”‚      â”‚        â”‚                     â”‚          â”‚
â”‚   â”‚      â”‚        â–¼                     â”‚          â”‚
â”‚   â”‚      â”‚   Confidence > 70%?          â”‚          â”‚
â”‚   â”‚      â”‚        â”‚                     â”‚          â”‚
â”‚   â”‚      â–¼        â–¼                     â”‚          â”‚
â”‚   â”‚   [SKIP]   [TRADE]                  â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5. TRADE EXECUTION

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               TRADE EXECUTION                        â”‚
â”‚                                                      â”‚
â”‚   Pre-Trade Checks:                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ â€¢ Capital allocation check           â”‚          â”‚
â”‚   â”‚ â€¢ Max positions check                â”‚          â”‚
â”‚   â”‚ â€¢ Daily loss limit check             â”‚          â”‚
â”‚   â”‚ â€¢ Drawdown guard check               â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚        EXECUTE BUY                   â”‚          â”‚
â”‚   â”‚   â€¢ Route to PumpFun (bonding curve) â”‚          â”‚
â”‚   â”‚   â€¢ Or Jupiter (graduated)           â”‚          â”‚
â”‚   â”‚   â€¢ 15% slippage tolerance           â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚        OPEN POSITION                 â”‚          â”‚
â”‚   â”‚   â€¢ Set stop loss: -12%              â”‚          â”‚
â”‚   â”‚   â€¢ Track initial investment         â”‚          â”‚
â”‚   â”‚   â€¢ Start position monitoring        â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6. POSITION MANAGEMENT (New TP Strategy)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            POSITION MONITORING                       â”‚
â”‚              (Every 1 second)                       â”‚
â”‚                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ 1. STOP LOSS CHECK (-12%)           â”‚          â”‚
â”‚   â”‚    If price drops 12% from entry    â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ CLOSE ALL (stop_loss)        â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ 2. TRAILING STOP CHECK              â”‚          â”‚
â”‚   â”‚    If price below trailing stop     â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ CLOSE ALL (trailing_stop)    â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ 3. INITIAL RECOVERY (+50%)          â”‚          â”‚
â”‚   â”‚    If profit >= 50% AND not yet     â”‚          â”‚
â”‚   â”‚    recovered initial:               â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ Sell enough to recover       â”‚          â”‚
â”‚   â”‚        initial investment           â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ Set 15% trailing stop        â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ 4. SCALED EXITS (+50% intervals)    â”‚          â”‚
â”‚   â”‚    After initial recovered,         â”‚          â”‚
â”‚   â”‚    every +50% gain:                 â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ Sell 20% of remaining        â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ Update trailing stop         â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Take Profit Example

```
Entry: 0.01 SOL for 1,000,000 tokens

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Price     â”‚ Action                           â”‚ Tokens Left â”‚ SOL Out     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Entry     â”‚ Buy 1M tokens for 0.01 SOL       â”‚ 1,000,000   â”‚ -0.01       â”‚
â”‚  +50%      â”‚ Sell ~666K to recover 0.01 SOL   â”‚   333,333   â”‚  0.01       â”‚
â”‚            â”‚ (Initial recovered!)              â”‚             â”‚             â”‚
â”‚  +100%     â”‚ Sell 20% (66K) = 0.0133 SOL      â”‚   266,667   â”‚  0.0133     â”‚
â”‚  +150%     â”‚ Sell 20% (53K) = 0.0133 SOL      â”‚   213,333   â”‚  0.0133     â”‚
â”‚  +200%     â”‚ Sell 20% (43K) = 0.0172 SOL      â”‚   170,667   â”‚  0.0172     â”‚
â”‚  ...       â”‚ Trailing stop hits at -15%       â”‚      0      â”‚  Rest       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  TOTAL     â”‚ Initial recovered + pure profit  â”‚             â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Comparison: Old vs New

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        OLD SYSTEM                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   New Token â”€â”€â–¶ Velocity Check â”€â”€â–¶ Buy Immediately â”€â”€â–¶ Hope it pumps        â”‚
â”‚                                                                              â”‚
â”‚   Problems:                                                                  â”‚
â”‚   â€¢ Buying tokens with 0 track record                                       â”‚
â”‚   â€¢ 50% stop loss = massive losses                                          â”‚
â”‚   â€¢ Most tokens rug within 1 minute                                         â”‚
â”‚   â€¢ Take profit rarely triggers                                             â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        NEW SYSTEM                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   New Token â”€â”€â–¶ Watchlist â”€â”€â–¶ Collect Data â”€â”€â–¶ Hard Filters â”€â”€â–¶ AI â”€â”€â–¶ Buy  â”‚
â”‚                    â”‚              â”‚                â”‚            â”‚           â”‚
â”‚                    â”‚              â”‚                â”‚            â”‚           â”‚
â”‚              Track trades    10+ points      Dev sold?      High           â”‚
â”‚              Track price                     >30% crash?   confidence      â”‚
â”‚              Track dev                                                      â”‚
â”‚                                                                              â”‚
â”‚   Benefits:                                                                  â”‚
â”‚   â€¢ Only buy proven survivors                                               â”‚
â”‚   â€¢ 12% stop loss = smaller losses                                          â”‚
â”‚   â€¢ Dev dump = instant rejection                                            â”‚
â”‚   â€¢ Recover initial at +50%, then scale out                                 â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Frontend Dashboard

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TOKEN WATCHLIST                          [12 watching] [3 ready] [2 dev]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ BONK...      [READY]                                        2m old  â”‚   â”‚
â”‚  â”‚ Price: +15.2%  Drawdown: -5.1%  Buy Pressure: 72%  Traders: 45     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ABC123...    [COLLECTING]                                   30s old â”‚   â”‚
â”‚  â”‚ [======     ] 6/10 data points                                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ RUGGED...    [REJECTED]                                      1m old â”‚   â”‚
â”‚  â”‚ Reason: Dev sold                                                    â”‚   â”‚
â”‚  â”‚ [! DEV SOLD]                                                        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ CRASH...     [REJECTED]                                      3m old â”‚   â”‚
â”‚  â”‚ Reason: Crashed 45% from peak (max 30%)                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Key Parameters

| Parameter | Old Value | New Value | Reason |
|-----------|-----------|-----------|--------|
| Stop Loss | 50% | 12% | Smaller losses |
| Initial TP | 2x | +50% recover initial | Protect capital |
| Scaled TP | 25% at 2x, 3x | 20% every +50% | Ride winners |
| Trailing Stop | 20% | 15% | Tighter protection |
| Min Data Points | N/A | 10 | Prove token viability |
| Max Drawdown | N/A | 30% | Reject crashed tokens |
| Dev Sold | Not tracked | Instant reject | Avoid rugs |
</file>

<file path="Procfile">
worker: npm start
</file>

<file path="src/ai/ddqn-agent.ts">
import * as tf from '@tensorflow/tfjs';
import { createChildLogger } from '../utils/logger';
import { Action, Experience, DDQNConfig } from './types';
import { config } from '../config/settings';

const logger = createChildLogger('ddqn-agent');

export class DDQNAgent {
  private mainNetwork: tf.Sequential | null = null;
  private targetNetwork: tf.Sequential | null = null;
  private replayBuffer: Experience[] = [];
  private config: DDQNConfig;
  private epsilon: number;
  private trainStepCount = 0;

  constructor(ddqnConfig?: Partial<DDQNConfig>) {
    this.config = { ...config.ddqnConfig, ...ddqnConfig };
    this.epsilon = this.config.epsilon;
  }

  async initialize(): Promise<void> {
    logger.info('Initializing DDQN networks');

    this.mainNetwork = this.buildNetwork();
    this.targetNetwork = this.buildNetwork();

    // Copy main network weights to target
    await this.hardUpdateTarget();

    logger.info('DDQN networks initialized');
  }

  private buildNetwork(): tf.Sequential {
    const model = tf.sequential();

    // Input layer + first hidden
    model.add(
      tf.layers.dense({
        units: this.config.hiddenSize,
        activation: 'relu',
        inputShape: [this.config.stateSize],
        kernelInitializer: 'heNormal',
      })
    );

    // Second hidden layer
    model.add(
      tf.layers.dense({
        units: this.config.hiddenSize,
        activation: 'relu',
        kernelInitializer: 'heNormal',
      })
    );

    // Output layer (Q-values for each action)
    model.add(
      tf.layers.dense({
        units: this.config.actionSize,
        activation: 'linear',
        kernelInitializer: 'heNormal',
      })
    );

    model.compile({
      optimizer: tf.train.adam(this.config.learningRate),
      loss: 'meanSquaredError',
    });

    return model;
  }

  selectAction(state: number[]): { action: Action; qValues: number[] } {
    if (!this.mainNetwork) {
      throw new Error('Network not initialized');
    }

    // Epsilon-greedy action selection
    if (Math.random() < this.epsilon) {
      // Random action
      const action = Math.floor(Math.random() * this.config.actionSize) as Action;
      return { action, qValues: [0, 0, 0] };
    }

    // Get Q-values from main network
    const stateTensor = tf.tensor2d([state]);
    const qValuesTensor = this.mainNetwork.predict(stateTensor) as tf.Tensor;
    const qValues = qValuesTensor.dataSync() as Float32Array;

    stateTensor.dispose();
    qValuesTensor.dispose();

    // Select action with highest Q-value
    const action = this.argMax(Array.from(qValues)) as Action;

    return { action, qValues: Array.from(qValues) };
  }

  private argMax(arr: number[]): number {
    return arr.indexOf(Math.max(...arr));
  }

  addExperience(experience: Experience): void {
    this.replayBuffer.push(experience);

    // Remove oldest if buffer is full
    if (this.replayBuffer.length > this.config.replayBufferSize) {
      this.replayBuffer.shift();
    }
  }

  async train(): Promise<number> {
    if (!this.mainNetwork || !this.targetNetwork) {
      throw new Error('Networks not initialized');
    }

    if (this.replayBuffer.length < this.config.batchSize) {
      return 0;
    }

    // Sample random batch
    const batch = this.sampleBatch(this.config.batchSize);

    // Prepare training data
    const states = batch.map((e) => e.state);
    const nextStates = batch.map((e) => e.nextState);

    const statesTensor = tf.tensor2d(states);
    const nextStatesTensor = tf.tensor2d(nextStates);

    // Get current Q-values
    const currentQs = this.mainNetwork.predict(statesTensor) as tf.Tensor;
    const currentQsArray = currentQs.arraySync() as number[][];

    // DDQN: Use main network to select actions, target network to evaluate
    const nextQsMain = this.mainNetwork.predict(nextStatesTensor) as tf.Tensor;
    const nextQsTarget = this.targetNetwork.predict(nextStatesTensor) as tf.Tensor;

    const nextQsMainArray = nextQsMain.arraySync() as number[][];
    const nextQsTargetArray = nextQsTarget.arraySync() as number[][];

    // Update Q-values based on Bellman equation
    const targetQs: number[][] = [];

    for (let i = 0; i < batch.length; i++) {
      const experience = batch[i];
      const targetQ = [...currentQsArray[i]];

      if (experience.done) {
        targetQ[experience.action] = experience.reward;
      } else {
        // DDQN: action selected by main, value from target
        const bestAction = this.argMax(nextQsMainArray[i]);
        targetQ[experience.action] =
          experience.reward + this.config.gamma * nextQsTargetArray[i][bestAction];
      }

      targetQs.push(targetQ);
    }

    // Train main network
    const targetTensor = tf.tensor2d(targetQs);
    const history = await this.mainNetwork.fit(statesTensor, targetTensor, {
      epochs: 1,
      verbose: 0,
    });

    const loss = history.history.loss[0] as number;

    // Cleanup tensors
    statesTensor.dispose();
    nextStatesTensor.dispose();
    currentQs.dispose();
    nextQsMain.dispose();
    nextQsTarget.dispose();
    targetTensor.dispose();

    // Soft update target network
    this.trainStepCount++;
    await this.softUpdateTarget();

    // Decay epsilon
    this.decayEpsilon();

    return loss;
  }

  private sampleBatch(size: number): Experience[] {
    const batch: Experience[] = [];
    const indices = new Set<number>();

    while (indices.size < size && indices.size < this.replayBuffer.length) {
      indices.add(Math.floor(Math.random() * this.replayBuffer.length));
    }

    for (const idx of indices) {
      batch.push(this.replayBuffer[idx]);
    }

    return batch;
  }

  private async softUpdateTarget(): Promise<void> {
    if (!this.mainNetwork || !this.targetNetwork) return;

    const mainWeights = this.mainNetwork.getWeights();
    const targetWeights = this.targetNetwork.getWeights();

    const newWeights = mainWeights.map((mainWeight, i) => {
      const targetWeight = targetWeights[i];
      return tf.tidy(() => {
        const mainScaled = mainWeight.mul(this.config.targetUpdateTau);
        const targetScaled = targetWeight.mul(1 - this.config.targetUpdateTau);
        return mainScaled.add(targetScaled);
      });
    });

    this.targetNetwork.setWeights(newWeights);

    // Dispose old weights
    newWeights.forEach((w) => w.dispose());
  }

  private async hardUpdateTarget(): Promise<void> {
    if (!this.mainNetwork || !this.targetNetwork) return;

    const mainWeights = this.mainNetwork.getWeights();
    const weightCopies = mainWeights.map((w) => w.clone());
    this.targetNetwork.setWeights(weightCopies);
    weightCopies.forEach((w) => w.dispose());
  }

  private decayEpsilon(): void {
    this.epsilon = Math.max(
      this.config.epsilonMin,
      this.epsilon * this.config.epsilonDecay
    );
  }

  getEpsilon(): number {
    return this.epsilon;
  }

  setEpsilon(epsilon: number): void {
    this.epsilon = Math.max(this.config.epsilonMin, Math.min(1, epsilon));
  }

  getReplayBufferSize(): number {
    return this.replayBuffer.length;
  }

  async saveModel(path: string): Promise<void> {
    if (!this.mainNetwork) throw new Error('Network not initialized');

    await this.mainNetwork.save(`file://${path}`);
    logger.info({ path }, 'Model saved');
  }

  async loadModel(path: string): Promise<void> {
    try {
      this.mainNetwork = (await tf.loadLayersModel(`file://${path}/model.json`)) as tf.Sequential;

      // Recompile
      this.mainNetwork.compile({
        optimizer: tf.train.adam(this.config.learningRate),
        loss: 'meanSquaredError',
      });

      // Copy to target
      await this.hardUpdateTarget();

      logger.info({ path }, 'Model loaded');
    } catch (error) {
      logger.warn({ path, error }, 'Failed to load model, using fresh network');
      await this.initialize();
    }
  }

  getWeightsAsJSON(): string {
    if (!this.mainNetwork) throw new Error('Network not initialized');

    const weights = this.mainNetwork.getWeights();
    const weightsData = weights.map((w) => ({
      shape: w.shape,
      data: Array.from(w.dataSync()),
    }));

    return JSON.stringify(weightsData);
  }

  async loadWeightsFromJSON(json: string): Promise<void> {
    if (!this.mainNetwork) throw new Error('Network not initialized');

    const weightsData = JSON.parse(json);
    const weights = weightsData.map((w: { shape: number[]; data: number[] }) =>
      tf.tensor(w.data, w.shape)
    );

    this.mainNetwork.setWeights(weights);
    await this.hardUpdateTarget();

    weights.forEach((w: tf.Tensor) => w.dispose());
    logger.info('Weights loaded from JSON');
  }

  clearReplayBuffer(): void {
    this.replayBuffer = [];
  }

  dispose(): void {
    if (this.mainNetwork) {
      this.mainNetwork.dispose();
      this.mainNetwork = null;
    }
    if (this.targetNetwork) {
      this.targetNetwork.dispose();
      this.targetNetwork = null;
    }
  }
}

export const ddqnAgent = new DDQNAgent();
</file>

<file path="src/ai/index.ts">
export * from './types';
export * from './ddqn-agent';
export * from './regime-detector';
export * from './position-sizer';
</file>

<file path="src/ai/position-sizer.ts">
import { createChildLogger } from '../utils/logger';
import { PositionSizeResult, MarketRegime } from './types';
import { regimeDetector } from './regime-detector';
import { config } from '../config/settings';

const logger = createChildLogger('position-sizer');

export class PositionSizer {
  private winHistory: boolean[] = [];
  private maxHistory = 100;

  constructor() {}

  calculateSize(
    availableCapital: number,
    winProbability?: number,
    avgWinLossRatio?: number,
    currentRegime?: MarketRegime,
    confidence?: number  // NEW: Use confidence as size multiplier
  ): PositionSizeResult {
    // Get regime multiplier
    const regime = currentRegime ?? regimeDetector.getCurrentRegime().regime;
    const regimeMultiplier = regimeDetector.getRegimeMultiplier(regime);

    // Calculate Kelly fraction
    const kellyFraction = this.calculateKellyFraction(winProbability, avgWinLossRatio);

    // NEW: Calculate confidence multiplier
    // 0.55 confidence â†’ 0.55x size, 0.80 confidence â†’ 1.0x size
    // Scale from 0.55-1.0 confidence to 0.6-1.0 multiplier
    let confidenceMultiplier = 1.0;
    if (confidence !== undefined) {
      // Clamp confidence to reasonable range
      const clampedConf = Math.max(0.4, Math.min(1.0, confidence));
      // Scale: 0.4 conf â†’ 0.5x, 0.7 conf â†’ 0.75x, 1.0 conf â†’ 1.0x
      confidenceMultiplier = 0.5 + (clampedConf - 0.4) * (0.5 / 0.6);
    }

    // Apply regime adjustment AND confidence multiplier
    let rawSize = kellyFraction * regimeMultiplier * confidenceMultiplier * availableCapital;

    // Apply hard limits
    const maxSize = config.maxPositionSize * config.initialCapitalSol;
    const minSize = 0.001; // Minimum 0.001 SOL

    const finalSize = Math.max(minSize, Math.min(maxSize, rawSize));

    const reason = this.buildReason(kellyFraction, regimeMultiplier, rawSize, finalSize, confidenceMultiplier);

    const result: PositionSizeResult = {
      sizeSol: finalSize,
      kellyFraction,
      regimeMultiplier,
      riskAdjustedSize: rawSize,
      reason,
    };

    logger.debug({
      availableCapital,
      kellyFraction: kellyFraction.toFixed(4),
      regimeMultiplier,
      confidenceMultiplier: confidenceMultiplier.toFixed(2),
      finalSize: finalSize.toFixed(4),
    }, 'Position size calculated');

    return result;
  }

  private calculateKellyFraction(winProb?: number, winLossRatio?: number): number {
    // Default estimates if not provided
    const p = winProb ?? this.estimateWinProbability();
    const r = winLossRatio ?? 2.0; // Assume 2:1 reward:risk by default

    // Kelly formula: f = (p * r - (1 - p)) / r
    // Or: f = p - (1 - p) / r
    const kelly = p - (1 - p) / r;

    // Half-Kelly for safety
    const halfKelly = kelly / 2;

    // Clamp to reasonable range [0, 0.25] (max 25% of capital)
    return Math.max(0, Math.min(0.25, halfKelly));
  }

  private estimateWinProbability(): number {
    if (this.winHistory.length < 10) {
      return 0.4; // Conservative default
    }

    const wins = this.winHistory.filter(Boolean).length;
    return wins / this.winHistory.length;
  }

  recordTrade(isWin: boolean): void {
    this.winHistory.push(isWin);

    if (this.winHistory.length > this.maxHistory) {
      this.winHistory.shift();
    }
  }

  private buildReason(
    kellyFraction: number,
    regimeMultiplier: number,
    rawSize: number,
    finalSize: number,
    confidenceMultiplier?: number
  ): string {
    const parts: string[] = [];

    parts.push(`Kelly: ${(kellyFraction * 100).toFixed(1)}%`);
    parts.push(`Regime: ${regimeDetector.getRegimeName()} (${(regimeMultiplier * 100).toFixed(0)}%)`);

    if (confidenceMultiplier !== undefined && confidenceMultiplier !== 1.0) {
      parts.push(`Conf: ${(confidenceMultiplier * 100).toFixed(0)}%`);
    }

    if (finalSize < rawSize) {
      parts.push(`Capped from ${rawSize.toFixed(4)} SOL`);
    }

    return parts.join(', ');
  }

  // Calculate optimal size for a specific trade setup
  calculateForTrade(params: {
    entryPrice: number;
    stopLoss: number;
    takeProfit: number;
    availableCapital: number;
    confidence: number;
  }): PositionSizeResult {
    const { entryPrice, stopLoss, takeProfit, availableCapital, confidence } = params;

    // Calculate risk/reward
    const riskPercent = Math.abs((entryPrice - stopLoss) / entryPrice);
    const rewardPercent = Math.abs((takeProfit - entryPrice) / entryPrice);
    const riskRewardRatio = rewardPercent / riskPercent;

    // Adjust win probability by confidence
    const baseWinProb = 0.4;
    const adjustedWinProb = baseWinProb + (confidence - 0.5) * 0.2;

    // Calculate Kelly with trade-specific parameters
    return this.calculateSize(availableCapital, adjustedWinProb, riskRewardRatio);
  }

  // Get suggested position count based on portfolio theory
  getOptimalPositionCount(totalCapital: number): number {
    const regime = regimeDetector.getCurrentRegime().regime;

    // More concentrated in bull, more diversified in volatile/crash
    switch (regime) {
      case MarketRegime.BULL:
        return 3; // Concentrated bets
      case MarketRegime.VOLATILE:
        return 5; // Moderate diversification
      case MarketRegime.CRASH:
        return Math.min(config.maxConcurrentPositions, 2); // Very selective
      default:
        return 4;
    }
  }

  getWinRate(): number {
    if (this.winHistory.length === 0) return 0.5;
    return this.winHistory.filter(Boolean).length / this.winHistory.length;
  }

  clearHistory(): void {
    this.winHistory = [];
  }
}

export const positionSizer = new PositionSizer();
</file>

<file path="src/ai/regime-detector.ts">
import * as ss from 'simple-statistics';
import { createChildLogger } from '../utils/logger';
import { MarketRegime, RegimeState } from './types';
import { priceFeed } from '../data/price-feed';
import { SOL_MINT } from '../config/settings';

const logger = createChildLogger('regime-detector');

export class RegimeDetector {
  private state: RegimeState;
  private priceHistory: number[] = [];
  private returnHistory: number[] = [];
  private maxHistory = 1000;
  private updateInterval: NodeJS.Timeout | null = null;

  // HMM parameters (simplified 3-state model)
  private transitionMatrix: number[][] = [
    [0.9, 0.08, 0.02], // From Bull
    [0.15, 0.7, 0.15], // From Volatile
    [0.1, 0.2, 0.7],   // From Crash
  ];

  private emissionParams = {
    [MarketRegime.BULL]: { meanReturn: 0.002, stdReturn: 0.01 },
    [MarketRegime.VOLATILE]: { meanReturn: 0, stdReturn: 0.03 },
    [MarketRegime.CRASH]: { meanReturn: -0.003, stdReturn: 0.04 },
  };

  constructor() {
    this.state = {
      regime: MarketRegime.VOLATILE,
      confidence: 0.5,
      transitionProbs: this.transitionMatrix,
      history: [],
    };
  }

  async start(): Promise<void> {
    // Start periodic regime updates
    this.updateInterval = setInterval(() => {
      this.updateRegime();
    }, 60000); // Update every minute

    logger.info('Regime detector started');
  }

  stop(): void {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
    logger.info('Regime detector stopped');
  }

  private async updateRegime(): Promise<void> {
    try {
      // Get SOL price as market proxy
      const solPrice = priceFeed.getSolPrice();
      if (solPrice > 0) {
        this.addPrice(solPrice);
        this.detectRegime();
      }
    } catch (error) {
      logger.error({ error }, 'Failed to update regime');
    }
  }

  addPrice(price: number): void {
    this.priceHistory.push(price);

    if (this.priceHistory.length > 1) {
      const lastPrice = this.priceHistory[this.priceHistory.length - 2];
      const returnValue = (price - lastPrice) / lastPrice;
      this.returnHistory.push(returnValue);
    }

    // Trim histories
    if (this.priceHistory.length > this.maxHistory) {
      this.priceHistory = this.priceHistory.slice(-this.maxHistory);
      this.returnHistory = this.returnHistory.slice(-this.maxHistory);
    }
  }

  detectRegime(): MarketRegime {
    if (this.returnHistory.length < 30) {
      return this.state.regime;
    }

    // Calculate recent statistics
    const recentReturns = this.returnHistory.slice(-60);
    const meanReturn = ss.mean(recentReturns);
    const stdReturn = ss.standardDeviation(recentReturns);

    // Calculate likelihood of each regime
    const likelihoods = this.calculateLikelihoods(meanReturn, stdReturn);

    // Apply transition probabilities (forward algorithm simplified)
    const currentProbs = this.applyTransition(likelihoods);

    // Select most likely regime
    let maxProb = 0;
    let newRegime = this.state.regime;

    for (const [regime, prob] of Object.entries(currentProbs)) {
      if (prob > maxProb) {
        maxProb = prob;
        newRegime = parseInt(regime) as MarketRegime;
      }
    }

    // Update state
    const previousRegime = this.state.regime;
    this.state.regime = newRegime;
    this.state.confidence = maxProb;
    this.state.history.push(newRegime);

    if (this.state.history.length > 100) {
      this.state.history = this.state.history.slice(-100);
    }

    if (newRegime !== previousRegime) {
      logger.info(
        { from: MarketRegime[previousRegime], to: MarketRegime[newRegime], confidence: maxProb.toFixed(3) },
        'Regime changed'
      );
    }

    return newRegime;
  }

  private calculateLikelihoods(meanReturn: number, stdReturn: number): Record<MarketRegime, number> {
    const likelihoods: Record<MarketRegime, number> = {
      [MarketRegime.BULL]: 0,
      [MarketRegime.VOLATILE]: 0,
      [MarketRegime.CRASH]: 0,
    };

    for (const regime of [MarketRegime.BULL, MarketRegime.VOLATILE, MarketRegime.CRASH]) {
      const params = this.emissionParams[regime];

      // Gaussian likelihood for mean
      const meanLikelihood = this.gaussianPdf(meanReturn, params.meanReturn, params.stdReturn * 0.5);

      // Likelihood for volatility (higher vol less likely for bull)
      const volLikelihood = this.gaussianPdf(stdReturn, params.stdReturn, params.stdReturn * 0.3);

      likelihoods[regime] = meanLikelihood * volLikelihood;
    }

    // Normalize
    const total = Object.values(likelihoods).reduce((a, b) => a + b, 0);
    if (total > 0) {
      for (const regime of Object.keys(likelihoods) as unknown as MarketRegime[]) {
        likelihoods[regime] /= total;
      }
    }

    return likelihoods;
  }

  private gaussianPdf(x: number, mean: number, std: number): number {
    const exponent = -Math.pow(x - mean, 2) / (2 * Math.pow(std, 2));
    return Math.exp(exponent) / (std * Math.sqrt(2 * Math.PI));
  }

  private applyTransition(likelihoods: Record<MarketRegime, number>): Record<MarketRegime, number> {
    const currentRegime = this.state.regime;
    const transitionProbs = this.transitionMatrix[currentRegime];

    const result: Record<MarketRegime, number> = {
      [MarketRegime.BULL]: 0,
      [MarketRegime.VOLATILE]: 0,
      [MarketRegime.CRASH]: 0,
    };

    // Combine transition probability with emission likelihood
    for (const regime of [MarketRegime.BULL, MarketRegime.VOLATILE, MarketRegime.CRASH]) {
      result[regime] = transitionProbs[regime] * likelihoods[regime];
    }

    // Normalize
    const total = Object.values(result).reduce((a, b) => a + b, 0);
    if (total > 0) {
      for (const regime of Object.keys(result) as unknown as MarketRegime[]) {
        result[regime] /= total;
      }
    }

    return result;
  }

  getCurrentRegime(): RegimeState {
    return { ...this.state };
  }

  getRegimeMultiplier(regime?: MarketRegime): number {
    const r = regime ?? this.state.regime;

    switch (r) {
      case MarketRegime.BULL:
        return 1.0;
      case MarketRegime.VOLATILE:
        return 0.5;
      case MarketRegime.CRASH:
        return 0.25;
      default:
        return 0.5;
    }
  }

  getRegimeName(regime?: MarketRegime): string {
    const r = regime ?? this.state.regime;
    return MarketRegime[r] || 'UNKNOWN';
  }

  // Update transition matrix based on observed data
  updateTransitionMatrix(transitions: Array<{ from: MarketRegime; to: MarketRegime }>): void {
    if (transitions.length < 10) return;

    const counts: number[][] = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
    ];

    for (const { from, to } of transitions) {
      counts[from][to]++;
    }

    // Convert counts to probabilities with smoothing
    for (let i = 0; i < 3; i++) {
      const total = counts[i].reduce((a, b) => a + b, 0) + 3; // Add 3 for smoothing
      for (let j = 0; j < 3; j++) {
        this.transitionMatrix[i][j] = (counts[i][j] + 1) / total;
      }
    }

    this.state.transitionProbs = this.transitionMatrix;
    logger.info({ transitionMatrix: this.transitionMatrix }, 'Transition matrix updated');
  }

  getVolatility(): number {
    if (this.returnHistory.length < 10) return 0.02;
    const recent = this.returnHistory.slice(-30);
    return ss.standardDeviation(recent);
  }

  getTrend(): 'up' | 'down' | 'sideways' {
    if (this.returnHistory.length < 10) return 'sideways';

    const recent = this.returnHistory.slice(-20);
    const sum = recent.reduce((a, b) => a + b, 0);

    if (sum > 0.02) return 'up';
    if (sum < -0.02) return 'down';
    return 'sideways';
  }
}

export const regimeDetector = new RegimeDetector();
</file>

<file path="src/ai/types.ts">
export enum Action {
  HOLD = 0,
  BUY = 1,
  SELL = 2,
}

export interface Experience {
  state: number[];
  action: Action;
  reward: number;
  nextState: number[];
  done: boolean;
}

export interface DDQNConfig {
  stateSize: number;
  actionSize: number;
  hiddenSize: number;
  learningRate: number;
  gamma: number;
  epsilon: number;
  epsilonMin: number;
  epsilonDecay: number;
  replayBufferSize: number;
  batchSize: number;
  targetUpdateTau: number;
}

export enum MarketRegime {
  BULL = 0,      // 100% position sizing
  VOLATILE = 1,  // 50% position sizing
  CRASH = 2,     // 25% position sizing
}

export interface RegimeState {
  regime: MarketRegime;
  confidence: number;
  transitionProbs: number[][];
  history: MarketRegime[];
}

export interface PositionSizeResult {
  sizeSol: number;
  kellyFraction: number;
  regimeMultiplier: number;
  riskAdjustedSize: number;
  reason: string;
}

export interface AIDecision {
  action: Action;
  confidence: number;
  regime: MarketRegime;
  positionSize: PositionSizeResult;
  qValues: number[];
  features: number[];
  timestamp: Date;
}

export interface ModelMetrics {
  totalTrades: number;
  winRate: number;
  avgReturn: number;
  sharpeRatio: number;
  maxDrawdown: number;
  profitFactor: number;
  lastUpdated: Date;
}
</file>

<file path="src/api/routes.ts">
import { Express, Request, Response } from 'express';
import { createChildLogger } from '../utils/logger';
import { positionManager, capitalAllocator, drawdownGuard } from '../risk';
import { tradeLogger, performanceAnalytics } from '../learning';
import { tokenWatchlist, pumpDetector } from '../signals';
import { ddqnAgent, regimeDetector, positionSizer } from '../ai';
import { config } from '../config/settings';
import { walletSync, equityTracker, positionReconciler } from '../services';

const logger = createChildLogger('api-routes');

// Store AI decision history for debugging
interface AIDecisionLog {
  mint: string;
  symbol: string;
  timestamp: Date;
  action: string;
  confidence: number;
  requiredConfidence: number;
  hasMomentum: boolean;
  qValues: number[];
  features: Record<string, number>;
  outcome?: 'passed' | 'rejected';
  rejectionReason?: string;
}

const aiDecisionHistory: AIDecisionLog[] = [];
const MAX_DECISION_HISTORY = 100;

// Store rejection stats
const rejectionStats = {
  quickSafety: 0,
  liquidity: 0,
  rugScore: 0,
  entryEval: 0,
  aiDecision: 0,
  riskCheck: 0,
  confidenceBelow: 0,  // NEW: Track confidence-based rejections
  total: 0,
  passed: 0,
};

// Export function to log AI decisions from index.ts
export function logAIDecision(decision: AIDecisionLog): void {
  aiDecisionHistory.unshift(decision);
  if (aiDecisionHistory.length > MAX_DECISION_HISTORY) {
    aiDecisionHistory.pop();
  }
}

// Export function to update rejection stats
export function updateRejectionStats(type: keyof typeof rejectionStats): void {
  if (type in rejectionStats) {
    rejectionStats[type]++;
    if (type !== 'passed') {
      rejectionStats.total++;
    }
  }
}

export function setupRoutes(app: Express): void {
  // Health check
  app.get('/api/health', (req: Request, res: Response) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
  });

  // Get bot status
  app.get('/api/status', async (req: Request, res: Response) => {
    try {
      const drawdown = drawdownGuard.getState();
      const allocation = capitalAllocator.getAllocation();
      const positions = positionManager.getOpenPositions();

      res.json({
        isRunning: true,
        isPaused: drawdown.isPaused,
        pauseReason: drawdown.pauseReason,
        pauseUntil: drawdown.pauseUntil,
        positionCount: positions.length,
        totalExposure: positionManager.getTotalExposure(),
        totalCapital: allocation.totalSol,
        currentEquity: drawdown.currentEquity,
        paperTrading: config.paperTrading,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get status');
      res.status(500).json({ error: 'Failed to get status' });
    }
  });

  // Get stats for dashboard
  app.get('/api/stats', async (req: Request, res: Response) => {
    try {
      const metrics = await performanceAnalytics.calculateMetrics();
      const allocation = capitalAllocator.getAllocation();
      const drawdown = drawdownGuard.getState();
      const positions = positionManager.getOpenPositions();

      // Calculate total unrealized P&L
      const totalUnrealizedPnl = positions.reduce((sum, p) => sum + p.unrealizedPnl, 0);

      // Calculate multiplier: (realized + unrealized + initial) / initial
      const realizedPnl = metrics.totalPnl;
      const currentEquity = config.initialCapitalSol + realizedPnl + totalUnrealizedPnl;
      const multiplier = currentEquity / config.initialCapitalSol;

      // Calculate win streak
      const recentTrades = await tradeLogger.getRecentTrades(20);
      let winStreak = 0;
      for (const trade of recentTrades) {
        if (trade.pnlSol !== undefined) {
          if (trade.pnlSol > 0) {
            winStreak++;
          } else {
            break;
          }
        }
      }

      res.json({
        multiplier: multiplier.toFixed(2),
        winRate: (metrics.winRate * 100).toFixed(1),
        totalTrades: metrics.totalTrades,
        winningTrades: metrics.winningTrades,
        losingTrades: metrics.losingTrades,
        totalPnl: metrics.totalPnl.toFixed(4),
        totalUnrealizedPnl: totalUnrealizedPnl.toFixed(4),
        currentEquity: currentEquity.toFixed(4),
        initialCapital: config.initialCapitalSol,
        progressPercent: Math.min(100, (currentEquity / 100) * 100),
        profitFactor: metrics.profitFactor.toFixed(2),
        sharpeRatio: metrics.sharpeRatio.toFixed(2),
        maxDrawdown: (metrics.maxDrawdown * 100).toFixed(1),
        avgWin: metrics.avgWin.toFixed(4),
        avgLoss: metrics.avgLoss.toFixed(4),
        largestWin: metrics.largestWin.toFixed(4),
        largestLoss: metrics.largestLoss.toFixed(4),
        winStreak,
        drawdown: {
          current: (drawdown.currentDrawdown * 100).toFixed(2),
          max: (drawdown.maxDrawdown * 100).toFixed(2),
          dailyPnl: drawdown.dailyPnl.toFixed(4),
        },
        allocation: {
          total: allocation.totalSol.toFixed(4),
          inPositions: allocation.inPositions.toFixed(4),
          availableActive: allocation.availableActive.toFixed(4),
          availableHighRisk: allocation.availableHighRisk.toFixed(4),
        },
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get stats');
      res.status(500).json({ error: 'Failed to get stats' });
    }
  });

  // Get recent trades
  app.get('/api/trades', async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 20;
      const trades = await tradeLogger.getRecentTrades(limit);

      const formattedTrades = trades.map((trade) => ({
        id: trade.id,
        mint: trade.mint,
        symbol: trade.symbol,
        entryPrice: trade.entryPrice,
        exitPrice: trade.exitPrice,
        amount: trade.amount,
        amountSol: trade.amountSol,
        entryTime: trade.entryTime,
        exitTime: trade.exitTime,
        pnlSol: trade.pnlSol?.toFixed(6),
        pnlPercent: trade.pnlPercent?.toFixed(2),
        duration: trade.duration,
        exitReason: trade.exitReason,
        isOpen: !trade.exitTime,
      }));

      res.json(formattedTrades);
    } catch (error) {
      logger.error({ error }, 'Failed to get trades');
      res.status(500).json({ error: 'Failed to get trades' });
    }
  });

  // Get open positions
  app.get('/api/positions', async (req: Request, res: Response) => {
    try {
      const positions = positionManager.getOpenPositions();

      const formattedPositions = positions.map((p) => ({
        id: p.id,
        mint: p.mint,
        symbol: p.symbol,
        amount: p.amount,
        amountSol: p.amountSol,
        entryPrice: p.entryPrice,
        currentPrice: p.currentPrice,
        highestPrice: p.highestPrice,
        unrealizedPnl: p.unrealizedPnl.toFixed(6),
        unrealizedPnlPercent: p.unrealizedPnlPercent.toFixed(2),
        stopLoss: p.stopLoss,
        takeProfit: p.takeProfit,
        tpSold: p.tpSold,
        trailingStop: p.trailingStop,
        status: p.status,
        poolType: p.poolType,
        entryTime: p.entryTime,
        lastUpdate: p.lastUpdate,
        holdTime: Date.now() - p.entryTime.getTime(),
      }));

      const totalUnrealizedPnl = positions.reduce((sum, p) => sum + p.unrealizedPnl, 0);
      const totalExposure = positionManager.getTotalExposure();

      res.json({
        positions: formattedPositions,
        totalUnrealizedPnl: totalUnrealizedPnl.toFixed(6),
        totalExposure: totalExposure.toFixed(4),
        positionCount: positions.length,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get positions');
      res.status(500).json({ error: 'Failed to get positions' });
    }
  });

  // Get detailed performance metrics
  app.get('/api/performance', async (req: Request, res: Response) => {
    try {
      const timeframePerformance = await performanceAnalytics.getTimeframePerformance();

      res.json({
        hourly: formatMetrics(timeframePerformance.hourly),
        daily: formatMetrics(timeframePerformance.daily),
        weekly: formatMetrics(timeframePerformance.weekly),
        monthly: formatMetrics(timeframePerformance.monthly),
        allTime: formatMetrics(timeframePerformance.allTime),
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get performance');
      res.status(500).json({ error: 'Failed to get performance' });
    }
  });

  // Get active trades (currently being monitored but not yet closed)
  app.get('/api/active-trades', (req: Request, res: Response) => {
    try {
      const activeTrades = tradeLogger.getActiveTrades();
      res.json(activeTrades);
    } catch (error) {
      logger.error({ error }, 'Failed to get active trades');
      res.status(500).json({ error: 'Failed to get active trades' });
    }
  });

  // NEW: Get AI decision history for debugging
  app.get('/api/debug/ai-decisions', (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const decisions = aiDecisionHistory.slice(0, limit);

      res.json({
        decisions,
        totalDecisions: aiDecisionHistory.length,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get AI decisions');
      res.status(500).json({ error: 'Failed to get AI decisions' });
    }
  });

  // NEW: Get rejection statistics
  app.get('/api/debug/rejection-stats', (req: Request, res: Response) => {
    try {
      const passRate = rejectionStats.passed > 0 || rejectionStats.total > 0
        ? (rejectionStats.passed / (rejectionStats.total + rejectionStats.passed)) * 100
        : 0;

      res.json({
        ...rejectionStats,
        passRate: passRate.toFixed(1) + '%',
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get rejection stats');
      res.status(500).json({ error: 'Failed to get rejection stats' });
    }
  });

  // NEW: Get watchlist status with detailed features
  app.get('/api/debug/watchlist', (req: Request, res: Response) => {
    try {
      const tokens = tokenWatchlist.getAllTokens();
      const watchlistData = tokens.map(mint => {
        const token = tokenWatchlist.getToken(mint);
        const features = tokenWatchlist.extractFeatures(mint);
        const momentumSignal = tokenWatchlist.getMomentumSignal(mint);
        const dynamicThreshold = tokenWatchlist.getDynamicConfidenceThreshold(mint);
        const filterResult = tokenWatchlist.passesHardFilters(mint);

        return {
          mint: mint.substring(0, 15) + '...',
          fullMint: mint,
          ageSeconds: token ? (Date.now() - token.firstSeen) / 1000 : 0,
          dataPoints: token?.priceHistory.length || 0,
          tradeCount: token?.trades.length || 0,
          devSoldPercent: token?.devSoldPercent || 0,
          devSold: token?.devSold || false,
          passesFilters: filterResult.passes,
          filterReason: filterResult.reason,
          dynamicThreshold: dynamicThreshold.toFixed(2),
          features: features ? {
            priceChange: (features.priceChange * 100).toFixed(2) + '%',
            buyPressure: (features.buyPressure * 100).toFixed(0) + '%',
            volumeAcceleration: features.volumeAcceleration.toFixed(2) + 'x',
            uniqueTraderGrowth: features.uniqueTraderGrowth,
            hasMomentum: features.hasMomentum,
            drawdown: (features.drawdown * 100).toFixed(1) + '%',
          } : null,
          momentum: momentumSignal,
        };
      });

      const stats = tokenWatchlist.getStats();

      res.json({
        stats,
        tokens: watchlistData,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get watchlist');
      res.status(500).json({ error: 'Failed to get watchlist' });
    }
  });

  // NEW: Get DDQN model stats
  app.get('/api/debug/model-stats', (req: Request, res: Response) => {
    try {
      const regime = regimeDetector.getCurrentRegime();
      const winRate = positionSizer.getWinRate();
      const epsilon = ddqnAgent.getEpsilon ? ddqnAgent.getEpsilon() : 'N/A';

      res.json({
        regime: regime.regime,
        regimeName: regimeDetector.getRegimeName(),
        regimeConfidence: regime.confidence,
        winRate: (winRate * 100).toFixed(1) + '%',
        epsilon,
        configThresholds: {
          minConfidence: config.watchlist?.minConfidence,
          maxConfidence: config.watchlist?.maxConfidence,
          minAgeSeconds: config.watchlist?.minAgeSeconds,
          maxDrawdown: config.watchlist?.maxDrawdown,
        },
        momentumConfig: config.momentumOverride,
        devSoldConfig: config.devSoldConfig,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get model stats');
      res.status(500).json({ error: 'Failed to get model stats' });
    }
  });

  // NEW: Get confidence analysis for winning vs losing trades
  app.get('/api/debug/confidence-analysis', async (req: Request, res: Response) => {
    try {
      const trades = await tradeLogger.getRecentTrades(100);
      const completedTrades = trades.filter(t => t.exitTime);

      const winners = completedTrades.filter(t => (t.pnlSol || 0) > 0);
      const losers = completedTrades.filter(t => (t.pnlSol || 0) <= 0);

      // Calculate average confidence for winners vs losers
      // Note: We'd need to store confidence with trades to do this properly
      // For now, return trade counts

      res.json({
        totalTrades: completedTrades.length,
        winners: winners.length,
        losers: losers.length,
        winRate: completedTrades.length > 0
          ? ((winners.length / completedTrades.length) * 100).toFixed(1) + '%'
          : 'N/A',
        avgWinPnl: winners.length > 0
          ? (winners.reduce((sum, t) => sum + (t.pnlPercent || 0), 0) / winners.length).toFixed(2) + '%'
          : 'N/A',
        avgLossPnl: losers.length > 0
          ? (losers.reduce((sum, t) => sum + (t.pnlPercent || 0), 0) / losers.length).toFixed(2) + '%'
          : 'N/A',
        recentDecisions: aiDecisionHistory.slice(0, 10).map(d => ({
          mint: d.mint.substring(0, 12),
          action: d.action,
          confidence: d.confidence.toFixed(2),
          requiredConfidence: d.requiredConfidence.toFixed(2),
          hasMomentum: d.hasMomentum,
          outcome: d.outcome,
        })),
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get confidence analysis');
      res.status(500).json({ error: 'Failed to get confidence analysis' });
    }
  });

  // NEW: Get actual wallet balance and equity
  app.get('/api/wallet', async (req: Request, res: Response) => {
    try {
      const walletState = walletSync.getState();
      const latestEquity = equityTracker.getLatestSnapshot();
      const equityChange = equityTracker.getEquityChange(24);

      res.json({
        solBalance: walletState?.solBalance || 0,
        lastSync: walletState?.lastSync || null,
        isHealthy: walletSync.isHealthy(),
        equity: latestEquity ? {
          total: latestEquity.totalEquitySol,
          walletBalance: latestEquity.walletBalanceSol,
          positionsValue: latestEquity.positionsValueSol,
          unrealizedPnl: latestEquity.unrealizedPnlSol,
          positionCount: latestEquity.positionCount,
          timestamp: latestEquity.timestamp,
        } : null,
        change24h: equityChange,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get wallet info');
      res.status(500).json({ error: 'Failed to get wallet info' });
    }
  });

  // NEW: Get equity history for chart
  app.get('/api/equity-history', async (req: Request, res: Response) => {
    try {
      const hours = parseInt(req.query.hours as string) || 24;
      const history = await equityTracker.getEquityHistory(hours);

      res.json({
        history: history.map(s => ({
          timestamp: s.timestamp,
          totalEquity: s.totalEquitySol,
          walletBalance: s.walletBalanceSol,
          positionsValue: s.positionsValueSol,
          unrealizedPnl: s.unrealizedPnlSol,
          positionCount: s.positionCount,
        })),
        count: history.length,
        hours,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get equity history');
      res.status(500).json({ error: 'Failed to get equity history' });
    }
  });

  // NEW: Trigger manual reconciliation
  app.post('/api/reconcile', async (req: Request, res: Response) => {
    try {
      const autoClose = req.body?.autoClose !== false; // Default true
      const result = await positionReconciler.reconcile(autoClose);

      res.json({
        success: true,
        phantomsFound: result.phantomsFound.length,
        phantomsClosed: result.phantomsClosed,
        orphansFound: result.orphansFound.length,
        details: {
          phantoms: result.phantomsFound.map(p => ({
            positionId: p.positionId,
            mint: p.mint.substring(0, 15) + '...',
            symbol: p.symbol,
            expectedAmount: p.expectedAmount,
            actualAmount: p.actualAmount,
            amountSol: p.amountSol,
          })),
          orphans: result.orphansFound,
        },
        reconciliationTime: result.reconciliationTime,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to reconcile positions');
      res.status(500).json({ error: 'Failed to reconcile positions' });
    }
  });

  // NEW: Get positions with real-time unrealized PnL
  app.get('/api/positions/realtime', async (req: Request, res: Response) => {
    try {
      const positions = positionManager.getOpenPositions();

      const formattedPositions = positions.map((p) => {
        const currentValue = p.amount * p.currentPrice;
        const entryValue = p.amountSol;
        const unrealizedPnl = currentValue - entryValue;
        const totalPnl = (p.realizedPnl || 0) + unrealizedPnl;

        return {
          id: p.id,
          mint: p.mint,
          symbol: p.symbol,
          amount: p.amount,
          amountSol: p.amountSol,
          entryPrice: p.entryPrice,
          currentPrice: p.currentPrice,
          highestPrice: p.highestPrice,
          currentValue,
          unrealizedPnl: unrealizedPnl.toFixed(6),
          unrealizedPnlPercent: ((unrealizedPnl / entryValue) * 100).toFixed(2),
          realizedPnl: (p.realizedPnl || 0).toFixed(6),
          totalPnl: totalPnl.toFixed(6),
          totalPnlPercent: ((totalPnl / entryValue) * 100).toFixed(2),
          stopLoss: p.stopLoss,
          trailingStop: p.trailingStop,
          initialRecovered: p.initialRecovered,
          scaledExitsTaken: p.scaledExitsTaken,
          status: p.status,
          poolType: p.poolType,
          entryTime: p.entryTime,
          lastUpdate: p.lastUpdate,
          holdTimeMs: Date.now() - p.entryTime.getTime(),
        };
      });

      const totalUnrealizedPnl = positions.reduce((sum, p) => {
        const currentValue = p.amount * p.currentPrice;
        return sum + (currentValue - p.amountSol);
      }, 0);

      const totalRealizedPnl = positions.reduce((sum, p) => sum + (p.realizedPnl || 0), 0);
      const totalExposure = positionManager.getTotalExposure();

      res.json({
        positions: formattedPositions,
        summary: {
          totalUnrealizedPnl: totalUnrealizedPnl.toFixed(6),
          totalRealizedPnl: totalRealizedPnl.toFixed(6),
          totalPnl: (totalUnrealizedPnl + totalRealizedPnl).toFixed(6),
          totalExposure: totalExposure.toFixed(4),
          positionCount: positions.length,
        },
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get realtime positions');
      res.status(500).json({ error: 'Failed to get realtime positions' });
    }
  });

  logger.info('API routes configured');
}

function formatMetrics(metrics: any): any {
  return {
    totalTrades: metrics.totalTrades,
    winningTrades: metrics.winningTrades,
    losingTrades: metrics.losingTrades,
    winRate: (metrics.winRate * 100).toFixed(1),
    totalPnl: metrics.totalPnl.toFixed(4),
    profitFactor: metrics.profitFactor.toFixed(2),
    sharpeRatio: metrics.sharpeRatio.toFixed(2),
    maxDrawdown: (metrics.maxDrawdown * 100).toFixed(1),
    avgWin: metrics.avgWin.toFixed(4),
    avgLoss: metrics.avgLoss.toFixed(4),
  };
}
</file>

<file path="src/api/server.ts">
import express, { Express } from 'express';
import { createServer, Server as HttpServer } from 'http';
import { Server as SocketServer } from 'socket.io';
import cors from 'cors';
import path from 'path';
import { createChildLogger } from '../utils/logger';
import { setupRoutes } from './routes';
import { setupWebSocket } from './websocket';

const logger = createChildLogger('api-server');

export class ApiServer {
  private app: Express;
  private httpServer: HttpServer;
  private io: SocketServer;
  private port: number;

  constructor(port: number = 3500) {
    this.port = port;
    this.app = express();
    this.httpServer = createServer(this.app);
    this.io = new SocketServer(this.httpServer, {
      cors: {
        origin: '*',
        methods: ['GET', 'POST'],
      },
    });

    this.setupMiddleware();
    this.setupStaticFiles();
    setupRoutes(this.app);
    setupWebSocket(this.io);
  }

  private setupMiddleware(): void {
    this.app.use(cors());
    this.app.use(express.json());
  }

  private setupStaticFiles(): void {
    // Serve static files from the public directory
    const publicPath = path.join(__dirname, '../../public');
    this.app.use(express.static(publicPath));

    // Serve index.html for root route
    this.app.get('/', (req, res) => {
      res.sendFile(path.join(publicPath, 'index.html'));
    });
  }

  start(): Promise<void> {
    return new Promise((resolve) => {
      this.httpServer.listen(this.port, () => {
        logger.info({ port: this.port }, 'API server started');
        logger.info(`Dashboard available at http://localhost:${this.port}`);
        resolve();
      });
    });
  }

  stop(): Promise<void> {
    return new Promise((resolve) => {
      this.io.close();
      this.httpServer.close(() => {
        logger.info('API server stopped');
        resolve();
      });
    });
  }

  getIO(): SocketServer {
    return this.io;
  }
}

export const apiServer = new ApiServer(3500);
</file>

<file path="src/api/websocket.ts">
import { Server as SocketServer, Socket } from 'socket.io';
import { createChildLogger } from '../utils/logger';
import { positionManager, capitalAllocator, drawdownGuard } from '../risk';
import { tradeLogger, performanceAnalytics } from '../learning';
import { heliusWs } from '../data';
import { tokenWatchlist } from '../signals';
import { config } from '../config/settings';
import { Position } from '../risk/types';
import { walletSync, equityTracker, positionReconciler } from '../services';

const logger = createChildLogger('websocket');

// Track scanner state
let tokensScanned = 0;
let currentScanningToken: { mint: string; symbol?: string } | null = null;

export function setupWebSocket(io: SocketServer): void {
  // Handle client connections
  io.on('connection', (socket: Socket) => {
    logger.info({ socketId: socket.id }, 'Client connected');

    // Send initial state on connect
    sendInitialState(socket);

    socket.on('disconnect', () => {
      logger.info({ socketId: socket.id }, 'Client disconnected');
    });

    // Allow clients to request refresh
    socket.on('refresh', async () => {
      await sendInitialState(socket);
    });
  });

  // Bridge existing EventEmitters to Socket.io
  setupEventBridges(io);

  // Start periodic broadcasts
  startPeriodicBroadcasts(io);

  logger.info('WebSocket handlers configured');
}

async function sendInitialState(socket: Socket): Promise<void> {
  try {
    // Send current stats
    const metrics = await performanceAnalytics.calculateMetrics();
    const allocation = capitalAllocator.getAllocation();
    const drawdown = drawdownGuard.getState();
    const positions = positionManager.getOpenPositions();
    const recentTrades = await tradeLogger.getRecentTrades(20);

    const totalUnrealizedPnl = positions.reduce((sum, p) => sum + p.unrealizedPnl, 0);
    const currentEquity = config.initialCapitalSol + metrics.totalPnl + totalUnrealizedPnl;
    const multiplier = currentEquity / config.initialCapitalSol;

    socket.emit('stats:initial', {
      multiplier: multiplier.toFixed(2),
      winRate: (metrics.winRate * 100).toFixed(1),
      totalTrades: metrics.totalTrades,
      tokensScanned,
      currentEquity: currentEquity.toFixed(4),
      initialCapital: config.initialCapitalSol,
      totalPnl: metrics.totalPnl.toFixed(4),
      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(4),
      isPaused: drawdown.isPaused,
    });

    // Send current positions
    socket.emit('positions:initial', formatPositions(positions));

    // Send recent trades
    socket.emit('trades:initial', recentTrades.slice(0, 10).map(formatTrade));

    // Send scanner state
    socket.emit('scanner:initial', {
      tokensScanned,
      currentToken: currentScanningToken,
    });
  } catch (error) {
    logger.error({ error }, 'Failed to send initial state');
  }
}

function setupEventBridges(io: SocketServer): void {
  // New token detected (scanner event)
  heliusWs.on('newToken', (event: { mint: string; signature: string }) => {
    tokensScanned++;
    currentScanningToken = { mint: event.mint };

    io.emit('scanner:token', {
      mint: event.mint,
      signature: event.signature,
      tokensScanned,
    });

    // Clear current token after a delay
    setTimeout(() => {
      if (currentScanningToken?.mint === event.mint) {
        currentScanningToken = null;
        io.emit('scanner:idle', { tokensScanned });
      }
    }, 10000);
  });

  // Position opened
  positionManager.on('positionOpened', (position: Position) => {
    io.emit('trade:open', {
      id: position.id,
      mint: position.mint,
      symbol: position.symbol,
      amountSol: position.amountSol.toFixed(4),
      entryPrice: position.entryPrice,
      poolType: position.poolType,
      timestamp: new Date().toISOString(),
    });

    io.emit('toast', {
      type: 'info',
      title: 'Position Opened',
      message: `Bought ${position.symbol || position.mint.substring(0, 8)} for ${position.amountSol.toFixed(4)} SOL`,
    });
  });

  // Position closed
  positionManager.on('positionClosed', (data: {
    position: Position;
    reason: string;
    exitPrice: number;
    pnlSol: number;
    pnlPercent: number;
  }) => {
    const { position, reason, pnlSol, pnlPercent } = data;

    io.emit('trade:close', {
      id: position.id,
      mint: position.mint,
      symbol: position.symbol,
      pnlSol: pnlSol.toFixed(6),
      pnlPercent: pnlPercent.toFixed(2),
      reason,
      timestamp: new Date().toISOString(),
    });

    // Show toast for profitable trades
    if (pnlSol > 0) {
      io.emit('toast', {
        type: 'success',
        title: `+${pnlSol.toFixed(4)} SOL`,
        message: `${position.symbol || position.mint.substring(0, 8)} closed at ${pnlPercent.toFixed(1)}%`,
      });
    } else {
      io.emit('toast', {
        type: 'error',
        title: `${pnlSol.toFixed(4)} SOL`,
        message: `${position.symbol || position.mint.substring(0, 8)} stopped out at ${pnlPercent.toFixed(1)}%`,
      });
    }
  });

  // Partial close (take profit hit)
  positionManager.on('partialClose', (data: {
    position: Position;
    tpLevel: number;
    sellAmount: number;
  }) => {
    io.emit('trade:partial', {
      id: data.position.id,
      mint: data.position.mint,
      symbol: data.position.symbol,
      tpLevel: data.tpLevel + 1,
      sellAmount: data.sellAmount,
      timestamp: new Date().toISOString(),
    });

    io.emit('toast', {
      type: 'success',
      title: `TP${data.tpLevel + 1} Hit`,
      message: `${data.position.symbol || data.position.mint.substring(0, 8)} partial sell`,
    });
  });

  // Trading paused
  drawdownGuard.on('tradingPaused', (data: { reason: string; until?: Date }) => {
    io.emit('status:paused', {
      reason: data.reason,
      until: data.until?.toISOString(),
    });

    io.emit('toast', {
      type: 'warning',
      title: 'Trading Paused',
      message: data.reason,
    });
  });

  // Trading resumed
  drawdownGuard.on('tradingResumed', (data: { reason: string }) => {
    io.emit('status:resumed', {
      reason: data.reason,
    });

    io.emit('toast', {
      type: 'info',
      title: 'Trading Resumed',
      message: data.reason,
    });
  });

  // Trade logged
  tradeLogger.on('exitLogged', (trade: any) => {
    io.emit('trade:logged', formatTrade(trade));
  });

  // Token Watchlist events
  tokenWatchlist.on('tokenAdded', (data: { mint: string; creator: string }) => {
    const token = tokenWatchlist.getToken(data.mint);
    if (token) {
      io.emit('watchlist:tokenAdded', formatWatchlistToken(data.mint, token));
    }
  });

  tokenWatchlist.on('tokenRemoved', (data: { mint: string }) => {
    io.emit('watchlist:tokenRemoved', { mint: data.mint });
  });

  tokenWatchlist.on('devSold', (data: { mint: string }) => {
    io.emit('watchlist:devSold', { mint: data.mint });
    io.emit('toast', {
      type: 'warning',
      title: 'Dev Sold',
      message: `Token ${data.mint.substring(0, 8)}... creator dumped`,
    });
  });

  tokenWatchlist.on('tokenReady', (data: { mint: string }) => {
    const token = tokenWatchlist.getToken(data.mint);
    if (token) {
      io.emit('watchlist:tokenAdded', formatWatchlistToken(data.mint, token));
    }
  });

  // Wallet sync events
  walletSync.on('synced', (data) => {
    io.emit('wallet:update', {
      solBalance: data.solBalance,
      lastSync: data.syncTime,
      discrepancyCount: data.discrepancies.length,
    });
  });

  walletSync.on('discrepancies', (discrepancies) => {
    if (discrepancies.length > 0) {
      io.emit('toast', {
        type: 'warning',
        title: 'Balance Discrepancy',
        message: `Found ${discrepancies.length} position(s) with balance issues`,
      });
    }
  });

  // Equity tracker events
  equityTracker.on('snapshot', (snapshot) => {
    io.emit('equity:snapshot', {
      timestamp: snapshot.timestamp,
      totalEquity: snapshot.totalEquitySol,
      walletBalance: snapshot.walletBalanceSol,
      positionsValue: snapshot.positionsValueSol,
      unrealizedPnl: snapshot.unrealizedPnlSol,
      positionCount: snapshot.positionCount,
      source: snapshot.source,
    });
  });

  // Position reconciler events
  positionReconciler.on('phantomsDetected', (phantoms) => {
    io.emit('reconciliation:phantoms', {
      count: phantoms.length,
      phantoms: phantoms.map((p: any) => ({
        positionId: p.positionId,
        mint: p.mint.substring(0, 15) + '...',
        symbol: p.symbol,
        lostSol: p.amountSol,
      })),
    });
  });

  positionReconciler.on('notification', (notification) => {
    io.emit('toast', notification);
  });
}

function startPeriodicBroadcasts(io: SocketServer): void {
  // Broadcast position updates every 1 second (live P&L)
  setInterval(() => {
    const positions = positionManager.getOpenPositions();
    if (positions.length > 0) {
      io.emit('positions:update', formatPositions(positions));
    }
  }, 1000);

  // Broadcast watchlist updates every 2 seconds
  setInterval(() => {
    const stats = tokenWatchlist.getStats();
    const allTokens = tokenWatchlist.getAllTokens();

    // Format all watched tokens (up to 20 most recent)
    if (stats.total > 0) {
      const formattedTokens = allTokens.slice(0, 20).map(mint => {
        const token = tokenWatchlist.getToken(mint);
        if (token) {
          return formatWatchlistToken(mint, token);
        }
        return null;
      }).filter(Boolean);

      io.emit('watchlist:update', {
        tokens: formattedTokens,
        stats
      });
    }
  }, 2000);

  // Broadcast stats every 5 seconds
  setInterval(async () => {
    try {
      const metrics = await performanceAnalytics.calculateMetrics();
      const drawdown = drawdownGuard.getState();
      const positions = positionManager.getOpenPositions();

      const totalUnrealizedPnl = positions.reduce((sum, p) => sum + p.unrealizedPnl, 0);
      const currentEquity = config.initialCapitalSol + metrics.totalPnl + totalUnrealizedPnl;
      const multiplier = currentEquity / config.initialCapitalSol;

      // Calculate win streak
      const recentTrades = await tradeLogger.getRecentTrades(20);
      let winStreak = 0;
      for (const trade of recentTrades) {
        if (trade.pnlSol !== undefined) {
          if (trade.pnlSol > 0) {
            winStreak++;
          } else {
            break;
          }
        }
      }

      io.emit('stats:update', {
        multiplier: multiplier.toFixed(2),
        winRate: (metrics.winRate * 100).toFixed(1),
        totalTrades: metrics.totalTrades,
        tokensScanned,
        currentEquity: currentEquity.toFixed(4),
        totalPnl: metrics.totalPnl.toFixed(4),
        totalUnrealizedPnl: totalUnrealizedPnl.toFixed(4),
        dailyPnl: drawdown.dailyPnl.toFixed(4),
        drawdown: (drawdown.currentDrawdown * 100).toFixed(2),
        winStreak,
        isPaused: drawdown.isPaused,
        positionCount: positions.length,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to broadcast stats');
    }
  }, 5000);

  // Broadcast wallet balance every 10 seconds
  setInterval(() => {
    try {
      const walletState = walletSync.getState();
      const latestEquity = equityTracker.getLatestSnapshot();

      if (walletState) {
        io.emit('wallet:update', {
          solBalance: walletState.solBalance,
          lastSync: walletState.lastSync,
          isHealthy: walletSync.isHealthy(),
          totalEquity: latestEquity?.totalEquitySol || walletState.solBalance,
        });
      }
    } catch (error) {
      logger.error({ error }, 'Failed to broadcast wallet update');
    }
  }, 10000);
}

function formatPositions(positions: Position[]): {
  positions: any[];
  totalUnrealizedPnl: string;
  totalExposure: string;
  positionCount: number;
} {
  const formattedPositions = positions.map((p) => ({
    id: p.id,
    mint: p.mint,
    symbol: p.symbol,
    amount: p.amount,
    amountSol: p.amountSol,
    entryPrice: p.entryPrice,
    currentPrice: p.currentPrice,
    highestPrice: p.highestPrice,
    unrealizedPnl: p.unrealizedPnl,
    unrealizedPnlPercent: p.unrealizedPnlPercent,
    stopLoss: p.stopLoss,
    takeProfit: p.takeProfit,
    tpSold: p.tpSold,
    trailingStop: p.trailingStop,
    status: p.status,
    poolType: p.poolType,
    entryTime: p.entryTime.toISOString(),
    holdTime: Date.now() - p.entryTime.getTime(),
  }));

  const totalUnrealizedPnl = positions.reduce((sum, p) => sum + p.unrealizedPnl, 0);
  const totalExposure = positionManager.getTotalExposure();

  return {
    positions: formattedPositions,
    totalUnrealizedPnl: totalUnrealizedPnl.toFixed(6),
    totalExposure: totalExposure.toFixed(4),
    positionCount: positions.length,
  };
}

function formatTrade(trade: any): any {
  return {
    id: trade.id,
    mint: trade.mint,
    symbol: trade.symbol,
    entryPrice: trade.entryPrice,
    exitPrice: trade.exitPrice,
    amount: trade.amount,
    amountSol: trade.amountSol,
    entryTime: trade.entryTime,
    exitTime: trade.exitTime,
    pnlSol: trade.pnlSol?.toFixed(6),
    pnlPercent: trade.pnlPercent?.toFixed(2),
    duration: trade.duration,
    exitReason: trade.exitReason,
    isOpen: !trade.exitTime,
  };
}

function formatWatchlistToken(mint: string, token: any): any {
  const features = tokenWatchlist.extractFeatures(mint);
  const filterResult = tokenWatchlist.passesHardFilters(mint);

  let status: 'collecting' | 'ready' | 'analyzing' | 'rejected' | 'bought' = 'collecting';
  if (token.devSold) {
    status = 'rejected';
  } else if (filterResult.passes) {
    status = 'ready';
  } else if (token.priceHistory?.length >= 10) {
    status = 'rejected';
  }

  return {
    mint,
    symbol: token.symbol,
    firstSeen: token.firstSeen,
    dataPoints: token.priceHistory?.length || 0,
    priceChange: features?.priceChange || 0,
    volatility: features?.volatility || 0,
    drawdown: features?.drawdown || 0,
    buyPressure: features?.buyPressure || 0.5,
    uniqueTraders: features?.uniqueTraders || 0,
    devSold: token.devSold || false,
    status,
    rejectReason: !filterResult.passes ? filterResult.reason : undefined
  };
}

// Export for external use
export function getTokensScanned(): number {
  return tokensScanned;
}

export function resetTokensScanned(): void {
  tokensScanned = 0;
}
</file>

<file path="src/config/settings.ts">
import dotenv from 'dotenv';
dotenv.config();

const heliusApiKey = process.env.HELIUS_API_KEY || '';

export const config = {
  // Solana RPC
  solanaRpcUrl: process.env.SOLANA_RPC_URL || `https://mainnet.helius-rpc.com/?api-key=${heliusApiKey}`,
  heliusApiKey,
  heliusWsUrl: process.env.HELIUS_WS_URL || `wss://mainnet.helius-rpc.com/?api-key=${heliusApiKey}`,
  privateKey: process.env.WALLET_PRIVATE_KEY || process.env.PRIVATE_KEY || '',

  // Database
  databaseUrl: process.env.DATABASE_URL || '',
  sqlitePath: process.env.SQLITE_PATH || './data/cache.db',

  // Trading Parameters
  initialCapitalSol: parseFloat(process.env.INITIAL_CAPITAL_SOL || '1.0'),
  maxPositionSize: parseFloat(process.env.MAX_POSITION_SIZE || '0.10'),  // 10% of capital max (allows small balances to trade)
  dailyLossLimit: parseFloat(process.env.DAILY_LOSS_LIMIT || '0.15'),
  maxConcurrentPositions: parseInt(process.env.MAX_CONCURRENT_POSITIONS || '5'),

  // Jito MEV Protection
  jitoBlockEngineUrl: process.env.JITO_BLOCK_ENGINE_URL || 'https://mainnet.block-engine.jito.wtf',
  jitoTipLamports: parseInt(process.env.JITO_TIP_LAMPORTS || '10000'),

  // Feature Flags
  paperTrading: process.env.PAPER_TRADING === 'true',
  enableJito: process.env.ENABLE_JITO === 'true',

  // API Endpoints (using public Jupiter API - no auth required)
  jupiterQuoteApi: 'https://public.jupiterapi.com/quote',
  jupiterSwapApi: 'https://public.jupiterapi.com/swap',
  // Note: Price data comes from DexScreener (free) instead of Jupiter price API (paid)
  dexScreenerApi: 'https://api.dexscreener.com/latest/dex/tokens',
  jitoBundleApi: 'https://mainnet.block-engine.jito.wtf/api/v1/bundles',

  // Program IDs
  pumpFunProgram: '6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P',

  // Risk Parameters
  capitalAllocation: {
    reserve: 0.40,    // 40% never trade
    active: 0.40,     // 40% normal trades
    highRisk: 0.20,   // 20% meme plays
  },

  stopLossPercent: 0.12,      // -12% stop loss (was 50%)

  // NEW Take Profit Strategy: recover initial at +50%, then scale out
  takeProfitStrategy: {
    // At +50% gain, sell enough to recover initial investment
    initialRecovery: {
      triggerPercent: 0.50,  // +50% gain
      action: 'recover_initial' as const,
    },
    // After initial recovery, sell 20% of remainder every +50%
    scaledExits: {
      intervalPercent: 0.50,  // Every +50% gain
      sellPercent: 0.20,      // Sell 20% of remaining
    },
    // Trailing stop on final portion
    trailingStopPercent: 0.15,  // 15% trailing stop
  },

  // LEGACY: Keep for backwards compatibility but unused
  takeProfitLevels: [
    { multiplier: 2.0, sellPercent: 0.25 },
    { multiplier: 3.0, sellPercent: 0.25 },
  ],
  trailingStopPercent: 0.15,  // 15% trailing stop (updated from 20%)

  // AI Parameters
  ddqnConfig: {
    stateSize: 16,         // Updated from 12 to 16 (added: drawdownFromPeak, volatility, uniqueTraders, volumeTrend)
    actionSize: 3,         // HOLD, BUY, SELL
    hiddenSize: 128,
    learningRate: 0.001,
    gamma: 0.99,           // discount factor
    epsilon: 1.0,          // exploration rate
    epsilonMin: 0.01,
    epsilonDecay: 0.995,
    replayBufferSize: 100000,
    batchSize: 64,
    targetUpdateTau: 0.005,
  },

  // Timing
  priceCheckIntervalMs: 1000,
  featureUpdateIntervalMs: 5000,
  modelRetrainIntervalMs: 7 * 24 * 60 * 60 * 1000, // 1 week

  // Thresholds
  // NOTE: minRugScore lowered from 70 to 45 because LP info is not available
  // (passed as null to rug detector), so max possible score is ~75 instead of 100
  // NOTE: minLiquiditySol lowered from 5 to 1 for testing
  minLiquiditySol: 1,
  minHolderCount: 50,
  maxTop10Concentration: 0.30,
  minRugScore: 45,
  minPumpHeat: 0,  // Lowered from 33 to 0 for testing live trades

  // Trade execution settings
  tradeAmountSol: parseFloat(process.env.BASE_POSITION_SOL || '0.01'),
  defaultSlippageBps: 1500,  // 15% slippage
  priorityFeeSol: 0.0001,    // Priority fee in SOL
  jitoBribeSol: 0.00001,     // Jito bribe (if enabled)

  // Velocity-based entry for new tokens (no price history)
  // Balance: fast enough to catch pumps, but filter out wash trading
  velocityEntry: {
    enabled: false,          // DISABLED: AI decides entry, not velocity
    minTxCount: 5,           // Lowered from 10 - tokens evaluated quickly after creation
    minUniqueBuyers: 3,      // Lowered from 5 - need at least 3 different wallets
    minBuyPressure: 0.70,    // 70% buys - slightly more permissive
    maxMarketCapSol: 60,     // Increased - tokens with traction often hit 40-50 SOL quickly
  },

  // Token Watchlist - AI-driven entry (NEW)
  watchlist: {
    minDataPoints: 10,       // Need 10+ price updates before AI can analyze
    minAgeSeconds: 60,       // NEW: Token must be at least 60 seconds old
    minConfidence: 0.55,     // LOWERED: Base confidence (dynamic scaling adds more)
    maxConfidence: 0.70,     // NEW: Max confidence threshold for older tokens
    maxDrawdown: 0.30,       // Hard reject if crashed >30% from peak
  },

  // Momentum Override - bypass lower confidence if signals are strong
  momentumOverride: {
    enabled: true,
    minBuyPressure: 0.75,           // 75%+ buys
    minVolumeAcceleration: 1.2,     // Volume 20%+ higher than previous window
    minUniqueTraderGrowth: 3,       // At least 3 new unique traders
    confidenceFloor: 0.45,          // Allow entries at 45% confidence if momentum strong
  },

  // Dev Sold Tracking - percentage-based instead of binary
  devSoldConfig: {
    maxSellPercent: 0.05,           // 5% max dev sell allowed
    earlyWindowSeconds: 180,        // First 3 minutes are critical
    earlyMaxSellPercent: 0.02,      // Only 2% allowed in early window
  },
};

export const SOL_MINT = 'So11111111111111111111111111111111111111112';
export const USDC_MINT = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';
export const LAMPORTS_PER_SOL = 1_000_000_000;
</file>

<file path="src/db/repository.ts">
import { Pool } from 'pg';
import { createChildLogger } from '../utils/logger';
import { TokenRecord, TradeRecordDB, PositionRecord, PriceRecord, EquitySnapshotRecord, PartialCloseRecord, WalletSyncLogRecord } from './types';
import { config } from '../config/settings';

const logger = createChildLogger('repository');

export class Repository {
  private pool: Pool;

  constructor() {
    this.pool = new Pool({
      connectionString: config.databaseUrl,
      max: 10,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });

    this.pool.on('error', (err) => {
      logger.error({ err }, 'Unexpected database pool error');
    });
  }

  async connect(): Promise<void> {
    const client = await this.pool.connect();
    try {
      const result = await client.query('SELECT NOW()');
      logger.info({ time: result.rows[0].now }, 'Database connected');
    } finally {
      client.release();
    }
  }

  async close(): Promise<void> {
    await this.pool.end();
    logger.info('Database pool closed');
  }

  // Token operations
  async upsertToken(token: Partial<TokenRecord>): Promise<void> {
    await this.pool.query(`
      INSERT INTO tokens (mint, name, symbol, decimals, creator, mint_revoked, freeze_revoked)
      VALUES ($1, $2, $3, $4, $5, $6, $7)
      ON CONFLICT (mint) DO UPDATE SET
        name = COALESCE(EXCLUDED.name, tokens.name),
        symbol = COALESCE(EXCLUDED.symbol, tokens.symbol),
        mint_revoked = COALESCE(EXCLUDED.mint_revoked, tokens.mint_revoked),
        freeze_revoked = COALESCE(EXCLUDED.freeze_revoked, tokens.freeze_revoked),
        last_updated = NOW()
    `, [token.mint, token.name, token.symbol, token.decimals, token.creator, token.mint_revoked, token.freeze_revoked]);
  }

  async getToken(mint: string): Promise<TokenRecord | null> {
    const result = await this.pool.query('SELECT * FROM tokens WHERE mint = $1', [mint]);
    return result.rows[0] || null;
  }

  // Price operations
  async insertPrice(price: Partial<PriceRecord>): Promise<void> {
    await this.pool.query(`
      INSERT INTO price_history (mint, price_sol, price_usd, volume_24h, market_cap_sol, liquidity)
      VALUES ($1, $2, $3, $4, $5, $6)
    `, [price.mint, price.price_sol, price.price_usd, price.volume_24h, price.market_cap_sol, price.liquidity]);
  }

  async getRecentPrices(mint: string, limit: number = 100): Promise<PriceRecord[]> {
    const result = await this.pool.query(`
      SELECT * FROM price_history
      WHERE mint = $1
      ORDER BY timestamp DESC
      LIMIT $2
    `, [mint, limit]);
    return result.rows;
  }

  // Trade operations
  async insertTrade(trade: Partial<TradeRecordDB>): Promise<void> {
    await this.pool.query(`
      INSERT INTO trades (id, mint, symbol, action, entry_price, amount, amount_sol,
                          entry_time, features_json, regime, pump_phase)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    `, [
      trade.id, trade.mint, trade.symbol, trade.action, trade.entry_price,
      trade.amount, trade.amount_sol, trade.entry_time, trade.features_json,
      trade.regime, trade.pump_phase
    ]);
  }

  async updateTradeExit(id: string, exitData: {
    exit_price: number;
    exit_time: Date;
    pnl_sol: number;
    pnl_percent: number;
    duration_ms: number;
    exit_reason: string;
    slippage?: number;
    fees?: number;
  }): Promise<void> {
    await this.pool.query(`
      UPDATE trades SET
        exit_price = $2,
        exit_time = $3,
        pnl_sol = $4,
        pnl_percent = $5,
        duration_ms = $6,
        exit_reason = $7,
        slippage = $8,
        fees = $9
      WHERE id = $1
    `, [
      id, exitData.exit_price, exitData.exit_time, exitData.pnl_sol,
      exitData.pnl_percent, exitData.duration_ms, exitData.exit_reason,
      exitData.slippage, exitData.fees
    ]);
  }

  async getRecentTrades(limit: number = 100): Promise<TradeRecordDB[]> {
    const result = await this.pool.query(`
      SELECT * FROM trades ORDER BY entry_time DESC LIMIT $1
    `, [limit]);
    return result.rows;
  }

  async getTradesForTraining(weeks: number = 4): Promise<TradeRecordDB[]> {
    const result = await this.pool.query(`
      SELECT * FROM trades
      WHERE exit_time IS NOT NULL
        AND entry_time > NOW() - INTERVAL '${weeks} weeks'
      ORDER BY entry_time ASC
    `);
    return result.rows;
  }

  // Position operations
  async upsertPosition(position: Partial<PositionRecord>): Promise<void> {
    await this.pool.query(`
      INSERT INTO positions (id, mint, symbol, entry_price, current_price, amount,
                            amount_sol, entry_time, highest_price, lowest_price,
                            stop_loss, take_profit_json, tp_sold_json, status, pool_type)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
      ON CONFLICT (id) DO UPDATE SET
        current_price = EXCLUDED.current_price,
        highest_price = GREATEST(positions.highest_price, EXCLUDED.current_price),
        lowest_price = LEAST(positions.lowest_price, EXCLUDED.current_price),
        tp_sold_json = EXCLUDED.tp_sold_json,
        status = EXCLUDED.status,
        last_update = NOW()
    `, [
      position.id, position.mint, position.symbol, position.entry_price,
      position.current_price, position.amount, position.amount_sol,
      position.entry_time, position.highest_price, position.lowest_price,
      position.stop_loss, position.take_profit_json, position.tp_sold_json,
      position.status, position.pool_type
    ]);
  }

  async getOpenPositions(): Promise<PositionRecord[]> {
    const result = await this.pool.query(`
      SELECT * FROM positions WHERE status = 'open' ORDER BY entry_time ASC
    `);
    return result.rows;
  }

  async closePosition(id: string): Promise<void> {
    await this.pool.query(`
      UPDATE positions SET status = 'closed', last_update = NOW() WHERE id = $1
    `, [id]);
  }

  // Config operations
  async getConfig(key: string): Promise<string | null> {
    const result = await this.pool.query('SELECT value FROM config WHERE key = $1', [key]);
    return result.rows[0]?.value || null;
  }

  async setConfig(key: string, value: string): Promise<void> {
    await this.pool.query(`
      INSERT INTO config (key, value) VALUES ($1, $2)
      ON CONFLICT (key) DO UPDATE SET value = $2, updated_at = NOW()
    `, [key, value]);
  }

  // Model operations
  async saveModelWeights(version: number, weights: string, metrics: string): Promise<void> {
    await this.pool.query(`
      INSERT INTO model_weights (version, weights_json, metrics_json)
      VALUES ($1, $2, $3)
    `, [version, weights, metrics]);
  }

  async getLatestModelWeights(): Promise<{ weights: string; metrics: string; version: number } | null> {
    const result = await this.pool.query(`
      SELECT weights_json, metrics_json, version
      FROM model_weights
      ORDER BY version DESC
      LIMIT 1
    `);
    if (!result.rows[0]) return null;
    return {
      weights: result.rows[0].weights_json,
      metrics: result.rows[0].metrics_json,
      version: result.rows[0].version,
    };
  }

  // Daily stats operations
  async updateDailyStats(date: Date, stats: {
    starting_equity?: number;
    ending_equity?: number;
    pnl?: number;
    trades_count?: number;
    winning_trades?: number;
    losing_trades?: number;
    max_drawdown?: number;
  }): Promise<void> {
    const dateStr = date.toISOString().split('T')[0];
    await this.pool.query(`
      INSERT INTO daily_stats (date, starting_equity, ending_equity, pnl, trades_count,
                               winning_trades, losing_trades, max_drawdown)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (date) DO UPDATE SET
        ending_equity = COALESCE(EXCLUDED.ending_equity, daily_stats.ending_equity),
        pnl = COALESCE(EXCLUDED.pnl, daily_stats.pnl),
        trades_count = COALESCE(EXCLUDED.trades_count, daily_stats.trades_count),
        winning_trades = COALESCE(EXCLUDED.winning_trades, daily_stats.winning_trades),
        losing_trades = COALESCE(EXCLUDED.losing_trades, daily_stats.losing_trades),
        max_drawdown = GREATEST(daily_stats.max_drawdown, COALESCE(EXCLUDED.max_drawdown, 0))
    `, [dateStr, stats.starting_equity, stats.ending_equity, stats.pnl,
        stats.trades_count, stats.winning_trades, stats.losing_trades, stats.max_drawdown]);
  }

  // Whale tracking
  async upsertWhaleWallet(address: string, label?: string): Promise<void> {
    await this.pool.query(`
      INSERT INTO whale_wallets (address, label)
      VALUES ($1, $2)
      ON CONFLICT (address) DO UPDATE SET
        label = COALESCE(EXCLUDED.label, whale_wallets.label)
    `, [address, label]);
  }

  async logWhaleActivity(activity: {
    wallet: string;
    action: string;
    mint: string;
    amount: number;
    amount_sol: number;
    signature?: string;
  }): Promise<void> {
    await this.pool.query(`
      INSERT INTO whale_activity (wallet, action, mint, amount, amount_sol, signature)
      VALUES ($1, $2, $3, $4, $5, $6)
    `, [activity.wallet, activity.action, activity.mint, activity.amount,
        activity.amount_sol, activity.signature]);

    await this.pool.query(`
      UPDATE whale_wallets SET
        total_volume = total_volume + $2,
        last_active = NOW()
      WHERE address = $1
    `, [activity.wallet, activity.amount_sol]);
  }

  // Equity snapshot operations
  async insertEquitySnapshot(snapshot: {
    wallet_balance_sol: number;
    positions_value_sol: number;
    total_equity_sol: number;
    unrealized_pnl_sol: number;
    position_count: number;
    source: 'periodic' | 'trade_close' | 'startup';
  }): Promise<void> {
    await this.pool.query(`
      INSERT INTO equity_snapshots (wallet_balance_sol, positions_value_sol, total_equity_sol,
                                   unrealized_pnl_sol, position_count, source)
      VALUES ($1, $2, $3, $4, $5, $6)
    `, [
      snapshot.wallet_balance_sol, snapshot.positions_value_sol, snapshot.total_equity_sol,
      snapshot.unrealized_pnl_sol, snapshot.position_count, snapshot.source
    ]);
  }

  async getEquityHistory(hours: number = 24): Promise<EquitySnapshotRecord[]> {
    const result = await this.pool.query(`
      SELECT * FROM equity_snapshots
      WHERE timestamp > NOW() - INTERVAL '${hours} hours'
      ORDER BY timestamp ASC
    `);
    return result.rows;
  }

  async getLatestEquitySnapshot(): Promise<EquitySnapshotRecord | null> {
    const result = await this.pool.query(`
      SELECT * FROM equity_snapshots
      ORDER BY timestamp DESC
      LIMIT 1
    `);
    return result.rows[0] || null;
  }

  // Partial close operations
  async insertPartialClose(partialClose: {
    position_id: string;
    mint: string;
    close_type: 'initial_recovery' | 'scaled_exit' | 'tp_level';
    sell_amount_tokens: number;
    sell_amount_sol: number;
    price_at_close: number;
    pnl_sol: number;
    fees_sol: number;
  }): Promise<void> {
    await this.pool.query(`
      INSERT INTO partial_closes (position_id, mint, close_type, sell_amount_tokens,
                                 sell_amount_sol, price_at_close, pnl_sol, fees_sol)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `, [
      partialClose.position_id, partialClose.mint, partialClose.close_type,
      partialClose.sell_amount_tokens, partialClose.sell_amount_sol,
      partialClose.price_at_close, partialClose.pnl_sol, partialClose.fees_sol
    ]);
  }

  async getPartialCloses(positionId: string): Promise<PartialCloseRecord[]> {
    const result = await this.pool.query(`
      SELECT * FROM partial_closes
      WHERE position_id = $1
      ORDER BY timestamp ASC
    `, [positionId]);
    return result.rows;
  }

  async getTotalPartialClosePnl(positionId: string): Promise<number> {
    const result = await this.pool.query(`
      SELECT COALESCE(SUM(pnl_sol), 0) as total_pnl
      FROM partial_closes
      WHERE position_id = $1
    `, [positionId]);
    return parseFloat(result.rows[0]?.total_pnl || '0');
  }

  // Wallet sync log operations
  async insertWalletSyncLog(log: {
    sol_balance: number;
    token_positions_json: string;
    discrepancies_json: string;
  }): Promise<void> {
    await this.pool.query(`
      INSERT INTO wallet_sync_log (sol_balance, token_positions_json, discrepancies_json)
      VALUES ($1, $2, $3)
    `, [log.sol_balance, log.token_positions_json, log.discrepancies_json]);
  }

  async getLatestWalletSync(): Promise<WalletSyncLogRecord | null> {
    const result = await this.pool.query(`
      SELECT * FROM wallet_sync_log
      ORDER BY timestamp DESC
      LIMIT 1
    `);
    return result.rows[0] || null;
  }

  // Delete phantom position
  async deletePosition(id: string): Promise<void> {
    await this.pool.query(`DELETE FROM positions WHERE id = $1`, [id]);
  }

  // Update position amount after partial close
  async updatePositionAmount(id: string, newAmount: number): Promise<void> {
    await this.pool.query(`
      UPDATE positions SET amount = $2, last_update = NOW() WHERE id = $1
    `, [id, newAmount]);
  }
}

export const repository = new Repository();
</file>

<file path="src/db/types.ts">
export interface DBConfig {
  postgresUrl: string;
  sqlitePath: string;
}

export interface TokenRecord {
  mint: string;
  name: string;
  symbol: string;
  decimals: number;
  created_at: Date;
  creator: string;
  mint_revoked: boolean;
  freeze_revoked: boolean;
  last_updated: Date;
}

export interface PriceRecord {
  id: number;
  mint: string;
  price_sol: number;
  price_usd: number;
  volume_24h: number;
  market_cap_sol: number;
  liquidity: number;
  timestamp: Date;
}

export interface TradeRecordDB {
  id: string;
  mint: string;
  symbol: string;
  action: number;
  entry_price: number;
  exit_price: number | null;
  amount: number;
  amount_sol: number;
  entry_time: Date;
  exit_time: Date | null;
  pnl_sol: number | null;
  pnl_percent: number | null;
  duration_ms: number | null;
  features_json: string;
  regime: number;
  pump_phase: string;
  exit_reason: string | null;
  slippage: number | null;
  fees: number | null;
}

export interface PositionRecord {
  id: string;
  mint: string;
  symbol: string;
  entry_price: number;
  current_price: number;
  amount: number;
  amount_sol: number;
  entry_time: Date;
  last_update: Date;
  highest_price: number;
  lowest_price: number;
  stop_loss: number;
  take_profit_json: string;
  tp_sold_json: string;
  trailing_stop: number | null;
  status: string;
  pool_type: string;
}

export interface ModelRecord {
  id: number;
  version: number;
  weights_json: string;
  metrics_json: string;
  created_at: Date;
}

export interface ConfigRecord {
  key: string;
  value: string;
  updated_at: Date;
}

export interface EquitySnapshotRecord {
  id: number;
  timestamp: Date;
  wallet_balance_sol: number;
  positions_value_sol: number;
  total_equity_sol: number;
  unrealized_pnl_sol: number;
  position_count: number;
  source: 'periodic' | 'trade_close' | 'startup';
}

export interface PartialCloseRecord {
  id: number;
  position_id: string;
  mint: string;
  close_type: 'initial_recovery' | 'scaled_exit' | 'tp_level';
  sell_amount_tokens: number;
  sell_amount_sol: number;
  price_at_close: number;
  pnl_sol: number;
  fees_sol: number;
  timestamp: Date;
}

export interface WalletSyncLogRecord {
  id: number;
  timestamp: Date;
  sol_balance: number;
  token_positions_json: string;
  discrepancies_json: string;
}
</file>

<file path="src/execution/index.ts">
export * from './types';
export * from './jupiter-swap';
export * from './jito-bundle';
export * from './tx-manager';
</file>

<file path="src/execution/jito-bundle.ts">
import {
  Connection,
  Keypair,
  PublicKey,
  VersionedTransaction,
  TransactionMessage,
  SystemProgram,
} from '@solana/web3.js';
import bs58 from 'bs58';
import { createChildLogger } from '../utils/logger';
import { config, LAMPORTS_PER_SOL } from '../config/settings';
import { JitoBundleResult } from './types';

const logger = createChildLogger('jito-bundle');

interface JitoTipAccount {
  address: string;
}

export class JitoBundle {
  private connection: Connection;
  private wallet: Keypair | null = null;
  private tipAccounts: string[] = [];

  constructor() {
    this.connection = new Connection(config.solanaRpcUrl, 'confirmed');
  }

  async initialize(): Promise<void> {
    if (config.privateKey) {
      try {
        const secretKey = bs58.decode(config.privateKey);
        this.wallet = Keypair.fromSecretKey(secretKey);
      } catch (error) {
        logger.error({ error }, 'Failed to initialize wallet');
      }
    }

    // Fetch tip accounts
    await this.fetchTipAccounts();
  }

  private async fetchTipAccounts(): Promise<void> {
    try {
      const response = await fetch(`${config.jitoBundleApi}/tip_accounts`);

      if (!response.ok) {
        throw new Error(`Failed to fetch tip accounts: ${response.status}`);
      }

      const data = await response.json() as string[];
      this.tipAccounts = data;

      logger.info({ count: this.tipAccounts.length }, 'Tip accounts loaded');
    } catch (error) {
      logger.error({ error }, 'Failed to fetch tip accounts');
      // Fallback tip accounts
      this.tipAccounts = [
        '96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5',
        'HFqU5x63VTqvQss8hp11i4bVmkdzGR3EXvgWyqD7njDr',
        'Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY',
        'ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49',
        'DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh',
      ];
    }
  }

  getRandomTipAccount(): string {
    const index = Math.floor(Math.random() * this.tipAccounts.length);
    return this.tipAccounts[index];
  }

  async createTipTransaction(tipLamports: number): Promise<VersionedTransaction | null> {
    if (!this.wallet) {
      logger.error('Wallet not initialized');
      return null;
    }

    try {
      const tipAccount = this.getRandomTipAccount();
      const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash();

      const tipInstruction = SystemProgram.transfer({
        fromPubkey: this.wallet.publicKey,
        toPubkey: new PublicKey(tipAccount),
        lamports: tipLamports,
      });

      const messageV0 = new TransactionMessage({
        payerKey: this.wallet.publicKey,
        recentBlockhash: blockhash,
        instructions: [tipInstruction],
      }).compileToV0Message();

      const transaction = new VersionedTransaction(messageV0);
      transaction.sign([this.wallet]);

      return transaction;
    } catch (error) {
      logger.error({ error }, 'Failed to create tip transaction');
      return null;
    }
  }

  async sendBundle(transactions: VersionedTransaction[]): Promise<JitoBundleResult> {
    if (!config.enableJito) {
      return {
        success: false,
        signatures: [],
        tipAmount: 0,
        error: 'Jito disabled',
      };
    }

    try {
      // Create tip transaction
      const tipTx = await this.createTipTransaction(config.jitoTipLamports);

      if (!tipTx) {
        return {
          success: false,
          signatures: [],
          tipAmount: config.jitoTipLamports,
          error: 'Failed to create tip transaction',
        };
      }

      // Add tip transaction to bundle
      const bundleTxs = [...transactions, tipTx];

      // Serialize transactions
      const encodedTransactions = bundleTxs.map((tx) =>
        bs58.encode(tx.serialize())
      );

      // Send bundle
      const response = await fetch(config.jitoBundleApi, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 1,
          method: 'sendBundle',
          params: [encodedTransactions],
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        logger.error({ status: response.status, error: errorText }, 'Bundle submission failed');
        return {
          success: false,
          signatures: [],
          tipAmount: config.jitoTipLamports,
          error: `Bundle submission failed: ${response.status}`,
        };
      }

      const data = await response.json() as any;

      if (data.error) {
        return {
          success: false,
          signatures: [],
          tipAmount: config.jitoTipLamports,
          error: data.error.message,
        };
      }

      const bundleId = data.result;

      logger.info({ bundleId }, 'Bundle submitted');

      // Poll for bundle status
      const result = await this.pollBundleStatus(bundleId);

      return {
        ...result,
        tipAmount: config.jitoTipLamports,
      };
    } catch (error: any) {
      logger.error({ error: error.message }, 'Bundle execution failed');
      return {
        success: false,
        signatures: [],
        tipAmount: config.jitoTipLamports,
        error: error.message,
      };
    }
  }

  private async pollBundleStatus(bundleId: string): Promise<JitoBundleResult> {
    const maxAttempts = 30;
    const pollInterval = 500;

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const response = await fetch(config.jitoBundleApi, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getBundleStatuses',
            params: [[bundleId]],
          }),
        });

        const data = await response.json() as any;

        if (data.result?.value?.[0]) {
          const status = data.result.value[0];

          if (status.confirmation_status === 'finalized' || status.confirmation_status === 'confirmed') {
            logger.info({ bundleId, status: status.confirmation_status, slot: status.slot }, 'Bundle landed');

            return {
              success: true,
              bundleId,
              signatures: status.transactions || [],
              tipAmount: config.jitoTipLamports,
              landedSlot: status.slot,
            };
          }

          if (status.err) {
            return {
              success: false,
              bundleId,
              signatures: [],
              tipAmount: config.jitoTipLamports,
              error: `Bundle failed: ${JSON.stringify(status.err)}`,
            };
          }
        }

        await new Promise((resolve) => setTimeout(resolve, pollInterval));
      } catch (error) {
        logger.debug({ bundleId, attempt, error }, 'Poll attempt failed');
      }
    }

    return {
      success: false,
      bundleId,
      signatures: [],
      tipAmount: config.jitoTipLamports,
      error: 'Bundle status poll timeout',
    };
  }

  async getBundleStatus(bundleId: string): Promise<any> {
    try {
      const response = await fetch(config.jitoBundleApi, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 1,
          method: 'getBundleStatuses',
          params: [[bundleId]],
        }),
      });

      const data = await response.json() as any;
      return data.result?.value?.[0] || null;
    } catch (error) {
      logger.error({ bundleId, error }, 'Failed to get bundle status');
      return null;
    }
  }

  isEnabled(): boolean {
    return config.enableJito && this.tipAccounts.length > 0;
  }

  getRecommendedTip(): number {
    // Could be dynamic based on network conditions
    return config.jitoTipLamports;
  }
}

export const jitoBundle = new JitoBundle();
</file>

<file path="src/execution/jupiter-swap.ts">
import {
  Connection,
  PublicKey,
  VersionedTransaction,
  Keypair,
} from '@solana/web3.js';
import bs58 from 'bs58';
import { createChildLogger } from '../utils/logger';
import { config, SOL_MINT, LAMPORTS_PER_SOL } from '../config/settings';
import { SwapQuote, SwapResult, SwapFees } from './types';

const logger = createChildLogger('jupiter-swap');

interface JupiterQuoteResponse {
  inputMint: string;
  inAmount: string;
  outputMint: string;
  outAmount: string;
  priceImpactPct: string;
  routePlan: Array<{
    swapInfo: {
      ammKey: string;
      label: string;
      inputMint: string;
      outputMint: string;
      inAmount: string;
      outAmount: string;
      feeAmount: string;
      feeMint: string;
    };
    percent: number;
  }>;
  contextSlot: number;
  timeTaken: number;
}

interface JupiterSwapResponse {
  swapTransaction: string;
  lastValidBlockHeight: number;
  prioritizationFeeLamports: number;
}

export class JupiterSwap {
  private connection: Connection;
  private wallet: Keypair | null = null;

  constructor() {
    this.connection = new Connection(config.solanaRpcUrl, 'confirmed');
  }

  initialize(): void {
    if (config.privateKey) {
      try {
        const secretKey = bs58.decode(config.privateKey);
        this.wallet = Keypair.fromSecretKey(secretKey);
        logger.info({ publicKey: this.wallet.publicKey.toBase58() }, 'Wallet initialized');
      } catch (error) {
        logger.error({ error }, 'Failed to initialize wallet');
      }
    }
  }

  async getQuote(
    inputMint: string,
    outputMint: string,
    amountLamports: number,
    slippageBps: number = 50
  ): Promise<SwapQuote | null> {
    try {
      const url = new URL(config.jupiterQuoteApi);
      url.searchParams.set('inputMint', inputMint);
      url.searchParams.set('outputMint', outputMint);
      url.searchParams.set('amount', amountLamports.toString());
      url.searchParams.set('slippageBps', slippageBps.toString());

      const response = await fetch(url.toString());

      if (!response.ok) {
        logger.error({ status: response.status }, 'Jupiter quote failed');
        return null;
      }

      const data = await response.json() as JupiterQuoteResponse;

      const quote: SwapQuote = {
        inputMint: data.inputMint,
        outputMint: data.outputMint,
        inputAmount: parseInt(data.inAmount),
        outputAmount: parseInt(data.outAmount),
        priceImpact: parseFloat(data.priceImpactPct),
        slippageBps,
        route: data.routePlan.map((r) => ({
          dex: r.swapInfo.label,
          poolAddress: r.swapInfo.ammKey,
          inputMint: r.swapInfo.inputMint,
          outputMint: r.swapInfo.outputMint,
          inputAmount: parseInt(r.swapInfo.inAmount),
          outputAmount: parseInt(r.swapInfo.outAmount),
        })),
        fees: {
          platformFee: 0,
          networkFee: 5000, // Estimate
          priorityFee: 0,
          totalFee: 5000,
        },
      };

      logger.debug({
        inputMint,
        outputMint,
        inputAmount: amountLamports / LAMPORTS_PER_SOL,
        outputAmount: quote.outputAmount,
        priceImpact: quote.priceImpact,
      }, 'Quote received');

      return quote;
    } catch (error) {
      logger.error({ error, inputMint, outputMint }, 'Failed to get quote');
      return null;
    }
  }

  async executeSwap(
    inputMint: string,
    outputMint: string,
    amountLamports: number,
    slippageBps: number = 50
  ): Promise<SwapResult> {
    if (!this.wallet) {
      return {
        success: false,
        inputAmount: amountLamports,
        outputAmount: 0,
        priceImpact: 0,
        fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
        error: 'Wallet not initialized',
        timestamp: new Date(),
      };
    }

    // Check for paper trading mode
    if (config.paperTrading) {
      return this.simulateSwap(inputMint, outputMint, amountLamports, slippageBps);
    }

    try {
      // Get quote first
      const quote = await this.getQuote(inputMint, outputMint, amountLamports, slippageBps);

      if (!quote) {
        return {
          success: false,
          inputAmount: amountLamports,
          outputAmount: 0,
          priceImpact: 0,
          fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
          error: 'Failed to get quote',
          timestamp: new Date(),
        };
      }

      // Get swap transaction
      const swapResponse = await fetch(config.jupiterSwapApi, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          quoteResponse: quote,
          userPublicKey: this.wallet.publicKey.toBase58(),
          wrapAndUnwrapSol: true,
          dynamicComputeUnitLimit: true,
          prioritizationFeeLamports: 'auto',
        }),
      });

      if (!swapResponse.ok) {
        const errorText = await swapResponse.text();
        logger.error({ status: swapResponse.status, error: errorText }, 'Swap request failed');
        return {
          success: false,
          inputAmount: amountLamports,
          outputAmount: 0,
          priceImpact: quote.priceImpact,
          fees: quote.fees,
          error: `Swap request failed: ${swapResponse.status}`,
          timestamp: new Date(),
        };
      }

      const swapData = await swapResponse.json() as JupiterSwapResponse;

      // Deserialize and sign transaction
      const swapTransactionBuf = Buffer.from(swapData.swapTransaction, 'base64');
      const transaction = VersionedTransaction.deserialize(swapTransactionBuf);

      transaction.sign([this.wallet]);

      // Send transaction
      const signature = await this.connection.sendRawTransaction(
        transaction.serialize(),
        {
          skipPreflight: true,
          maxRetries: 3,
        }
      );

      logger.info({ signature }, 'Swap transaction sent');

      // Confirm transaction
      const confirmation = await this.connection.confirmTransaction(
        {
          signature,
          blockhash: transaction.message.recentBlockhash,
          lastValidBlockHeight: swapData.lastValidBlockHeight,
        },
        'confirmed'
      );

      if (confirmation.value.err) {
        return {
          success: false,
          signature,
          inputAmount: amountLamports,
          outputAmount: 0,
          priceImpact: quote.priceImpact,
          fees: quote.fees,
          error: `Transaction failed: ${JSON.stringify(confirmation.value.err)}`,
          timestamp: new Date(),
        };
      }

      logger.info(
        { signature, inputAmount: amountLamports / LAMPORTS_PER_SOL, outputAmount: quote.outputAmount },
        'Swap successful'
      );

      return {
        success: true,
        signature,
        inputAmount: amountLamports,
        outputAmount: quote.outputAmount,
        priceImpact: quote.priceImpact,
        fees: {
          ...quote.fees,
          priorityFee: swapData.prioritizationFeeLamports,
          totalFee: quote.fees.networkFee + swapData.prioritizationFeeLamports,
        },
        timestamp: new Date(),
      };
    } catch (error: any) {
      logger.error({ error: error.message }, 'Swap execution failed');
      return {
        success: false,
        inputAmount: amountLamports,
        outputAmount: 0,
        priceImpact: 0,
        fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
        error: error.message,
        timestamp: new Date(),
      };
    }
  }

  private async simulateSwap(
    inputMint: string,
    outputMint: string,
    amountLamports: number,
    slippageBps: number
  ): Promise<SwapResult> {
    // Get quote for realistic simulation
    const quote = await this.getQuote(inputMint, outputMint, amountLamports, slippageBps);

    if (!quote) {
      return {
        success: false,
        inputAmount: amountLamports,
        outputAmount: 0,
        priceImpact: 0,
        fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
        error: 'Failed to get quote for simulation',
        timestamp: new Date(),
      };
    }

    // Simulate slippage
    const slippageMultiplier = 1 - (Math.random() * slippageBps / 10000);
    const simulatedOutput = Math.floor(quote.outputAmount * slippageMultiplier);

    logger.info(
      {
        mode: 'PAPER',
        inputMint,
        outputMint,
        inputAmount: amountLamports / LAMPORTS_PER_SOL,
        outputAmount: simulatedOutput,
      },
      'Paper trade executed'
    );

    return {
      success: true,
      signature: `PAPER_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      inputAmount: amountLamports,
      outputAmount: simulatedOutput,
      priceImpact: quote.priceImpact,
      fees: quote.fees,
      timestamp: new Date(),
    };
  }

  async buy(
    tokenMint: string,
    amountSol: number,
    slippageBps: number = 100
  ): Promise<SwapResult> {
    const amountLamports = Math.floor(amountSol * LAMPORTS_PER_SOL);
    return this.executeSwap(SOL_MINT, tokenMint, amountLamports, slippageBps);
  }

  async sell(
    tokenMint: string,
    amountTokens: number,
    decimals: number,
    slippageBps: number = 100
  ): Promise<SwapResult> {
    const amountRaw = Math.floor(amountTokens * Math.pow(10, decimals));
    return this.executeSwap(tokenMint, SOL_MINT, amountRaw, slippageBps);
  }

  getWalletAddress(): string | null {
    return this.wallet?.publicKey.toBase58() || null;
  }

  async getBalance(): Promise<number> {
    if (!this.wallet) return 0;

    try {
      const balance = await this.connection.getBalance(this.wallet.publicKey);
      return balance / LAMPORTS_PER_SOL;
    } catch (error) {
      logger.error({ error }, 'Failed to get balance');
      return 0;
    }
  }

  async getTokenBalance(mint: string): Promise<number> {
    if (!this.wallet) return 0;

    try {
      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
        this.wallet.publicKey,
        { mint: new PublicKey(mint) }
      );

      if (tokenAccounts.value.length === 0) return 0;

      const balance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;
      return balance || 0;
    } catch (error) {
      logger.error({ mint, error }, 'Failed to get token balance');
      return 0;
    }
  }
}

export const jupiterSwap = new JupiterSwap();
</file>

<file path="src/execution/pumpfun-swap.ts">
import { Connection, Keypair, VersionedTransaction } from '@solana/web3.js';
import bs58 from 'bs58';
import { createChildLogger } from '../utils/logger';
import { config, LAMPORTS_PER_SOL } from '../config/settings';
import { SwapResult } from './types';

const logger = createChildLogger('pumpfun-swap');

const PUMPPORTAL_API_URL = 'https://pumpportal.fun/api';

interface PumpPortalTradeRequest {
  publicKey: string;
  action: 'buy' | 'sell';
  mint: string;
  amount: number;
  denominatedInSol: 'true' | 'false';
  slippage: number;
  priorityFee: number;
  pool: 'pump' | 'raydium' | 'auto';
}

interface PumpPortalTradeResponse {
  transaction?: string;
  error?: string;
}

export class PumpFunSwap {
  private connection: Connection;
  private wallet: Keypair | null = null;

  constructor() {
    this.connection = new Connection(config.solanaRpcUrl, 'confirmed');
  }

  initialize(): void {
    if (config.privateKey) {
      try {
        const secretKey = bs58.decode(config.privateKey);
        this.wallet = Keypair.fromSecretKey(secretKey);
        logger.info({ publicKey: this.wallet.publicKey.toBase58() }, 'PumpFun wallet initialized');
      } catch (error) {
        logger.error({ error }, 'Failed to initialize PumpFun wallet');
      }
    }
  }

  async buy(
    tokenMint: string,
    amountSol: number,
    slippagePct: number = config.defaultSlippageBps / 100,  // Convert bps to %
    priorityFee: number = config.priorityFeeSol
  ): Promise<SwapResult> {
    if (!this.wallet) {
      return this.errorResult(amountSol * LAMPORTS_PER_SOL, 'Wallet not initialized');
    }

    // Paper trading simulation
    if (config.paperTrading) {
      return this.simulateBuy(tokenMint, amountSol, slippagePct);
    }

    try {
      logger.info({ mint: tokenMint, amountSol, slippage: slippagePct }, 'Executing PumpFun buy');

      const response = await fetch(`${PUMPPORTAL_API_URL}/trade-local`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          publicKey: this.wallet.publicKey.toBase58(),
          action: 'buy',
          mint: tokenMint,
          amount: amountSol,
          denominatedInSol: 'true',
          slippage: slippagePct,
          priorityFee: priorityFee,
          pool: 'pump', // Use bonding curve
        } as PumpPortalTradeRequest),
      });

      if (!response.ok) {
        const errorText = await response.text();
        logger.error({ status: response.status, error: errorText }, 'PumpPortal trade request failed');
        return this.errorResult(amountSol * LAMPORTS_PER_SOL, `Trade request failed: ${response.status}`);
      }

      // PumpPortal returns raw transaction bytes directly, not JSON
      const arrayBuffer = await response.arrayBuffer();
      const txData = new Uint8Array(arrayBuffer);

      // Check if response is actually JSON error
      if (txData.length < 100) {
        const text = new TextDecoder().decode(txData);
        try {
          const jsonError = JSON.parse(text);
          if (jsonError.error) {
            return this.errorResult(amountSol * LAMPORTS_PER_SOL, jsonError.error);
          }
        } catch {
          // Not JSON, continue with deserialization
        }
      }

      logger.debug({ bytes: txData.length }, 'Received raw transaction bytes');

      // Deserialize and sign
      const transaction = VersionedTransaction.deserialize(txData);
      transaction.sign([this.wallet]);

      // Send transaction
      const signature = await this.connection.sendRawTransaction(
        transaction.serialize(),
        { skipPreflight: true, maxRetries: 3 }
      );

      logger.info({ signature }, 'PumpFun buy transaction sent');

      // Confirm
      const latestBlockhash = await this.connection.getLatestBlockhash();
      const confirmation = await this.connection.confirmTransaction(
        { signature, ...latestBlockhash },
        'confirmed'
      );

      if (confirmation.value.err) {
        return this.errorResult(
          amountSol * LAMPORTS_PER_SOL,
          `Transaction failed: ${JSON.stringify(confirmation.value.err)}`,
          signature
        );
      }

      logger.info({ signature, amountSol }, 'PumpFun buy successful');

      return {
        success: true,
        signature,
        inputAmount: amountSol * LAMPORTS_PER_SOL,
        outputAmount: 0, // Will be updated by position manager
        priceImpact: 0,
        fees: {
          platformFee: amountSol * LAMPORTS_PER_SOL * 0.01, // 1% pump.fun fee
          networkFee: 5000,
          priorityFee: priorityFee * LAMPORTS_PER_SOL,
          totalFee: amountSol * LAMPORTS_PER_SOL * 0.01 + 5000 + priorityFee * LAMPORTS_PER_SOL,
        },
        timestamp: new Date(),
      };
    } catch (error: any) {
      logger.error({ error: error.message }, 'PumpFun buy failed');
      return this.errorResult(amountSol * LAMPORTS_PER_SOL, error.message);
    }
  }

  async sell(
    tokenMint: string,
    amountTokens: number,
    slippagePct: number = config.defaultSlippageBps / 100,  // Convert bps to %
    priorityFee: number = config.priorityFeeSol
  ): Promise<SwapResult> {
    if (!this.wallet) {
      return this.errorResult(0, 'Wallet not initialized');
    }

    // Paper trading simulation
    if (config.paperTrading) {
      return this.simulateSell(tokenMint, amountTokens, slippagePct);
    }

    try {
      logger.info({ mint: tokenMint, amountTokens, slippage: slippagePct }, 'Executing PumpFun sell');

      const response = await fetch(`${PUMPPORTAL_API_URL}/trade-local`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          publicKey: this.wallet.publicKey.toBase58(),
          action: 'sell',
          mint: tokenMint,
          amount: amountTokens,
          denominatedInSol: 'false',
          slippage: slippagePct,
          priorityFee: priorityFee,
          pool: 'auto', // Auto-detect if on bonding curve or Raydium
        } as PumpPortalTradeRequest),
      });

      if (!response.ok) {
        const errorText = await response.text();
        logger.error({ status: response.status, error: errorText }, 'PumpPortal sell request failed');
        return this.errorResult(0, `Sell request failed: ${response.status}`);
      }

      // PumpPortal returns raw transaction bytes directly, not JSON
      const arrayBuffer = await response.arrayBuffer();
      const txData = new Uint8Array(arrayBuffer);

      // Check if response is actually JSON error
      if (txData.length < 100) {
        const text = new TextDecoder().decode(txData);
        try {
          const jsonError = JSON.parse(text);
          if (jsonError.error) {
            return this.errorResult(0, jsonError.error);
          }
        } catch {
          // Not JSON, continue with deserialization
        }
      }

      logger.debug({ bytes: txData.length }, 'Received raw transaction bytes');

      // Deserialize and sign
      const transaction = VersionedTransaction.deserialize(txData);
      transaction.sign([this.wallet]);

      // Send transaction
      const signature = await this.connection.sendRawTransaction(
        transaction.serialize(),
        { skipPreflight: true, maxRetries: 3 }
      );

      logger.info({ signature }, 'PumpFun sell transaction sent');

      // Confirm
      const latestBlockhash = await this.connection.getLatestBlockhash();
      const confirmation = await this.connection.confirmTransaction(
        { signature, ...latestBlockhash },
        'confirmed'
      );

      if (confirmation.value.err) {
        return this.errorResult(
          0,
          `Transaction failed: ${JSON.stringify(confirmation.value.err)}`,
          signature
        );
      }

      logger.info({ signature, amountTokens }, 'PumpFun sell successful');

      return {
        success: true,
        signature,
        inputAmount: amountTokens,
        outputAmount: 0, // SOL received, will be calculated
        priceImpact: 0,
        fees: {
          platformFee: 0, // Calculated based on output
          networkFee: 5000,
          priorityFee: priorityFee * LAMPORTS_PER_SOL,
          totalFee: 5000 + priorityFee * LAMPORTS_PER_SOL,
        },
        timestamp: new Date(),
      };
    } catch (error: any) {
      logger.error({ error: error.message }, 'PumpFun sell failed');
      return this.errorResult(0, error.message);
    }
  }

  private async simulateBuy(
    tokenMint: string,
    amountSol: number,
    slippagePct: number
  ): Promise<SwapResult> {
    // Simulate buying on bonding curve
    // In reality, tokens received depends on bonding curve state
    const estimatedTokens = amountSol * 1_000_000; // Rough estimate for new tokens

    logger.info({
      mode: 'PAPER',
      action: 'buy',
      mint: tokenMint,
      amountSol,
      estimatedTokens,
    }, 'Paper PumpFun buy');

    return {
      success: true,
      signature: `PAPER_PUMP_BUY_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      inputAmount: amountSol * LAMPORTS_PER_SOL,
      outputAmount: estimatedTokens,
      priceImpact: 0.5, // Estimate
      fees: {
        platformFee: amountSol * LAMPORTS_PER_SOL * 0.01,
        networkFee: 5000,
        priorityFee: 0,
        totalFee: amountSol * LAMPORTS_PER_SOL * 0.01 + 5000,
      },
      timestamp: new Date(),
    };
  }

  private async simulateSell(
    tokenMint: string,
    amountTokens: number,
    slippagePct: number
  ): Promise<SwapResult> {
    // Simulate selling on bonding curve
    const estimatedSol = amountTokens / 1_000_000; // Rough estimate

    logger.info({
      mode: 'PAPER',
      action: 'sell',
      mint: tokenMint,
      amountTokens,
      estimatedSol,
    }, 'Paper PumpFun sell');

    return {
      success: true,
      signature: `PAPER_PUMP_SELL_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      inputAmount: amountTokens,
      outputAmount: estimatedSol * LAMPORTS_PER_SOL,
      priceImpact: 0.5,
      fees: {
        platformFee: estimatedSol * LAMPORTS_PER_SOL * 0.01,
        networkFee: 5000,
        priorityFee: 0,
        totalFee: estimatedSol * LAMPORTS_PER_SOL * 0.01 + 5000,
      },
      timestamp: new Date(),
    };
  }

  private errorResult(inputAmount: number, error: string, signature?: string): SwapResult {
    return {
      success: false,
      signature,
      inputAmount,
      outputAmount: 0,
      priceImpact: 0,
      fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
      error,
      timestamp: new Date(),
    };
  }

  getWalletAddress(): string | null {
    return this.wallet?.publicKey.toBase58() || null;
  }
}

export const pumpFunSwap = new PumpFunSwap();
</file>

<file path="src/execution/tx-manager.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { jupiterSwap } from './jupiter-swap';
import { pumpFunSwap } from './pumpfun-swap';
import { jitoBundle } from './jito-bundle';
import { SwapResult, PendingTransaction, ExecutionMetrics } from './types';

const logger = createChildLogger('tx-manager');

// Track which tokens are on bonding curve vs graduated
const bondingCurveTokens: Set<string> = new Set();

export class TransactionManager extends EventEmitter {
  private pendingTxs: Map<string, PendingTransaction> = new Map();
  private metrics: ExecutionMetrics = {
    totalTransactions: 0,
    successRate: 0,
    avgSlippage: 0,
    avgConfirmationTime: 0,
    totalFeesPaid: 0,
    jitoSuccessRate: 0,
  };
  private successCount = 0;
  private jitoSuccessCount = 0;
  private jitoAttemptCount = 0;
  private slippageSum = 0;
  private confirmationTimeSum = 0;

  constructor() {
    super();
  }

  async initialize(): Promise<void> {
    jupiterSwap.initialize();
    pumpFunSwap.initialize();
    await jitoBundle.initialize();
    logger.info('Transaction manager initialized');
  }

  // Mark a token as being on bonding curve (not graduated yet)
  markAsBondingCurve(mint: string): void {
    bondingCurveTokens.add(mint);
  }

  // Mark a token as graduated (now on Raydium)
  markAsGraduated(mint: string): void {
    bondingCurveTokens.delete(mint);
  }

  // Check if token is on bonding curve
  isOnBondingCurve(mint: string): boolean {
    // If we've explicitly tracked it, use that
    if (bondingCurveTokens.has(mint)) return true;

    // Default: assume pump.fun tokens ending in "pump" are on bonding curve
    // unless we know they've graduated
    return mint.endsWith('pump');
  }

  async executeBuy(
    mint: string,
    amountSol: number,
    options: {
      slippageBps?: number;
      useJito?: boolean;
      maxRetries?: number;
    } = {}
  ): Promise<SwapResult> {
    const {
      slippageBps = 100,
      useJito = config.enableJito && amountSol > 0.1,
      maxRetries = 3,
    } = options;

    const txId = `buy_${mint}_${Date.now()}`;

    const pendingTx: PendingTransaction = {
      id: txId,
      type: 'buy',
      mint,
      inputAmount: amountSol,
      expectedOutput: 0, // Will be set after quote
      status: 'pending',
      retries: 0,
      createdAt: new Date(),
    };

    this.pendingTxs.set(txId, pendingTx);
    this.emit('txPending', pendingTx);

    let result: SwapResult;
    let lastError: string | undefined;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const startTime = Date.now();

        // Route to appropriate exchange
        const useBondingCurve = this.isOnBondingCurve(mint);
        if (useBondingCurve) {
          logger.info({ mint, amountSol }, 'Routing buy to PumpFun (bonding curve)');
          result = await pumpFunSwap.buy(mint, amountSol, slippageBps / 100); // Convert bps to %
        } else {
          logger.info({ mint, amountSol }, 'Routing buy to Jupiter (graduated)');
          result = await jupiterSwap.buy(mint, amountSol, slippageBps);
        }

        if (result.success) {
          pendingTx.status = 'confirmed';
          pendingTx.signature = result.signature;
          pendingTx.confirmedAt = new Date();

          this.updateMetrics(result, Date.now() - startTime, false);
          this.emit('txConfirmed', { ...pendingTx, result });

          logger.info({
            txId,
            mint,
            amountSol,
            outputAmount: result.outputAmount,
            signature: result.signature,
          }, 'Buy executed');

          return result;
        }

        lastError = result.error;
        pendingTx.retries++;

        logger.warn({
          txId,
          attempt: attempt + 1,
          error: lastError,
        }, 'Buy attempt failed, retrying');

        // Wait before retry
        await this.sleep(1000 * Math.pow(2, attempt));
      } catch (error: any) {
        lastError = error.message;
        pendingTx.retries++;
      }
    }

    pendingTx.status = 'failed';
    pendingTx.error = lastError;
    this.emit('txFailed', pendingTx);

    return {
      success: false,
      inputAmount: amountSol,
      outputAmount: 0,
      priceImpact: 0,
      fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
      error: lastError,
      timestamp: new Date(),
    };
  }

  async executeSell(
    mint: string,
    amountTokens: number,
    decimals: number,
    options: {
      slippageBps?: number;
      useJito?: boolean;
      maxRetries?: number;
    } = {}
  ): Promise<SwapResult> {
    const {
      slippageBps = config.defaultSlippageBps,  // Use config default (15%) for volatile tokens
      useJito = config.enableJito,
      maxRetries = 3,
    } = options;

    // Verify actual token balance before selling
    const actualBalance = await this.getTokenBalance(mint);

    if (actualBalance < amountTokens * 0.99) {  // 1% tolerance
      logger.warn({ mint, requested: amountTokens, actual: actualBalance },
        'Insufficient token balance - adjusting sell amount');

      if (actualBalance > 0) {
        // Sell what we actually have
        amountTokens = actualBalance;
      } else {
        logger.error({ mint }, 'No tokens to sell');
        return {
          success: false,
          inputAmount: amountTokens,
          outputAmount: 0,
          priceImpact: 0,
          fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
          error: 'No tokens to sell - zero balance',
          timestamp: new Date(),
        };
      }
    }

    const txId = `sell_${mint}_${Date.now()}`;

    const pendingTx: PendingTransaction = {
      id: txId,
      type: 'sell',
      mint,
      inputAmount: amountTokens,
      expectedOutput: 0,
      status: 'pending',
      retries: 0,
      createdAt: new Date(),
    };

    this.pendingTxs.set(txId, pendingTx);
    this.emit('txPending', pendingTx);

    let result: SwapResult;
    let lastError: string | undefined;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const startTime = Date.now();

        // Route to appropriate exchange
        // For sells, use 'auto' pool in PumpPortal which handles both
        const useBondingCurve = this.isOnBondingCurve(mint);
        if (useBondingCurve) {
          logger.info({ mint, amountTokens }, 'Routing sell to PumpFun (auto-detect pool)');
          result = await pumpFunSwap.sell(mint, amountTokens, slippageBps / 100);
        } else {
          logger.info({ mint, amountTokens }, 'Routing sell to Jupiter (graduated)');
          result = await jupiterSwap.sell(mint, amountTokens, decimals, slippageBps);
        }

        if (result.success) {
          pendingTx.status = 'confirmed';
          pendingTx.signature = result.signature;
          pendingTx.confirmedAt = new Date();

          this.updateMetrics(result, Date.now() - startTime, false);
          this.emit('txConfirmed', { ...pendingTx, result });

          logger.info({
            txId,
            mint,
            amountTokens,
            outputSol: result.outputAmount,
            signature: result.signature,
          }, 'Sell executed');

          return result;
        }

        lastError = result.error;
        pendingTx.retries++;

        logger.warn({
          txId,
          attempt: attempt + 1,
          error: lastError,
        }, 'Sell attempt failed, retrying');

        await this.sleep(1000 * Math.pow(2, attempt));
      } catch (error: any) {
        lastError = error.message;
        pendingTx.retries++;
      }
    }

    pendingTx.status = 'failed';
    pendingTx.error = lastError;
    this.emit('txFailed', pendingTx);

    return {
      success: false,
      inputAmount: amountTokens,
      outputAmount: 0,
      priceImpact: 0,
      fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
      error: lastError,
      timestamp: new Date(),
    };
  }

  private updateMetrics(result: SwapResult, confirmationTime: number, usedJito: boolean): void {
    this.metrics.totalTransactions++;

    if (result.success) {
      this.successCount++;
      this.slippageSum += result.priceImpact;
      this.confirmationTimeSum += confirmationTime;
      this.metrics.totalFeesPaid += result.fees.totalFee;
    }

    if (usedJito) {
      this.jitoAttemptCount++;
      if (result.success) {
        this.jitoSuccessCount++;
      }
    }

    // Update rates
    this.metrics.successRate = this.successCount / this.metrics.totalTransactions;
    this.metrics.avgSlippage = this.successCount > 0 ? this.slippageSum / this.successCount : 0;
    this.metrics.avgConfirmationTime = this.successCount > 0
      ? this.confirmationTimeSum / this.successCount
      : 0;
    this.metrics.jitoSuccessRate = this.jitoAttemptCount > 0
      ? this.jitoSuccessCount / this.jitoAttemptCount
      : 0;
  }

  getPendingTransactions(): PendingTransaction[] {
    return Array.from(this.pendingTxs.values()).filter((tx) => tx.status === 'pending');
  }

  getMetrics(): ExecutionMetrics {
    return { ...this.metrics };
  }

  async getWalletBalance(): Promise<number> {
    return jupiterSwap.getBalance();
  }

  async getTokenBalance(mint: string): Promise<number> {
    return jupiterSwap.getTokenBalance(mint);
  }

  getWalletAddress(): string | null {
    return jupiterSwap.getWalletAddress();
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  cleanupOldTransactions(maxAge: number = 3600000): void {
    const cutoff = Date.now() - maxAge;

    for (const [id, tx] of this.pendingTxs.entries()) {
      if (tx.createdAt.getTime() < cutoff && tx.status !== 'pending') {
        this.pendingTxs.delete(id);
      }
    }
  }
}

export const txManager = new TransactionManager();
</file>

<file path="src/execution/types.ts">
import { PublicKey } from '@solana/web3.js';

export interface SwapQuote {
  inputMint: string;
  outputMint: string;
  inputAmount: number;
  outputAmount: number;
  priceImpact: number;
  slippageBps: number;
  route: SwapRoute[];
  fees: SwapFees;
}

export interface SwapRoute {
  dex: string;
  poolAddress: string;
  inputMint: string;
  outputMint: string;
  inputAmount: number;
  outputAmount: number;
}

export interface SwapFees {
  platformFee: number;
  networkFee: number;
  priorityFee: number;
  totalFee: number;
}

export interface SwapResult {
  success: boolean;
  signature?: string;
  inputAmount: number;
  outputAmount: number;
  priceImpact: number;
  fees: SwapFees;
  error?: string;
  timestamp: Date;
}

export interface JitoBundleResult {
  success: boolean;
  bundleId?: string;
  signatures: string[];
  tipAmount: number;
  landedSlot?: number;
  error?: string;
}

export interface TransactionConfig {
  priorityFee: number;
  maxRetries: number;
  confirmationTimeout: number;
  useJito: boolean;
  jitoTip: number;
}

export interface PendingTransaction {
  id: string;
  signature?: string;
  type: 'buy' | 'sell';
  mint: string;
  inputAmount: number;
  expectedOutput: number;
  status: 'pending' | 'confirmed' | 'failed';
  retries: number;
  createdAt: Date;
  confirmedAt?: Date;
  error?: string;
}

export interface ExecutionMetrics {
  totalTransactions: number;
  successRate: number;
  avgSlippage: number;
  avgConfirmationTime: number;
  totalFeesPaid: number;
  jitoSuccessRate: number;
}
</file>

<file path="src/learning/index.ts">
export * from './types';
export * from './trade-logger';
export * from './performance';
export * from './model-trainer';
</file>

<file path="src/learning/model-trainer.ts">
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { ddqnAgent } from '../ai/ddqn-agent';
import { positionSizer } from '../ai/position-sizer';
import { repository } from '../db/repository';
import { tradeLogger } from './trade-logger';
import { performanceAnalytics } from './performance';
import { ModelTrainingResult, LearningState } from './types';

const logger = createChildLogger('model-trainer');

export class ModelTrainer {
  private state: LearningState;
  private trainingInterval: NodeJS.Timeout | null = null;
  private modelVersion: number = 0;

  constructor() {
    this.state = {
      tradesProcessed: 0,
      lastTrainingTime: new Date(0),
      modelVersion: 0,
      performanceHistory: [],
      featureImportance: [],
    };
  }

  async initialize(): Promise<void> {
    // Load model version from database
    const savedVersion = await repository.getConfig('model_version');
    if (savedVersion) {
      this.modelVersion = parseInt(savedVersion);
      this.state.modelVersion = this.modelVersion;
    }

    // Try to load existing model weights
    const modelData = await repository.getLatestModelWeights();
    if (modelData) {
      try {
        await ddqnAgent.loadWeightsFromJSON(modelData.weights);
        this.modelVersion = modelData.version;
        logger.info({ version: this.modelVersion }, 'Loaded model weights from database');
      } catch (error) {
        logger.warn({ error }, 'Failed to load model weights, using fresh model');
        await ddqnAgent.initialize();
      }
    } else {
      await ddqnAgent.initialize();
    }

    logger.info('Model trainer initialized');
  }

  async startPeriodicTraining(): Promise<void> {
    // Train every week
    this.trainingInterval = setInterval(() => {
      this.runTrainingCycle();
    }, config.modelRetrainIntervalMs);

    logger.info({ intervalMs: config.modelRetrainIntervalMs }, 'Periodic training started');
  }

  stopPeriodicTraining(): void {
    if (this.trainingInterval) {
      clearInterval(this.trainingInterval);
      this.trainingInterval = null;
    }
    logger.info('Periodic training stopped');
  }

  async runTrainingCycle(): Promise<ModelTrainingResult | null> {
    logger.info('Starting training cycle');

    const startTime = Date.now();

    try {
      // Get trades for training
      const trades = await tradeLogger.getTradesForTraining(4);

      if (trades.length < 50) {
        logger.info({ tradeCount: trades.length }, 'Not enough trades for training');
        return null;
      }

      // Convert trades to experiences
      const experiences = trades
        .map((trade) => tradeLogger.tradeToExperience(trade))
        .filter((e) => e !== null);

      if (experiences.length < 32) {
        logger.info({ experienceCount: experiences.length }, 'Not enough experiences');
        return null;
      }

      // Add to replay buffer
      for (const exp of experiences) {
        if (exp) {
          ddqnAgent.addExperience(exp);
        }
      }

      // Calculate pre-training metrics
      const preMetrics = await performanceAnalytics.calculateMetrics(trades);

      // Run training epochs
      const epochs = 100;
      let totalLoss = 0;

      for (let epoch = 0; epoch < epochs; epoch++) {
        const loss = await ddqnAgent.train();
        totalLoss += loss;

        if (epoch % 10 === 0) {
          logger.debug({ epoch, loss: loss.toFixed(6) }, 'Training progress');
        }
      }

      const avgLoss = totalLoss / epochs;

      // Update position sizer with win rate
      const winTrades = trades.filter((t) => (t.pnlSol || 0) > 0);
      for (const trade of trades) {
        positionSizer.recordTrade((trade.pnlSol || 0) > 0);
      }

      // Calculate post-training validation (simplified)
      const validationLoss = avgLoss * 1.1; // Approximate

      // Update model version
      this.modelVersion++;
      this.state.modelVersion = this.modelVersion;
      this.state.lastTrainingTime = new Date();
      this.state.tradesProcessed += trades.length;

      // Save model weights
      const weights = ddqnAgent.getWeightsAsJSON();
      const metrics = JSON.stringify(preMetrics);

      await repository.saveModelWeights(this.modelVersion, weights, metrics);
      await repository.setConfig('model_version', this.modelVersion.toString());

      // Update feature importance
      this.state.featureImportance = await performanceAnalytics.analyzeFeatureImportance();

      // Store performance history
      this.state.performanceHistory.push(preMetrics);
      if (this.state.performanceHistory.length > 52) {
        // Keep last year of weekly metrics
        this.state.performanceHistory.shift();
      }

      const trainingTime = Date.now() - startTime;

      const result: ModelTrainingResult = {
        epochsTrained: epochs,
        finalLoss: avgLoss,
        validationLoss,
        trainingTime,
        samplesUsed: experiences.length,
        improvementPercent: 0, // Would need post-validation
        timestamp: new Date(),
      };

      logger.info({
        version: this.modelVersion,
        epochs,
        loss: avgLoss.toFixed(6),
        samples: experiences.length,
        trainingTime,
      }, 'Training cycle completed');

      return result;
    } catch (error) {
      logger.error({ error }, 'Training cycle failed');
      return null;
    }
  }

  async addTradeExperience(positionId: string): Promise<void> {
    const trade = await tradeLogger.getActiveTrade(positionId);

    if (!trade || !trade.exitPrice) {
      return;
    }

    const experience = tradeLogger.tradeToExperience(trade);

    if (experience) {
      ddqnAgent.addExperience(experience);
      this.state.tradesProcessed++;

      // Train incrementally every 10 trades
      if (this.state.tradesProcessed % 10 === 0) {
        await ddqnAgent.train();
      }
    }
  }

  getState(): LearningState {
    return { ...this.state };
  }

  getModelVersion(): number {
    return this.modelVersion;
  }

  async exportModel(path: string): Promise<void> {
    await ddqnAgent.saveModel(path);
    logger.info({ path, version: this.modelVersion }, 'Model exported');
  }

  async importModel(path: string): Promise<void> {
    await ddqnAgent.loadModel(path);
    this.modelVersion++;
    await repository.setConfig('model_version', this.modelVersion.toString());
    logger.info({ path, version: this.modelVersion }, 'Model imported');
  }

  getTrainingStatus(): string {
    const timeSinceTrain = Date.now() - this.state.lastTrainingTime.getTime();
    const hoursSinceTrain = Math.floor(timeSinceTrain / (60 * 60 * 1000));

    return [
      `Model v${this.modelVersion}`,
      `Trades: ${this.state.tradesProcessed}`,
      `Buffer: ${ddqnAgent.getReplayBufferSize()}`,
      `Last train: ${hoursSinceTrain}h ago`,
      `Epsilon: ${ddqnAgent.getEpsilon().toFixed(3)}`,
    ].join(' | ');
  }
}

export const modelTrainer = new ModelTrainer();
</file>

<file path="src/learning/performance.ts">
import * as ss from 'simple-statistics';
import { createChildLogger } from '../utils/logger';
import { TradeRecord, PerformanceMetrics, TimeframePerformance, FeatureImportance } from './types';
import { tradeLogger } from './trade-logger';

const logger = createChildLogger('performance');

export class PerformanceAnalytics {
  constructor() {}

  async calculateMetrics(trades?: TradeRecord[]): Promise<PerformanceMetrics> {
    const completedTrades = trades || (await tradeLogger.getRecentTrades(1000)).filter(
      (t) => t.exitPrice !== undefined
    );

    if (completedTrades.length === 0) {
      return this.getEmptyMetrics();
    }

    const pnls = completedTrades.map((t) => t.pnlSol || 0);
    const pnlPercents = completedTrades.map((t) => t.pnlPercent || 0);
    const holdTimes = completedTrades.map((t) => t.duration || 0);

    const wins = completedTrades.filter((t) => (t.pnlSol || 0) > 0);
    const losses = completedTrades.filter((t) => (t.pnlSol || 0) < 0);

    const grossProfit = wins.reduce((sum, t) => sum + (t.pnlSol || 0), 0);
    const grossLoss = Math.abs(losses.reduce((sum, t) => sum + (t.pnlSol || 0), 0));

    const avgWin = wins.length > 0 ? grossProfit / wins.length : 0;
    const avgLoss = losses.length > 0 ? grossLoss / losses.length : 0;

    const metrics: PerformanceMetrics = {
      totalTrades: completedTrades.length,
      winningTrades: wins.length,
      losingTrades: losses.length,
      winRate: wins.length / completedTrades.length,
      avgWin,
      avgLoss,
      largestWin: wins.length > 0 ? Math.max(...wins.map((t) => t.pnlSol || 0)) : 0,
      largestLoss: losses.length > 0 ? Math.min(...losses.map((t) => t.pnlSol || 0)) : 0,
      profitFactor: grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? Infinity : 0,
      expectancy: ss.mean(pnls),
      sharpeRatio: this.calculateSharpeRatio(pnlPercents),
      sortinoRatio: this.calculateSortinoRatio(pnlPercents),
      maxDrawdown: this.calculateMaxDrawdown(pnls),
      avgHoldTime: holdTimes.length > 0 ? ss.mean(holdTimes) : 0,
      totalPnl: ss.sum(pnls),
      totalPnlPercent: ss.sum(pnlPercents),
    };

    return metrics;
  }

  private calculateSharpeRatio(returns: number[], riskFreeRate: number = 0): number {
    if (returns.length < 2) return 0;

    const meanReturn = ss.mean(returns);
    const stdDev = ss.standardDeviation(returns);

    if (stdDev === 0) return 0;

    // Annualize assuming ~100 trades per month
    const annualizationFactor = Math.sqrt(1200);
    return ((meanReturn - riskFreeRate) / stdDev) * annualizationFactor;
  }

  private calculateSortinoRatio(returns: number[], riskFreeRate: number = 0): number {
    if (returns.length < 2) return 0;

    const meanReturn = ss.mean(returns);
    const negativeReturns = returns.filter((r) => r < 0);

    if (negativeReturns.length === 0) return Infinity;

    const downstdDev = ss.standardDeviation(negativeReturns);

    if (downstdDev === 0) return Infinity;

    const annualizationFactor = Math.sqrt(1200);
    return ((meanReturn - riskFreeRate) / downstdDev) * annualizationFactor;
  }

  private calculateMaxDrawdown(pnls: number[]): number {
    if (pnls.length === 0) return 0;

    let cumulative = 0;
    let peak = 0;
    let maxDrawdown = 0;

    for (const pnl of pnls) {
      cumulative += pnl;
      peak = Math.max(peak, cumulative);
      const drawdown = (peak - cumulative) / (peak || 1);
      maxDrawdown = Math.max(maxDrawdown, drawdown);
    }

    return maxDrawdown;
  }

  async getTimeframePerformance(): Promise<TimeframePerformance> {
    const allTrades = await tradeLogger.getRecentTrades(10000);
    const completedTrades = allTrades.filter((t) => t.exitPrice !== undefined);

    const now = new Date();

    const hourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    const dayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const hourlyTrades = completedTrades.filter(
      (t) => t.exitTime && t.exitTime >= hourAgo
    );
    const dailyTrades = completedTrades.filter(
      (t) => t.exitTime && t.exitTime >= dayAgo
    );
    const weeklyTrades = completedTrades.filter(
      (t) => t.exitTime && t.exitTime >= weekAgo
    );
    const monthlyTrades = completedTrades.filter(
      (t) => t.exitTime && t.exitTime >= monthAgo
    );

    return {
      hourly: await this.calculateMetrics(hourlyTrades),
      daily: await this.calculateMetrics(dailyTrades),
      weekly: await this.calculateMetrics(weeklyTrades),
      monthly: await this.calculateMetrics(monthlyTrades),
      allTime: await this.calculateMetrics(completedTrades),
    };
  }

  async analyzeFeatureImportance(): Promise<FeatureImportance[]> {
    const trades = await tradeLogger.getTradesForTraining(4);

    if (trades.length < 20) {
      return [];
    }

    const featureNames = [
      'priceChange1m',
      'priceChange5m',
      'volumeZScore',
      'buySellRatio',
      'holderCount',
      'top10Concentration',
      'mintRevoked',
      'freezeRevoked',
      'lpLocked',
      'ageMinutes',
      'tradeIntensity',
      'marketCapSol',
    ];

    const importance: FeatureImportance[] = [];

    for (let i = 0; i < featureNames.length; i++) {
      const featureValues = trades.map((t) => {
        const arr = Object.values(t.features);
        return arr[i] || 0;
      });

      const profits = trades.map((t) => t.pnlPercent || 0);

      // Calculate correlation with profit
      let correlation = 0;
      try {
        correlation = ss.sampleCorrelation(featureValues, profits);
        if (isNaN(correlation)) correlation = 0;
      } catch {
        correlation = 0;
      }

      // Calculate feature variance as importance proxy
      const variance = ss.variance(featureValues);

      importance.push({
        feature: featureNames[i],
        importance: variance,
        correlation,
      });
    }

    // Sort by absolute correlation
    importance.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));

    return importance;
  }

  private getEmptyMetrics(): PerformanceMetrics {
    return {
      totalTrades: 0,
      winningTrades: 0,
      losingTrades: 0,
      winRate: 0,
      avgWin: 0,
      avgLoss: 0,
      largestWin: 0,
      largestLoss: 0,
      profitFactor: 0,
      expectancy: 0,
      sharpeRatio: 0,
      sortinoRatio: 0,
      maxDrawdown: 0,
      avgHoldTime: 0,
      totalPnl: 0,
      totalPnlPercent: 0,
    };
  }

  formatMetrics(metrics: PerformanceMetrics): string {
    return [
      `Trades: ${metrics.totalTrades} (${metrics.winningTrades}W/${metrics.losingTrades}L)`,
      `Win Rate: ${(metrics.winRate * 100).toFixed(1)}%`,
      `Total P&L: ${metrics.totalPnl >= 0 ? '+' : ''}${metrics.totalPnl.toFixed(4)} SOL`,
      `Profit Factor: ${metrics.profitFactor.toFixed(2)}`,
      `Sharpe: ${metrics.sharpeRatio.toFixed(2)}`,
      `Max DD: ${(metrics.maxDrawdown * 100).toFixed(1)}%`,
    ].join(' | ');
  }
}

export const performanceAnalytics = new PerformanceAnalytics();
</file>

<file path="src/learning/trade-logger.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { repository } from '../db/repository';
import { Action, MarketRegime } from '../ai/types';
import { StateVector, PumpPhase } from '../signals/types';
import { featureExtractor } from '../signals/feature-extractor';
import { TradeRecord } from './types';

const logger = createChildLogger('trade-logger');

export class TradeLogger extends EventEmitter {
  private activeTrades: Map<string, TradeRecord> = new Map();

  constructor() {
    super();
  }

  async logEntry(params: {
    positionId: string;
    mint: string;
    symbol: string;
    entryPrice: number;
    amount: number;
    amountSol: number;
    features: StateVector;
    regime: MarketRegime;
    pumpPhase: PumpPhase;
  }): Promise<TradeRecord> {
    const record: TradeRecord = {
      id: params.positionId,
      mint: params.mint,
      symbol: params.symbol,
      action: Action.BUY,
      entryPrice: params.entryPrice,
      amount: params.amount,
      amountSol: params.amountSol,
      entryTime: new Date(),
      features: params.features,
      regime: params.regime,
      pumpPhase: params.pumpPhase,
    };

    this.activeTrades.set(record.id, record);

    // Save to database
    await repository.insertTrade({
      id: record.id,
      mint: record.mint,
      symbol: record.symbol,
      action: record.action,
      entry_price: record.entryPrice,
      amount: record.amount,
      amount_sol: record.amountSol,
      entry_time: record.entryTime,
      features_json: JSON.stringify(record.features),
      regime: record.regime,
      pump_phase: record.pumpPhase,
    });

    logger.info({
      id: record.id,
      mint: record.mint,
      entryPrice: record.entryPrice,
      amountSol: record.amountSol,
    }, 'Trade entry logged');

    this.emit('entryLogged', record);

    return record;
  }

  async logExit(params: {
    positionId: string;
    exitPrice: number;
    exitReason: 'stop_loss' | 'take_profit' | 'trailing_stop' | 'manual' | 'ai_signal' | 'rug_detected';
    slippage?: number;
    fees?: number;
    actualSolReceived?: number;
    partialClosePnl?: number;
  }): Promise<TradeRecord | null> {
    const record = this.activeTrades.get(params.positionId);

    if (!record) {
      logger.warn({ positionId: params.positionId }, 'Trade not found for exit');
      return null;
    }

    record.exitPrice = params.exitPrice;
    record.exitTime = new Date();
    record.exitReason = params.exitReason;
    record.slippage = params.slippage;
    record.fees = params.fees;

    // Calculate P&L with fees and slippage included
    const grossPnl = (record.exitPrice - record.entryPrice) * record.amount;
    const fees = params.fees || 0;
    const slippageCost = params.slippage ? (params.slippage * record.amountSol) : 0;

    // If we have actual SOL received from the swap, use that for accurate PnL
    let netPnl: number;
    if (params.actualSolReceived !== undefined) {
      // Accurate PnL = actual received - initial investment
      netPnl = params.actualSolReceived - record.amountSol;
    } else {
      // Estimated PnL = gross - fees - slippage
      netPnl = grossPnl - fees - slippageCost;
    }

    // Add any accumulated partial close PnL
    const partialClosePnl = params.partialClosePnl || 0;
    record.pnlSol = netPnl + partialClosePnl;
    record.pnlPercent = (record.pnlSol / record.amountSol) * 100;
    record.duration = record.exitTime.getTime() - record.entryTime.getTime();

    logger.debug({
      positionId: params.positionId,
      grossPnl,
      fees,
      slippageCost,
      actualSolReceived: params.actualSolReceived,
      partialClosePnl,
      netPnl: record.pnlSol,
    }, 'PnL calculation breakdown');

    // Update database
    await repository.updateTradeExit(record.id, {
      exit_price: record.exitPrice,
      exit_time: record.exitTime,
      pnl_sol: record.pnlSol,
      pnl_percent: record.pnlPercent,
      duration_ms: record.duration,
      exit_reason: record.exitReason,
      slippage: record.slippage,
      fees: record.fees,
    });

    logger.info({
      id: record.id,
      mint: record.mint,
      exitPrice: record.exitPrice,
      pnlSol: record.pnlSol?.toFixed(6),
      pnlPercent: record.pnlPercent?.toFixed(2),
      duration: record.duration,
      exitReason: record.exitReason,
    }, 'Trade exit logged');

    this.activeTrades.delete(record.id);
    this.emit('exitLogged', record);

    return record;
  }

  getActiveTrades(): TradeRecord[] {
    return Array.from(this.activeTrades.values());
  }

  getActiveTrade(id: string): TradeRecord | undefined {
    return this.activeTrades.get(id);
  }

  async getRecentTrades(limit: number = 100): Promise<TradeRecord[]> {
    const dbTrades = await repository.getRecentTrades(limit);

    return dbTrades.map((t) => ({
      id: t.id,
      mint: t.mint,
      symbol: t.symbol || '',
      action: t.action as Action,
      entryPrice: parseFloat(t.entry_price.toString()),
      exitPrice: t.exit_price ? parseFloat(t.exit_price.toString()) : undefined,
      amount: parseFloat(t.amount.toString()),
      amountSol: parseFloat(t.amount_sol.toString()),
      entryTime: new Date(t.entry_time),
      exitTime: t.exit_time ? new Date(t.exit_time) : undefined,
      pnlSol: t.pnl_sol ? parseFloat(t.pnl_sol.toString()) : undefined,
      pnlPercent: t.pnl_percent ? parseFloat(t.pnl_percent.toString()) : undefined,
      duration: t.duration_ms ? parseInt(t.duration_ms.toString()) : undefined,
      features: JSON.parse(t.features_json || '{}'),
      regime: t.regime as MarketRegime,
      pumpPhase: t.pump_phase as PumpPhase,
      exitReason: t.exit_reason as any,
      slippage: t.slippage ? parseFloat(t.slippage.toString()) : undefined,
      fees: t.fees ? parseFloat(t.fees.toString()) : undefined,
    }));
  }

  async getTradesForTraining(weeks: number = 4): Promise<TradeRecord[]> {
    const dbTrades = await repository.getTradesForTraining(weeks);

    return dbTrades
      .filter((t) => t.exit_time !== null)
      .map((t) => ({
        id: t.id,
        mint: t.mint,
        symbol: t.symbol || '',
        action: t.action as Action,
        entryPrice: parseFloat(t.entry_price.toString()),
        exitPrice: t.exit_price ? parseFloat(t.exit_price.toString()) : undefined,
        amount: parseFloat(t.amount.toString()),
        amountSol: parseFloat(t.amount_sol.toString()),
        entryTime: new Date(t.entry_time),
        exitTime: t.exit_time ? new Date(t.exit_time) : undefined,
        pnlSol: t.pnl_sol ? parseFloat(t.pnl_sol.toString()) : undefined,
        pnlPercent: t.pnl_percent ? parseFloat(t.pnl_percent.toString()) : undefined,
        duration: t.duration_ms ? parseInt(t.duration_ms.toString()) : undefined,
        features: JSON.parse(t.features_json || '{}'),
        regime: t.regime as MarketRegime,
        pumpPhase: t.pump_phase as PumpPhase,
        exitReason: t.exit_reason as any,
        slippage: t.slippage ? parseFloat(t.slippage.toString()) : undefined,
        fees: t.fees ? parseFloat(t.fees.toString()) : undefined,
      }));
  }

  // Convert trade to experience for DDQN training
  tradeToExperience(trade: TradeRecord): {
    state: number[];
    action: Action;
    reward: number;
    nextState: number[];
    done: boolean;
  } | null {
    if (!trade.exitPrice || !trade.pnlPercent) {
      return null;
    }

    const state = featureExtractor.toArray(trade.features);

    // Reward function: profit-based with risk adjustment
    let reward = trade.pnlPercent / 10; // Scale to reasonable range

    // Penalty for large losses
    if (trade.pnlPercent < -20) {
      reward *= 1.5; // Amplify negative signal for big losses
    }

    // Bonus for good risk-adjusted exits
    if (trade.exitReason === 'take_profit') {
      reward *= 1.1;
    } else if (trade.exitReason === 'trailing_stop' && trade.pnlPercent > 0) {
      reward *= 1.05;
    }

    // Next state is similar to current (simplified)
    const nextState = state.slice();

    return {
      state,
      action: trade.action,
      reward,
      nextState,
      done: true,
    };
  }

  // NEW: Dense reward shaping for intermediate states during position holding
  // Call this periodically while position is open to provide learning signal
  calculateIntermediateReward(params: {
    unrealizedPnlPercent: number;
    previousPnlPercent: number;
    momentum: number;        // Price velocity
    volatility: number;
    drawdownFromPeak: number;
    holdDurationSeconds: number;
  }): number {
    const {
      unrealizedPnlPercent,
      previousPnlPercent,
      momentum,
      volatility,
      drawdownFromPeak,
      holdDurationSeconds,
    } = params;

    let reward = 0;

    // Reward for P&L improvement (delta reward)
    const pnlDelta = unrealizedPnlPercent - previousPnlPercent;
    reward += pnlDelta * 0.1;  // Small reward for positive movement

    // Reward for holding through upward momentum
    if (momentum > 0 && unrealizedPnlPercent > 0) {
      reward += 0.1 * Math.min(momentum, 1.0);  // Cap at 0.1 bonus
    }

    // Penalty for holding during drawdown
    if (drawdownFromPeak > 0.1) {  // More than 10% drawdown from peak
      reward -= 0.05 * drawdownFromPeak;
    }

    // Small penalty for holding through high volatility (risk)
    if (volatility > 0.05) {  // High volatility threshold
      reward -= 0.02 * volatility;
    }

    // Small penalty for entering tokens that immediately stagnate
    if (holdDurationSeconds < 30 && Math.abs(unrealizedPnlPercent) < 1) {
      reward -= 0.05;  // Token going nowhere quickly
    }

    // Clip rewards to prevent extreme values
    return Math.max(-1, Math.min(1, reward));
  }

  // NEW: Calculate reward signal for a position update
  getPositionRewardSignal(position: {
    mint: string;
    entryPrice: number;
    currentPrice: number;
    peakPrice: number;
    entryTime: Date;
    previousPrice?: number;
  }): {
    intermediateReward: number;
    unrealizedPnlPercent: number;
    momentum: number;
    drawdownFromPeak: number;
  } {
    const unrealizedPnlPercent = ((position.currentPrice - position.entryPrice) / position.entryPrice) * 100;
    const previousPnlPercent = position.previousPrice
      ? ((position.previousPrice - position.entryPrice) / position.entryPrice) * 100
      : 0;

    // Calculate momentum (price change rate)
    const momentum = position.previousPrice
      ? (position.currentPrice - position.previousPrice) / position.previousPrice
      : 0;

    // Calculate drawdown from peak
    const drawdownFromPeak = position.peakPrice > position.currentPrice
      ? (position.peakPrice - position.currentPrice) / position.peakPrice
      : 0;

    const holdDurationSeconds = (Date.now() - position.entryTime.getTime()) / 1000;

    const intermediateReward = this.calculateIntermediateReward({
      unrealizedPnlPercent,
      previousPnlPercent,
      momentum,
      volatility: 0,  // Would need historical data to calculate
      drawdownFromPeak,
      holdDurationSeconds,
    });

    return {
      intermediateReward,
      unrealizedPnlPercent,
      momentum,
      drawdownFromPeak,
    };
  }
}

export const tradeLogger = new TradeLogger();
</file>

<file path="src/learning/types.ts">
import { Action, MarketRegime } from '../ai/types';
import { StateVector, PumpPhase } from '../signals/types';

export interface TradeRecord {
  id: string;
  mint: string;
  symbol: string;
  action: Action;
  entryPrice: number;
  exitPrice?: number;
  amount: number;
  amountSol: number;
  entryTime: Date;
  exitTime?: Date;
  pnlSol?: number;
  pnlPercent?: number;
  duration?: number;          // milliseconds
  features: StateVector;
  regime: MarketRegime;
  pumpPhase: PumpPhase;
  exitReason?: 'stop_loss' | 'take_profit' | 'trailing_stop' | 'manual' | 'ai_signal' | 'rug_detected';
  slippage?: number;
  fees?: number;
}

export interface PerformanceMetrics {
  totalTrades: number;
  winningTrades: number;
  losingTrades: number;
  winRate: number;
  avgWin: number;
  avgLoss: number;
  largestWin: number;
  largestLoss: number;
  profitFactor: number;       // gross profit / gross loss
  expectancy: number;         // avg profit per trade
  sharpeRatio: number;
  sortinoRatio: number;
  maxDrawdown: number;
  avgHoldTime: number;
  totalPnl: number;
  totalPnlPercent: number;
}

export interface TimeframePerformance {
  hourly: PerformanceMetrics;
  daily: PerformanceMetrics;
  weekly: PerformanceMetrics;
  monthly: PerformanceMetrics;
  allTime: PerformanceMetrics;
}

export interface FeatureImportance {
  feature: string;
  importance: number;
  correlation: number;        // correlation with profit
}

export interface ModelTrainingResult {
  epochsTrained: number;
  finalLoss: number;
  validationLoss: number;
  trainingTime: number;
  samplesUsed: number;
  improvementPercent: number;
  timestamp: Date;
}

export interface LearningState {
  tradesProcessed: number;
  lastTrainingTime: Date;
  modelVersion: number;
  performanceHistory: PerformanceMetrics[];
  featureImportance: FeatureImportance[];
}
</file>

<file path="src/risk/capital-allocator.ts">
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { txManager } from '../execution/tx-manager';
import { positionManager } from './position-manager';
import { CapitalAllocation, RiskCheckResult, RiskLimits } from './types';

const logger = createChildLogger('capital-allocator');

export class CapitalAllocator {
  private allocation: CapitalAllocation;
  private limits: RiskLimits;

  constructor() {
    const totalCapital = config.initialCapitalSol;

    this.allocation = {
      totalSol: totalCapital,
      reserveSol: totalCapital * config.capitalAllocation.reserve,
      activeSol: totalCapital * config.capitalAllocation.active,
      highRiskSol: totalCapital * config.capitalAllocation.highRisk,
      inPositions: 0,
      availableActive: totalCapital * config.capitalAllocation.active,
      availableHighRisk: totalCapital * config.capitalAllocation.highRisk,
    };

    this.limits = {
      maxPositionSizeSol: config.maxPositionSize * totalCapital,
      maxConcurrentPositions: config.maxConcurrentPositions,
      dailyLossLimit: config.dailyLossLimit,
      maxDrawdownLimit: 0.30, // 30% max drawdown
      minPositionSizeSol: 0.001,
    };
  }

  async syncWithWallet(): Promise<void> {
    try {
      const actualBalance = await txManager.getWalletBalance();
      const inPositions = positionManager.getTotalExposure();

      this.allocation.totalSol = actualBalance + inPositions;
      this.allocation.inPositions = inPositions;

      // Recalculate allocations
      this.allocation.reserveSol = this.allocation.totalSol * config.capitalAllocation.reserve;
      this.allocation.activeSol = this.allocation.totalSol * config.capitalAllocation.active;
      this.allocation.highRiskSol = this.allocation.totalSol * config.capitalAllocation.highRisk;

      // Calculate available capital by pool
      const activeInPositions = this.getPoolExposure('active');
      const highRiskInPositions = this.getPoolExposure('high_risk');

      this.allocation.availableActive = Math.max(0, this.allocation.activeSol - activeInPositions);
      this.allocation.availableHighRisk = Math.max(0, this.allocation.highRiskSol - highRiskInPositions);

      // Update limits based on new total
      this.limits.maxPositionSizeSol = config.maxPositionSize * this.allocation.totalSol;

      logger.debug({
        total: this.allocation.totalSol.toFixed(4),
        available: actualBalance.toFixed(4),
        inPositions: inPositions.toFixed(4),
        availableActive: this.allocation.availableActive.toFixed(4),
        availableHighRisk: this.allocation.availableHighRisk.toFixed(4),
      }, 'Capital synced');
    } catch (error) {
      logger.error({ error }, 'Failed to sync capital');
    }
  }

  private getPoolExposure(poolType: 'active' | 'high_risk'): number {
    return positionManager
      .getOpenPositions()
      .filter((p) => p.poolType === poolType)
      .reduce((sum, p) => sum + p.amountSol, 0);
  }

  checkRisk(
    requestedSizeSol: number,
    poolType: 'active' | 'high_risk'
  ): RiskCheckResult {
    const warnings: string[] = [];
    let adjustedSize = requestedSizeSol;
    let approved = true;

    // Check position count limit
    const currentPositions = positionManager.getPositionCount();
    if (currentPositions >= this.limits.maxConcurrentPositions) {
      return {
        approved: false,
        reason: `Max positions (${this.limits.maxConcurrentPositions}) reached`,
        warnings: [],
      };
    }

    // Check pool availability
    const available =
      poolType === 'active'
        ? this.allocation.availableActive
        : this.allocation.availableHighRisk;

    if (requestedSizeSol > available) {
      adjustedSize = available;
      warnings.push(`Size reduced to available: ${available.toFixed(4)} SOL`);
    }

    // Check max position size
    if (adjustedSize > this.limits.maxPositionSizeSol) {
      adjustedSize = this.limits.maxPositionSizeSol;
      warnings.push(`Size capped at max: ${this.limits.maxPositionSizeSol.toFixed(4)} SOL`);
    }

    // Check min position size
    if (adjustedSize < this.limits.minPositionSizeSol) {
      return {
        approved: false,
        reason: `Size ${adjustedSize.toFixed(4)} below minimum ${this.limits.minPositionSizeSol} SOL`,
        warnings,
      };
    }

    // Check total exposure
    const totalExposure = positionManager.getTotalExposure() + adjustedSize;
    const maxExposure = this.allocation.totalSol - this.allocation.reserveSol;

    if (totalExposure > maxExposure) {
      const allowedSize = maxExposure - positionManager.getTotalExposure();
      if (allowedSize < this.limits.minPositionSizeSol) {
        return {
          approved: false,
          reason: 'Would exceed total exposure limit',
          warnings,
        };
      }
      adjustedSize = allowedSize;
      warnings.push(`Size reduced due to exposure limit: ${adjustedSize.toFixed(4)} SOL`);
    }

    return {
      approved: true,
      adjustedSize,
      reason: 'Risk check passed',
      warnings,
    };
  }

  getAllocation(): CapitalAllocation {
    return { ...this.allocation };
  }

  getLimits(): RiskLimits {
    return { ...this.limits };
  }

  getAvailableCapital(poolType: 'active' | 'high_risk'): number {
    return poolType === 'active'
      ? this.allocation.availableActive
      : this.allocation.availableHighRisk;
  }

  getExposurePercent(): number {
    if (this.allocation.totalSol === 0) return 0;
    return (this.allocation.inPositions / this.allocation.totalSol) * 100;
  }

  reserveCapital(amount: number, poolType: 'active' | 'high_risk'): void {
    if (poolType === 'active') {
      this.allocation.availableActive = Math.max(0, this.allocation.availableActive - amount);
    } else {
      this.allocation.availableHighRisk = Math.max(0, this.allocation.availableHighRisk - amount);
    }
    this.allocation.inPositions += amount;
  }

  releaseCapital(amount: number, poolType: 'active' | 'high_risk'): void {
    if (poolType === 'active') {
      this.allocation.availableActive += amount;
    } else {
      this.allocation.availableHighRisk += amount;
    }
    this.allocation.inPositions = Math.max(0, this.allocation.inPositions - amount);
  }

  suggestPoolType(rugScore: number): 'active' | 'high_risk' {
    // Higher rug score = safer token = active pool
    // Lower rug score = riskier = high risk pool
    return rugScore >= 70 ? 'active' : 'high_risk';
  }

  getStatus(): string {
    const exposure = this.getExposurePercent();
    const positions = positionManager.getPositionCount();

    return [
      `Total: ${this.allocation.totalSol.toFixed(4)} SOL`,
      `In Positions: ${this.allocation.inPositions.toFixed(4)} SOL (${exposure.toFixed(1)}%)`,
      `Available Active: ${this.allocation.availableActive.toFixed(4)} SOL`,
      `Available High Risk: ${this.allocation.availableHighRisk.toFixed(4)} SOL`,
      `Positions: ${positions}/${this.limits.maxConcurrentPositions}`,
    ].join(' | ');
  }
}

export const capitalAllocator = new CapitalAllocator();
</file>

<file path="src/risk/drawdown-guard.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { repository } from '../db/repository';
import { positionManager } from './position-manager';
import { capitalAllocator } from './capital-allocator';
import { DrawdownState } from './types';

const logger = createChildLogger('drawdown-guard');

export class DrawdownGuard extends EventEmitter {
  private state: DrawdownState;
  private checkInterval: NodeJS.Timeout | null = null;

  constructor() {
    super();

    this.state = {
      currentEquity: config.initialCapitalSol,
      peakEquity: config.initialCapitalSol,
      currentDrawdown: 0,
      maxDrawdown: 0,
      dailyPnl: 0,
      dailyStartEquity: config.initialCapitalSol,
      isPaused: false,
    };
  }

  async start(): Promise<void> {
    // Load state from database if available
    await this.loadState();

    // Start periodic checks
    this.checkInterval = setInterval(() => {
      this.updateState();
      this.checkLimits();
    }, 10000); // Check every 10 seconds

    logger.info('Drawdown guard started');
  }

  stop(): void {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    logger.info('Drawdown guard stopped');
  }

  private async loadState(): Promise<void> {
    try {
      const savedState = await repository.getConfig('drawdown_state');
      if (savedState) {
        const parsed = JSON.parse(savedState);
        this.state = { ...this.state, ...parsed };

        // Check if pause should be lifted
        if (this.state.pauseUntil && new Date(this.state.pauseUntil) < new Date()) {
          this.state.isPaused = false;
          this.state.pauseUntil = undefined;
          this.state.pauseReason = undefined;
        }
      }
    } catch (error) {
      logger.error({ error }, 'Failed to load drawdown state');
    }
  }

  private async saveState(): Promise<void> {
    try {
      await repository.setConfig('drawdown_state', JSON.stringify(this.state));
    } catch (error) {
      logger.error({ error }, 'Failed to save drawdown state');
    }
  }

  private async updateState(): Promise<void> {
    const allocation = capitalAllocator.getAllocation();
    const positions = positionManager.getOpenPositions();

    // Calculate current equity (wallet balance + unrealized P&L)
    let unrealizedPnl = 0;
    for (const position of positions) {
      unrealizedPnl += position.unrealizedPnl;
    }

    // In paper trading or when wallet is empty, use initial capital
    const baseEquity = allocation.totalSol > 0 ? allocation.totalSol : config.initialCapitalSol;
    this.state.currentEquity = baseEquity + unrealizedPnl;

    // Update peak equity
    if (this.state.currentEquity > this.state.peakEquity) {
      this.state.peakEquity = this.state.currentEquity;
    }

    // Calculate current drawdown
    this.state.currentDrawdown =
      (this.state.peakEquity - this.state.currentEquity) / this.state.peakEquity;

    // Update max drawdown
    if (this.state.currentDrawdown > this.state.maxDrawdown) {
      this.state.maxDrawdown = this.state.currentDrawdown;
    }

    // Update daily P&L
    this.state.dailyPnl = this.state.currentEquity - this.state.dailyStartEquity;

    // Check for new day
    await this.checkDayRollover();
  }

  private async checkDayRollover(): Promise<void> {
    const now = new Date();
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    const lastUpdate = await repository.getConfig('last_day_update');
    const lastUpdateDate = lastUpdate ? new Date(lastUpdate) : null;

    if (!lastUpdateDate || lastUpdateDate < todayStart) {
      // New day - record previous day stats and reset
      if (lastUpdateDate) {
        await repository.updateDailyStats(lastUpdateDate, {
          ending_equity: this.state.currentEquity,
          pnl: this.state.dailyPnl,
          max_drawdown: this.state.currentDrawdown,
        });
      }

      // Reset daily tracking
      this.state.dailyStartEquity = this.state.currentEquity;
      this.state.dailyPnl = 0;

      await repository.setConfig('last_day_update', now.toISOString());
      await repository.updateDailyStats(now, {
        starting_equity: this.state.currentEquity,
      });

      // Check if pause should be lifted
      if (this.state.isPaused && this.state.pauseUntil) {
        if (new Date(this.state.pauseUntil) <= now) {
          this.resumeTrading('Pause period expired');
        }
      }
    }
  }

  private checkLimits(): void {
    if (this.state.isPaused) return;

    // Prevent division by zero
    if (this.state.dailyStartEquity <= 0 || this.state.peakEquity <= 0) {
      return;
    }

    // Check daily loss limit
    const dailyLossPercent = -this.state.dailyPnl / this.state.dailyStartEquity;

    if (dailyLossPercent >= config.dailyLossLimit) {
      const pauseUntil = new Date();
      pauseUntil.setHours(pauseUntil.getHours() + 24);

      this.pauseTrading(
        `Daily loss limit (${(config.dailyLossLimit * 100).toFixed(0)}%) exceeded`,
        pauseUntil
      );
      return;
    }

    // Check max drawdown
    if (this.state.currentDrawdown >= 0.30) {
      // 30% max drawdown
      const pauseUntil = new Date();
      pauseUntil.setHours(pauseUntil.getHours() + 48);

      this.pauseTrading('Max drawdown (30%) exceeded', pauseUntil);
      return;
    }

    // Warn at 20% drawdown
    if (this.state.currentDrawdown >= 0.20 && this.state.currentDrawdown < 0.25) {
      logger.warn(
        { drawdown: (this.state.currentDrawdown * 100).toFixed(1) },
        'Drawdown warning - approaching limit'
      );
    }
  }

  pauseTrading(reason: string, until?: Date): void {
    this.state.isPaused = true;
    this.state.pauseReason = reason;
    this.state.pauseUntil = until;

    this.emit('tradingPaused', {
      reason,
      until,
      drawdown: this.state.currentDrawdown,
      dailyPnl: this.state.dailyPnl,
    });

    logger.error(
      { reason, until: until?.toISOString(), drawdown: this.state.currentDrawdown },
      'TRADING PAUSED'
    );

    this.saveState();
  }

  resumeTrading(reason: string): void {
    if (!this.state.isPaused) return;

    this.state.isPaused = false;
    this.state.pauseReason = undefined;
    this.state.pauseUntil = undefined;

    this.emit('tradingResumed', { reason });

    logger.info({ reason }, 'Trading resumed');

    this.saveState();
  }

  canTrade(): boolean {
    return !this.state.isPaused;
  }

  getState(): DrawdownState {
    return { ...this.state };
  }

  getStatus(): string {
    if (this.state.isPaused) {
      return `PAUSED: ${this.state.pauseReason} (until ${this.state.pauseUntil?.toISOString()})`;
    }

    return [
      `Equity: ${this.state.currentEquity.toFixed(4)} SOL`,
      `Peak: ${this.state.peakEquity.toFixed(4)} SOL`,
      `Drawdown: ${(this.state.currentDrawdown * 100).toFixed(2)}%`,
      `Daily P&L: ${this.state.dailyPnl >= 0 ? '+' : ''}${this.state.dailyPnl.toFixed(4)} SOL`,
    ].join(' | ');
  }

  resetPeakEquity(): void {
    this.state.peakEquity = this.state.currentEquity;
    this.state.maxDrawdown = 0;
    logger.info({ newPeak: this.state.peakEquity }, 'Peak equity reset');
    this.saveState();
  }

  // Full reset for fresh start - uses actual wallet balance
  async resetAll(): Promise<void> {
    const allocation = capitalAllocator.getAllocation();
    const actualEquity = allocation.totalSol > 0 ? allocation.totalSol : config.initialCapitalSol;

    this.state = {
      currentEquity: actualEquity,
      peakEquity: actualEquity,
      currentDrawdown: 0,
      maxDrawdown: 0,
      dailyPnl: 0,
      dailyStartEquity: actualEquity,
      isPaused: false,
    };
    await this.saveState();
    logger.info({ equity: actualEquity }, 'Drawdown guard fully reset');
  }

  recordTrade(pnlSol: number): void {
    this.state.dailyPnl += pnlSol;

    if (pnlSol > 0) {
      this.state.currentEquity += pnlSol;
      if (this.state.currentEquity > this.state.peakEquity) {
        this.state.peakEquity = this.state.currentEquity;
      }
    } else {
      this.state.currentEquity += pnlSol;
      this.state.currentDrawdown =
        (this.state.peakEquity - this.state.currentEquity) / this.state.peakEquity;

      if (this.state.currentDrawdown > this.state.maxDrawdown) {
        this.state.maxDrawdown = this.state.currentDrawdown;
      }
    }

    this.checkLimits();
    this.saveState();
  }
}

export const drawdownGuard = new DrawdownGuard();
</file>

<file path="src/risk/index.ts">
export * from './types';
export * from './position-manager';
export * from './capital-allocator';
export * from './drawdown-guard';
</file>

<file path="src/risk/position-manager.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config, LAMPORTS_PER_SOL } from '../config/settings';
import { priceFeed } from '../data/price-feed';
import { txManager } from '../execution/tx-manager';
import { repository } from '../db/repository';
import { Position, RiskCheckResult } from './types';

// Estimated fee per transaction in SOL (Jupiter swap fee + priority fee)
const ESTIMATED_TX_FEE_SOL = 0.001;

const logger = createChildLogger('position-manager');

export class PositionManager extends EventEmitter {
  private positions: Map<string, Position> = new Map();
  private monitorInterval: NodeJS.Timeout | null = null;

  constructor() {
    super();
  }

  async start(): Promise<void> {
    // Load existing positions from database
    await this.loadPositions();

    // Start position monitoring
    this.monitorInterval = setInterval(() => {
      this.monitorPositions();
    }, config.priceCheckIntervalMs);

    logger.info({ positionCount: this.positions.size }, 'Position manager started');
  }

  stop(): void {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = null;
    }
    logger.info('Position manager stopped');
  }

  private async loadPositions(): Promise<void> {
    try {
      const dbPositions = await repository.getOpenPositions();

      for (const dbPos of dbPositions) {
        const amountSol = parseFloat(dbPos.amount_sol.toString());
        // Load accumulated PnL from partial closes
        const partialClosePnl = await repository.getTotalPartialClosePnl(dbPos.id);

        const position: Position = {
          id: dbPos.id,
          mint: dbPos.mint,
          symbol: dbPos.symbol || '',
          entryPrice: parseFloat(dbPos.entry_price.toString()),
          currentPrice: parseFloat(dbPos.current_price.toString()),
          amount: parseFloat(dbPos.amount.toString()),
          amountSol,
          entryTime: new Date(dbPos.entry_time),
          lastUpdate: new Date(dbPos.last_update),
          unrealizedPnl: 0,
          unrealizedPnlPercent: 0,
          highestPrice: parseFloat(dbPos.highest_price.toString()),
          lowestPrice: parseFloat(dbPos.lowest_price.toString()),
          stopLoss: parseFloat(dbPos.stop_loss.toString()),
          takeProfit: JSON.parse(dbPos.take_profit_json || '[]'),
          tpSold: JSON.parse(dbPos.tp_sold_json || '[]'),
          status: dbPos.status as 'open' | 'closing' | 'closed',
          poolType: dbPos.pool_type as 'active' | 'high_risk',
          // NEW: Performance-based TP tracking (default for existing positions)
          initialRecovered: (dbPos as any).initial_recovered || false,
          scaledExitsTaken: (dbPos as any).scaled_exits_taken || 0,
          initialInvestment: (dbPos as any).initial_investment || amountSol,
          // NEW: Accumulated PnL from partial closes
          realizedPnl: partialClosePnl,
        };

        this.positions.set(position.id, position);
        priceFeed.addToWatchList(position.mint);
      }

      logger.info({ loaded: this.positions.size }, 'Positions loaded from database');
    } catch (error) {
      logger.error({ error }, 'Failed to load positions');
    }
  }

  async openPosition(params: {
    mint: string;
    symbol: string;
    entryPrice: number;
    amount: number;
    amountSol: number;
    poolType: 'active' | 'high_risk';
  }): Promise<Position> {
    const id = `pos_${params.mint}_${Date.now()}`;

    // Calculate stop loss and take profit levels
    const stopLoss = params.entryPrice * (1 - config.stopLossPercent);
    const takeProfit = config.takeProfitLevels.map((tp) => params.entryPrice * tp.multiplier);

    const position: Position = {
      id,
      mint: params.mint,
      symbol: params.symbol,
      entryPrice: params.entryPrice,
      currentPrice: params.entryPrice,
      amount: params.amount,
      amountSol: params.amountSol,
      entryTime: new Date(),
      lastUpdate: new Date(),
      unrealizedPnl: 0,
      unrealizedPnlPercent: 0,
      highestPrice: params.entryPrice,
      lowestPrice: params.entryPrice,
      stopLoss,
      takeProfit,
      tpSold: [],
      status: 'open',
      poolType: params.poolType,
      // NEW: Performance-based TP tracking
      initialRecovered: false,
      scaledExitsTaken: 0,
      initialInvestment: params.amountSol,
      // NEW: Accumulated PnL tracking
      realizedPnl: 0,
    };

    this.positions.set(id, position);
    priceFeed.addToWatchList(params.mint);

    // Save to database
    await repository.upsertPosition({
      id: position.id,
      mint: position.mint,
      symbol: position.symbol,
      entry_price: position.entryPrice,
      current_price: position.currentPrice,
      amount: position.amount,
      amount_sol: position.amountSol,
      entry_time: position.entryTime,
      highest_price: position.highestPrice,
      lowest_price: position.lowestPrice,
      stop_loss: position.stopLoss,
      take_profit_json: JSON.stringify(position.takeProfit),
      tp_sold_json: JSON.stringify(position.tpSold),
      status: position.status,
      pool_type: position.poolType,
    });

    this.emit('positionOpened', position);
    logger.info({
      id,
      mint: params.mint,
      amountSol: params.amountSol,
      stopLoss: stopLoss.toFixed(10),
      takeProfit: takeProfit.map((tp) => tp.toFixed(10)),
    }, 'Position opened');

    return position;
  }

  private async monitorPositions(): Promise<void> {
    for (const position of this.positions.values()) {
      if (position.status !== 'open') continue;

      try {
        let priceData = priceFeed.getPrice(position.mint);

        // If cache miss, attempt fresh fetch for bonding curve tokens
        if (!priceData && position.mint.endsWith('pump')) {
          priceData = await priceFeed.fetchTokenPrice(position.mint);
        }

        if (!priceData) {
          logger.warn({ mint: position.mint }, 'No price data - skipping position');
          continue;
        }

        const previousPrice = position.currentPrice;
        position.currentPrice = priceData.priceSol;
        position.lastUpdate = new Date();

        // Update highest/lowest
        if (position.currentPrice > position.highestPrice) {
          position.highestPrice = position.currentPrice;
          this.updateTrailingStop(position);
        }
        if (position.currentPrice < position.lowestPrice) {
          position.lowestPrice = position.currentPrice;
        }

        // Calculate unrealized P&L
        const currentValue = position.amount * position.currentPrice;
        position.unrealizedPnl = currentValue - position.amountSol;
        position.unrealizedPnlPercent =
          ((position.currentPrice - position.entryPrice) / position.entryPrice) * 100;

        // Check exit conditions
        await this.checkExitConditions(position);

        // Update database periodically (every 10th update)
        if (Math.random() < 0.1) {
          await this.persistPosition(position);
        }
      } catch (error) {
        logger.error({ positionId: position.id, error }, 'Failed to monitor position');
      }
    }
  }

  private updateTrailingStop(position: Position): void {
    // Only enable trailing stop after first TP hit
    if (position.tpSold.length > 0) {
      const trailingStopPrice = position.highestPrice * (1 - config.trailingStopPercent);
      position.trailingStop = Math.max(position.trailingStop || 0, trailingStopPrice);
    }
  }

  private async checkExitConditions(position: Position): Promise<void> {
    const currentPrice = position.currentPrice;
    const profitPercent = (currentPrice - position.entryPrice) / position.entryPrice;

    // 1. STOP LOSS CHECK (-12%)
    if (profitPercent <= -config.stopLossPercent) {
      logger.warn({
        positionId: position.id,
        currentPrice,
        entryPrice: position.entryPrice,
        profitPercent: (profitPercent * 100).toFixed(2),
        stopLossPercent: (config.stopLossPercent * 100).toFixed(0),
      }, 'Stop loss triggered at -12%');

      await this.closePosition(position.id, 'stop_loss');
      return;
    }

    // 2. TRAILING STOP CHECK (after any TP)
    if (position.trailingStop && currentPrice <= position.trailingStop) {
      logger.info({
        positionId: position.id,
        currentPrice,
        trailingStop: position.trailingStop,
        profitPercent: (profitPercent * 100).toFixed(2),
      }, 'Trailing stop triggered');

      await this.closePosition(position.id, 'trailing_stop');
      return;
    }

    // 3. INITIAL RECOVERY CHECK (+50%)
    const tpStrategy = config.takeProfitStrategy;
    if (!position.initialRecovered && profitPercent >= tpStrategy.initialRecovery.triggerPercent) {
      // Calculate how much to sell to recover initial investment
      const currentValue = position.amount * currentPrice;
      const sellAmount = position.initialInvestment / currentPrice;

      logger.info({
        positionId: position.id,
        profitPercent: (profitPercent * 100).toFixed(2),
        sellAmount,
        initialInvestment: position.initialInvestment,
        currentValue,
      }, 'Initial recovery: selling to recover initial investment at +50%');

      await this.partialCloseNewStrategy(position, sellAmount, 'initial_recovery');
      position.initialRecovered = true;
      position.trailingStop = currentPrice * (1 - tpStrategy.trailingStopPercent);

      await this.persistPosition(position);
      return;
    }

    // 4. SCALED EXITS (every +50% after recovery)
    if (position.initialRecovered) {
      const profitSinceRecovery = profitPercent - tpStrategy.initialRecovery.triggerPercent;
      const exitCount = Math.floor(profitSinceRecovery / tpStrategy.scaledExits.intervalPercent);

      if (exitCount > position.scaledExitsTaken && position.amount > 0) {
        const sellAmount = position.amount * tpStrategy.scaledExits.sellPercent;

        logger.info({
          positionId: position.id,
          profitPercent: (profitPercent * 100).toFixed(2),
          exitNumber: position.scaledExitsTaken + 1,
          sellPercent: tpStrategy.scaledExits.sellPercent * 100,
          sellAmount,
        }, 'Scaled exit: selling 20% of remaining at +50% interval');

        await this.partialCloseNewStrategy(position, sellAmount, 'scaled_exit');
        position.scaledExitsTaken++;
        position.trailingStop = currentPrice * (1 - tpStrategy.trailingStopPercent);

        await this.persistPosition(position);
      }
    }

    // 5. Update trailing stop on new highs (after initial recovery)
    if (position.initialRecovered && currentPrice >= position.highestPrice) {
      const newTrailingStop = currentPrice * (1 - tpStrategy.trailingStopPercent);
      if (!position.trailingStop || newTrailingStop > position.trailingStop) {
        position.trailingStop = newTrailingStop;
      }
    }
  }

  private async partialClose(position: Position, sellPercent: number, tpLevel: number): Promise<void> {
    const sellAmount = position.amount * sellPercent;

    // Execute partial sell with proper slippage for volatile tokens
    const result = await txManager.executeSell(position.mint, sellAmount, 9, { slippageBps: config.defaultSlippageBps });

    if (result.success) {
      position.amount -= sellAmount;
      position.tpSold.push(tpLevel);

      this.emit('partialClose', { position, tpLevel, sellAmount, result });

      // Update in database
      await this.persistPosition(position);
    } else {
      logger.error({
        positionId: position.id,
        tpLevel,
        error: result.error,
      }, 'Partial close failed');
    }
  }

  // NEW: Partial close for new TP strategy (absolute amount instead of percent)
  private async partialCloseNewStrategy(
    position: Position,
    sellAmount: number,
    reason: 'initial_recovery' | 'scaled_exit'
  ): Promise<void> {
    // Ensure we don't sell more than we have
    const actualSellAmount = Math.min(sellAmount, position.amount * 0.99);

    // Execute partial sell with proper slippage for volatile tokens
    const result = await txManager.executeSell(position.mint, actualSellAmount, 9, { slippageBps: config.defaultSlippageBps });

    if (result.success) {
      const previousAmount = position.amount;
      position.amount -= actualSellAmount;

      // Calculate PnL for this partial close
      const priceAtClose = position.currentPrice;
      const solReceived = result.outputAmount || (actualSellAmount * priceAtClose);
      const proportionalEntry = (actualSellAmount / previousAmount) * position.amountSol;
      const pnlSol = solReceived - proportionalEntry - ESTIMATED_TX_FEE_SOL;

      // Accumulate realized PnL
      position.realizedPnl = (position.realizedPnl || 0) + pnlSol;

      // Log to database
      await repository.insertPartialClose({
        position_id: position.id,
        mint: position.mint,
        close_type: reason,
        sell_amount_tokens: actualSellAmount,
        sell_amount_sol: solReceived,
        price_at_close: priceAtClose,
        pnl_sol: pnlSol,
        fees_sol: ESTIMATED_TX_FEE_SOL,
      });

      // Update position amount in database
      await repository.updatePositionAmount(position.id, position.amount);

      this.emit('partialClose', { position, reason, sellAmount: actualSellAmount, result, pnlSol });

      logger.info({
        positionId: position.id,
        reason,
        sellAmount: actualSellAmount,
        remainingAmount: position.amount,
        solReceived,
        pnlSol: pnlSol.toFixed(6),
        totalRealizedPnl: position.realizedPnl.toFixed(6),
      }, 'Partial close executed (new strategy)');
    } else {
      logger.error({
        positionId: position.id,
        reason,
        error: result.error,
      }, 'Partial close failed (new strategy)');
    }
  }

  async closePosition(
    positionId: string,
    reason: 'stop_loss' | 'take_profit' | 'trailing_stop' | 'manual' | 'ai_signal' | 'rug_detected'
  ): Promise<void> {
    const position = this.positions.get(positionId);

    if (!position) {
      logger.warn({ positionId }, 'Position not found');
      return;
    }

    if (position.status !== 'open') {
      logger.warn({ positionId, status: position.status }, 'Position not open');
      return;
    }

    position.status = 'closing';

    // Execute full sell with proper slippage for volatile tokens
    const result = await txManager.executeSell(position.mint, position.amount, 9, { slippageBps: config.defaultSlippageBps });

    if (result.success) {
      position.status = 'closed';

      const exitPrice = position.currentPrice;

      // Calculate PnL for final close (remaining tokens)
      const solReceived = result.outputAmount || (position.amount * exitPrice);
      const remainingEntryValue = position.amount * position.entryPrice;
      const finalClosePnl = solReceived - remainingEntryValue - ESTIMATED_TX_FEE_SOL;

      // Total PnL = partial closes + final close
      const totalPnlSol = (position.realizedPnl || 0) + finalClosePnl;
      const pnlPercent = (totalPnlSol / position.amountSol) * 100;

      // Update database
      await repository.closePosition(positionId);

      // Clean up
      priceFeed.removeFromWatchList(position.mint);
      this.positions.delete(positionId);

      this.emit('positionClosed', {
        position,
        reason,
        exitPrice,
        pnlSol: totalPnlSol,
        pnlPercent,
        result,
        partialClosePnl: position.realizedPnl || 0,
        finalClosePnl,
        actualSolReceived: solReceived,
      });

      logger.info({
        positionId,
        reason,
        exitPrice,
        partialClosePnl: (position.realizedPnl || 0).toFixed(6),
        finalClosePnl: finalClosePnl.toFixed(6),
        totalPnlSol: totalPnlSol.toFixed(6),
        pnlPercent: pnlPercent.toFixed(2),
      }, 'Position closed');
    } else {
      position.status = 'open'; // Revert status
      logger.error({
        positionId,
        reason,
        error: result.error,
      }, 'Failed to close position');
    }
  }

  private async persistPosition(position: Position): Promise<void> {
    await repository.upsertPosition({
      id: position.id,
      mint: position.mint,
      symbol: position.symbol,
      entry_price: position.entryPrice,
      current_price: position.currentPrice,
      amount: position.amount,
      amount_sol: position.amountSol,
      entry_time: position.entryTime,
      highest_price: position.highestPrice,
      lowest_price: position.lowestPrice,
      stop_loss: position.stopLoss,
      take_profit_json: JSON.stringify(position.takeProfit),
      tp_sold_json: JSON.stringify(position.tpSold),
      status: position.status,
      pool_type: position.poolType,
    });
  }

  getPosition(id: string): Position | undefined {
    return this.positions.get(id);
  }

  getPositionByMint(mint: string): Position | undefined {
    for (const position of this.positions.values()) {
      if (position.mint === mint && position.status === 'open') {
        return position;
      }
    }
    return undefined;
  }

  getOpenPositions(): Position[] {
    return Array.from(this.positions.values()).filter((p) => p.status === 'open');
  }

  getPositionCount(): number {
    return this.getOpenPositions().length;
  }

  getTotalExposure(): number {
    return this.getOpenPositions().reduce((sum, p) => sum + p.amountSol, 0);
  }

  canOpenPosition(riskCheck: RiskCheckResult): boolean {
    return riskCheck.approved;
  }
}

export const positionManager = new PositionManager();
</file>

<file path="src/risk/types.ts">
export interface Position {
  id: string;
  mint: string;
  symbol: string;
  entryPrice: number;
  currentPrice: number;
  amount: number;
  amountSol: number;            // Initial SOL investment
  entryTime: Date;
  lastUpdate: Date;
  unrealizedPnl: number;
  unrealizedPnlPercent: number;
  highestPrice: number;
  lowestPrice: number;
  stopLoss: number;
  takeProfit: number[];
  tpSold: number[];             // Track which TP levels hit (legacy)
  trailingStop?: number;
  status: 'open' | 'closing' | 'closed';
  poolType: 'active' | 'high_risk';

  // NEW: Performance-based TP tracking
  initialRecovered: boolean;    // True after initial investment recovered at +50%
  scaledExitsTaken: number;     // Count of scaled exits taken after recovery
  initialInvestment: number;    // Original SOL amount for recovery calculation

  // NEW: Accumulated PnL from partial closes
  realizedPnl: number;          // Total realized PnL from partial closes
}

export interface CapitalAllocation {
  totalSol: number;
  reserveSol: number;         // Never trade
  activeSol: number;          // Normal trades
  highRiskSol: number;        // Meme plays
  inPositions: number;        // Currently allocated
  availableActive: number;    // Available for active pool
  availableHighRisk: number;  // Available for high risk pool
}

export interface DrawdownState {
  currentEquity: number;
  peakEquity: number;
  currentDrawdown: number;
  maxDrawdown: number;
  dailyPnl: number;
  dailyStartEquity: number;
  isPaused: boolean;
  pauseUntil?: Date;
  pauseReason?: string;
}

export interface RiskLimits {
  maxPositionSizeSol: number;
  maxConcurrentPositions: number;
  dailyLossLimit: number;
  maxDrawdownLimit: number;
  minPositionSizeSol: number;
}

export interface RiskCheckResult {
  approved: boolean;
  adjustedSize?: number;
  reason: string;
  warnings: string[];
}

export interface PortfolioMetrics {
  totalValue: number;
  totalPnl: number;
  totalPnlPercent: number;
  positionCount: number;
  avgPositionSize: number;
  largestPosition: number;
  exposure: number;           // Total in positions / total capital
}
</file>

<file path="src/scripts/analyze-wallets.ts">
import dotenv from 'dotenv';
dotenv.config();

import fs from 'fs';
import path from 'path';
import { Connection, PublicKey, ParsedTransactionWithMeta } from '@solana/web3.js';
import { config } from '../config/settings';

// === CONFIGURATION ===
const LOOKBACK_TX_LIMIT = 100; 
const RATE_LIMIT_DELAY = 1500; // Slower to be safe
const MIN_SOL_VOLUME = 0.1;

// === USER SCORING WEIGHTS ===
const SCORING = {
  WIN_RATE_WEIGHT: 0.25,
  ROI_WEIGHT: 0.30,
  CONSISTENCY_WEIGHT: 0.20,
  EARLY_ENTRY_WEIGHT: 0.15,
  TRADE_COUNT_WEIGHT: 0.10
};

interface Trade {
  mint: string;
  type: 'buy' | 'sell';
  amountSol: number;
  amountTokens: number;
  timestamp: number;
  signature: string;
}

interface WalletAnalysis {
  address: string;
  totalPnL: number;
  totalSolSpent: number;
  winRate: number;
  roi: number;
  totalTrades: number;
  profitableTokens: number;
  tokensTraded: number;
  avgHoldTime: number; // Seconds
  walletAgeDays: number;
  compositeScore: number;
  verdict: 'KEEP' | 'DISCARD';
  tier: 'High' | 'Medium' | 'Low';
  flags: string[];
}

async function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function analyzeWallets() {
  console.log('ðŸ•µï¸  Starting Advanced Wallet Analysis (Composite Scorer)...');

  // 1. Read wallets from wallet.md
  const walletFile = path.join(process.cwd(), 'wallet.md');
  if (!fs.existsSync(walletFile)) {
    console.error('âŒ wallet.md not found!');
    process.exit(1);
  }

  const content = fs.readFileSync(walletFile, 'utf-8');
  const wallets = content
    .split('\n')
    .map(l => l.trim())
    .filter(l => /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(l));

  if (wallets.length === 0) {
    console.error('âŒ No valid wallets found in wallet.md');
    process.exit(1);
  }

  console.log(`ðŸ“‹ Analyzing ${wallets.length} wallets against Composite Score...`);

  const connection = new Connection(config.solanaRpcUrl || `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`);
  const results: WalletAnalysis[] = [];

  // 2. Process each wallet
  for (let i = 0; i < wallets.length; i++) {
    const wallet = wallets[i];
    process.stdout.write(`\r[${i + 1}/${wallets.length}] Analyzing ${wallet.substring(0, 6)}... `);

    try {
      const stats = await processWallet(connection, wallet);
      results.push(stats);
      await sleep(RATE_LIMIT_DELAY); 
    } catch (error) {
      console.error(`\nâŒ Error analyzing ${wallet}:`, error);
    }
  }

  console.log('\n\n=== ðŸ“Š ANALYSIS RESULTS (Ranked by Score) ===');
  
  // Sort by Score
  results.sort((a, b) => b.compositeScore - a.compositeScore);

  console.table(results.map(r => ({
    Address: r.address.substring(0, 8) + '...',
    'Score': r.compositeScore.toFixed(0),
    'Verdict': r.verdict,
    'Win Rate': (r.winRate * 100).toFixed(0) + '%',
    'ROI': (r.roi * 100).toFixed(0) + '%',
    'PnL (SOL)': r.totalPnL.toFixed(1),
    'Tokens': `${r.profitableTokens}/${r.tokensTraded}`,
    'Flags': r.flags.join(', ')
  })));

  // Recommendation
  const keepers = results.filter(r => r.verdict === 'KEEP').map(r => r.address);
  console.log(`\nâœ… Recommended Keepers (${keepers.length}):`);
  if (keepers.length > 0) {
    console.log(keepers.join(','));
  } else {
    console.log('None passed the strict criteria.');
  }

  // Generate Report File
  const reportPath = path.join(process.cwd(), 'analysis_report.md');
  let reportContent = '# ðŸ“Š Wallet Analysis Report\n\n';
  reportContent += `**Generated:** ${new Date().toISOString()}\n`;
  reportContent += `**Total Wallets Analyzed:** ${results.length}\n`;
  reportContent += `**Keepers Found:** ${keepers.length}\n\n`;
  
  reportContent += '| Address | Score | Verdict | Win Rate | ROI | PnL | Tokens | Est. Hold Time | Flags |\n';
  reportContent += '|---------|-------|---------|----------|-----|-----|--------|----------------|-------|\n';
  
  results.forEach(r => {
    reportContent += `| \`${r.address}\` | **${r.compositeScore.toFixed(0)}** | ${r.verdict === 'KEEP' ? 'âœ… KEEP' : 'Xu274 DISCARD'} | ${(r.winRate * 100).toFixed(0)}% | ${(r.roi * 100).toFixed(0)}% | ${r.totalPnL.toFixed(2)} SOL | ${r.profitableTokens}/${r.tokensTraded} | ${r.avgHoldTime.toFixed(0)}s | ${r.flags.join(', ')} |\n`;
  });

  reportContent += '\n## Metric Explanations\n';
  reportContent += '- **Score:** Composite rating (0-100) based on Win Rate, ROI, Consistency, and Profit.\n';
  reportContent += '- **Verdict:** KEEP if Score > 40 per user criteria.\n';
  reportContent += '- **Win Rate:** Percentage of tokens traded that resulted in profit.\n';
  reportContent += '- **ROI:** Total Profit / Total Cost (capped at 300% for scoring).\n';

  fs.writeFileSync(reportPath, reportContent);
  console.log(`\nðŸ“„ Detailed report saved to: ${reportPath}`);
}

async function processWallet(connection: Connection, address: string): Promise<WalletAnalysis> {
  const pubkey = new PublicKey(address);
  
  const signatures = await connection.getSignaturesForAddress(pubkey, { limit: LOOKBACK_TX_LIMIT });
  const trades: Trade[] = [];

  let oldestTxTime = Date.now() / 1000;
  let newestTxTime = 0;

  for (const sig of signatures) {
    if (sig.err) continue;
    if (sig.blockTime && sig.blockTime < oldestTxTime) oldestTxTime = sig.blockTime;
    if (sig.blockTime && sig.blockTime > newestTxTime) newestTxTime = sig.blockTime;

    try {
      const tx = await connection.getParsedTransaction(sig.signature, { maxSupportedTransactionVersion: 0 });
      if (!tx || !tx.meta) continue;

      const trade = extractTrade(tx, address);
      if (trade) trades.push(trade);
    } catch { /* ignore */ }
  }

  return calculateMetrics(address, trades, oldestTxTime);
}

function extractTrade(tx: ParsedTransactionWithMeta, walletAddress: string): Trade | null {
  // Simplified trade extraction (reuse from previous, but abbreviated here)
  const meta = tx.meta!;
  const accountKeys = tx.transaction.message.accountKeys;
  const walletIndex = accountKeys.findIndex((k) => k.pubkey.toString() === walletAddress);
  if (walletIndex === -1) return null;

  const solChange = (meta.postBalances[walletIndex] - meta.preBalances[walletIndex]) / 1e9;
  
  // Find token change
  const preToken = meta.preTokenBalances?.filter(t => t.owner === walletAddress) || [];
  const postToken = meta.postTokenBalances?.filter(t => t.owner === walletAddress) || [];
  
  // Find largest token change
  let maxChange = 0; 
  let tradedMint = '';
  let tokenChangeAmount = 0;
  const changes = new Map<string, number>();

  preToken.forEach(t => changes.set(t.mint, -(t.uiTokenAmount.uiAmount || 0)));
  postToken.forEach(t => { const c = changes.get(t.mint)||0; changes.set(t.mint, c + (t.uiTokenAmount.uiAmount||0)); });

  for (const [mint, change] of changes.entries()) {
    if (Math.abs(change) > maxChange) { maxChange = Math.abs(change); tradedMint = mint; tokenChangeAmount = change; }
  }

  if (!tradedMint || Math.abs(solChange) < MIN_SOL_VOLUME) return null;

  if (solChange < 0 && tokenChangeAmount > 0) return { mint: tradedMint, type: 'buy', amountSol: Math.abs(solChange), amountTokens: tokenChangeAmount, timestamp: tx.blockTime||0, signature: tx.transaction.signatures[0] };
  if (solChange > 0 && tokenChangeAmount < 0) return { mint: tradedMint, type: 'sell', amountSol: Math.abs(solChange), amountTokens: Math.abs(tokenChangeAmount), timestamp: tx.blockTime||0, signature: tx.transaction.signatures[0] };
  return null;
}

function calculateMetrics(address: string, trades: Trade[], oldestTxTime: number): WalletAnalysis {
  // 1. Group by token
  const tokens = new Map<string, { bought: number, sold: number, entryTime: number, exitTime: number }>();
  
  trades.forEach(t => {
    if (!tokens.has(t.mint)) tokens.set(t.mint, { bought: 0, sold: 0, entryTime: t.timestamp, exitTime: t.timestamp });
    const stat = tokens.get(t.mint)!;
    if (t.type === 'buy') {
      stat.bought += t.amountSol;
      if (t.timestamp < stat.entryTime) stat.entryTime = t.timestamp;
    } else {
      stat.sold += t.amountSol;
      if (t.timestamp > stat.exitTime) stat.exitTime = t.timestamp;
    }
  });

  // 2. Score Components
  let totalPnL = 0;
  let totalSolSpent = 0;
  let profitableTokens = 0;
  let holdTimes: number[] = [];

  tokens.forEach(stat => {
    if (stat.bought > 0) {
      const pnl = stat.sold - stat.bought;
      totalPnL += pnl;
      totalSolSpent += stat.bought;
      if (pnl > 0) profitableTokens++;
      
      // Est hold time
      if (stat.sold > 0) holdTimes.push(stat.exitTime - stat.entryTime);
    }
  });

  const numTokens = tokens.size;
  const avgHoldTime = holdTimes.length > 0 ? holdTimes.reduce((a,b)=>a+b,0)/holdTimes.length : 0;
  const walletAgeDays = (Date.now()/1000 - oldestTxTime) / 86400;

  // 3. Normalized Scores
  const winRate = numTokens > 0 ? profitableTokens / numTokens : 0;
  const roi = totalSolSpent > 0 ? totalPnL / totalSolSpent : 0;
  
  // ROI Score: Cap at 300% (3.0) -> 30 pts
  const roiScore = Math.min(Math.max(roi, 0), 3.0) * 10; // 0 to 30

  // Win Rate Score: 0-100% -> 0-25 pts
  const winRateScore = winRate * 25;

  // Consistency: >2 profitable tokens -> max 20 pts
  const consistencyScore = Math.min(profitableTokens, 5) * 4; // 5 tokens = 20 pts

  // Trade Count: Capped at 50 -> 10 pts
  const tradeCountScore = Math.min(trades.length, 50) / 5; // 50 txs = 10 pts
  
  // Early Entry (Cannot easily calc historically for all tokens, assuming neutral for analyze phase)
  const earlyEntryScore = 7.5; // Give average

  const compositeScore = winRateScore + roiScore + consistencyScore + tradeCountScore + earlyEntryScore;

  // 4. Flags & Verdict
  const flags: string[] = [];
  if (avgHoldTime < 60 && numTokens > 2) flags.push('MEV/Bot');
  if (walletAgeDays < 7) flags.push('Fresh Wallet');
  if (numTokens < 3) flags.push('Low Sample');

  let verdict: 'KEEP' | 'DISCARD' = 'DISCARD';
  // Keep if Score > 50 AND no critical flags
  if (compositeScore > 50 && avgHoldTime > 60) {
    verdict = 'KEEP';
  }

  return {
    address,
    totalPnL,
    totalSolSpent,
    winRate,
    roi,
    totalTrades: trades.length,
    profitableTokens,
    tokensTraded: numTokens,
    avgHoldTime,
    walletAgeDays,
    compositeScore,
    verdict,
    tier: compositeScore > 80 ? 'High' : (compositeScore > 50 ? 'Medium' : 'Low'),
    flags
  };
}

analyzeWallets();
</file>

<file path="src/scripts/discover-whales.ts">
import dotenv from 'dotenv';
dotenv.config();

import { Connection, PublicKey, ParsedTransactionWithMeta } from '@solana/web3.js';
import { config } from '../config/settings';

// === CONFIGURATION ===
const SCAN_LIMIT = 2000;           // Be aggressive: Scan last 2000 txs (approx 10-20 mins on active meme)
const MIN_REALIZED_PROFIT = 1.0;   // Loose Tier: At least 1 SOL profit banked
const MIN_TRADE_SIZE = 0.5;        // Medium Tier: Ignore < 0.5 SOL trades

interface WalletStats {
  address: string;
  solSpent: number;     // Cost Basis (Buys)
  solReceived: number;  // Realized Gains (Sells)
  tokenBought: number;
  tokenSold: number;
  txCount: number;
  isEarly: boolean;     // Heuristic: Sold but never bought in this window (implies bought before)
  firstActionTime: number;
}

async function discoverWhales(mintAddress: string) {
  console.log(`\nðŸ•µï¸  Deep Scanning Token: ${mintAddress}`);
  console.log(`    Strategy: Realized PnL Analysis (Last ${SCAN_LIMIT} txs)`);
  
  const connection = new Connection(config.solanaRpcUrl || `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`);
  
  try {
    const mintPubkey = new PublicKey(mintAddress);
    
    // 1. Fetch Transaction History (Batching to respect limits)
    console.log(`\nâ³ Fetching transaction history...`);
    let signatures: string[] = [];
    let lastSig: string | undefined = undefined;
    
    while (signatures.length < SCAN_LIMIT) {
      const batch = await connection.getSignaturesForAddress(mintPubkey, { 
        limit: 1000, 
        before: lastSig 
      });
      
      if (batch.length === 0) break;
      
      batch.forEach(s => signatures.push(s.signature));
      lastSig = batch[batch.length - 1].signature;
      
      process.stdout.write(`\r    Fetched ${signatures.length} signatures...`);
      if (batch.length < 1000) break; // Reached end of history
    }
    console.log(`\n    âœ… Scan complete. Found ${signatures.length} transactions.`);

    // 2. Analyze Transactions & Build Ledgers
    console.log(`\nðŸ§® reconstructing ledger & calculating PnL...`);
    const wallets = new Map<string, WalletStats>();
    
    // Process in chunks to avoid rate limits
    const CHUNK_SIZE = 50; 
    for (let i = 0; i < signatures.length; i += CHUNK_SIZE) {
      const chunk = signatures.slice(i, i + CHUNK_SIZE);
      process.stdout.write(`\r    Processing tx ${i + 1} to ${Math.min(i + CHUNK_SIZE, signatures.length)}...`);
      
      const txs = await connection.getParsedTransactions(chunk, { 
        maxSupportedTransactionVersion: 0 
      });

      for (const tx of txs) {
        if (!tx || !tx.meta) continue;
        analyzeTransaction(tx, mintAddress, wallets);
      }
      
      // Safety delay for RPC
      await new Promise(r => setTimeout(r, 100));
    }

    // 3. Filter & Rank Candidates
    const candidates = Array.from(wallets.values())
      .map(stats => {
        const realizedPnL = stats.solReceived - stats.solSpent;
        // If they sold more tokens than they bought in this window, 
        // it means they entered BEFORE this window.
        // We assume their "Cost" for those extra tokens was effectively 0 (or low) 
        // relative to current price, so the PnL is valid "Realized" gains from this pump.
        return { ...stats, realizedPnL };
      })
      .filter(w => {
        // FILTER LOGIC
        if (w.realizedPnL < MIN_REALIZED_PROFIT) return false; // Must be profitable
        if (w.solReceived < MIN_TRADE_SIZE && w.solSpent < MIN_TRADE_SIZE) return false; // Ignore dust
        return true;
      })
      .sort((a, b) => b.realizedPnL - a.realizedPnL); // Rank by highest profit

    // 4. Output Results
    console.log(`\n\nðŸ† TOP PROFITABLE WALLETS (Last 2000 Txs)`);
    console.log(`   Criteria: Realized PnL > ${MIN_REALIZED_PROFIT} SOL`);

    if (candidates.length === 0) {
      console.log('   âŒ No whales found matching criteria. Analysis suggests this might be new or PVP.');
      return;
    }

    const tableData = candidates.slice(0, 15).map(c => ({
      Address: c.address,
      'Realized PnL': `${c.realizedPnL.toFixed(2)} SOL`,
      'Est. ROI': c.solSpent > 0 ? `${((c.realizedPnL / c.solSpent) * 100).toFixed(0)}%` : 'EARLY',
      'Action': c.solSpent === 0 ? 'SOLD ONLY' : (c.solReceived === 0 ? 'BOUGHT ONLY' : 'TRADED'),
      'Tx Count': c.txCount
    }));

    console.table(tableData);
    
    // Output clean list for .env
    console.log('\nðŸ‘‡ COPY THIS LIST FOR YOUR .env:');
    const cleanList = candidates.slice(0, 15).map(c => c.address).join(',');
    console.log(`COPY_TRADE_WALLETS="${cleanList}"`);

  } catch (error) {
    console.error('\nâŒ Discovery failed:', error);
  }
}

function analyzeTransaction(tx: ParsedTransactionWithMeta, mint: string, wallets: Map<string, WalletStats>) {
  if (!tx.meta) return;
  
  // Identify who traded using pre/post balances
  // Strategy: Scan all token balance changes.
  
  const tokenBalances = [
    ...(tx.meta.preTokenBalances || []),
    ...(tx.meta.postTokenBalances || [])
  ];
  
  // Get unique owners involved with THIS token
  const owners = new Set<string>();
  tokenBalances.forEach(tb => {
    if (tb.mint === mint && tb.owner) owners.add(tb.owner);
  });

  for (const owner of owners) {
    // Determine Token Change
    const preToken = tx.meta.preTokenBalances?.find(t => t.owner === owner && t.mint === mint)?.uiTokenAmount.uiAmount || 0;
    const postToken = tx.meta.postTokenBalances?.find(t => t.owner === owner && t.mint === mint)?.uiTokenAmount.uiAmount || 0;
    const tokenChange = postToken - preToken;
    
    if (tokenChange === 0) continue; // No movement for this user

    // Determine SOL Change (Cost/Revenue)
    // Find account index
    const accountIndex = tx.transaction.message.accountKeys.findIndex(k => k.pubkey.toString() === owner);
    if (accountIndex === -1) continue;

    const preSol = tx.meta.preBalances[accountIndex] || 0;
    const postSol = tx.meta.postBalances[accountIndex] || 0;
    const solChange = (postSol - preSol) / 1e9; // Lamports back to SOL
    
    // Ignore gas-only changes (approx < 0.01 SOL change with no token movement? No, we checked token movement)
    // Actually, SOL change might include other transfers, but usually accurate enough for swaps.
    
    let stats = wallets.get(owner) || {
      address: owner,
      solSpent: 0,
      solReceived: 0,
      tokenBought: 0,
      tokenSold: 0,
      txCount: 0,
      isEarly: false,
      firstActionTime: tx.blockTime || Date.now()/1000
    };
    
    stats.txCount++;
    if (tx.blockTime && tx.blockTime < stats.firstActionTime) stats.firstActionTime = tx.blockTime;

    if (tokenChange > 0) {
      // BUY: Gained Token, Spent SOL (solChange negative)
      stats.tokenBought += tokenChange;
      if (solChange < 0) stats.solSpent += Math.abs(solChange);
    } else {
      // SELL: Lost Token, Gained SOL (solChange positive)
      stats.tokenSold += Math.abs(tokenChange);
      if (solChange > 0) stats.solReceived += solChange;
    }
    
    wallets.set(owner, stats);
  }
}

const mintArg = process.argv[2];
if (!mintArg) {
  console.log('Usage: npm run discover <MINT_ADDRESS>');
  process.exit(1);
}

discoverWhales(mintArg);
</file>

<file path="src/scripts/find-smart-wallets.ts">
import dotenv from 'dotenv';
dotenv.config();

import { Connection, PublicKey, ParsedTransactionWithMeta } from '@solana/web3.js';
import { config } from '../config/settings';

// === CONFIGURATION ===
// Phase 1: Discovery
const DISCOVERY_ScanLimit = 2000;
const DISCOVERY_MinProfit = 0.1; 
const DISCOVERY_MinSize = 0.1;

// Phase 2: Analysis
const ANALYSIS_Lookback = 100;
const ANALYSIS_RateLimit = 1500;

// Scoring Weights
const SCORING = {
  WIN_RATE_WEIGHT: 0.25,
  ROI_WEIGHT: 0.30,
  CONSISTENCY_WEIGHT: 0.20,
  EARLY_ENTRY_WEIGHT: 0.15,
  TRADE_COUNT_WEIGHT: 0.10
};

// === TYPES ===
interface WalletStats {
  address: string;
  solSpent: number;
  solReceived: number;
  tokenBought: number;
  tokenSold: number;
  txCount: number;
  realizedPnL: number;
}

interface WalletAnalysis {
  address: string;
  totalPnL: number;
  totalSolSpent: number;
  winRate: number;
  roi: number;
  totalTrades: number;
  profitableTokens: number;
  tokensTraded: number;
  avgHoldTime: number;
  walletAgeDays: number;
  compositeScore: number;
  verdict: 'KEEP' | 'DISCARD';
  tier: 'High' | 'Medium' | 'Low';
  flags: string[];
}

interface Trade {
  mint: string;
  type: 'buy' | 'sell';
  amountSol: number;
  amountTokens: number;
  timestamp: number;
  signature: string;
}

// === MAIN ENTRY POINT ===
async function main() {
  const mintArg = process.argv[2];
  if (!mintArg) {
    console.log('Usage: npm run find-whales <MINT_ADDRESS>');
    process.exit(1);
  }

  const connection = new Connection(config.solanaRpcUrl || `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`);
  
  console.log(`\nðŸš€ STARTING SMART WALLET HUNT`);
  console.log(`   Target Token: ${mintArg}`);

  // --- PHASE 1: DISCOVERY ---
  console.log(`\n=== PHASE 1: DISCOVERY (Scanning last ${DISCOVERY_ScanLimit} txs) ===`);
  const candidates = await discoverCandidates(connection, mintArg);
  
  if (candidates.length === 0) {
    console.log('âŒ No profitable candidates found on this token.');
    return;
  }
  
  console.log(`\nâœ… Found ${candidates.length} profitable candidates. Proceeding to vetting...`);

  // --- PHASE 2: ANALYSIS ---
  console.log(`\n=== PHASE 2: VETTING (Checking consistency across ${ANALYSIS_Lookback} txs) ===`);
  const results: WalletAnalysis[] = [];

  for (let i = 0; i < candidates.length; i++) {
    const candidate = candidates[i];
    process.stdout.write(`\r[${i + 1}/${candidates.length}] Vetting ${candidate.address.substring(0, 6)}... `);
    
    try {
      // Analyze full history
      const stats = await analyzeWallet(connection, candidate.address);
      results.push(stats);
      await sleep(ANALYSIS_RateLimit);
    } catch (e) {
      console.error(`Error: ${e}`);
    }
  }

  // --- OUTPUT ---
  console.log('\n\n=== ðŸ† FINAL RESULTS: HIGH QUALITY WALLETS ===');
  
  // Filter for keepers and sort by score
  const keepers = results
    .filter(r => r.verdict === 'KEEP')
    .sort((a, b) => b.compositeScore - a.compositeScore);

  if (keepers.length === 0) {
    console.log('âŒ No wallets passed the strict vetting criteria needed for copy trading.');
    console.log('   (Many might have profited on this token but failed consistency checks).');
  } else {
    console.table(keepers.map(r => ({
      Address: r.address,
      'Score': r.compositeScore.toFixed(0),
      'Tier': r.tier,
      'Win Rate': (r.winRate * 100).toFixed(0) + '%',
      'Total ROI': (r.roi * 100).toFixed(0) + '%',
      'PnL (SOL)': r.totalPnL.toFixed(1),
      'Tokens': `${r.profitableTokens}/${r.tokensTraded}`
    })));

    const cleanList = keepers.map(r => r.address).join(',');
    console.log('\nðŸ‘‡ COPY THIS LIST FOR YOUR .env:');
    console.log(`COPY_TRADE_WALLETS="${cleanList}"`);
  }
}

// === PHASE 1 LOGIC ===
async function discoverCandidates(connection: Connection, mintAddress: string): Promise<WalletStats[]> {
  const mintPubkey = new PublicKey(mintAddress);
  let signatures: string[] = [];
  let lastSig: string | undefined = undefined;

  // 1. Fetch History
  while (signatures.length < DISCOVERY_ScanLimit) {
    const batch = await connection.getSignaturesForAddress(mintPubkey, { limit: 1000, before: lastSig });
    if (batch.length === 0) break;
    batch.forEach(s => signatures.push(s.signature));
    lastSig = batch[batch.length - 1].signature;
    process.stdout.write(`\r    Fetched ${signatures.length} signatures...`);
  }

  // 2. Build Ledger
  const wallets = new Map<string, WalletStats>();
  const CHUNK_SIZE = 50;
  
  for (let i = 0; i < signatures.length; i += CHUNK_SIZE) {
    const chunk = signatures.slice(i, i + CHUNK_SIZE);
    // process.stdout.write(`\r    Processing batch ${i}...`);
    const txs = await connection.getParsedTransactions(chunk, { maxSupportedTransactionVersion: 0 });
    
    for (const tx of txs) {
      if (!tx || !tx.meta) continue;
      
      const tokenBalances = [...(tx.meta.preTokenBalances || []), ...(tx.meta.postTokenBalances || [])];
      const owners = new Set<string>();
      tokenBalances.forEach(tb => { if (tb.mint === mintAddress && tb.owner) owners.add(tb.owner); });

      for (const owner of owners) {
        // Calculate Changes
        const preToken = tx.meta.preTokenBalances?.find(t => t.owner === owner && t.mint === mintAddress)?.uiTokenAmount.uiAmount || 0;
        const postToken = tx.meta.postTokenBalances?.find(t => t.owner === owner && t.mint === mintAddress)?.uiTokenAmount.uiAmount || 0;
        const tokenChange = postToken - preToken;
        if (tokenChange === 0) continue;

        const accountIndex = tx.transaction.message.accountKeys.findIndex(k => k.pubkey.toString() === owner);
        if (accountIndex === -1) continue;
        const solChange = ((tx.meta.postBalances[accountIndex] || 0) - (tx.meta.preBalances[accountIndex] || 0)) / 1e9;

        let stats = wallets.get(owner) || { address: owner, solSpent: 0, solReceived: 0, tokenBought: 0, tokenSold: 0, txCount: 0, realizedPnL: 0 };
        stats.txCount++;

        if (tokenChange > 0) { // BUY
          stats.tokenBought += tokenChange;
          if (solChange < 0) stats.solSpent += Math.abs(solChange);
        } else { // SELL
          stats.tokenSold += Math.abs(tokenChange);
          if (solChange > 0) stats.solReceived += solChange;
        }
        wallets.set(owner, stats);
      }
    }
  }

  // 3. Filter
  return Array.from(wallets.values())
    .map(w => ({ ...w, realizedPnL: w.solReceived - w.solSpent }))
    .filter(w => w.realizedPnL > DISCOVERY_MinProfit && (w.solReceived > DISCOVERY_MinSize || w.solSpent > DISCOVERY_MinSize))
    .sort((a, b) => b.realizedPnL - a.realizedPnL)
    .slice(0, 30); // Take top 30 candidates max to vet
}

// === PHASE 2 LOGIC ===
async function analyzeWallet(connection: Connection, address: string): Promise<WalletAnalysis> {
  const pubkey = new PublicKey(address);
  // Fetch signatures
  const signatures = await connection.getSignaturesForAddress(pubkey, { limit: ANALYSIS_Lookback });
  const trades: Trade[] = [];
  let oldestTxTime = Date.now() / 1000;

  // Batch Fetch Transactions (Optimized with Chunking)
  const txIds = signatures.map(s => s.signature);
  const CHUNK_SIZE = 25;
  const txs: (ParsedTransactionWithMeta | null)[] = [];

  for (let i = 0; i < txIds.length; i += CHUNK_SIZE) {
    const chunk = txIds.slice(i, i + CHUNK_SIZE);
    const chunkTxs = await connection.getParsedTransactions(chunk, { maxSupportedTransactionVersion: 0 });
    txs.push(...chunkTxs);
    await sleep(500); // Delay between chunks to respect rate limits
  }

  for (let i = 0; i < txs.length; i++) {
    const tx = txs[i];
    const sig = signatures[i];
    
    if (sig.err) continue;
    if (sig.blockTime && sig.blockTime < oldestTxTime) oldestTxTime = sig.blockTime;

    if (!tx || !tx.meta) continue;

    try {
      // Extract Trade (Simplified)
      const walletIndex = tx.transaction.message.accountKeys.findIndex(k => k.pubkey.toString() === address);
      if (walletIndex === -1) continue;
      
      const solChange = ((tx.meta.postBalances[walletIndex] - tx.meta.preBalances[walletIndex]) / 1e9);
      
      const preTok = tx.meta.preTokenBalances?.filter(t => t.owner === address) || [];
      const postTok = tx.meta.postTokenBalances?.filter(t => t.owner === address) || [];
      
      let bigMint = '', bigChange = 0;
      const changes = new Map<string, number>();
      preTok.forEach(t => changes.set(t.mint, -(t.uiTokenAmount.uiAmount||0)));
      postTok.forEach(t => { const v = changes.get(t.mint)||0; changes.set(t.mint, v + (t.uiTokenAmount.uiAmount||0)); });
      
      for (const [m, c] of changes.entries()) { if(Math.abs(c)>Math.abs(bigChange)) { bigChange=c; bigMint=m; } }

      if (bigMint && Math.abs(solChange) > 0.05) {
        if (solChange < 0 && bigChange > 0) trades.push({ mint: bigMint, type: 'buy', amountSol: Math.abs(solChange), amountTokens: bigChange, timestamp: tx.blockTime||0, signature: sig.signature });
        if (solChange > 0 && bigChange < 0) trades.push({ mint: bigMint, type: 'sell', amountSol: Math.abs(solChange), amountTokens: Math.abs(bigChange), timestamp: tx.blockTime||0, signature: sig.signature });
      }
    } catch {}
  }

  // Scoring
  const tokens = new Map<string, { bought: number, sold: number }>();
  trades.forEach(t => {
    if (!tokens.has(t.mint)) tokens.set(t.mint, { bought:0, sold:0 });
    const s = tokens.get(t.mint)!;
    if (t.type === 'buy') s.bought += t.amountSol; else s.sold += t.amountSol;
  });

  let totalPnL = 0, totalSolSpent = 0, profitableTokens = 0, holdTimes: number[] = [];
  tokens.forEach(s => {
    if (s.bought > 0) {
      const pnl = s.sold - s.bought;
      totalPnL += pnl;
      totalSolSpent += s.bought;
      if (pnl > 0) profitableTokens++;
    }
  });

  const numTokens = tokens.size;
  const winRate = numTokens > 0 ? profitableTokens / numTokens : 0;
  const roi = totalSolSpent > 0 ? totalPnL / totalSolSpent : 0;
  const compositeScore = (winRate * 25) + (Math.min(Math.max(roi,0),3)*10) + (Math.min(profitableTokens,5)*4) + (Math.min(trades.length,50)/5) + 7.5;
  
  const avgHoldTime = 120; // Defaulting for speed (calc omitted for brevity)
  const walletAgeDays = (Date.now()/1000 - oldestTxTime) / 86400;

  const flags: string[] = [];
  if (walletAgeDays < 7) flags.push('Fresh');
  if (numTokens < 3) flags.push('Low Sample');

  let verdict: 'KEEP' | 'DISCARD' = 'DISCARD';
  // Relaxed: Keep if Score > 40. Only ban MEV bots.
  if (compositeScore > 40 && !flags.includes('MEV/Bot')) {
    verdict = 'KEEP';
  }

  return {
    address, totalPnL, totalSolSpent, winRate, roi, totalTrades: trades.length,
    profitableTokens, tokensTraded: numTokens, avgHoldTime, walletAgeDays,
    compositeScore, verdict, tier: compositeScore > 80 ? 'High' : (compositeScore>50?'Medium':'Low'), flags
  };
}

function sleep(ms: number) { return new Promise(r => setTimeout(r, ms)); }

main();
</file>

<file path="src/services/equity-tracker.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { walletSync } from './wallet-sync';
import { positionManager } from '../risk/position-manager';
import { priceFeed } from '../data/price-feed';
import { repository } from '../db/repository';

const logger = createChildLogger('equity-tracker');

export interface EquitySnapshot {
  timestamp: Date;
  walletBalanceSol: number;
  positionsValueSol: number;
  totalEquitySol: number;
  unrealizedPnlSol: number;
  positionCount: number;
  source: 'periodic' | 'trade_close' | 'startup';
}

export class EquityTracker extends EventEmitter {
  private snapshotInterval: NodeJS.Timeout | null = null;
  private isRunning = false;
  private recentSnapshots: EquitySnapshot[] = [];
  private maxRecentSnapshots = 1440; // 24 hours at 1 minute intervals

  constructor() {
    super();
  }

  async start(intervalMs: number = 60000): Promise<void> {
    if (this.isRunning) {
      logger.warn('Equity tracker already running');
      return;
    }

    this.isRunning = true;

    // Initial snapshot
    await this.takeSnapshot('startup');

    // Start periodic snapshots
    this.snapshotInterval = setInterval(async () => {
      try {
        await this.takeSnapshot('periodic');
      } catch (error) {
        logger.error({ error }, 'Failed to take equity snapshot');
      }
    }, intervalMs);

    logger.info({ intervalMs }, 'Equity tracker started');
  }

  stop(): void {
    if (this.snapshotInterval) {
      clearInterval(this.snapshotInterval);
      this.snapshotInterval = null;
    }
    this.isRunning = false;
    logger.info('Equity tracker stopped');
  }

  async takeSnapshot(source: 'periodic' | 'trade_close' | 'startup'): Promise<EquitySnapshot> {
    // Get wallet SOL balance
    const walletState = walletSync.getState();
    const walletBalanceSol = walletState?.solBalance || 0;

    // Calculate position values
    const positions = positionManager.getOpenPositions();
    let positionsValueSol = 0;
    let unrealizedPnlSol = 0;

    for (const position of positions) {
      // Get current price
      const priceData = priceFeed.getPrice(position.mint);
      const currentPrice = priceData?.priceSol || position.currentPrice;

      // Calculate current value
      const currentValue = position.amount * currentPrice;
      positionsValueSol += currentValue;

      // Calculate unrealized PnL
      const entryValue = position.amountSol;
      unrealizedPnlSol += currentValue - entryValue;
    }

    // Total equity = wallet SOL + position values
    const totalEquitySol = walletBalanceSol + positionsValueSol;

    const snapshot: EquitySnapshot = {
      timestamp: new Date(),
      walletBalanceSol,
      positionsValueSol,
      totalEquitySol,
      unrealizedPnlSol,
      positionCount: positions.length,
      source,
    };

    // Save to database
    await repository.insertEquitySnapshot({
      wallet_balance_sol: snapshot.walletBalanceSol,
      positions_value_sol: snapshot.positionsValueSol,
      total_equity_sol: snapshot.totalEquitySol,
      unrealized_pnl_sol: snapshot.unrealizedPnlSol,
      position_count: snapshot.positionCount,
      source: snapshot.source,
    });

    // Add to recent snapshots
    this.recentSnapshots.push(snapshot);
    if (this.recentSnapshots.length > this.maxRecentSnapshots) {
      this.recentSnapshots.shift();
    }

    // Emit event
    this.emit('snapshot', snapshot);

    logger.debug({
      walletSol: walletBalanceSol.toFixed(4),
      positionsValue: positionsValueSol.toFixed(4),
      totalEquity: totalEquitySol.toFixed(4),
      unrealizedPnl: unrealizedPnlSol.toFixed(4),
      positionCount: positions.length,
      source,
    }, 'Equity snapshot taken');

    return snapshot;
  }

  // Called when a trade closes to capture the equity change
  async onTradeClose(): Promise<void> {
    await this.takeSnapshot('trade_close');
  }

  getRecentSnapshots(): EquitySnapshot[] {
    return [...this.recentSnapshots];
  }

  async getEquityHistory(hours: number = 24): Promise<EquitySnapshot[]> {
    const dbSnapshots = await repository.getEquityHistory(hours);

    return dbSnapshots.map((s) => ({
      timestamp: new Date(s.timestamp),
      walletBalanceSol: parseFloat(s.wallet_balance_sol.toString()),
      positionsValueSol: parseFloat(s.positions_value_sol.toString()),
      totalEquitySol: parseFloat(s.total_equity_sol.toString()),
      unrealizedPnlSol: parseFloat(s.unrealized_pnl_sol.toString()),
      positionCount: s.position_count,
      source: s.source,
    }));
  }

  getLatestSnapshot(): EquitySnapshot | null {
    if (this.recentSnapshots.length === 0) return null;
    return this.recentSnapshots[this.recentSnapshots.length - 1];
  }

  getCurrentEquity(): number {
    const latest = this.getLatestSnapshot();
    return latest?.totalEquitySol || 0;
  }

  // Calculate equity change over a period
  getEquityChange(hours: number = 24): { changeSol: number; changePercent: number } {
    const cutoffTime = Date.now() - hours * 60 * 60 * 1000;
    const oldSnapshot = this.recentSnapshots.find((s) => s.timestamp.getTime() >= cutoffTime);
    const currentSnapshot = this.getLatestSnapshot();

    if (!oldSnapshot || !currentSnapshot) {
      return { changeSol: 0, changePercent: 0 };
    }

    const changeSol = currentSnapshot.totalEquitySol - oldSnapshot.totalEquitySol;
    const changePercent = oldSnapshot.totalEquitySol > 0
      ? (changeSol / oldSnapshot.totalEquitySol) * 100
      : 0;

    return { changeSol, changePercent };
  }
}

export const equityTracker = new EquityTracker();
</file>

<file path="src/services/index.ts">
export { walletSync, WalletSync, WalletState, TokenDiscrepancy, SyncResult } from './wallet-sync';
export { equityTracker, EquityTracker, EquitySnapshot } from './equity-tracker';
export { positionReconciler, PositionReconciler, PhantomPosition, OrphanToken, ReconciliationResult } from './position-reconciler';
</file>

<file path="src/services/position-reconciler.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { txManager } from '../execution/tx-manager';
import { positionManager } from '../risk/position-manager';
import { priceFeed } from '../data/price-feed';
import { repository } from '../db/repository';

const logger = createChildLogger('position-reconciler');

export interface PhantomPosition {
  positionId: string;
  mint: string;
  symbol: string;
  expectedAmount: number;
  actualAmount: number;
  amountSol: number;
  entryTime: Date;
}

export interface OrphanToken {
  mint: string;
  balance: number;
  estimatedValueSol: number;
}

export interface ReconciliationResult {
  phantomsFound: PhantomPosition[];
  orphansFound: OrphanToken[];
  phantomsClosed: number;
  reconciliationTime: Date;
}

export class PositionReconciler extends EventEmitter {
  private isRunning = false;

  constructor() {
    super();
  }

  async reconcile(autoClose: boolean = true): Promise<ReconciliationResult> {
    if (this.isRunning) {
      logger.warn('Reconciliation already in progress');
      return {
        phantomsFound: [],
        orphansFound: [],
        phantomsClosed: 0,
        reconciliationTime: new Date(),
      };
    }

    this.isRunning = true;
    const reconciliationTime = new Date();

    try {
      const phantomsFound: PhantomPosition[] = [];
      const orphansFound: OrphanToken[] = [];
      let phantomsClosed = 0;

      // Get all open positions
      const positions = positionManager.getOpenPositions();

      logger.info({ positionCount: positions.length }, 'Starting position reconciliation');

      // Check each position for phantom status
      for (const position of positions) {
        const actualBalance = await txManager.getTokenBalance(position.mint);

        // Position is phantom if we have position record but no tokens
        // Allow for small dust amounts (less than 0.1% of expected)
        const minTokenThreshold = position.amount * 0.001;

        if (actualBalance < minTokenThreshold) {
          const phantom: PhantomPosition = {
            positionId: position.id,
            mint: position.mint,
            symbol: position.symbol,
            expectedAmount: position.amount,
            actualAmount: actualBalance,
            amountSol: position.amountSol,
            entryTime: position.entryTime,
          };

          phantomsFound.push(phantom);

          logger.warn({
            positionId: position.id,
            mint: position.mint.substring(0, 15),
            expectedAmount: position.amount.toFixed(4),
            actualAmount: actualBalance.toFixed(4),
          }, 'PHANTOM POSITION DETECTED - No tokens in wallet');

          // Auto-close phantom position
          if (autoClose) {
            try {
              // Delete from position manager memory
              await this.closePhantomPosition(position.id);
              phantomsClosed++;

              logger.info({
                positionId: position.id,
                mint: position.mint.substring(0, 15),
              }, 'Phantom position closed');
            } catch (error) {
              logger.error({ error, positionId: position.id }, 'Failed to close phantom position');
            }
          }
        }
      }

      // Emit events
      if (phantomsFound.length > 0) {
        this.emit('phantomsDetected', phantomsFound);

        // Send toast notification for dashboard
        this.emit('notification', {
          type: 'warning',
          title: 'Phantom Positions Detected',
          message: `Found ${phantomsFound.length} phantom position(s). ${phantomsClosed} auto-closed.`,
        });
      }

      if (orphansFound.length > 0) {
        this.emit('orphansDetected', orphansFound);
      }

      const result: ReconciliationResult = {
        phantomsFound,
        orphansFound,
        phantomsClosed,
        reconciliationTime,
      };

      logger.info({
        phantomsFound: phantomsFound.length,
        orphansFound: orphansFound.length,
        phantomsClosed,
      }, 'Reconciliation complete');

      return result;
    } finally {
      this.isRunning = false;
    }
  }

  private async closePhantomPosition(positionId: string): Promise<void> {
    const position = positionManager.getPosition(positionId);
    if (!position) {
      logger.warn({ positionId }, 'Position not found for phantom close');
      return;
    }

    // Log the phantom close as a loss (no SOL received since no tokens to sell)
    // Calculate the loss as the initial investment
    const pnlSol = -position.amountSol;

    // Remove from price feed watch list
    priceFeed.removeFromWatchList(position.mint);

    // Update database - mark as closed with phantom reason
    await repository.closePosition(positionId);

    // Log the trade exit as a phantom close
    await repository.updateTradeExit(positionId, {
      exit_price: 0,
      exit_time: new Date(),
      pnl_sol: pnlSol,
      pnl_percent: -100,
      duration_ms: Date.now() - position.entryTime.getTime(),
      exit_reason: 'phantom_close',
    });

    // Emit position closed event (for capital allocator etc)
    positionManager.emit('positionClosed', {
      position,
      reason: 'phantom_close',
      exitPrice: 0,
      pnlSol,
      pnlPercent: -100,
      result: { success: false, error: 'Phantom position - no tokens' },
    });

    logger.info({
      positionId,
      mint: position.mint.substring(0, 15),
      lostSol: position.amountSol.toFixed(4),
    }, 'Phantom position logged as loss');
  }

  // Check a single position for phantom status
  async checkPosition(positionId: string): Promise<boolean> {
    const position = positionManager.getPosition(positionId);
    if (!position) {
      return false;
    }

    const actualBalance = await txManager.getTokenBalance(position.mint);
    const minTokenThreshold = position.amount * 0.001;

    return actualBalance < minTokenThreshold;
  }

  // Get current phantom count without closing
  async getPhantomCount(): Promise<number> {
    const positions = positionManager.getOpenPositions();
    let phantomCount = 0;

    for (const position of positions) {
      const actualBalance = await txManager.getTokenBalance(position.mint);
      const minTokenThreshold = position.amount * 0.001;

      if (actualBalance < minTokenThreshold) {
        phantomCount++;
      }
    }

    return phantomCount;
  }
}

export const positionReconciler = new PositionReconciler();
</file>

<file path="src/services/wallet-sync.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { txManager } from '../execution/tx-manager';
import { positionManager } from '../risk/position-manager';
import { repository } from '../db/repository';

const logger = createChildLogger('wallet-sync');

export interface WalletState {
  solBalance: number;
  tokenBalances: Map<string, number>;
  lastSync: Date;
}

export interface TokenDiscrepancy {
  mint: string;
  positionId: string;
  expectedAmount: number;
  actualAmount: number;
  difference: number;
  percentDiff: number;
}

export interface SyncResult {
  solBalance: number;
  tokenPositions: { mint: string; expected: number; actual: number }[];
  discrepancies: TokenDiscrepancy[];
  syncTime: Date;
}

export class WalletSync extends EventEmitter {
  private syncInterval: NodeJS.Timeout | null = null;
  private lastState: WalletState | null = null;
  private isRunning = false;

  constructor() {
    super();
  }

  async start(intervalMs: number = 30000): Promise<void> {
    if (this.isRunning) {
      logger.warn('Wallet sync already running');
      return;
    }

    this.isRunning = true;

    // Initial sync
    await this.sync();

    // Start periodic sync
    this.syncInterval = setInterval(async () => {
      try {
        await this.sync();
      } catch (error) {
        logger.error({ error }, 'Wallet sync failed');
      }
    }, intervalMs);

    logger.info({ intervalMs }, 'Wallet sync started');
  }

  stop(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
    }
    this.isRunning = false;
    logger.info('Wallet sync stopped');
  }

  async sync(): Promise<SyncResult> {
    const syncTime = new Date();

    // Get actual SOL balance from wallet
    const solBalance = await txManager.getWalletBalance();

    // Get all open positions
    const positions = positionManager.getOpenPositions();

    // Get actual token balances for each position
    const tokenPositions: { mint: string; expected: number; actual: number }[] = [];
    const discrepancies: TokenDiscrepancy[] = [];
    const tokenBalances = new Map<string, number>();

    for (const position of positions) {
      const actualBalance = await txManager.getTokenBalance(position.mint);
      tokenBalances.set(position.mint, actualBalance);

      const expected = position.amount;
      const actual = actualBalance;

      tokenPositions.push({
        mint: position.mint,
        expected,
        actual,
      });

      // Check for significant discrepancy (more than 1% or position amount is 0)
      const difference = actual - expected;
      const percentDiff = expected > 0 ? (difference / expected) * 100 : (actual === 0 ? -100 : 100);

      if (Math.abs(percentDiff) > 1 || (expected > 0 && actual === 0)) {
        const discrepancy: TokenDiscrepancy = {
          mint: position.mint,
          positionId: position.id,
          expectedAmount: expected,
          actualAmount: actual,
          difference,
          percentDiff,
        };

        discrepancies.push(discrepancy);

        logger.warn({
          mint: position.mint.substring(0, 15),
          positionId: position.id,
          expected: expected.toFixed(4),
          actual: actual.toFixed(4),
          percentDiff: percentDiff.toFixed(2),
        }, 'Token balance discrepancy detected');
      }
    }

    // Update state
    this.lastState = {
      solBalance,
      tokenBalances,
      lastSync: syncTime,
    };

    // Log to database
    await repository.insertWalletSyncLog({
      sol_balance: solBalance,
      token_positions_json: JSON.stringify(tokenPositions),
      discrepancies_json: JSON.stringify(discrepancies),
    });

    // Emit events
    this.emit('synced', { solBalance, tokenPositions, discrepancies, syncTime });

    if (discrepancies.length > 0) {
      this.emit('discrepancies', discrepancies);
    }

    logger.debug({
      solBalance: solBalance.toFixed(4),
      positionCount: positions.length,
      discrepancyCount: discrepancies.length,
    }, 'Wallet synced');

    return {
      solBalance,
      tokenPositions,
      discrepancies,
      syncTime,
    };
  }

  getState(): WalletState | null {
    return this.lastState;
  }

  getSolBalance(): number {
    return this.lastState?.solBalance || 0;
  }

  getTokenBalance(mint: string): number {
    return this.lastState?.tokenBalances.get(mint) || 0;
  }

  getLastSyncTime(): Date | null {
    return this.lastState?.lastSync || null;
  }

  isHealthy(): boolean {
    if (!this.lastState) return false;

    // Check if last sync was within 2 minutes
    const timeSinceSync = Date.now() - this.lastState.lastSync.getTime();
    return timeSinceSync < 120000;
  }
}

export const walletSync = new WalletSync();
</file>

<file path="src/signals/axiom-sensor.ts">
import puppeteer, { Browser, Page } from 'puppeteer';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { createChildLogger } from '../utils/logger';
import path from 'path';

const logger = createChildLogger('axiom-sensor');

// Setup Gemini
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');
const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

export interface AxiomNarrativeSignal {
  sentiment: 'bullish' | 'bearish' | 'neutral';
  bullishnessScore: number;
  hypeScore: number;
  keywords: string[];
  tweetCount: number;
  sampleTweets: string[];
}

export class AxiomSensor {
  private browser: Browser | null = null;
  private page: Page | null = null;
  private readonly DASHBOARD_URL = 'https://axiom.trade/trackers?chain=sol';
  private headlessMode: boolean = false; // Set to true for headless once login is saved

  private findChrome(): string {
    // Find Chrome executable on Windows
    const possiblePaths = [
      process.env.CHROME_PATH || '',
      'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
      'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
      path.join(process.env.LOCALAPPDATA || '', 'Google', 'Chrome', 'Application', 'chrome.exe'),
    ];

    for (const chromePath of possiblePaths) {
      if (chromePath && require('fs').existsSync(chromePath)) {
        return chromePath;
      }
    }

    // Fallback - let Puppeteer find it
    return '';
  }

  async initialize(): Promise<void> {
    logger.info('Booting Axiom Sensor (Persistent Mode)...');

    // Use a dedicated profile directory for the bot
    const userDataDir = path.join(process.cwd(), 'puppeteer_data');
    const chromePath = this.findChrome();

    const launchOptions: Parameters<typeof puppeteer.launch>[0] = {
      headless: this.headlessMode,
      userDataDir,
      defaultViewport: null,
      args: [
        '--start-maximized',
        '--no-sandbox',
        '--disable-setuid-sandbox',
        // Enable extensions so you can install Phantom
        '--enable-extensions'
      ]
    };

    if (chromePath) {
      launchOptions.executablePath = chromePath;
    }

    logger.info({ chromePath, userDataDir }, 'Launching Chrome');
    this.browser = await puppeteer.launch(launchOptions);

    this.page = await this.browser.newPage();

    try {
      logger.info('Navigating to Axiom...');
      await this.page.goto(this.DASHBOARD_URL, { waitUntil: 'domcontentloaded', timeout: 30000 });

      // Smart Login Check - check if we need manual login
      await this.waitForLogin();

      // Dismiss any promo modals
      await this.dismissModals();

    } catch (e) {
      logger.error({ error: e }, 'Initialization failed');
    }
  }

  private async waitForLogin(): Promise<void> {
    if (!this.page) return;

    const currentUrl = this.page.url();

    // Check if we are on login/connect page or if Sign Up modal is visible
    const needsLogin = await this.page.evaluate(`(() => {
      const url = window.location.href;
      if (url.includes('login') || url.includes('connect')) return true;

      // Check for Sign Up modal
      const buttons = document.querySelectorAll('button');
      for (const btn of buttons) {
        if (btn.textContent?.includes('Sign Up') || btn.textContent?.includes('Connect with')) {
          return true;
        }
      }
      return false;
    })()`);

    if (needsLogin) {
      logger.warn('========================================');
      logger.warn('>>> ACTION REQUIRED <<<');
      logger.warn('Please log in manually in the browser window!');
      logger.warn('Waiting up to 120 seconds...');
      logger.warn('========================================');

      // Wait up to 120 seconds for the user to log in
      try {
        await this.page.waitForFunction(
          `(() => {
            // Check we're not on login page
            if (window.location.href.includes('login') || window.location.href.includes('connect')) {
              return false;
            }
            // Check Sign Up modal is gone
            const buttons = document.querySelectorAll('button');
            for (const btn of buttons) {
              if (btn.textContent === 'Sign Up') return false;
            }
            return true;
          })()`,
          { timeout: 120000 }
        );
        logger.info('Login detected! Session saved to ./puppeteer_data');
        logger.info('Future runs will be automatic.');
      } catch (e) {
        logger.error('Login timed out. Please run again and complete login.');
        throw new Error('Manual login timeout');
      }
    } else {
      logger.info('Already logged in (session restored from puppeteer_data)');
    }
  }

  private async dismissModals(): Promise<void> {
    if (!this.page) return;

    for (let attempt = 0; attempt < 3; attempt++) {
      try {
        await new Promise(r => setTimeout(r, 1000));

        const dismissed = await this.page.evaluate(`(() => {
          const buttons = document.querySelectorAll('button');
          for (const btn of buttons) {
            const text = btn.textContent?.toLowerCase() || '';
            if (text.includes('finish') || text.includes('close') || text.includes('skip') ||
                text.includes('got it') || text.includes('cancel') || text.includes('dismiss')) {
              btn.click();
              return true;
            }
          }
          return false;
        })()`);

        if (dismissed) {
          logger.debug({ attempt }, 'Dismissed modal');
        } else {
          break;
        }
      } catch (e) {
        break;
      }
    }
  }

  async scrapeFeed(): Promise<string[]> {
    if (!this.page) await this.initialize();

    try {
      // 1. Click "Twitter Alerts" tab
      try {
        await this.page!.waitForFunction(
          `(() => {
            const els = document.querySelectorAll('*');
            for (const el of els) {
              if (el.textContent === 'Twitter Alerts' ||
                  (el.textContent?.includes('Twitter Alerts') && el.textContent.length < 30)) {
                return true;
              }
            }
            return false;
          })()`,
          { timeout: 5000 }
        );

        await this.page!.evaluate(`(() => {
          const els = document.querySelectorAll('*');
          for (const el of els) {
            if (el.textContent === 'Twitter Alerts' ||
                (el.textContent?.includes('Twitter Alerts') && el.textContent.length < 30)) {
              el.click();
              break;
            }
          }
        })()`);

        await new Promise(r => setTimeout(r, 2000));
        logger.debug('Clicked Twitter Alerts tab');
      } catch (e) {
        logger.debug('Tab interaction skipped (might already be active)');
      }

      // 2. Scrape tweet-like content from the feed
      const tweets = await this.page!.evaluate(`(() => {
        const results = [];
        const allElements = document.querySelectorAll('div, span, p');

        for (const el of allElements) {
          const text = el.textContent?.trim() || '';
          if (text.length > 40 && text.length < 400) {
            // Filter out UI elements
            if (!text.includes('Connect Wallet') &&
                !text.includes('Live Trades') &&
                !text.includes('Sign Up') &&
                !text.includes('Settings') &&
                !text.includes('Discover') &&
                !text.includes('Trackers') &&
                !text.includes('Perpetuals')) {
              results.push(text);
            }
          }
        }
        return results;
      })()`) as string[];

      const uniqueTweets = Array.from(new Set(tweets)).slice(0, 15);

      if (uniqueTweets.length === 0) {
        logger.warn('No tweets found - check if Twitter Alerts tab is visible');
      } else {
        logger.info({ count: uniqueTweets.length }, 'Scraped Axiom Twitter feed');
      }

      return uniqueTweets;

    } catch (e) {
      logger.error({ error: e }, 'Scrape failed');
      return [];
    }
  }

  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
    }
    this.browser = null;
    this.page = null;
  }

  // Take a screenshot for debugging
  async takeScreenshot(filename: string = 'axiom-debug.png'): Promise<void> {
    if (!this.page) await this.initialize();
    await this.page!.screenshot({ path: filename, fullPage: false });
    logger.info({ path: filename }, 'Screenshot saved');
  }

  // --- GEMINI ANALYSIS ---
  async getMarketSignal(): Promise<AxiomNarrativeSignal> {
    const tweets = await this.scrapeFeed();

    if (tweets.length === 0) {
      return {
        sentiment: 'neutral',
        bullishnessScore: 0,
        hypeScore: 0,
        keywords: [],
        tweetCount: 0,
        sampleTweets: []
      };
    }

    const prompt = `Analyze these crypto tweets from a trading alpha feed.

Tweets:
${tweets.join('\n---\n')}

Return JSON only (no markdown):
{ "bullishnessScore": number (-1 to 1), "hypeScore": number (0 to 1), "keywords": string[] }`;

    try {
      const result = await model.generateContent(prompt);
      const text = result.response.text().replace(/```json|```/g, '').trim();
      const data = JSON.parse(text);

      return {
        sentiment: data.bullishnessScore > 0.2 ? 'bullish' : data.bullishnessScore < -0.2 ? 'bearish' : 'neutral',
        bullishnessScore: data.bullishnessScore,
        hypeScore: data.hypeScore,
        keywords: data.keywords || [],
        tweetCount: tweets.length,
        sampleTweets: tweets.slice(0, 3)
      };
    } catch (e) {
      logger.error({ error: e }, 'Gemini analysis failed');
      return {
        sentiment: 'neutral',
        bullishnessScore: 0,
        hypeScore: 0,
        keywords: [],
        tweetCount: tweets.length,
        sampleTweets: tweets.slice(0, 3)
      };
    }
  }

  // Enable headless mode after first successful login
  setHeadless(enabled: boolean): void {
    this.headlessMode = enabled;
  }
}

export const axiomSensor = new AxiomSensor();
</file>

<file path="src/signals/entry-evaluator.ts">
import { createChildLogger } from '../utils/logger';
import { pumpDetector } from './pump-detector';
import { velocityTracker } from './velocity-tracker';
import { priceFeed } from '../data/price-feed';
import { EntryResult, PumpMetrics } from './types';

const logger = createChildLogger('entry-evaluator');

export class EntryEvaluator {
  constructor() {}

  /**
   * Unified entry evaluation:
   * - If token has price history â†’ use pump detector
   * - If new token â†’ check velocity tracker
   */
  evaluate(mint: string, marketCapSol?: number): EntryResult {
    // Check if we have price history for pump analysis
    const priceHistory = priceFeed.getPriceHistory(mint, 300);
    const hasPriceHistory = priceHistory.length >= 10;

    logger.debug({
      mint: mint.substring(0, 12),
      priceHistoryLen: priceHistory.length,
      hasPriceHistory,
      hasVelocityData: velocityTracker.hasTradeData(mint),
    }, 'Evaluating entry');

    // Path 1: Token has sufficient price history â†’ use pump detector
    if (hasPriceHistory) {
      const pumpMetrics = pumpDetector.analyzePump(mint);
      const isGoodEntry = pumpDetector.isGoodEntry(pumpMetrics);

      logger.info({
        mint: mint.substring(0, 12),
        source: 'pump_detector',
        phase: pumpMetrics.phase,
        heat: pumpMetrics.heat.toFixed(1),
        confidence: pumpMetrics.confidence.toFixed(2),
        isGoodEntry,
      }, 'Pump detector evaluation');

      return {
        canEnter: isGoodEntry,
        source: 'pump_detector',
        reason: isGoodEntry
          ? `Pump OK: ${pumpMetrics.phase} phase, heat=${pumpMetrics.heat.toFixed(0)}`
          : `Pump rejected: ${pumpMetrics.phase} phase, heat=${pumpMetrics.heat.toFixed(0)}, conf=${pumpMetrics.confidence.toFixed(2)}`,
        metrics: pumpMetrics,
      };
    }

    // Path 2: New token without price history â†’ check velocity
    const velocityResult = velocityTracker.hasGoodVelocity(mint, marketCapSol);

    logger.info({
      mint: mint.substring(0, 12),
      source: 'velocity',
      hasGoodVelocity: velocityResult.hasGoodVelocity,
      reason: velocityResult.reason,
      metrics: velocityResult.metrics ? {
        txCount: velocityResult.metrics.txCount,
        uniqueBuyers: velocityResult.metrics.uniqueBuyers.size,
        buyPressure: (velocityResult.metrics.buyPressure * 100).toFixed(0) + '%',
      } : null,
    }, 'Velocity evaluation');

    return {
      canEnter: velocityResult.hasGoodVelocity,
      source: velocityResult.hasGoodVelocity ? 'velocity' : 'none',
      reason: velocityResult.reason,
      metrics: velocityResult.metrics || undefined,
    };
  }

  /**
   * Get pump metrics (for logging/display even if using velocity path)
   */
  getPumpMetrics(mint: string): PumpMetrics {
    return pumpDetector.analyzePump(mint);
  }
}

export const entryEvaluator = new EntryEvaluator();
</file>

<file path="src/signals/feature-extractor.ts">
import { createChildLogger } from '../utils/logger';
import { priceFeed } from '../data/price-feed';
import { PriceData, HolderInfo, TokenInfo, LiquidityPool } from '../data/types';
import { StateVector, FeatureHistory } from './types';
import { tokenWatchlist } from './token-watchlist';

const logger = createChildLogger('feature-extractor');

export class FeatureExtractor {
  private featureHistories: Map<string, FeatureHistory> = new Map();
  private maxHistoryLength = 300; // 5 minutes at 1-second intervals
  private tradeCountCache: Map<string, { count: number; timestamp: Date }> = new Map();

  constructor() {}

  async extractFeatures(
    mint: string,
    priceData: PriceData,
    holderInfo: HolderInfo | null,
    tokenInfo: TokenInfo | null,
    lpInfo?: LiquidityPool | null
  ): Promise<StateVector> {
    const priceHistory = priceFeed.getPriceHistory(mint, 300);

    // Calculate price changes
    const priceChange1m = this.calculatePriceChange(priceHistory, 60);
    const priceChange5m = this.calculatePriceChange(priceHistory, 300);

    // Calculate volume z-score
    const volumeZScore = this.calculateVolumeZScore(priceHistory);

    // Calculate buy/sell ratio from recent transactions
    const buySellRatio = this.calculateBuySellRatio(priceHistory);

    // Holder metrics
    const holderCount = holderInfo
      ? this.normalizeHolderCount(holderInfo.totalHolders)
      : 0.5;
    const top10Concentration = holderInfo?.top10Concentration || 0.5;

    // Token safety flags
    const mintRevoked = tokenInfo?.mintAuthorityRevoked ? 1 : 0;
    const freezeRevoked = tokenInfo?.freezeAuthorityRevoked ? 1 : 0;

    // LP locked - use actual lpInfo if available
    const lpLocked = lpInfo?.lpLocked ? 1 : 0;

    // Token age
    const ageMinutes = tokenInfo
      ? this.normalizeAge((Date.now() - tokenInfo.createdAt.getTime()) / 60000)
      : 0.5;

    // Trade intensity
    const tradeIntensity = this.calculateTradeIntensity(priceHistory);

    // Market cap normalized
    const marketCapSol = this.normalizeMarketCap(priceData.marketCapSol);

    // NEW: Calculate drawdown from peak
    const drawdownFromPeak = this.calculateDrawdownFromPeak(mint, priceHistory, priceData.priceSol);

    // NEW: Calculate volatility (standard deviation of recent price changes)
    const volatility = this.calculateVolatility(priceHistory);

    // NEW: Calculate unique traders (normalized)
    const uniqueTraders = this.calculateUniqueTraders(mint);

    // NEW: Calculate volume trend (acceleration/deceleration)
    const volumeTrend = this.calculateVolumeTrend(mint, priceHistory);

    const state: StateVector = {
      priceChange1m: this.clamp(priceChange1m / 100, -1, 1), // Normalize to [-1, 1]
      priceChange5m: this.clamp(priceChange5m / 100, -1, 1),
      volumeZScore: this.clamp(volumeZScore / 5, -1, 1), // Normalize z-score
      buySellRatio: this.clamp(buySellRatio, 0, 1),
      holderCount,
      top10Concentration,
      mintRevoked,
      freezeRevoked,
      lpLocked,
      ageMinutes,
      tradeIntensity,
      marketCapSol,
      // NEW: Additional features
      drawdownFromPeak: this.clamp(drawdownFromPeak, 0, 1),
      volatility: this.clamp(volatility, 0, 1),
      uniqueTraders: this.clamp(uniqueTraders, 0, 1),
      volumeTrend: this.clamp(volumeTrend, -1, 1),
    };

    // Store in history
    this.updateHistory(mint, state);

    return state;
  }

  getFeatureHistory(mint: string): StateVector[] {
    return this.featureHistories.get(mint)?.features || [];
  }

  private calculatePriceChange(history: PriceData[], seconds: number): number {
    if (history.length < 2) return 0;

    const targetTime = Date.now() - seconds * 1000;
    const currentPrice = history[history.length - 1].priceSol;

    // Find price closest to target time
    let pastPrice = currentPrice;
    for (let i = history.length - 1; i >= 0; i--) {
      if (history[i].timestamp.getTime() <= targetTime) {
        pastPrice = history[i].priceSol;
        break;
      }
    }

    if (pastPrice === 0) return 0;
    return ((currentPrice - pastPrice) / pastPrice) * 100;
  }

  private calculateVolumeZScore(history: PriceData[]): number {
    if (history.length < 10) return 0;

    // Use liquidity changes as volume proxy
    const volumes = history.map((h) => h.volume24h || 0);
    const recentVolume = volumes[volumes.length - 1];

    const mean = volumes.reduce((a, b) => a + b, 0) / volumes.length;
    const stdDev = Math.sqrt(
      volumes.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / volumes.length
    );

    if (stdDev === 0) return 0;
    return (recentVolume - mean) / stdDev;
  }

  private calculateBuySellRatio(history: PriceData[]): number {
    if (history.length < 2) return 0.5;

    // Infer buy/sell from price movements
    let buys = 0;
    let sells = 0;

    for (let i = 1; i < history.length; i++) {
      const change = history[i].priceSol - history[i - 1].priceSol;
      if (change > 0) buys++;
      else if (change < 0) sells++;
    }

    const total = buys + sells;
    if (total === 0) return 0.5;

    return buys / total;
  }

  private calculateTradeIntensity(history: PriceData[]): number {
    if (history.length < 10) return 0.5;

    // Count significant price changes as proxy for trade activity
    let significantChanges = 0;
    const threshold = 0.001; // 0.1% change threshold

    for (let i = 1; i < history.length; i++) {
      const change = Math.abs(
        (history[i].priceSol - history[i - 1].priceSol) / history[i - 1].priceSol
      );
      if (change > threshold) significantChanges++;
    }

    // Normalize: 0 = no activity, 1 = constant activity
    return Math.min(significantChanges / history.length, 1);
  }

  private normalizeHolderCount(count: number): number {
    // Log scale normalization
    // 10 holders -> ~0.3, 100 holders -> ~0.5, 1000 holders -> ~0.75, 10000 -> ~1.0
    if (count <= 0) return 0;
    return Math.min(Math.log10(count) / 4, 1);
  }

  private normalizeAge(minutes: number): number {
    // Sigmoid normalization
    // 0 min -> 0, 30 min -> ~0.5, 60 min -> ~0.75, 240 min -> ~0.95
    return 1 - 1 / (1 + minutes / 30);
  }

  private normalizeMarketCap(marketCapSol: number): number {
    // Log scale: 10 SOL -> ~0.25, 100 SOL -> ~0.5, 1000 SOL -> ~0.75, 10000 SOL -> 1.0
    if (marketCapSol <= 0) return 0;
    return Math.min(Math.log10(marketCapSol) / 4, 1);
  }

  /**
   * NEW: Calculate drawdown from peak price
   * Returns 0-1 where 0 = at peak, 1 = 100% below peak
   */
  private calculateDrawdownFromPeak(mint: string, priceHistory: PriceData[], currentPrice: number): number {
    // Try to get peak price from watchlist first (most accurate)
    const watchedToken = tokenWatchlist.getToken(mint);
    if (watchedToken && watchedToken.peakPrice > 0) {
      const drawdown = (watchedToken.peakPrice - currentPrice) / watchedToken.peakPrice;
      return Math.max(0, drawdown);
    }

    // Fallback: calculate from price history
    if (priceHistory.length < 2) return 0;

    const prices = priceHistory.map(p => p.priceSol);
    const peakPrice = Math.max(...prices);

    if (peakPrice <= 0) return 0;
    const drawdown = (peakPrice - currentPrice) / peakPrice;
    return Math.max(0, drawdown);
  }

  /**
   * NEW: Calculate volatility as standard deviation of recent price changes
   * Returns 0-1 where higher = more volatile
   */
  private calculateVolatility(priceHistory: PriceData[]): number {
    if (priceHistory.length < 5) return 0.5; // Default to medium volatility

    const prices = priceHistory.map(p => p.priceSol);

    // Calculate returns (percentage changes)
    const returns: number[] = [];
    for (let i = 1; i < prices.length; i++) {
      if (prices[i - 1] > 0) {
        returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
      }
    }

    if (returns.length === 0) return 0.5;

    // Calculate standard deviation of returns
    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
    const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
    const stdDev = Math.sqrt(variance);

    // Normalize: 0% stdDev = 0, 10% stdDev = 0.5, 20%+ stdDev = 1
    return Math.min(stdDev / 0.2, 1);
  }

  /**
   * NEW: Calculate unique traders (normalized)
   * Uses watchlist data if available, returns 0-1
   */
  private calculateUniqueTraders(mint: string): number {
    const watchedToken = tokenWatchlist.getToken(mint);
    if (!watchedToken || watchedToken.trades.length === 0) {
      return 0.5; // Default to medium
    }

    // Count unique traders
    const uniqueTraderSet = new Set(watchedToken.trades.map(t => t.traderPublicKey));
    const count = uniqueTraderSet.size;

    // Normalize: 0 traders = 0, 25 traders = 0.5, 50+ traders = 1
    return Math.min(count / 50, 1);
  }

  /**
   * NEW: Calculate volume trend (acceleration/deceleration)
   * Returns -1 to 1 where:
   *  - Positive = volume accelerating (more recent volume)
   *  - Negative = volume decelerating (less recent volume)
   *  - 0 = stable volume
   */
  private calculateVolumeTrend(mint: string, priceHistory: PriceData[]): number {
    // Try watchlist for trade-based volume trend first
    const watchedToken = tokenWatchlist.getToken(mint);
    if (watchedToken && watchedToken.volumeHistory.length >= 2) {
      const recent = watchedToken.volumeHistory[watchedToken.volumeHistory.length - 1]?.count || 0;
      const previous = watchedToken.volumeHistory[watchedToken.volumeHistory.length - 2]?.count || 1;

      if (previous > 0) {
        const ratio = recent / previous;
        // Convert ratio to -1 to 1 scale: 0.5x = -0.5, 1x = 0, 2x = 0.5, 3x+ = 1
        return Math.max(-1, Math.min(1, (ratio - 1) * 0.5));
      }
    }

    // Fallback: use price history volume
    if (priceHistory.length < 10) return 0;

    const midpoint = Math.floor(priceHistory.length / 2);
    const firstHalf = priceHistory.slice(0, midpoint);
    const secondHalf = priceHistory.slice(midpoint);

    const firstVolume = firstHalf.reduce((sum, p) => sum + (p.volume24h || 0), 0) / firstHalf.length;
    const secondVolume = secondHalf.reduce((sum, p) => sum + (p.volume24h || 0), 0) / secondHalf.length;

    if (firstVolume <= 0) return 0;

    const ratio = secondVolume / firstVolume;
    // Convert ratio to -1 to 1 scale
    return Math.max(-1, Math.min(1, (ratio - 1) * 0.5));
  }

  private clamp(value: number, min: number, max: number): number {
    return Math.max(min, Math.min(max, value));
  }

  private updateHistory(mint: string, state: StateVector): void {
    let history = this.featureHistories.get(mint);

    if (!history) {
      history = {
        mint,
        features: [],
        timestamps: [],
        maxHistory: this.maxHistoryLength,
      };
      this.featureHistories.set(mint, history);
    }

    history.features.push(state);
    history.timestamps.push(new Date());

    // Trim old entries
    if (history.features.length > history.maxHistory) {
      history.features = history.features.slice(-history.maxHistory);
      history.timestamps = history.timestamps.slice(-history.maxHistory);
    }
  }

  toArray(state: StateVector): number[] {
    return [
      state.priceChange1m,
      state.priceChange5m,
      state.volumeZScore,
      state.buySellRatio,
      state.holderCount,
      state.top10Concentration,
      state.mintRevoked,
      state.freezeRevoked,
      state.lpLocked,
      state.ageMinutes,
      state.tradeIntensity,
      state.marketCapSol,
      // NEW: 4 additional features
      state.drawdownFromPeak,
      state.volatility,
      state.uniqueTraders,
      state.volumeTrend,
    ];
  }

  fromArray(arr: number[]): StateVector {
    return {
      priceChange1m: arr[0],
      priceChange5m: arr[1],
      volumeZScore: arr[2],
      buySellRatio: arr[3],
      holderCount: arr[4],
      top10Concentration: arr[5],
      mintRevoked: arr[6],
      freezeRevoked: arr[7],
      lpLocked: arr[8],
      ageMinutes: arr[9],
      tradeIntensity: arr[10],
      marketCapSol: arr[11],
      // NEW: 4 additional features
      drawdownFromPeak: arr[12] ?? 0,
      volatility: arr[13] ?? 0.5,
      uniqueTraders: arr[14] ?? 0.5,
      volumeTrend: arr[15] ?? 0,
    };
  }

  clearHistory(mint: string): void {
    this.featureHistories.delete(mint);
  }
}

export const featureExtractor = new FeatureExtractor();
</file>

<file path="src/signals/index.ts">
export * from './types';
export * from './feature-extractor';
export * from './rug-detector';
export * from './pump-detector';
export * from './velocity-tracker';
export * from './entry-evaluator';
export * from './narrative-sensor';
export * from './news-sensor';
export * from './rug-monitor';
export * from './token-watchlist';
</file>

<file path="src/signals/narrative-sensor.ts">
import { ApifyClient } from 'apify-client';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { createChildLogger } from '../utils/logger';

const logger = createChildLogger('narrative-sensor');

export interface NarrativeSignal {
  sentiment: 'bullish' | 'bearish' | 'neutral';
  bullishnessScore: number; // -1 to 1 (Granular score for Math)
  hypeScore: number;        // 0 to 1 (Volume/Excitement)
  volume: number;           // Number of tweets found
  keywords: string[];       // LLM-identified topics (e.g., "Congestion", "Burn")
  sampleTweets: string[];
}

export class NarrativeSensor {
  private apifyClient: ApifyClient;
  private genAI: GoogleGenerativeAI;
  private model: ReturnType<GoogleGenerativeAI['getGenerativeModel']>;
  private searchTerms: string[];
  private maxItems: number;

  constructor(
    searchTerms: string[] = ['$SOL', 'Solana', 'memecoin'],
    maxItems: number = 50
  ) {
    // 1. Setup Apify (The Eyes)
    const apifyToken = process.env.APIFY_API_TOKEN;
    if (!apifyToken) logger.warn('APIFY_API_TOKEN missing - Scraper will fail');
    this.apifyClient = new ApifyClient({ token: apifyToken });

    // 2. Setup Gemini (The Brain)
    const geminiKey = process.env.GEMINI_API_KEY || '';
    if (!geminiKey) logger.warn('GEMINI_API_KEY missing - Analysis will be "neutral"');
    this.genAI = new GoogleGenerativeAI(geminiKey);
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

    this.searchTerms = searchTerms;
    this.maxItems = maxItems;
  }

  // --- STEP 1: GET DATA (APIFY) ---
  async scrapeTweets(query?: string): Promise<string[]> {
    try {
      const terms = query ? [query] : this.searchTerms;

      logger.debug({ terms }, 'Starting Apify scrape');

      const run = await this.apifyClient.actor('apidojo/tweet-scraper').call({
        searchTerms: terms,
        maxItems: this.maxItems,
        sort: 'Latest',
        tweetLanguage: 'en',
      });

      const { items } = await this.apifyClient.dataset(run.defaultDatasetId).listItems();

      // Extract text and remove duplicates
      const tweets = items
        .map((item: Record<string, unknown>) => item.text as string)
        .filter((text): text is string => typeof text === 'string' && text.length > 10);

      const uniqueTweets = Array.from(new Set(tweets));

      logger.info({ count: uniqueTweets.length, query: terms[0] }, 'Tweets scraped successfully');
      return uniqueTweets;

    } catch (error) {
      logger.error({ error }, 'Apify scrape failed');
      return [];
    }
  }

  // --- STEP 2: ANALYZE DATA (LLM) ---
  async analyzeWithBrain(tweets: string[]): Promise<NarrativeSignal> {
    if (tweets.length === 0) return this.getNeutralSignal();

    try {
      // Prompt Engineering: Asking for specific JSON format
      const prompt = `
        Act as a degenerate Solana trader. Analyze these ${tweets.length} tweets.

        Tweets:
        ${tweets.slice(0, 40).join('\n---\n')}

        Output valid JSON only with no markdown:
        {
          "bullishnessScore": number, // -1.0 (Bearish) to 1.0 (Bullish)
          "hypeScore": number,        // 0.0 (Dead) to 1.0 (Viral)
          "keywords": string[]        // Top 3 specific narratives (e.g. "Network Congestion", "Bonk Listing")
        }
      `;

      const result = await this.model.generateContent(prompt);
      const text = result.response.text().replace(/```json|```/g, '').trim();
      const analysis = JSON.parse(text);

      // Determine explicit sentiment label based on score
      let sentiment: 'bullish' | 'bearish' | 'neutral' = 'neutral';
      if (analysis.bullishnessScore > 0.3) sentiment = 'bullish';
      if (analysis.bullishnessScore < -0.3) sentiment = 'bearish';

      return {
        sentiment,
        bullishnessScore: analysis.bullishnessScore,
        hypeScore: analysis.hypeScore,
        volume: tweets.length,
        keywords: analysis.keywords || [],
        sampleTweets: tweets.slice(0, 3)
      };

    } catch (error) {
      logger.error({ error }, 'LLM Analysis failed');
      return this.getNeutralSignal();
    }
  }

  // --- PUBLIC API ---
  async getNarrativeSignal(tokenSymbol?: string): Promise<NarrativeSignal> {
    const tweets = await this.scrapeTweets(tokenSymbol);
    return this.analyzeWithBrain(tweets);
  }

  private getNeutralSignal(): NarrativeSignal {
    return {
      sentiment: 'neutral',
      bullishnessScore: 0,
      hypeScore: 0,
      volume: 0,
      keywords: [],
      sampleTweets: []
    };
  }
}

export const narrativeSensor = new NarrativeSensor();
</file>

<file path="src/signals/news-sensor.ts">
import { createChildLogger } from '../utils/logger';
import Groq from 'groq-sdk';

const logger = createChildLogger('news-sensor');

// Setup Groq for LLM analysis (faster + more generous free tier)
const groq = new Groq({ apiKey: process.env.GROQ_API_KEY });

export interface NewsSignal {
  bullishness: number; // -1 to 1
  marketFocus: string[]; // e.g. ["Regulation", "Solana Congestion"]
  breakingNews: boolean;
  headline: string;
}

export class NewsSensor {

  // News API endpoints (fallback chain)
  private readonly NEWS_APIS = [
    'https://free-crypto-news.vercel.app/api/news',
    'https://min-api.cryptocompare.com/data/v2/news/?lang=EN&sortOrder=popular'
  ];

  async getMarketNewsSignal(): Promise<NewsSignal> {
    try {
      // 1. Fetch raw news - try multiple APIs with fallback
      let articles: Array<{ title: string; source: string }> = [];

      for (const apiUrl of this.NEWS_APIS) {
        try {
          const response = await fetch(apiUrl, {
            headers: {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Accept': 'application/json'
            }
          });

          if (!response.ok) {
            logger.debug({ apiUrl, status: response.status }, 'API failed, trying next...');
            continue;
          }

          const data = await response.json() as Record<string, unknown>;

          // Handle different API response formats
          if (data.articles && Array.isArray(data.articles)) {
            // free-crypto-news format
            articles = (data.articles as Array<{ title: string; source: string }>).map(a => ({
              title: a.title || '',
              source: a.source || ''
            }));
          } else if (data.Data && Array.isArray(data.Data)) {
            // CryptoCompare format
            articles = (data.Data as Array<{ title: string; source_info?: { name: string } }>).map(a => ({
              title: a.title || '',
              source: a.source_info?.name || 'CryptoCompare'
            }));
          }

          if (articles.length > 0) {
            logger.debug({ apiUrl, count: articles.length }, 'News fetched successfully');
            break;
          }
        } catch (e) {
          logger.debug({ apiUrl, error: e }, 'API error, trying next...');
          continue;
        }
      }

      if (articles.length === 0) {
        logger.warn('All news APIs failed');
        return this.getNeutralSignal();
      }

      // Filter for only recent news
      const recentArticles = articles
        .slice(0, 15)
        .map((a) => `- ${a.title} (${a.source})`)
        .join('\n');

      if (!recentArticles) return this.getNeutralSignal();

      // 2. Ask Groq LLM to analyze it
      const prompt = `Analyze these crypto news headlines for a trading bot.

Headlines:
${recentArticles}

Task:
1. Determine global crypto sentiment (-1.0 to 1.0).
2. Identify if there is Breaking News that invalidates technical analysis (SEC lawsuits, exchange hacks, etc).
3. Extract top 2 market themes.

Output JSON only: { "score": number, "isBreaking": boolean, "themes": string[] }`;

      const completion = await groq.chat.completions.create({
        model: 'llama-3.3-70b-versatile',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3,
        max_tokens: 200,
        response_format: { type: 'json_object' }
      });

      const text = completion.choices[0]?.message?.content || '{}';
      const analysis = JSON.parse(text);

      logger.info({ analysis }, 'News analysis complete');

      return {
        bullishness: analysis.score || 0,
        breakingNews: analysis.isBreaking || false,
        marketFocus: analysis.themes || [],
        headline: articles[0]?.title || ''
      };

    } catch (error) {
      logger.error({ error }, 'Failed to fetch or analyze news');
      return this.getNeutralSignal();
    }
  }

  private getNeutralSignal(): NewsSignal {
    return { bullishness: 0, marketFocus: [], breakingNews: false, headline: '' };
  }
}

export const newsSensor = new NewsSensor();
</file>

<file path="src/signals/pump-detector.ts">
import { createChildLogger } from '../utils/logger';
import { priceFeed } from '../data/price-feed';
import { PriceData } from '../data/types';
import { PumpPhase, PumpMetrics } from './types';
import { config } from '../config/settings';

const logger = createChildLogger('pump-detector');

export class PumpDetector {
  private pumpHistories: Map<string, PumpMetrics[]> = new Map();
  private maxHistory = 60; // 1 minute of history

  constructor() {}

  analyzePump(mint: string): PumpMetrics {
    const history = priceFeed.getPriceHistory(mint, 300);

    if (history.length < 10) {
      return this.getDefaultMetrics();
    }

    // Calculate volume ratio (1min / 5min)
    const volume1m = this.getVolumeWindow(history, 60);
    const volume5m = this.getVolumeWindow(history, 300);
    const volumeRatio = volume5m > 0 ? volume1m / volume5m : 0;

    // Calculate heat metric
    const heat = volumeRatio * 100;

    // Determine phase based on heat and price velocity
    const priceVelocity = this.calculatePriceVelocity(history);
    const buyPressure = this.calculateBuyPressure(history);

    const phase = this.determinePhase(heat, priceVelocity, buyPressure);
    const confidence = this.calculateConfidence(history, phase);

    const metrics: PumpMetrics = {
      phase,
      heat,
      volumeRatio,
      priceVelocity,
      buyPressure,
      confidence,
    };

    // Update history
    this.updateHistory(mint, metrics);

    logger.debug({ mint, phase, heat: heat.toFixed(1), confidence: confidence.toFixed(2) }, 'Pump analysis');

    return metrics;
  }

  private getDefaultMetrics(): PumpMetrics {
    return {
      phase: 'cold',
      heat: 0,
      volumeRatio: 0,
      priceVelocity: 0,
      buyPressure: 0.5,
      confidence: 0,
    };
  }

  private getVolumeWindow(history: PriceData[], seconds: number): number {
    const cutoff = Date.now() - seconds * 1000;
    const windowData = history.filter((h) => h.timestamp.getTime() >= cutoff);

    if (windowData.length < 2) return 0;

    // Sum of absolute price changes as volume proxy
    let volume = 0;
    for (let i = 1; i < windowData.length; i++) {
      volume += Math.abs(windowData[i].priceSol - windowData[i - 1].priceSol);
    }

    return volume;
  }

  private calculatePriceVelocity(history: PriceData[]): number {
    if (history.length < 10) return 0;

    // Price velocity = rate of price change over recent period
    const recent = history.slice(-30); // Last 30 seconds
    if (recent.length < 2) return 0;

    const startPrice = recent[0].priceSol;
    const endPrice = recent[recent.length - 1].priceSol;
    const timeDiff = (recent[recent.length - 1].timestamp.getTime() - recent[0].timestamp.getTime()) / 1000;

    if (timeDiff === 0 || startPrice === 0) return 0;

    // Percentage change per second
    const velocity = ((endPrice - startPrice) / startPrice) * 100 / timeDiff;

    return velocity;
  }

  private calculateBuyPressure(history: PriceData[]): number {
    if (history.length < 10) return 0.5;

    const recent = history.slice(-60); // Last minute
    let upMoves = 0;
    let downMoves = 0;

    for (let i = 1; i < recent.length; i++) {
      const change = recent[i].priceSol - recent[i - 1].priceSol;
      if (change > 0) upMoves++;
      else if (change < 0) downMoves++;
    }

    const total = upMoves + downMoves;
    if (total === 0) return 0.5;

    return upMoves / total;
  }

  private determinePhase(heat: number, priceVelocity: number, buyPressure: number): PumpPhase {
    // Phase determination based on heat metric and supporting indicators

    // Dumping: negative velocity with selling pressure
    if (priceVelocity < -1 && buyPressure < 0.3) {
      return 'dumping';
    }

    // Peak: very high heat but slowing
    if (heat > 100 && priceVelocity < 0.5) {
      return 'peak';
    }

    // Hot: high heat with positive momentum
    if (heat >= 48 && heat <= 100 && buyPressure > 0.5) {
      return 'hot';
    }

    // Building: moderate heat with buying
    if (heat >= 33 && heat < 48 && buyPressure > 0.45) {
      return 'building';
    }

    // Cold: low activity
    return 'cold';
  }

  private calculateConfidence(history: PriceData[], phase: PumpPhase): number {
    if (history.length < 30) return 0.3;

    // Base confidence on data quality
    let confidence = Math.min(history.length / 100, 0.5);

    // Adjust based on signal clarity
    const recent = history.slice(-30);
    const priceChanges = [];

    for (let i = 1; i < recent.length; i++) {
      priceChanges.push((recent[i].priceSol - recent[i - 1].priceSol) / recent[i - 1].priceSol);
    }

    // Calculate consistency of direction
    const positiveChanges = priceChanges.filter((c) => c > 0).length;
    const consistency = Math.abs(positiveChanges / priceChanges.length - 0.5) * 2;

    confidence += consistency * 0.3;

    // Phase-specific adjustments
    if (phase === 'hot' || phase === 'peak') {
      confidence += 0.2;
    }

    return Math.min(confidence, 1);
  }

  private updateHistory(mint: string, metrics: PumpMetrics): void {
    let history = this.pumpHistories.get(mint) || [];
    history.push(metrics);

    if (history.length > this.maxHistory) {
      history = history.slice(-this.maxHistory);
    }

    this.pumpHistories.set(mint, history);
  }

  isGoodEntry(metrics: PumpMetrics): boolean {
    // Good entry: building phase with decent confidence, or early hot
    if (metrics.phase === 'building' && metrics.confidence > 0.4 && metrics.buyPressure > 0.5) {
      return true;
    }

    if (metrics.phase === 'hot' && metrics.heat < 60 && metrics.confidence > 0.5) {
      return true;
    }

    return false;
  }

  shouldExit(metrics: PumpMetrics): boolean {
    // Exit signals
    if (metrics.phase === 'peak' || metrics.phase === 'dumping') {
      return true;
    }

    if (metrics.priceVelocity < -2 && metrics.confidence > 0.5) {
      return true;
    }

    return false;
  }

  getPumpHistory(mint: string): PumpMetrics[] {
    return this.pumpHistories.get(mint) || [];
  }

  detectPhaseTransition(mint: string): { from: PumpPhase; to: PumpPhase } | null {
    const history = this.pumpHistories.get(mint);
    if (!history || history.length < 2) return null;

    const current = history[history.length - 1].phase;
    const previous = history[history.length - 2].phase;

    if (current !== previous) {
      logger.info({ mint, from: previous, to: current }, 'Phase transition detected');
      return { from: previous, to: current };
    }

    return null;
  }

  clearHistory(mint: string): void {
    this.pumpHistories.delete(mint);
  }
}

export const pumpDetector = new PumpDetector();
</file>

<file path="src/signals/rug-detector.ts">
import { createChildLogger } from '../utils/logger';
import { TokenInfo, HolderInfo, LiquidityPool } from '../data/types';
import { RugScore } from './types';
import { config } from '../config/settings';

const logger = createChildLogger('rug-detector');

export class RugDetector {
  private bundledBuysCache: Map<string, boolean> = new Map();

  constructor() {}

  async analyzeToken(
    mint: string,
    tokenInfo: TokenInfo | null,
    holderInfo: HolderInfo | null,
    lpInfo: LiquidityPool | null
  ): Promise<RugScore> {
    const details: string[] = [];
    let total = 0;

    // Check if this is a Pump.fun token (program controls mint/freeze)
    const isPumpFunToken = mint.endsWith('pump');

    // Mint authority check (25 points)
    let mintAuthorityScore = 0;
    if (tokenInfo?.mintAuthorityRevoked) {
      mintAuthorityScore = 25;
      details.push('âœ“ Mint authority revoked (+25)');
    } else if (isPumpFunToken) {
      // Pump.fun program controls mint authority - inherently safe
      mintAuthorityScore = 25;
      details.push('âœ“ Pump.fun token - mint controlled by program (+25)');
    } else {
      details.push('âœ— Mint authority NOT revoked (0)');
    }
    total += mintAuthorityScore;

    // Freeze authority check (20 points)
    let freezeAuthorityScore = 0;
    if (tokenInfo?.freezeAuthorityRevoked) {
      freezeAuthorityScore = 20;
      details.push('âœ“ Freeze authority revoked (+20)');
    } else if (isPumpFunToken) {
      // Pump.fun program controls freeze authority - inherently safe
      freezeAuthorityScore = 20;
      details.push('âœ“ Pump.fun token - freeze controlled by program (+20)');
    } else {
      details.push('âœ— Freeze authority NOT revoked (0)');
    }
    total += freezeAuthorityScore;

    // LP locked check (25 points)
    let lpLockedScore = 0;
    if (lpInfo?.lpLocked) {
      lpLockedScore = 25;
      details.push(`âœ“ LP locked (${(lpInfo.lpLockedPercent * 100).toFixed(1)}%) (+25)`);
    } else if (lpInfo) {
      // Partial points for high liquidity
      const liquidityScore = Math.min((lpInfo.liquiditySol / 100) * 10, 10);
      lpLockedScore = liquidityScore;
      details.push(`~ LP not locked, but ${lpInfo.liquiditySol.toFixed(1)} SOL liquidity (+${liquidityScore.toFixed(0)})`);
    } else {
      details.push('âœ— No LP info available (0)');
    }
    total += lpLockedScore;

    // Top 10 concentration check (15 points)
    let concentrationScore = 0;
    if (holderInfo) {
      const concentration = holderInfo.top10Concentration;
      if (concentration <= 0.30) {
        concentrationScore = 15;
        details.push(`âœ“ Top 10 hold ${(concentration * 100).toFixed(1)}% (<30%) (+15)`);
      } else if (concentration <= 0.50) {
        concentrationScore = 10;
        details.push(`~ Top 10 hold ${(concentration * 100).toFixed(1)}% (30-50%) (+10)`);
      } else if (concentration <= 0.70) {
        concentrationScore = 5;
        details.push(`! Top 10 hold ${(concentration * 100).toFixed(1)}% (50-70%) (+5)`);
      } else {
        details.push(`âœ— Top 10 hold ${(concentration * 100).toFixed(1)}% (>70%) (0)`);
      }
    } else {
      details.push('âœ— No holder info available (0)');
    }
    total += concentrationScore;

    // Bundled buys check (15 points)
    let bundledBuysScore = 0;
    const hasBundledBuys = await this.checkBundledBuys(mint);
    if (!hasBundledBuys) {
      bundledBuysScore = 15;
      details.push('âœ“ No suspicious bundled buys detected (+15)');
    } else {
      details.push('âœ— Bundled buys detected - potential coordinated buying (0)');
    }
    total += bundledBuysScore;

    const rugScore: RugScore = {
      total,
      mintAuthorityScore,
      freezeAuthorityScore,
      lpLockedScore,
      concentrationScore,
      bundledBuysScore,
      details,
    };

    logger.info({ mint, score: total }, 'Rug score calculated');

    return rugScore;
  }

  isSafe(rugScore: RugScore): boolean {
    return rugScore.total >= config.minRugScore;
  }

  private async checkBundledBuys(mint: string): Promise<boolean> {
    // Check cache first
    if (this.bundledBuysCache.has(mint)) {
      return this.bundledBuysCache.get(mint)!;
    }

    try {
      // Fetch recent transactions and analyze for bundled patterns
      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getSignaturesForAddress',
            params: [mint, { limit: 50 }],
          }),
        }
      );

      const data = await response.json() as any;
      const signatures = data.result || [];

      // Group transactions by block slot
      const slotGroups: Map<number, number> = new Map();
      for (const sig of signatures) {
        const count = slotGroups.get(sig.slot) || 0;
        slotGroups.set(sig.slot, count + 1);
      }

      // Check for bundled transactions (multiple in same slot)
      let bundledCount = 0;
      for (const count of slotGroups.values()) {
        if (count >= 3) {
          bundledCount++;
        }
      }

      // Flag if >20% of slots have bundled transactions
      const hasBundledBuys = bundledCount > slotGroups.size * 0.2;

      this.bundledBuysCache.set(mint, hasBundledBuys);
      return hasBundledBuys;
    } catch (error) {
      logger.error({ mint, error }, 'Failed to check bundled buys');
      return false; // Assume safe on error
    }
  }

  async checkCreatorHistory(creator: string): Promise<{
    tokenCount: number;
    rugCount: number;
    successRate: number;
  }> {
    try {
      // This would analyze creator's history of token launches
      // Simplified implementation
      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getSignaturesForAddress',
            params: [creator, { limit: 100 }],
          }),
        }
      );

      const data = await response.json() as any;
      const signatures = data.result || [];

      // Count unique token interactions (simplified)
      const uniqueTokens = new Set<string>();
      // Would need to parse transactions to extract token mints

      return {
        tokenCount: uniqueTokens.size,
        rugCount: 0, // Would need historical analysis
        successRate: 0.5, // Default neutral
      };
    } catch (error) {
      logger.error({ creator, error }, 'Failed to check creator history');
      return { tokenCount: 0, rugCount: 0, successRate: 0.5 };
    }
  }

  getQuickSafetyFlags(tokenInfo: TokenInfo | null, mint?: string): {
    isSafe: boolean;
    flags: string[];
  } {
    const flags: string[] = [];
    let isSafe = true;

    // Pump.fun tokens (ending in "pump") are inherently safe from mint/freeze authority
    // The Pump.fun program controls these - creators cannot mint or freeze
    const isPumpFunToken = mint?.endsWith('pump');

    if (!tokenInfo) {
      if (isPumpFunToken) {
        // Pump.fun tokens are safe by design - skip token info check
        flags.push('INFO: Pump.fun token - inherently safe');
        return { isSafe: true, flags };
      }
      return { isSafe: false, flags: ['No token info available'] };
    }

    if (!tokenInfo.mintAuthorityRevoked && !isPumpFunToken) {
      flags.push('WARN: Mint authority not revoked');
      isSafe = false;
    }

    if (!tokenInfo.freezeAuthorityRevoked && !isPumpFunToken) {
      flags.push('WARN: Freeze authority not revoked');
      // Not critical but noteworthy
    }

    return { isSafe, flags };
  }

  clearCache(mint?: string): void {
    if (mint) {
      this.bundledBuysCache.delete(mint);
    } else {
      this.bundledBuysCache.clear();
    }
  }

  /**
   * Check if LP tokens are locked/burned for a token
   * Returns LiquidityPool info with lpLocked status
   */
  async checkLpLocked(mint: string, poolAddress?: string): Promise<{
    lpLocked: boolean;
    lpLockedPercent: number;
    liquiditySol: number;
    reason: string;
  }> {
    try {
      // Known burn addresses for Solana
      const BURN_ADDRESSES = [
        '1111111111111111111111111111111111111111111',  // System program (null address)
        '1nc1nerator11111111111111111111111111111111',  // Incinerator
        '11111111111111111111111111111111',              // Short burn address
      ];

      // Known lock protocols on Solana
      const LOCK_PROTOCOLS = [
        'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',  // SPL Token
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL', // Associated Token
        // Streamflow vesting
        'strmRqUCoQUgGUan5YhzUZa6KqdzwX5L6FpUxfmKg5m',
        // Squads multisig (often used for lock)
        'SMPLecH534NA9acpos4G6x7uf3LWbCAwZQE9e8ZekMu',
      ];

      // Try to get LP pool info from DexScreener
      const response = await fetch(
        `https://api.dexscreener.com/latest/dex/tokens/${mint}`,
        { headers: { 'Accept': 'application/json' } }
      );

      if (!response.ok) {
        logger.debug({ mint }, 'Failed to fetch DexScreener data for LP check');
        return { lpLocked: false, lpLockedPercent: 0, liquiditySol: 0, reason: 'Failed to fetch data' };
      }

      const data = await response.json() as any;
      const pairs = data.pairs || [];

      if (pairs.length === 0) {
        return { lpLocked: false, lpLockedPercent: 0, liquiditySol: 0, reason: 'No pairs found' };
      }

      // Get the main pair (usually Raydium or Orca)
      const mainPair = pairs.find((p: any) =>
        p.dexId === 'raydium' || p.dexId === 'orca' || p.dexId === 'pump'
      ) || pairs[0];

      const liquiditySol = mainPair.liquidity?.usd
        ? (mainPair.liquidity.usd / (mainPair.priceNative || 1)) / 1000  // Rough SOL estimate
        : 0;

      // Check if liquidity is locked via DexScreener info (if available)
      const liquidityInfo = mainPair.liquidity || {};
      if (liquidityInfo.locked) {
        return {
          lpLocked: true,
          lpLockedPercent: liquidityInfo.lockedPercent || 1,
          liquiditySol,
          reason: `LP locked (${(liquidityInfo.lockedPercent * 100 || 100).toFixed(0)}%)`
        };
      }

      // For Pump.fun tokens, LP is managed by the bonding curve (effectively locked)
      if (mint.endsWith('pump') || mainPair.dexId === 'pump') {
        return {
          lpLocked: true,
          lpLockedPercent: 1,
          liquiditySol,
          reason: 'Pump.fun bonding curve (inherently locked)'
        };
      }

      // If we have a pool address, we can do additional on-chain checks
      if (poolAddress) {
        const lpCheckResult = await this.checkLpTokensBurned(poolAddress);
        if (lpCheckResult.burned) {
          return {
            lpLocked: true,
            lpLockedPercent: lpCheckResult.burnedPercent,
            liquiditySol,
            reason: `LP tokens burned (${(lpCheckResult.burnedPercent * 100).toFixed(0)}%)`
          };
        }
      }

      // Default: cannot confirm LP is locked
      return {
        lpLocked: false,
        lpLockedPercent: 0,
        liquiditySol,
        reason: 'LP lock status unknown'
      };

    } catch (error) {
      logger.error({ mint, error }, 'Error checking LP lock status');
      return { lpLocked: false, lpLockedPercent: 0, liquiditySol: 0, reason: 'Error checking LP' };
    }
  }

  /**
   * Check if LP tokens have been burned by querying token account holders
   */
  private async checkLpTokensBurned(lpMint: string): Promise<{
    burned: boolean;
    burnedPercent: number;
  }> {
    try {
      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getTokenLargestAccounts',
            params: [lpMint],
          }),
        }
      );

      const data = await response.json() as any;
      const accounts = data.result?.value || [];

      if (accounts.length === 0) {
        return { burned: false, burnedPercent: 0 };
      }

      // Check if any large holders are burn addresses
      const BURN_PATTERNS = ['1111111111111111111111111111', '1nc1nerator', 'burn', 'dead'];
      let totalSupply = 0;
      let burnedSupply = 0;

      for (const account of accounts) {
        const amount = parseFloat(account.amount) || 0;
        totalSupply += amount;

        // Check if this is a burn address
        const address = account.address?.toLowerCase() || '';
        const isBurned = BURN_PATTERNS.some(pattern => address.includes(pattern.toLowerCase()));

        if (isBurned) {
          burnedSupply += amount;
        }
      }

      const burnedPercent = totalSupply > 0 ? burnedSupply / totalSupply : 0;

      return {
        burned: burnedPercent >= 0.5, // Consider locked if >50% burned
        burnedPercent,
      };

    } catch (error) {
      logger.debug({ lpMint, error }, 'Failed to check LP token burn status');
      return { burned: false, burnedPercent: 0 };
    }
  }
}

export const rugDetector = new RugDetector();
</file>

<file path="src/signals/rug-monitor.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';

const logger = createChildLogger('rug-monitor');

interface WatchedPosition {
  mint: string;
  creator: string;
  entryTime: Date;
  entryPrice: number;
  entryMarketCapSol: number;

  // Trading activity tracking
  sellCount: number;
  buyCount: number;
  totalSellVolume: number;    // Token amount sold
  creatorSellCount: number;
  creatorTotalSold: number;   // Token amount creator sold
  largestSingleSell: number;  // Largest single sell in tokens
  largestSellerWallet: string;

  // Price tracking (from PumpPortal trades)
  highestPrice: number;
  currentPrice: number;
  priceAtLastCheck: number;
}

export interface RugWarning {
  mint: string;
  type: 'creator_sell' | 'large_dump' | 'sell_pressure' | 'price_crash';
  severity: 'warning' | 'critical';
  message: string;
  details: {
    [key: string]: number | string;
  };
  timestamp: Date;
}

export class RugMonitor extends EventEmitter {
  private watchedPositions: Map<string, WatchedPosition> = new Map();
  private recentWarnings: Map<string, RugWarning[]> = new Map();

  constructor() {
    super();
  }

  /**
   * Start watching a position for rug signals
   */
  watchPosition(params: {
    mint: string;
    creator: string;
    entryPrice: number;
    entryMarketCapSol: number;
  }): void {
    const { mint, creator, entryPrice, entryMarketCapSol } = params;

    if (this.watchedPositions.has(mint)) {
      logger.debug({ mint }, 'Position already being watched');
      return;
    }

    const position: WatchedPosition = {
      mint,
      creator,
      entryTime: new Date(),
      entryPrice,
      entryMarketCapSol,
      sellCount: 0,
      buyCount: 0,
      totalSellVolume: 0,
      creatorSellCount: 0,
      creatorTotalSold: 0,
      largestSingleSell: 0,
      largestSellerWallet: '',
      highestPrice: entryPrice,
      currentPrice: entryPrice,
      priceAtLastCheck: entryPrice,
    };

    this.watchedPositions.set(mint, position);
    this.recentWarnings.set(mint, []);

    logger.info({
      mint: mint.substring(0, 12) + '...',
      creator: creator.substring(0, 12) + '...',
      entryPrice: entryPrice.toExponential(4),
      marketCapSol: entryMarketCapSol.toFixed(2),
    }, 'Rug monitor: Watching position');
  }

  /**
   * Stop watching a position
   */
  unwatchPosition(mint: string): void {
    this.watchedPositions.delete(mint);
    this.recentWarnings.delete(mint);
    logger.debug({ mint: mint.substring(0, 12) + '...' }, 'Rug monitor: Stopped watching');
  }

  /**
   * Process a trade event from PumpPortal
   */
  processTrade(data: {
    mint: string;
    txType: 'buy' | 'sell';
    traderPublicKey: string;
    tokenAmount: number;
    marketCapSol: number;
    priceSol: number;
  }): void {
    const position = this.watchedPositions.get(data.mint);
    if (!position) return;

    // Update price tracking
    position.currentPrice = data.priceSol;
    if (data.priceSol > position.highestPrice) {
      position.highestPrice = data.priceSol;
    }

    if (data.txType === 'buy') {
      position.buyCount++;
      return; // Buys are good, no rug signals
    }

    // It's a sell - analyze for rug signals
    position.sellCount++;
    position.totalSellVolume += data.tokenAmount;

    // Track largest single sell
    if (data.tokenAmount > position.largestSingleSell) {
      position.largestSingleSell = data.tokenAmount;
      position.largestSellerWallet = data.traderPublicKey;
    }

    // CHECK 1: Creator selling
    if (data.traderPublicKey === position.creator) {
      position.creatorSellCount++;
      position.creatorTotalSold += data.tokenAmount;

      this.emitWarning({
        mint: data.mint,
        type: 'creator_sell',
        severity: position.creatorSellCount >= 2 ? 'critical' : 'warning',
        message: `Creator sold ${data.tokenAmount.toLocaleString()} tokens (sell #${position.creatorSellCount})`,
        details: {
          creatorWallet: data.traderPublicKey.substring(0, 12) + '...',
          tokensSold: data.tokenAmount,
          totalCreatorSold: position.creatorTotalSold,
          sellCount: position.creatorSellCount,
        },
      });
    }

    // CHECK 2: Large single dump (>5% of market cap equivalent)
    const sellValueSol = data.tokenAmount * data.priceSol;
    const dumpPercent = (sellValueSol / data.marketCapSol) * 100;

    if (dumpPercent > 5) {
      this.emitWarning({
        mint: data.mint,
        type: 'large_dump',
        severity: dumpPercent > 10 ? 'critical' : 'warning',
        message: `Large sell: ${dumpPercent.toFixed(1)}% of market cap dumped`,
        details: {
          sellerWallet: data.traderPublicKey.substring(0, 12) + '...',
          tokensSold: data.tokenAmount,
          sellValueSol: sellValueSol.toFixed(4),
          dumpPercent: dumpPercent,
        },
      });
    }

    // CHECK 3: Sell pressure (more sells than buys in recent window)
    const totalTrades = position.buyCount + position.sellCount;
    if (totalTrades >= 5) {  // Need minimum trades for meaningful ratio
      const sellRatio = position.sellCount / totalTrades;

      if (sellRatio > 0.6) {  // >60% sells
        this.emitWarning({
          mint: data.mint,
          type: 'sell_pressure',
          severity: sellRatio > 0.75 ? 'critical' : 'warning',
          message: `High sell pressure: ${(sellRatio * 100).toFixed(0)}% sells`,
          details: {
            buyCount: position.buyCount,
            sellCount: position.sellCount,
            sellRatio: sellRatio,
          },
        });
      }
    }

    // CHECK 4: Price crash from high (>30% drop from peak)
    if (position.highestPrice > position.entryPrice) {  // Only if it went up first
      const dropFromHigh = ((position.highestPrice - data.priceSol) / position.highestPrice) * 100;

      if (dropFromHigh > 30) {
        this.emitWarning({
          mint: data.mint,
          type: 'price_crash',
          severity: dropFromHigh > 50 ? 'critical' : 'warning',
          message: `Price crashed ${dropFromHigh.toFixed(0)}% from high`,
          details: {
            highestPrice: position.highestPrice,
            currentPrice: data.priceSol,
            dropPercent: dropFromHigh,
            currentGainPercent: ((data.priceSol - position.entryPrice) / position.entryPrice) * 100,
          },
        });
      }
    }

    position.priceAtLastCheck = data.priceSol;
  }

  /**
   * Emit a rug warning
   */
  private emitWarning(warning: Omit<RugWarning, 'timestamp'>): void {
    const fullWarning: RugWarning = {
      ...warning,
      timestamp: new Date(),
    };

    // Store warning
    const warnings = this.recentWarnings.get(warning.mint) || [];
    warnings.push(fullWarning);

    // Keep only last 10 warnings per token
    if (warnings.length > 10) {
      warnings.shift();
    }
    this.recentWarnings.set(warning.mint, warnings);

    // Log it
    const logData = {
      mint: warning.mint.substring(0, 12) + '...',
      type: warning.type,
      severity: warning.severity,
      ...warning.details,
    };

    if (warning.severity === 'critical') {
      logger.error(logData, `RUG ALERT: ${warning.message}`);
    } else {
      logger.warn(logData, `Rug warning: ${warning.message}`);
    }

    // Emit event for position manager
    this.emit('rugWarning', fullWarning);

    // Critical warnings get special emission
    if (warning.severity === 'critical') {
      this.emit('rugAlert', fullWarning);
    }
  }

  /**
   * Check if a position should be exited based on rug signals
   */
  shouldExit(mint: string): { shouldExit: boolean; reason: string } {
    const warnings = this.recentWarnings.get(mint) || [];
    const position = this.watchedPositions.get(mint);

    if (!position) {
      return { shouldExit: false, reason: '' };
    }

    // Exit immediately on creator sell
    const creatorSells = warnings.filter(w => w.type === 'creator_sell');
    if (creatorSells.length > 0) {
      return {
        shouldExit: true,
        reason: `Creator sold (${position.creatorSellCount} times, ${position.creatorTotalSold.toLocaleString()} tokens)`
      };
    }

    // Exit on multiple critical warnings
    const criticalWarnings = warnings.filter(w =>
      w.severity === 'critical' &&
      Date.now() - w.timestamp.getTime() < 60000  // Last minute
    );

    if (criticalWarnings.length >= 2) {
      return {
        shouldExit: true,
        reason: `Multiple critical warnings: ${criticalWarnings.map(w => w.type).join(', ')}`,
      };
    }

    // Exit on large dump + price crash combo
    const recentLargeDump = warnings.find(w =>
      w.type === 'large_dump' &&
      w.severity === 'critical' &&
      Date.now() - w.timestamp.getTime() < 30000
    );
    const recentCrash = warnings.find(w =>
      w.type === 'price_crash' &&
      Date.now() - w.timestamp.getTime() < 30000
    );

    if (recentLargeDump && recentCrash) {
      return {
        shouldExit: true,
        reason: 'Large dump followed by price crash - likely rug',
      };
    }

    return { shouldExit: false, reason: '' };
  }

  /**
   * Get warnings for a position
   */
  getWarnings(mint: string): RugWarning[] {
    return this.recentWarnings.get(mint) || [];
  }

  /**
   * Get watched position stats
   */
  getPositionStats(mint: string): WatchedPosition | null {
    return this.watchedPositions.get(mint) || null;
  }

  /**
   * Get all watched positions
   */
  getWatchedMints(): string[] {
    return Array.from(this.watchedPositions.keys());
  }
}

export const rugMonitor = new RugMonitor();
</file>

<file path="src/signals/token-watchlist.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';

const logger = createChildLogger('token-watchlist');

export interface TradeData {
  txType: 'buy' | 'sell';
  traderPublicKey: string;
  tokenAmount: number;
  marketCapSol: number;
  priceSol: number;
  timestamp: number;
}

export interface WatchedToken {
  mint: string;
  creator: string;
  firstSeen: number;
  priceHistory: Array<{
    price: number;
    marketCap: number;
    timestamp: number;
  }>;
  trades: TradeData[];
  devSold: boolean;
  devSoldPercent: number;           // NEW: Track percentage of dev holdings sold
  devInitialHolding: number;        // NEW: Track initial dev holding for percentage calc
  devSoldTimestamp: number | null;  // NEW: When dev first sold
  peakPrice: number;
  lowestPrice: number;
  volumeHistory: Array<{            // NEW: Track volume windows for acceleration
    count: number;
    timestamp: number;
  }>;
  uniqueTraderHistory: number[];    // NEW: Track unique trader growth
}

export interface WatchlistFeatures {
  priceChange: number;
  volatility: number;
  drawdown: number;
  buyPressure: number;
  volumeTrend: number;
  ageMinutes: number;
  ageSeconds: number;               // NEW: Raw age in seconds
  uniqueTraders: number;
  devHolding: number;
  devSoldPercent: number;           // NEW: Percentage of dev holdings sold
  volumeAcceleration: number;       // NEW: Volume acceleration (recent vs previous window)
  uniqueTraderGrowth: number;       // NEW: Growth in unique traders over time
  hasMomentum: boolean;             // NEW: Whether momentum override conditions met
}

export interface MomentumSignal {
  hasMomentum: boolean;
  buyPressure: number;
  volumeAcceleration: number;
  uniqueTraderGrowth: number;
  reason: string;
}

export interface HardFilterResult {
  passes: boolean;
  reason: string;
}

export class TokenWatchlist extends EventEmitter {
  private watchlist: Map<string, WatchedToken> = new Map();
  private readonly minDataPoints = config.watchlist?.minDataPoints || 10;

  constructor() {
    super();
  }

  addToken(mint: string, creator: string): void {
    if (this.watchlist.has(mint)) {
      logger.debug({ mint }, 'Token already in watchlist');
      return;
    }

    this.watchlist.set(mint, {
      mint,
      creator,
      firstSeen: Date.now(),
      priceHistory: [],
      trades: [],
      devSold: false,
      devSoldPercent: 0,
      devInitialHolding: 0,
      devSoldTimestamp: null,
      peakPrice: 0,
      lowestPrice: Infinity,
      volumeHistory: [],
      uniqueTraderHistory: [],
    });

    logger.info({ mint: mint.substring(0, 15), creator: creator.substring(0, 10) }, 'Added token to watchlist');
    this.emit('tokenAdded', { mint, creator });
  }

  removeToken(mint: string): void {
    if (this.watchlist.delete(mint)) {
      logger.debug({ mint }, 'Removed token from watchlist');
      this.emit('tokenRemoved', { mint });
    }
  }

  recordPrice(mint: string, price: number, marketCap: number): void {
    const token = this.watchlist.get(mint);
    if (!token) return;

    token.priceHistory.push({ price, marketCap, timestamp: Date.now() });

    // Keep last 5 minutes of data (at ~1 update/sec = 300 entries)
    if (token.priceHistory.length > 300) {
      token.priceHistory = token.priceHistory.slice(-300);
    }

    // Track peak and lowest
    if (price > token.peakPrice) token.peakPrice = price;
    if (price < token.lowestPrice) token.lowestPrice = price;

    // Emit event when we have enough data points for AI analysis
    if (token.priceHistory.length === this.minDataPoints) {
      this.emit('tokenReady', { mint, token });
    }
  }

  recordTrade(mint: string, trade: Omit<TradeData, 'timestamp'>): void {
    const token = this.watchlist.get(mint);
    if (!token) return;

    const tradeWithTimestamp: TradeData = {
      ...trade,
      timestamp: Date.now(),
    };

    token.trades.push(tradeWithTimestamp);

    // Keep last 500 trades
    if (token.trades.length > 500) {
      token.trades = token.trades.slice(-500);
    }

    // Track volume windows for acceleration calculation (every 30 seconds)
    const now = Date.now();
    const lastVolumeEntry = token.volumeHistory[token.volumeHistory.length - 1];
    if (!lastVolumeEntry || now - lastVolumeEntry.timestamp >= 30000) {
      // Count trades in last 30 seconds
      const recentTrades = token.trades.filter(t => now - t.timestamp < 30000).length;
      token.volumeHistory.push({ count: recentTrades, timestamp: now });
      // Keep last 10 entries (5 minutes of 30-second windows)
      if (token.volumeHistory.length > 10) {
        token.volumeHistory = token.volumeHistory.slice(-10);
      }
    }

    // Track unique traders growth
    const uniqueTraders = new Set(token.trades.map(t => t.traderPublicKey)).size;
    token.uniqueTraderHistory.push(uniqueTraders);
    if (token.uniqueTraderHistory.length > 60) {
      token.uniqueTraderHistory = token.uniqueTraderHistory.slice(-60);
    }

    // Track dev behavior - percentage-based instead of binary
    if (trade.traderPublicKey === token.creator) {
      if (trade.txType === 'buy' && token.devInitialHolding === 0) {
        // Track initial dev holding
        token.devInitialHolding = trade.tokenAmount;
      } else if (trade.txType === 'sell') {
        // Calculate percentage sold
        if (token.devInitialHolding > 0) {
          token.devSoldPercent += trade.tokenAmount / token.devInitialHolding;
        } else {
          // If we don't know initial holding, estimate from this sell
          token.devSoldPercent = Math.min(token.devSoldPercent + 0.1, 1.0);
        }

        if (token.devSoldTimestamp === null) {
          token.devSoldTimestamp = now;
        }

        const ageSeconds = (now - token.firstSeen) / 1000;
        const earlyWindow = config.devSoldConfig?.earlyWindowSeconds || 180;
        const earlyMaxSell = config.devSoldConfig?.earlyMaxSellPercent || 0.02;
        const maxSell = config.devSoldConfig?.maxSellPercent || 0.05;

        // Check if dev sold too much (percentage-based)
        const threshold = ageSeconds < earlyWindow ? earlyMaxSell : maxSell;
        if (token.devSoldPercent > threshold) {
          token.devSold = true;
          logger.warn({
            mint: mint.substring(0, 15),
            devSoldPercent: (token.devSoldPercent * 100).toFixed(1) + '%',
            threshold: (threshold * 100).toFixed(1) + '%',
            ageSeconds: ageSeconds.toFixed(0),
          }, 'DEV SOLD TOO MUCH - Token flagged');
          this.emit('devSold', { mint, trade: tradeWithTimestamp, percent: token.devSoldPercent });
        } else {
          logger.debug({
            mint: mint.substring(0, 15),
            devSoldPercent: (token.devSoldPercent * 100).toFixed(1) + '%',
            threshold: (threshold * 100).toFixed(1) + '%',
          }, 'Dev sold (within threshold)');
        }
      }
    }

    // Update price if trade has price info
    if (trade.priceSol > 0) {
      this.recordPrice(mint, trade.priceSol, trade.marketCapSol);
    }
  }

  // HARD FILTERS: Instant rejection (don't waste AI on these)
  passesHardFilters(mint: string): HardFilterResult {
    const token = this.watchlist.get(mint);
    if (!token) {
      return { passes: false, reason: 'Token not in watchlist' };
    }

    // INSTANT REJECT: Dev already sold too much
    if (token.devSold) {
      return { passes: false, reason: `Dev sold ${(token.devSoldPercent * 100).toFixed(1)}%` };
    }

    // INSTANT REJECT: Not enough data for AI analysis
    if (token.priceHistory.length < this.minDataPoints) {
      return {
        passes: false,
        reason: `Only ${token.priceHistory.length}/${this.minDataPoints} data points`
      };
    }

    // NEW: INSTANT REJECT: Token too young (need time-based validity)
    const minAgeSeconds = config.watchlist?.minAgeSeconds || 60;
    const ageSeconds = (Date.now() - token.firstSeen) / 1000;
    if (ageSeconds < minAgeSeconds) {
      return {
        passes: false,
        reason: `Token only ${ageSeconds.toFixed(0)}s old (min ${minAgeSeconds}s)`
      };
    }

    // INSTANT REJECT: Crashed more than maxDrawdown from peak
    const maxDrawdown = config.watchlist?.maxDrawdown || 0.30;
    if (token.peakPrice > 0) {
      const currentPrice = token.priceHistory[token.priceHistory.length - 1]?.price || 0;
      const drawdown = (token.peakPrice - currentPrice) / token.peakPrice;
      if (drawdown > maxDrawdown) {
        return {
          passes: false,
          reason: `Crashed ${(drawdown * 100).toFixed(0)}% from peak (max ${(maxDrawdown * 100).toFixed(0)}%)`
        };
      }
    }

    return { passes: true, reason: 'Ready for AI analysis' };
  }

  // Extract features for DDQN agent
  extractFeatures(mint: string): WatchlistFeatures | null {
    const token = this.watchlist.get(mint);
    if (!token || token.priceHistory.length < this.minDataPoints) {
      return null;
    }

    const prices = token.priceHistory.map(p => p.price);
    const currentPrice = prices[prices.length - 1];
    const firstPrice = prices[0];

    // Recent trades (last 60 seconds)
    const recentTrades = token.trades.filter(t => Date.now() - t.timestamp < 60000);
    const recentBuys = recentTrades.filter(t => t.txType === 'buy').length;

    // Calculate features
    const priceChange = firstPrice > 0 ? (currentPrice - firstPrice) / firstPrice : 0;
    const volatility = this.calculateVolatility(prices);
    const drawdown = token.peakPrice > 0 ? (token.peakPrice - currentPrice) / token.peakPrice : 0;
    const buyPressure = recentTrades.length > 0 ? recentBuys / recentTrades.length : 0.5;
    const volumeTrend = this.calculateVolumeTrend(token.trades);
    const ageMinutes = (Date.now() - token.firstSeen) / 60000;
    const ageSeconds = (Date.now() - token.firstSeen) / 1000;
    const uniqueTraders = new Set(token.trades.map(t => t.traderPublicKey)).size;
    const devHolding = token.devSold ? 0 : 1 - token.devSoldPercent;
    const devSoldPercent = token.devSoldPercent;

    // Calculate volume acceleration (compare last 30s window to previous 30s)
    const volumeAcceleration = this.calculateVolumeAcceleration(token);

    // Calculate unique trader growth (compare current to 30 seconds ago)
    const uniqueTraderGrowth = this.calculateUniqueTraderGrowth(token);

    // Check momentum conditions
    const momentumSignal = this.checkMomentum(token, buyPressure, volumeAcceleration, uniqueTraderGrowth);

    return {
      priceChange,
      volatility,
      drawdown,
      buyPressure,
      volumeTrend,
      ageMinutes,
      ageSeconds,
      uniqueTraders,
      devHolding,
      devSoldPercent,
      volumeAcceleration,
      uniqueTraderGrowth,
      hasMomentum: momentumSignal.hasMomentum,
    };
  }

  // Calculate volume acceleration (recent window vs previous window)
  private calculateVolumeAcceleration(token: WatchedToken): number {
    if (token.volumeHistory.length < 2) return 1.0;

    const recent = token.volumeHistory[token.volumeHistory.length - 1]?.count || 0;
    const previous = token.volumeHistory[token.volumeHistory.length - 2]?.count || 1;

    return previous > 0 ? recent / previous : 1.0;
  }

  // Calculate unique trader growth
  private calculateUniqueTraderGrowth(token: WatchedToken): number {
    if (token.uniqueTraderHistory.length < 10) return 0;

    const current = token.uniqueTraderHistory[token.uniqueTraderHistory.length - 1];
    const previous = token.uniqueTraderHistory[Math.max(0, token.uniqueTraderHistory.length - 10)];

    return current - previous;
  }

  // Check if token has momentum override conditions
  checkMomentum(
    token: WatchedToken,
    buyPressure: number,
    volumeAcceleration: number,
    uniqueTraderGrowth: number
  ): MomentumSignal {
    const cfg = config.momentumOverride || {
      enabled: true,
      minBuyPressure: 0.75,
      minVolumeAcceleration: 1.2,
      minUniqueTraderGrowth: 3,
    };

    if (!cfg.enabled) {
      return {
        hasMomentum: false,
        buyPressure,
        volumeAcceleration,
        uniqueTraderGrowth,
        reason: 'Momentum override disabled',
      };
    }

    const meetsAll =
      buyPressure >= cfg.minBuyPressure &&
      volumeAcceleration >= cfg.minVolumeAcceleration &&
      uniqueTraderGrowth >= cfg.minUniqueTraderGrowth;

    const reasons: string[] = [];
    if (buyPressure >= cfg.minBuyPressure) {
      reasons.push(`buyPressure ${(buyPressure * 100).toFixed(0)}%`);
    }
    if (volumeAcceleration >= cfg.minVolumeAcceleration) {
      reasons.push(`volume accel ${volumeAcceleration.toFixed(2)}x`);
    }
    if (uniqueTraderGrowth >= cfg.minUniqueTraderGrowth) {
      reasons.push(`+${uniqueTraderGrowth} traders`);
    }

    return {
      hasMomentum: meetsAll,
      buyPressure,
      volumeAcceleration,
      uniqueTraderGrowth,
      reason: meetsAll ? `MOMENTUM: ${reasons.join(', ')}` : 'Conditions not met',
    };
  }

  // Get momentum signal for a token
  getMomentumSignal(mint: string): MomentumSignal | null {
    const token = this.watchlist.get(mint);
    if (!token) return null;

    const recentTrades = token.trades.filter(t => Date.now() - t.timestamp < 60000);
    const recentBuys = recentTrades.filter(t => t.txType === 'buy').length;
    const buyPressure = recentTrades.length > 0 ? recentBuys / recentTrades.length : 0.5;
    const volumeAcceleration = this.calculateVolumeAcceleration(token);
    const uniqueTraderGrowth = this.calculateUniqueTraderGrowth(token);

    return this.checkMomentum(token, buyPressure, volumeAcceleration, uniqueTraderGrowth);
  }

  // Calculate dynamic confidence threshold based on token age
  getDynamicConfidenceThreshold(mint: string): number {
    const token = this.watchlist.get(mint);
    if (!token) return config.watchlist?.maxConfidence || 0.70;

    const ageSeconds = (Date.now() - token.firstSeen) / 1000;
    const minConf = config.watchlist?.minConfidence || 0.55;
    const maxConf = config.watchlist?.maxConfidence || 0.70;

    // Scale confidence from minConf to maxConf over 180 seconds (3 minutes)
    // Formula: requiredConfidence = clamp(0.55 + (tokenAgeSeconds / 180) * 0.15, 0.55, 0.70)
    const scaleFactor = Math.min(ageSeconds / 180, 1.0);
    const threshold = minConf + scaleFactor * (maxConf - minConf);

    return Math.max(minConf, Math.min(maxConf, threshold));
  }

  // Convert features to array for AI model
  featuresToArray(features: WatchlistFeatures): number[] {
    return [
      features.priceChange,                                // Price momentum
      features.volatility,                                 // Risk indicator
      features.drawdown,                                   // How far from peak
      features.buyPressure,                                // Demand indicator
      features.volumeTrend,                                // Increasing or decreasing volume
      Math.min(features.ageMinutes / 10, 1),               // Normalized age (0-1 for first 10 min)
      Math.min(features.uniqueTraders / 50, 1),            // Normalized unique traders
      features.devHolding,                                 // Dev hasn't sold = 1 (scaled by sold percent)
      features.devSoldPercent,                             // NEW: How much dev sold
      Math.min(features.volumeAcceleration / 2, 1),        // NEW: Volume acceleration (capped at 2x)
      Math.min(features.uniqueTraderGrowth / 10, 1),       // NEW: Unique trader growth (capped at 10)
      features.hasMomentum ? 1 : 0,                        // NEW: Momentum override flag
    ];
  }

  private calculateVolatility(prices: number[]): number {
    if (prices.length < 2) return 0;

    const returns = prices.slice(1).map((p, i) =>
      prices[i] > 0 ? (p - prices[i]) / prices[i] : 0
    );

    if (returns.length === 0) return 0;

    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
    const variance = returns.reduce((a, r) => a + (r - mean) ** 2, 0) / returns.length;

    return Math.sqrt(variance);
  }

  private calculateVolumeTrend(trades: TradeData[]): number {
    if (trades.length < 10) return 0;

    const midpoint = Math.floor(trades.length / 2);
    const firstHalfCount = midpoint;
    const secondHalfCount = trades.length - midpoint;

    if (firstHalfCount === 0) return 0;

    return (secondHalfCount - firstHalfCount) / firstHalfCount;
  }

  // Get all tokens ready for AI analysis
  getReadyTokens(): string[] {
    const ready: string[] = [];

    for (const [mint, token] of this.watchlist.entries()) {
      const filterResult = this.passesHardFilters(mint);
      if (filterResult.passes) {
        ready.push(mint);
      }
    }

    return ready;
  }

  // Get all watched tokens (for frontend display)
  getAllTokens(): string[] {
    return Array.from(this.watchlist.keys());
  }

  // Get token info
  getToken(mint: string): WatchedToken | undefined {
    return this.watchlist.get(mint);
  }

  // Check if token is being watched
  isWatched(mint: string): boolean {
    return this.watchlist.has(mint);
  }

  // Get stats
  getStats(): { total: number; ready: number; devSold: number } {
    let ready = 0;
    let devSold = 0;

    for (const token of this.watchlist.values()) {
      if (this.passesHardFilters(token.mint).passes) ready++;
      if (token.devSold) devSold++;
    }

    return {
      total: this.watchlist.size,
      ready,
      devSold,
    };
  }

  // Cleanup old tokens (not seen for >10 minutes with no activity)
  cleanup(maxAge: number = 600000): void {
    const now = Date.now();

    for (const [mint, token] of this.watchlist.entries()) {
      const age = now - token.firstSeen;
      const lastActivity = token.trades.length > 0
        ? token.trades[token.trades.length - 1].timestamp
        : token.firstSeen;
      const timeSinceActivity = now - lastActivity;

      // Remove if old and inactive
      if (age > maxAge && timeSinceActivity > 60000) {
        this.watchlist.delete(mint);
        logger.debug({ mint }, 'Cleaned up inactive token');
      }
    }
  }
}

export const tokenWatchlist = new TokenWatchlist();
</file>

<file path="src/signals/types.ts">
export interface StateVector {
  priceChange1m: number;      // 1-minute price change percentage
  priceChange5m: number;      // 5-minute price change percentage
  volumeZScore: number;       // Volume relative to average
  buySellRatio: number;       // Ratio of buy to sell volume
  holderCount: number;        // Normalized holder count
  top10Concentration: number; // Top 10 holder concentration
  mintRevoked: number;        // 1 if mint authority revoked, 0 otherwise
  freezeRevoked: number;      // 1 if freeze authority revoked, 0 otherwise
  lpLocked: number;           // 1 if LP locked, 0 otherwise
  ageMinutes: number;         // Token age in minutes (normalized)
  tradeIntensity: number;     // Trades per minute normalized
  marketCapSol: number;       // Market cap in SOL (normalized)
  // NEW: Additional features for better DDQN decision making
  drawdownFromPeak: number;   // 0-1, how far price has dropped from peak
  volatility: number;         // 0-1, standard deviation of recent price changes
  uniqueTraders: number;      // 0-1, normalized count of unique traders
  volumeTrend: number;        // -1 to 1, volume acceleration/deceleration
}

export interface RugScore {
  total: number;              // 0-100 overall safety score
  mintAuthorityScore: number; // 0-25 points
  freezeAuthorityScore: number; // 0-20 points
  lpLockedScore: number;      // 0-25 points
  concentrationScore: number; // 0-15 points
  bundledBuysScore: number;   // 0-15 points
  details: string[];          // Human readable breakdown
}

export type PumpPhase = 'cold' | 'building' | 'hot' | 'peak' | 'dumping';

export interface PumpMetrics {
  phase: PumpPhase;
  heat: number;               // 0-200+ heat metric
  volumeRatio: number;        // 1min/5min volume ratio
  priceVelocity: number;      // Rate of price change
  buyPressure: number;        // Buy vs sell imbalance
  confidence: number;         // 0-1 confidence in assessment
}

export interface TokenSignal {
  mint: string;
  state: StateVector;
  rugScore: RugScore;
  pumpMetrics: PumpMetrics;
  timestamp: Date;
  recommendation: 'strong_buy' | 'buy' | 'hold' | 'sell' | 'avoid';
}

export interface FeatureHistory {
  mint: string;
  features: StateVector[];
  timestamps: Date[];
  maxHistory: number;
}

export interface VelocityMetrics {
  mint: string;
  txCount: number;
  buyCount: number;
  sellCount: number;
  uniqueBuyers: Set<string>;
  uniqueSellers: Set<string>;
  txPerMinute: number;
  buyPressure: number;  // buyCount / txCount
  windowStartTime: number;
}

export interface VelocityResult {
  hasGoodVelocity: boolean;
  metrics: VelocityMetrics | null;
  reason: string;
}

export interface EntryResult {
  canEnter: boolean;
  source: 'pump_detector' | 'velocity' | 'none';
  reason: string;
  metrics?: PumpMetrics | VelocityMetrics;
}
</file>

<file path="src/signals/velocity-tracker.ts">
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { VelocityMetrics, VelocityResult } from './types';

const logger = createChildLogger('velocity-tracker');

interface TradeEvent {
  mint: string;
  txType: 'buy' | 'sell';
  traderPublicKey: string;
  marketCapSol: number;
  timestamp: number;
}

export class VelocityTracker {
  // Rolling window of trades per token
  private tokenTrades: Map<string, TradeEvent[]> = new Map();
  private windowMs = 60000; // 60-second rolling window

  constructor() {}

  /**
   * Record a trade event from PumpPortal WebSocket
   */
  recordTrade(data: {
    mint: string;
    txType: 'buy' | 'sell';
    traderPublicKey: string;
    marketCapSol: number;
  }): void {
    const trade: TradeEvent = {
      ...data,
      timestamp: Date.now(),
    };

    let trades = this.tokenTrades.get(data.mint);
    if (!trades) {
      trades = [];
      this.tokenTrades.set(data.mint, trades);
    }

    trades.push(trade);

    // Prune old trades outside the window
    this.pruneOldTrades(data.mint);

    logger.debug({
      mint: data.mint.substring(0, 12),
      txType: data.txType,
      totalTrades: trades.length,
    }, 'Trade recorded');
  }

  /**
   * Remove trades outside the rolling window
   */
  private pruneOldTrades(mint: string): void {
    const trades = this.tokenTrades.get(mint);
    if (!trades) return;

    const cutoff = Date.now() - this.windowMs;
    const filtered = trades.filter(t => t.timestamp >= cutoff);
    this.tokenTrades.set(mint, filtered);
  }

  /**
   * Get velocity metrics for a token
   */
  getMetrics(mint: string): VelocityMetrics | null {
    this.pruneOldTrades(mint);
    const trades = this.tokenTrades.get(mint);

    if (!trades || trades.length === 0) {
      return null;
    }

    const uniqueBuyers = new Set<string>();
    const uniqueSellers = new Set<string>();
    let buyCount = 0;
    let sellCount = 0;

    for (const trade of trades) {
      if (trade.txType === 'buy') {
        buyCount++;
        uniqueBuyers.add(trade.traderPublicKey);
      } else {
        sellCount++;
        uniqueSellers.add(trade.traderPublicKey);
      }
    }

    const txCount = trades.length;
    const windowSeconds = this.windowMs / 1000;
    const txPerMinute = (txCount / windowSeconds) * 60;
    const buyPressure = txCount > 0 ? buyCount / txCount : 0;

    return {
      mint,
      txCount,
      buyCount,
      sellCount,
      uniqueBuyers,
      uniqueSellers,
      txPerMinute,
      buyPressure,
      windowStartTime: Date.now() - this.windowMs,
    };
  }

  /**
   * Check if a token has good velocity for entry
   */
  hasGoodVelocity(mint: string, marketCapSol?: number): VelocityResult {
    const metrics = this.getMetrics(mint);
    const thresholds = config.velocityEntry;

    if (!metrics) {
      return {
        hasGoodVelocity: false,
        metrics: null,
        reason: 'No trade data available',
      };
    }

    // Check market cap limit (only for early tokens)
    if (marketCapSol !== undefined && marketCapSol > thresholds.maxMarketCapSol) {
      return {
        hasGoodVelocity: false,
        metrics,
        reason: `Market cap ${marketCapSol.toFixed(2)} SOL exceeds ${thresholds.maxMarketCapSol} SOL limit`,
      };
    }

    // Check minimum transaction count
    if (metrics.txCount < thresholds.minTxCount) {
      return {
        hasGoodVelocity: false,
        metrics,
        reason: `Only ${metrics.txCount} txs, need ${thresholds.minTxCount}`,
      };
    }

    // Check unique buyers
    if (metrics.uniqueBuyers.size < thresholds.minUniqueBuyers) {
      return {
        hasGoodVelocity: false,
        metrics,
        reason: `Only ${metrics.uniqueBuyers.size} unique buyers, need ${thresholds.minUniqueBuyers}`,
      };
    }

    // Check buy pressure
    if (metrics.buyPressure < thresholds.minBuyPressure) {
      return {
        hasGoodVelocity: false,
        metrics,
        reason: `Buy pressure ${(metrics.buyPressure * 100).toFixed(0)}% below ${(thresholds.minBuyPressure * 100).toFixed(0)}%`,
      };
    }

    // All checks passed
    logger.info({
      mint: mint.substring(0, 12),
      txCount: metrics.txCount,
      uniqueBuyers: metrics.uniqueBuyers.size,
      buyPressure: (metrics.buyPressure * 100).toFixed(0) + '%',
      txPerMinute: metrics.txPerMinute.toFixed(1),
    }, 'Good velocity detected');

    return {
      hasGoodVelocity: true,
      metrics,
      reason: `Velocity OK: ${metrics.txCount} txs, ${metrics.uniqueBuyers.size} buyers, ${(metrics.buyPressure * 100).toFixed(0)}% buys`,
    };
  }

  /**
   * Check if we have any trade data for a token
   */
  hasTradeData(mint: string): boolean {
    const trades = this.tokenTrades.get(mint);
    return trades !== undefined && trades.length > 0;
  }

  /**
   * Clear data for a token (after position closed or rejected)
   */
  clearToken(mint: string): void {
    this.tokenTrades.delete(mint);
  }

  /**
   * Get status for logging
   */
  getStatus(): string {
    return `Tracking ${this.tokenTrades.size} tokens`;
  }
}

export const velocityTracker = new VelocityTracker();
</file>

<file path="src/test-velocity.ts">
/**
 * Quick test script for velocity tracker
 * Run with: npx ts-node src/test-velocity.ts
 */

import { velocityTracker } from './signals/velocity-tracker';
import { config } from './config/settings';

const TEST_MINT = 'TestToken123pump';

console.log('\n=== Velocity Tracker Test ===\n');
console.log('Config thresholds:', config.velocityEntry);

// Test 1: No trades - should fail
console.log('\n--- Test 1: No trades ---');
let result = velocityTracker.hasGoodVelocity(TEST_MINT, 5);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);

// Test 2: Add some trades but not enough
console.log('\n--- Test 2: Only 3 trades (below threshold) ---');
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'buy', traderPublicKey: 'wallet1', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'buy', traderPublicKey: 'wallet2', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'buy', traderPublicKey: 'wallet3', marketCapSol: 5 });

result = velocityTracker.hasGoodVelocity(TEST_MINT, 5);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);
console.log('Metrics:', result.metrics ? {
  txCount: result.metrics.txCount,
  uniqueBuyers: result.metrics.uniqueBuyers.size,
  buyPressure: (result.metrics.buyPressure * 100).toFixed(0) + '%'
} : null);

// Test 3: Add enough trades with good buy pressure
console.log('\n--- Test 3: 6 trades, 4 buyers, 83% buys ---');
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'buy', traderPublicKey: 'wallet4', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'buy', traderPublicKey: 'wallet1', marketCapSol: 5 }); // repeat buyer
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'sell', traderPublicKey: 'seller1', marketCapSol: 5 });

result = velocityTracker.hasGoodVelocity(TEST_MINT, 5);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);
console.log('Metrics:', result.metrics ? {
  txCount: result.metrics.txCount,
  uniqueBuyers: result.metrics.uniqueBuyers.size,
  buyPressure: (result.metrics.buyPressure * 100).toFixed(0) + '%'
} : null);

// Test 4: Too high market cap
console.log('\n--- Test 4: Market cap too high (15 SOL > 10 SOL limit) ---');
result = velocityTracker.hasGoodVelocity(TEST_MINT, 15);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);

// Test 5: Low buy pressure (too many sells)
console.log('\n--- Test 5: Low buy pressure scenario ---');
const TEST_MINT2 = 'TestToken456pump';
velocityTracker.recordTrade({ mint: TEST_MINT2, txType: 'buy', traderPublicKey: 'wallet1', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT2, txType: 'buy', traderPublicKey: 'wallet2', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT2, txType: 'sell', traderPublicKey: 'wallet3', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT2, txType: 'sell', traderPublicKey: 'wallet4', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT2, txType: 'sell', traderPublicKey: 'wallet5', marketCapSol: 5 });

result = velocityTracker.hasGoodVelocity(TEST_MINT2, 5);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);
console.log('Metrics:', result.metrics ? {
  txCount: result.metrics.txCount,
  uniqueBuyers: result.metrics.uniqueBuyers.size,
  buyPressure: (result.metrics.buyPressure * 100).toFixed(0) + '%'
} : null);

// Test 6: Perfect scenario
console.log('\n--- Test 6: Perfect entry scenario ---');
const TEST_MINT3 = 'PerfectToken789pump';
for (let i = 0; i < 8; i++) {
  velocityTracker.recordTrade({ mint: TEST_MINT3, txType: 'buy', traderPublicKey: `buyer${i}`, marketCapSol: 3 });
}
velocityTracker.recordTrade({ mint: TEST_MINT3, txType: 'sell', traderPublicKey: 'seller1', marketCapSol: 3 });
velocityTracker.recordTrade({ mint: TEST_MINT3, txType: 'sell', traderPublicKey: 'seller2', marketCapSol: 3 });

result = velocityTracker.hasGoodVelocity(TEST_MINT3, 3);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);
console.log('Metrics:', result.metrics ? {
  txCount: result.metrics.txCount,
  uniqueBuyers: result.metrics.uniqueBuyers.size,
  uniqueSellers: result.metrics.uniqueSellers.size,
  buyPressure: (result.metrics.buyPressure * 100).toFixed(0) + '%',
  txPerMinute: result.metrics.txPerMinute.toFixed(1)
} : null);

console.log('\n=== Test Complete ===\n');
</file>

<file path="src/utils/logger.ts">
import pino from 'pino';

export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: process.env.NODE_ENV !== 'production' ? {
    target: 'pino-pretty',
    options: {
      colorize: true,
      translateTime: 'SYS:standard',
      ignore: 'pid,hostname',
    },
  } : undefined,
});

export const createChildLogger = (name: string) => {
  return logger.child({ module: name });
};
</file>

<file path="src/api/index.ts">
export { ApiServer, apiServer } from './server';
export { setupRoutes } from './routes';
export { setupWebSocket, getTokensScanned, resetTokensScanned } from './websocket';
</file>

<file path="src/db/schema.ts">
import { Pool } from 'pg';
import { createChildLogger } from '../utils/logger';

const logger = createChildLogger('db-schema');

export const createTables = async (pool: Pool): Promise<void> => {
  logger.info('Creating database tables...');

  await pool.query(`
    CREATE TABLE IF NOT EXISTS tokens (
      mint VARCHAR(64) PRIMARY KEY,
      name VARCHAR(255),
      symbol VARCHAR(32),
      decimals INTEGER,
      created_at TIMESTAMP DEFAULT NOW(),
      creator VARCHAR(64),
      mint_revoked BOOLEAN DEFAULT FALSE,
      freeze_revoked BOOLEAN DEFAULT FALSE,
      last_updated TIMESTAMP DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS price_history (
      id SERIAL PRIMARY KEY,
      mint VARCHAR(64) NOT NULL,
      price_sol DECIMAL(20, 10),
      price_usd DECIMAL(20, 10),
      volume_24h DECIMAL(20, 2),
      market_cap_sol DECIMAL(20, 2),
      liquidity DECIMAL(20, 2),
      timestamp TIMESTAMP DEFAULT NOW(),
      FOREIGN KEY (mint) REFERENCES tokens(mint) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_price_history_mint_time
      ON price_history(mint, timestamp DESC);

    CREATE TABLE IF NOT EXISTS trades (
      id VARCHAR(64) PRIMARY KEY,
      mint VARCHAR(64) NOT NULL,
      symbol VARCHAR(32),
      action INTEGER NOT NULL,
      entry_price DECIMAL(20, 10) NOT NULL,
      exit_price DECIMAL(20, 10),
      amount DECIMAL(20, 10) NOT NULL,
      amount_sol DECIMAL(20, 10) NOT NULL,
      entry_time TIMESTAMP NOT NULL,
      exit_time TIMESTAMP,
      pnl_sol DECIMAL(20, 10),
      pnl_percent DECIMAL(10, 4),
      duration_ms BIGINT,
      features_json TEXT,
      regime INTEGER,
      pump_phase VARCHAR(20),
      exit_reason VARCHAR(32),
      slippage DECIMAL(10, 6),
      fees DECIMAL(20, 10)
    );

    CREATE INDEX IF NOT EXISTS idx_trades_mint ON trades(mint);
    CREATE INDEX IF NOT EXISTS idx_trades_entry_time ON trades(entry_time DESC);

    CREATE TABLE IF NOT EXISTS positions (
      id VARCHAR(64) PRIMARY KEY,
      mint VARCHAR(64) NOT NULL,
      symbol VARCHAR(32),
      entry_price DECIMAL(20, 10) NOT NULL,
      current_price DECIMAL(20, 10) NOT NULL,
      amount DECIMAL(20, 10) NOT NULL,
      amount_sol DECIMAL(20, 10) NOT NULL,
      entry_time TIMESTAMP NOT NULL,
      last_update TIMESTAMP DEFAULT NOW(),
      highest_price DECIMAL(20, 10) NOT NULL,
      lowest_price DECIMAL(20, 10) NOT NULL,
      stop_loss DECIMAL(20, 10) NOT NULL,
      take_profit_json TEXT,
      tp_sold_json TEXT,
      trailing_stop DECIMAL(20, 10),
      status VARCHAR(16) DEFAULT 'open',
      pool_type VARCHAR(16) DEFAULT 'active'
    );

    CREATE INDEX IF NOT EXISTS idx_positions_status ON positions(status);

    CREATE TABLE IF NOT EXISTS model_weights (
      id SERIAL PRIMARY KEY,
      version INTEGER NOT NULL,
      weights_json TEXT NOT NULL,
      metrics_json TEXT,
      created_at TIMESTAMP DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS config (
      key VARCHAR(64) PRIMARY KEY,
      value TEXT NOT NULL,
      updated_at TIMESTAMP DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS whale_wallets (
      address VARCHAR(64) PRIMARY KEY,
      label VARCHAR(255),
      total_volume DECIMAL(20, 2) DEFAULT 0,
      win_rate DECIMAL(5, 4) DEFAULT 0,
      last_active TIMESTAMP,
      created_at TIMESTAMP DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS whale_activity (
      id SERIAL PRIMARY KEY,
      wallet VARCHAR(64) NOT NULL,
      action VARCHAR(16) NOT NULL,
      mint VARCHAR(64) NOT NULL,
      amount DECIMAL(20, 10) NOT NULL,
      amount_sol DECIMAL(20, 10) NOT NULL,
      signature VARCHAR(128),
      timestamp TIMESTAMP DEFAULT NOW(),
      FOREIGN KEY (wallet) REFERENCES whale_wallets(address) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_whale_activity_time
      ON whale_activity(timestamp DESC);

    CREATE TABLE IF NOT EXISTS daily_stats (
      date DATE PRIMARY KEY,
      starting_equity DECIMAL(20, 10),
      ending_equity DECIMAL(20, 10),
      pnl DECIMAL(20, 10),
      pnl_percent DECIMAL(10, 4),
      trades_count INTEGER DEFAULT 0,
      winning_trades INTEGER DEFAULT 0,
      losing_trades INTEGER DEFAULT 0,
      max_drawdown DECIMAL(10, 4),
      created_at TIMESTAMP DEFAULT NOW()
    );

    -- Equity snapshots for historical chart
    CREATE TABLE IF NOT EXISTS equity_snapshots (
      id SERIAL PRIMARY KEY,
      timestamp TIMESTAMP DEFAULT NOW(),
      wallet_balance_sol DECIMAL(20, 10),
      positions_value_sol DECIMAL(20, 10),
      total_equity_sol DECIMAL(20, 10),
      unrealized_pnl_sol DECIMAL(20, 10),
      position_count INTEGER,
      source VARCHAR(16)
    );

    CREATE INDEX IF NOT EXISTS idx_equity_snapshots_time
      ON equity_snapshots(timestamp DESC);

    -- Partial close records for accurate PnL tracking
    CREATE TABLE IF NOT EXISTS partial_closes (
      id SERIAL PRIMARY KEY,
      position_id VARCHAR(64),
      mint VARCHAR(64),
      close_type VARCHAR(32),
      sell_amount_tokens DECIMAL(20, 10),
      sell_amount_sol DECIMAL(20, 10),
      price_at_close DECIMAL(20, 10),
      pnl_sol DECIMAL(20, 10),
      fees_sol DECIMAL(20, 10),
      timestamp TIMESTAMP DEFAULT NOW()
    );

    CREATE INDEX IF NOT EXISTS idx_partial_closes_position
      ON partial_closes(position_id);

    -- Wallet sync audit log
    CREATE TABLE IF NOT EXISTS wallet_sync_log (
      id SERIAL PRIMARY KEY,
      timestamp TIMESTAMP DEFAULT NOW(),
      sol_balance DECIMAL(20, 10),
      token_positions_json TEXT,
      discrepancies_json TEXT
    );

    CREATE INDEX IF NOT EXISTS idx_wallet_sync_time
      ON wallet_sync_log(timestamp DESC);
  `);

  logger.info('Database tables created successfully');
};

export const dropTables = async (pool: Pool): Promise<void> => {
  logger.warn('Dropping all tables...');
  await pool.query(`
    DROP TABLE IF EXISTS wallet_sync_log CASCADE;
    DROP TABLE IF EXISTS partial_closes CASCADE;
    DROP TABLE IF EXISTS equity_snapshots CASCADE;
    DROP TABLE IF EXISTS whale_activity CASCADE;
    DROP TABLE IF EXISTS whale_wallets CASCADE;
    DROP TABLE IF EXISTS price_history CASCADE;
    DROP TABLE IF EXISTS trades CASCADE;
    DROP TABLE IF EXISTS positions CASCADE;
    DROP TABLE IF EXISTS model_weights CASCADE;
    DROP TABLE IF EXISTS config CASCADE;
    DROP TABLE IF EXISTS daily_stats CASCADE;
    DROP TABLE IF EXISTS tokens CASCADE;
  `);
  logger.info('All tables dropped');
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
</file>

<file path=".gitignore">
node_modules/
dist/
.env
*.log
data/
models/*.json
!models/.gitkeep
.DS_Store
*.sqlite
*.db
puppeteer_data/
</file>

<file path="package.json">
{
  "name": "schizo-agent",
  "version": "1.0.0",
  "description": "Solana AI Trading Bot",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "ts-node src/index.ts",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "discover": "ts-node src/scripts/discover-whales.ts",
    "analyze": "ts-node src/scripts/analyze-wallets.ts",
    "find-whales": "ts-node src/scripts/find-smart-wallets.ts"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "@jup-ag/api": "^6.0.0",
    "@solana/web3.js": "^1.95.0",
    "@tensorflow/tfjs": "^4.22.0",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.6",
    "apify-client": "^2.21.0",
    "axios": "^1.13.2",
    "better-sqlite3": "^11.0.0",
    "bs58": "^5.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.0",
    "express": "^5.2.1",
    "groq-sdk": "^0.37.0",
    "helius-sdk": "^1.3.0",
    "node-fetch": "^3.3.0",
    "pg": "^8.11.0",
    "pino": "^8.19.0",
    "pino-pretty": "^10.3.0",
    "puppeteer": "^24.36.0",
    "simple-statistics": "^7.8.0",
    "socket.io": "^4.8.3",
    "ws": "^8.16.0"
  },
  "devDependencies": {
    "@types/better-sqlite3": "^7.6.9",
    "@types/jest": "^29.5.0",
    "@types/node": "^20.11.0",
    "@types/pg": "^8.11.0",
    "@types/ws": "^8.5.10",
    "@typescript-eslint/eslint-plugin": "^6.19.0",
    "@typescript-eslint/parser": "^6.19.0",
    "eslint": "^8.56.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.4.6",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.0"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(echo:*)",
      "Bash(curl:*)",
      "Bash(node -e:*)",
      "Bash(npm install:*)",
      "WebSearch",
      "mcp__sequential-thinking__sequentialthinking"
    ]
  }
}
</file>

<file path=".env.example">
# Solana
SOLANA_RPC_URL=https://mainnet.helius-rpc.com/?api-key=YOUR_KEY
HELIUS_API_KEY=YOUR_HELIUS_KEY
HELIUS_WS_URL=wss://atlas-mainnet.helius-rpc.com/?api-key=YOUR_KEY
PRIVATE_KEY=YOUR_BASE58_PRIVATE_KEY

# Database
DATABASE_URL=postgresql://user:pass@host:port/db
SQLITE_PATH=./data/cache.db

# Trading
INITIAL_CAPITAL_SOL=1.0
MAX_POSITION_SIZE=0.05
DAILY_LOSS_LIMIT=0.15
MAX_CONCURRENT_POSITIONS=5

# Jito MEV Protection
JITO_BLOCK_ENGINE_URL=https://mainnet.block-engine.jito.wtf
JITO_TIP_LAMPORTS=10000

# Apify (Twitter/X scraping)
APIFY_API_TOKEN=YOUR_APIFY_TOKEN

# Gemini (LLM sentiment analysis)
GEMINI_API_KEY=YOUR_GEMINI_KEY

# Feature Flags
PAPER_TRADING=true
ENABLE_JITO=false
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Solana Trading Bot</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="/socket.io/socket.io.js"></script>
  <style>
    :root {
      /* Claude dark mode inspired palette - warm browns */
      --bg-page: #1C1917;
      --bg-card: #262320;
      --bg-card-hover: #2E2A26;
      --bg-elevated: #33302C;
      --border: rgba(255, 245, 230, 0.08);
      --border-light: rgba(255, 245, 230, 0.12);
      --text-primary: #F5F5F4;
      --text-secondary: #A8A29E;
      --text-muted: #78716C;
      --accent: #D97706;
      --accent-secondary: #F59E0B;
      --accent-glow: rgba(217, 119, 6, 0.3);
      --accent-subtle: rgba(217, 119, 6, 0.12);
      --success: #22C55E;
      --success-glow: rgba(34, 197, 94, 0.25);
      --success-subtle: rgba(34, 197, 94, 0.12);
      --error: #EF4444;
      --error-subtle: rgba(239, 68, 68, 0.12);
      --warning: #F59E0B;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-page);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 24px 32px;
      -webkit-font-smoothing: antialiased;
    }

    /* Subtle warm noise texture */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        radial-gradient(circle at 50% 50%, rgba(217, 119, 6, 0.03) 0%, transparent 50%);
      pointer-events: none;
      z-index: -1;
    }

    .dashboard {
      max-width: 1280px;
      margin: 0 auto;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 32px;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 14px;
    }

    .logo-icon {
      width: 48px;
      height: 48px;
      border-radius: 14px;
      background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 8px 32px var(--accent-glow);
    }

    .logo-icon svg {
      width: 26px;
      height: 26px;
      color: white;
    }

    .logo-text h1 {
      font-size: 20px;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: -0.02em;
    }

    .logo-text p {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .live-badge {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 18px;
      border-radius: 100px;
      background: var(--success-subtle);
      border: 1px solid rgba(16, 185, 129, 0.2);
      color: var(--success);
      font-size: 13px;
      font-weight: 500;
      backdrop-filter: blur(10px);
    }

    .live-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
      box-shadow: 0 0 12px var(--success);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(0.9); }
    }

    /* Stats Grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 16px;
      margin-bottom: 24px;
    }

    .stat-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px 24px;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .stat-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255,245,230,0.06), transparent);
    }

    .stat-card:hover {
      background: var(--bg-card-hover);
      border-color: var(--border-light);
      transform: translateY(-2px);
    }

    .stat-card.highlight {
      background: linear-gradient(135deg, rgba(255, 107, 53, 0.08), rgba(255, 143, 92, 0.04));
      border-color: rgba(255, 107, 53, 0.3);
    }

    .stat-card.highlight::after {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
      opacity: 0.3;
      pointer-events: none;
    }

    .stat-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 10px;
    }

    .stat-value {
      font-size: 32px;
      font-weight: 600;
      color: var(--text-primary);
      line-height: 1.1;
      letter-spacing: -0.02em;
    }

    .stat-value.accent {
      background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .stat-sub {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-top: 8px;
    }

    .stat-sub.positive {
      color: var(--success);
    }

    .stat-sub .arrow {
      font-size: 14px;
    }

    /* Main Layout */
    .main-grid {
      display: grid;
      grid-template-columns: 1.6fr 1fr;
      gap: 24px;
    }

    .left-column {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .right-column {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    /* Card Base */
    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 20px;
      overflow: hidden;
      position: relative;
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255,245,230,0.05), transparent);
    }

    .card-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .card-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: -0.01em;
    }

    /* Challenge Card */
    .challenge-card {
      padding: 48px 32px;
      text-align: center;
      position: relative;
    }

    .challenge-card::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      height: 400px;
      background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
      opacity: 0.4;
      pointer-events: none;
    }

    .challenge-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.15em;
      margin-bottom: 20px;
      position: relative;
      z-index: 1;
    }

    .challenge-value {
      font-size: 84px;
      font-weight: 300;
      line-height: 1;
      position: relative;
      z-index: 1;
      background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 80px var(--accent-glow);
    }

    .challenge-value span {
      font-size: 42px;
      background: linear-gradient(135deg, var(--text-muted), var(--text-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .challenge-sub {
      font-size: 14px;
      color: var(--text-secondary);
      margin-top: 12px;
      margin-bottom: 32px;
      position: relative;
      z-index: 1;
    }

    .progress-bar-container {
      position: relative;
      z-index: 1;
    }

    .progress-bar {
      height: 10px;
      background: #3D3835;
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
      border-radius: 10px;
      transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,245,230,0.2), transparent);
      animation: shimmer 2.5s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .progress-markers {
      display: flex;
      justify-content: space-between;
      margin-top: 12px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
    }

    .progress-markers span.active {
      color: var(--accent);
    }

    /* Scanner Card */
    .scanner-card .card-header {
      border-bottom: none;
      padding-bottom: 0;
    }

    .scanner-content {
      padding: 0 24px 24px;
    }

    .scanner-token {
      display: flex;
      align-items: center;
      gap: 14px;
      padding: 18px;
      background: var(--bg-elevated);
      border-radius: 14px;
      margin-bottom: 18px;
      border: 1px solid var(--border);
    }

    .scanner-icon {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      background: linear-gradient(135deg, var(--accent-subtle), transparent);
      border: 1px solid rgba(255, 107, 53, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: var(--accent);
      animation: rotate 2s linear infinite;
    }

    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .scanner-icon.idle {
      animation: none;
    }

    .scanner-token-info h4 {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: -0.01em;
    }

    .scanner-token-info p {
      font-size: 12px;
      color: var(--accent);
      margin-top: 2px;
    }

    .scanner-metrics {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 18px;
    }

    .metric-box {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      transition: all 0.2s ease;
    }

    .metric-box:hover {
      border-color: var(--border-light);
      background: var(--bg-card-hover);
    }

    .metric-value {
      font-size: 22px;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: -0.02em;
    }

    .metric-value.accent {
      color: var(--accent);
    }

    .metric-value.success {
      color: var(--success);
    }

    .metric-label {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.06em;
      margin-top: 6px;
    }

    /* Mini Chart */
    .mini-chart {
      height: 60px;
      display: flex;
      align-items: flex-end;
      gap: 2px;
      padding: 12px 0;
    }

    .chart-bar {
      flex: 1;
      border-radius: 3px;
      transition: all 0.3s ease;
      min-height: 4px;
    }

    .chart-bar.up {
      background: linear-gradient(to top, var(--success), rgba(34, 197, 94, 0.5));
    }

    .chart-bar.down {
      background: linear-gradient(to top, #A8A29E, #78716C);
    }

    .chart-bar:hover {
      opacity: 0.8;
      transform: scaleY(1.1);
    }

    /* Recent Trades */
    .trades-list {
      max-height: 360px;
      overflow-y: auto;
    }

    .trades-list::-webkit-scrollbar {
      width: 4px;
    }

    .trades-list::-webkit-scrollbar-track {
      background: transparent;
    }

    .trades-list::-webkit-scrollbar-thumb {
      background: #44403C;
      border-radius: 4px;
    }

    .trades-list::-webkit-scrollbar-thumb:hover {
      background: #57534E;
    }

    .trade-item {
      display: flex;
      align-items: center;
      padding: 14px 24px;
      border-bottom: 1px solid var(--border);
      gap: 14px;
      transition: background 0.15s ease;
    }

    .trade-item:hover {
      background: var(--bg-elevated);
    }

    .trade-item:last-child {
      border-bottom: none;
    }

    .trade-arrow {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
    }

    .trade-arrow.up {
      background: var(--success-subtle);
      color: var(--success);
      box-shadow: 0 0 20px var(--success-glow);
    }

    .trade-arrow.down {
      background: var(--error-subtle);
      color: var(--error);
    }

    .trade-info {
      flex: 1;
    }

    .trade-token {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .trade-time {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .trade-pnl {
      text-align: right;
    }

    .trade-pnl-value {
      font-size: 14px;
      font-weight: 600;
    }

    .trade-pnl-value.positive {
      color: var(--success);
    }

    .trade-pnl-value.negative {
      color: var(--text-secondary);
    }

    .trade-pnl-percent {
      font-size: 11px;
      color: var(--success);
      margin-top: 2px;
    }

    /* AI Engine */
    .ai-content {
      padding: 28px 24px;
      text-align: center;
    }

    .ai-indicator {
      width: 100px;
      height: 100px;
      margin: 0 auto 20px;
      position: relative;
    }

    .ai-ring-outer {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid #3D3835;
    }

    .ai-ring {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid transparent;
      border-top-color: var(--accent);
      animation: spin 1.5s linear infinite;
    }

    .ai-ring-inner {
      position: absolute;
      width: 70%;
      height: 70%;
      top: 15%;
      left: 15%;
      border-radius: 50%;
      border: 2px solid transparent;
      border-top-color: var(--accent-secondary);
      animation: spin 2s linear infinite reverse;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .ai-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 30px var(--accent-glow);
    }

    .ai-center-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #FAFAF9;
      animation: pulse 2s ease-in-out infinite;
    }

    .ai-status {
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 20px;
    }

    .confidence-bar {
      margin-bottom: 24px;
    }

    .confidence-header {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      margin-bottom: 8px;
    }

    .confidence-header span:first-child {
      color: var(--text-muted);
    }

    .confidence-header span:last-child {
      color: var(--accent);
      font-weight: 600;
    }

    .confidence-track {
      height: 6px;
      background: #3D3835;
      border-radius: 6px;
      overflow: hidden;
    }

    .confidence-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
      border-radius: 6px;
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .win-streak-box {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 24px;
    }

    .win-streak-value {
      font-size: 48px;
      font-weight: 300;
      background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      line-height: 1;
    }

    .win-streak-label {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* Toast Notifications */
    .toast-container {
      position: fixed;
      top: 24px;
      right: 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 1000;
    }

    .toast {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px 20px;
      min-width: 300px;
      animation: slideIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(20px);
    }

    .toast.success {
      border-left: 3px solid var(--success);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), 0 0 40px var(--success-glow);
    }

    .toast.error {
      border-left: 3px solid var(--error);
    }

    .toast.warning {
      border-left: 3px solid var(--warning);
    }

    .toast.info {
      border-left: 3px solid var(--accent);
    }

    .toast-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .toast.success .toast-title {
      color: var(--success);
    }

    .toast.error .toast-title {
      color: var(--error);
    }

    .toast-message {
      font-size: 13px;
      color: var(--text-secondary);
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%) scale(0.9);
        opacity: 0;
      }
      to {
        transform: translateX(0) scale(1);
        opacity: 1;
      }
    }

    /* Empty State */
    .empty-state {
      padding: 40px 24px;
      text-align: center;
      color: var(--text-muted);
      font-size: 13px;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 600px) {
      .stats-grid {
        grid-template-columns: 1fr;
      }
      body {
        padding: 16px;
      }
      .challenge-value {
        font-size: 56px;
      }
    }

    /* Number animation */
    .animate-number {
      display: inline-block;
      transition: transform 0.3s ease;
    }

    .animate-number.updating {
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <div class="dashboard">
    <!-- Header -->
    <header class="header">
      <div class="header-left">
        <div class="logo-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="3"/>
            <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
          </svg>
        </div>
        <div class="logo-text">
          <h1>Solana Trading Bot</h1>
          <p>Autonomous trading system</p>
        </div>
      </div>
      <div class="live-badge" id="statusBadge">
        <span class="live-dot"></span>
        <span id="statusText">Live</span>
      </div>
    </header>

    <!-- Stats Grid -->
    <div class="stats-grid">
      <div class="stat-card highlight">
        <div class="stat-label">Multiplier</div>
        <div class="stat-value accent animate-number" id="statMultiplier">1.00x</div>
        <div class="stat-sub positive" id="profitSub">
          <span class="arrow">â†‘</span>
          <span id="totalProfit">+0.00 SOL profit</span>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Win Rate</div>
        <div class="stat-value animate-number" id="winRate">0%</div>
        <div class="stat-sub positive" id="winRateSub">
          <span class="arrow">â†‘</span>
          <span id="winRateChange">+0% today</span>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Total Trades</div>
        <div class="stat-value animate-number" id="totalTrades">0</div>
        <div class="stat-sub" id="tradesToday">0 today</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Tokens Scanned</div>
        <div class="stat-value animate-number" id="tokensScanned">0</div>
        <div class="stat-sub">Last 24 hours</div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-grid">
      <div class="left-column">
        <!-- Challenge Card -->
        <div class="card">
          <div class="challenge-card">
            <div class="challenge-label">THE 1 â†’ 100 CHALLENGE</div>
            <div class="challenge-value animate-number" id="challengeMultiplier">1.00<span>x</span></div>
            <div class="challenge-sub" id="challengeSub">1.00 SOL from 1 SOL start</div>
            <div class="progress-bar-container">
              <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 1%;"></div>
              </div>
              <div class="progress-markers">
                <span class="active">1x</span>
                <span>10x</span>
                <span>25x</span>
                <span>50x</span>
                <span>100x</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Token Scanner -->
        <div class="card scanner-card">
          <div class="card-header">
            <span class="card-title">Token Scanner</span>
          </div>
          <div class="scanner-content">
            <div class="scanner-token">
              <div class="scanner-icon idle" id="scannerIcon">âŸ³</div>
              <div class="scanner-token-info">
                <h4 id="scannerTokenName">Waiting...</h4>
                <p id="scannerStatus">Scanning for tokens</p>
              </div>
            </div>
            <div class="scanner-metrics">
              <div class="metric-box">
                <div class="metric-value accent" id="safetyScore">--</div>
                <div class="metric-label">Safety Score</div>
              </div>
              <div class="metric-box">
                <div class="metric-value success" id="sentiment">--</div>
                <div class="metric-label">Sentiment</div>
              </div>
              <div class="metric-box">
                <div class="metric-value" id="volume24h">--</div>
                <div class="metric-label">24H Volume</div>
              </div>
              <div class="metric-box">
                <div class="metric-value" id="holders">--</div>
                <div class="metric-label">Holders</div>
              </div>
            </div>
            <div class="mini-chart" id="miniChart">
              <!-- Dynamic chart bars -->
            </div>
          </div>
        </div>
      </div>

      <div class="right-column">
        <!-- Recent Trades -->
        <div class="card">
          <div class="card-header">
            <span class="card-title">Recent Trades</span>
          </div>
          <div class="trades-list" id="tradesList">
            <div class="empty-state">No trades yet</div>
          </div>
        </div>

        <!-- AI Engine -->
        <div class="card">
          <div class="card-header">
            <span class="card-title">AI Engine</span>
          </div>
          <div class="ai-content">
            <div class="ai-indicator">
              <div class="ai-ring-outer"></div>
              <div class="ai-ring"></div>
              <div class="ai-ring-inner"></div>
              <div class="ai-center">
                <div class="ai-center-dot"></div>
              </div>
            </div>
            <div class="ai-status" id="aiStatus">Analyzing token metrics</div>
            <div class="confidence-bar">
              <div class="confidence-header">
                <span>Confidence</span>
                <span id="confidenceValue">0%</span>
              </div>
              <div class="confidence-track">
                <div class="confidence-fill" id="confidenceFill" style="width: 0%;"></div>
              </div>
            </div>
            <div class="win-streak-box">
              <div class="win-streak-value animate-number" id="winStreak">0</div>
              <div class="win-streak-label">Win streak</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toastContainer"></div>

  <script>
    // Connect to WebSocket
    const socket = io();

    // DOM Elements
    const statusBadge = document.getElementById('statusBadge');
    const statusText = document.getElementById('statusText');
    const statMultiplier = document.getElementById('statMultiplier');
    const totalProfit = document.getElementById('totalProfit');
    const profitSub = document.getElementById('profitSub');
    const winRate = document.getElementById('winRate');
    const winRateChange = document.getElementById('winRateChange');
    const totalTrades = document.getElementById('totalTrades');
    const tradesToday = document.getElementById('tradesToday');
    const tokensScanned = document.getElementById('tokensScanned');
    const challengeMultiplier = document.getElementById('challengeMultiplier');
    const challengeSub = document.getElementById('challengeSub');
    const progressFill = document.getElementById('progressFill');
    const scannerIcon = document.getElementById('scannerIcon');
    const scannerTokenName = document.getElementById('scannerTokenName');
    const scannerStatus = document.getElementById('scannerStatus');
    const safetyScore = document.getElementById('safetyScore');
    const sentiment = document.getElementById('sentiment');
    const volume24h = document.getElementById('volume24h');
    const holders = document.getElementById('holders');
    const miniChart = document.getElementById('miniChart');
    const tradesList = document.getElementById('tradesList');
    const aiStatus = document.getElementById('aiStatus');
    const confidenceValue = document.getElementById('confidenceValue');
    const confidenceFill = document.getElementById('confidenceFill');
    const winStreak = document.getElementById('winStreak');
    const toastContainer = document.getElementById('toastContainer');

    // Initialize chart
    function initChart() {
      let bars = '';
      for (let i = 0; i < 40; i++) {
        const height = Math.random() * 70 + 20;
        const isUp = Math.random() > 0.4;
        bars += `<div class="chart-bar ${isUp ? 'up' : 'down'}" style="height: ${height}%"></div>`;
      }
      miniChart.innerHTML = bars;
    }
    initChart();

    // Animate number update
    function animateValue(element, newValue) {
      element.classList.add('updating');
      element.textContent = newValue;
      setTimeout(() => element.classList.remove('updating'), 300);
    }

    // Connection status
    socket.on('connect', () => {
      statusBadge.style.background = 'var(--success-subtle)';
      statusBadge.style.borderColor = 'rgba(16, 185, 129, 0.2)';
      statusBadge.style.color = 'var(--success)';
      statusText.textContent = 'Live';
      loadInitialData();
    });

    socket.on('disconnect', () => {
      statusBadge.style.background = 'var(--error-subtle)';
      statusBadge.style.borderColor = 'rgba(239, 68, 68, 0.2)';
      statusBadge.style.color = 'var(--error)';
      statusText.textContent = 'Disconnected';
    });

    // Load initial data
    async function loadInitialData() {
      try {
        const [statsRes, tradesRes] = await Promise.all([
          fetch('/api/stats'),
          fetch('/api/trades?limit=10')
        ]);

        const stats = await statsRes.json();
        const trades = await tradesRes.json();

        updateStats(stats);
        renderTrades(trades);
      } catch (error) {
        console.error('Failed to load initial data:', error);
      }
    }

    // Update stats
    function updateStats(stats) {
      const multiplier = parseFloat(stats.multiplier);
      const equity = parseFloat(stats.currentEquity);
      const profit = equity - parseFloat(stats.initialCapital);

      animateValue(statMultiplier, multiplier.toFixed(2) + 'x');
      challengeMultiplier.innerHTML = multiplier.toFixed(2) + '<span>x</span>';
      challengeSub.textContent = `${equity.toFixed(2)} SOL from ${stats.initialCapital} SOL start`;

      totalProfit.textContent = `${profit >= 0 ? '+' : ''}${profit.toFixed(2)} SOL profit`;
      profitSub.className = 'stat-sub ' + (profit >= 0 ? 'positive' : '');

      animateValue(winRate, stats.winRate + '%');
      animateValue(totalTrades, stats.totalTrades);
      animateValue(tokensScanned, formatNumber(stats.tokensScanned || 0));
      animateValue(winStreak, stats.winStreak || 0);

      // Progress bar (1x to 100x)
      const progress = Math.min(100, (multiplier / 100) * 100);
      progressFill.style.width = Math.max(1, progress) + '%';

      // Update progress markers
      const markers = document.querySelectorAll('.progress-markers span');
      markers.forEach((marker, i) => {
        const thresholds = [1, 10, 25, 50, 100];
        marker.className = multiplier >= thresholds[i] ? 'active' : '';
      });

      // Confidence
      const confidence = Math.min(100, Math.max(0, parseFloat(stats.winRate) * 1.2));
      confidenceValue.textContent = confidence.toFixed(0) + '%';
      confidenceFill.style.width = confidence + '%';
    }

    // Render trades
    function renderTrades(trades) {
      const closedTrades = trades.filter(t => !t.isOpen).slice(0, 6);

      if (closedTrades.length === 0) {
        tradesList.innerHTML = '<div class="empty-state">No trades yet</div>';
        return;
      }

      tradesList.innerHTML = closedTrades.map(t => {
        const pnl = parseFloat(t.pnlSol || 0);
        const pnlPercent = parseFloat(t.pnlPercent || 0);
        const isProfit = pnl >= 0;
        const time = formatTime(new Date(t.exitTime));

        return `
          <div class="trade-item">
            <div class="trade-arrow ${isProfit ? 'up' : 'down'}">${isProfit ? 'â†‘' : 'â†“'}</div>
            <div class="trade-info">
              <div class="trade-token">$${t.symbol || t.mint.substring(0, 6).toUpperCase()}</div>
              <div class="trade-time">${time}</div>
            </div>
            <div class="trade-pnl">
              <div class="trade-pnl-value ${isProfit ? 'positive' : 'negative'}">${isProfit ? '+' : ''}${pnl.toFixed(3)} SOL</div>
              ${isProfit ? `<div class="trade-pnl-percent">+${pnlPercent.toFixed(0)}%</div>` : ''}
            </div>
          </div>
        `;
      }).join('');
    }

    // WebSocket event handlers
    socket.on('stats:initial', updateStats);
    socket.on('stats:update', updateStats);
    socket.on('trades:initial', renderTrades);

    socket.on('scanner:token', (data) => {
      scannerIcon.classList.remove('idle');
      scannerTokenName.textContent = '$' + (data.mint.substring(0, 6).toUpperCase());
      scannerStatus.textContent = 'Analyzing...';
      animateValue(tokensScanned, formatNumber(data.tokensScanned));

      safetyScore.textContent = Math.floor(Math.random() * 30 + 70);
      sentiment.textContent = '+' + (Math.random() * 0.8 + 0.2).toFixed(1);
      volume24h.textContent = '$' + formatNumber(Math.random() * 900000 + 100000);
      holders.textContent = formatNumber(Math.random() * 5000 + 1000);

      initChart();
    });

    socket.on('scanner:idle', (data) => {
      scannerIcon.classList.add('idle');
      scannerTokenName.textContent = 'Waiting...';
      scannerStatus.textContent = 'Scanning for tokens';
      safetyScore.textContent = '--';
      sentiment.textContent = '--';
      volume24h.textContent = '--';
      holders.textContent = '--';
      animateValue(tokensScanned, formatNumber(data.tokensScanned));
    });

    socket.on('trade:open', (trade) => {
      aiStatus.textContent = `Bought ${trade.symbol || trade.mint.substring(0, 6)}`;
      showToast('info', 'Position Opened', `Bought ${trade.symbol || trade.mint.substring(0, 8)} for ${trade.amountSol} SOL`);
    });

    socket.on('trade:close', (trade) => {
      const pnl = parseFloat(trade.pnlSol);
      if (pnl > 0) {
        showToast('success', `+${trade.pnlSol} SOL`, `${trade.symbol || trade.mint.substring(0, 8)} closed at ${trade.pnlPercent}%`);
      } else {
        showToast('error', `${trade.pnlSol} SOL`, `${trade.symbol || trade.mint.substring(0, 8)} stopped out`);
      }
      fetch('/api/trades?limit=10')
        .then(r => r.json())
        .then(trades => renderTrades(trades));
    });

    socket.on('toast', (data) => showToast(data.type, data.title, data.message));

    socket.on('status:paused', (data) => {
      statusBadge.style.background = 'var(--error-subtle)';
      statusBadge.style.color = 'var(--error)';
      statusText.textContent = 'Paused';
      showToast('warning', 'Trading Paused', data.reason);
    });

    // Helper functions
    function showToast(type, title, message) {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <div class="toast-title">${title}</div>
        <div class="toast-message">${message}</div>
      `;
      toastContainer.appendChild(toast);

      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(100%)';
        toast.style.transition = 'all 0.3s ease';
        setTimeout(() => toast.remove(), 300);
      }, 4000);
    }

    function formatNumber(num) {
      if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
      if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
      return num.toString();
    }

    function formatTime(date) {
      return date.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
    }

    // AI status rotation
    const aiStatuses = [
      'Analyzing token metrics',
      'Evaluating market conditions',
      'Checking holder distribution',
      'Scanning for opportunities',
      'Processing signals',
      'Monitoring price action'
    ];
    let aiStatusIndex = 0;
    setInterval(() => {
      aiStatusIndex = (aiStatusIndex + 1) % aiStatuses.length;
      aiStatus.textContent = aiStatuses[aiStatusIndex];
    }, 3000);
  </script>
</body>
</html>
</file>

<file path="src/index.ts">
import { Pool } from 'pg';
import { createChildLogger } from './utils/logger';
import { config } from './config/settings';
import { createTables } from './db/schema';
import { repository } from './db/repository';

// Data Layer
import { heliusWs, priceFeed, whaleTracker, NewTokenEvent, PriceData, WhaleActivity } from './data';
import { pumpPortalWs, BondingCurveData } from './data/pumpportal-ws';

// Signal Processing Layer
import { featureExtractor, rugDetector, pumpDetector, velocityTracker, entryEvaluator, rugMonitor, narrativeSensor, NarrativeSignal, tokenWatchlist } from './signals';
import { StateVector, PumpMetrics, RugScore } from './signals/types';

// AI Layer
import { ddqnAgent, regimeDetector, positionSizer } from './ai';
import { Action, AIDecision, MarketRegime } from './ai/types';

// Execution Layer
import { txManager } from './execution';

// Risk Layer
import { positionManager, capitalAllocator, drawdownGuard } from './risk';

// Learning Layer
import { tradeLogger, performanceAnalytics, modelTrainer } from './learning';

// Services Layer
import { walletSync, equityTracker, positionReconciler } from './services';

// API Layer
import { apiServer } from './api';

const logger = createChildLogger('orchestrator');

class TradingBot {
  private isRunning = false;
  private tokenQueue: NewTokenEvent[] = [];
  private processedMints: Set<string> = new Set();
  private bondingCurveCache: Map<string, BondingCurveData> = new Map();
  private rejectionStats = {
    quickSafety: 0,
    liquidity: 0,
    rugScore: 0,
    entryEval: 0,  // Combined pump/velocity rejection
    aiDecision: 0,
    riskCheck: 0,
    total: 0,
    passed: 0,
  };

  async start(): Promise<void> {
    logger.info('Starting Solana AI Trading Bot');
    logger.info({ paperTrading: config.paperTrading }, 'Mode');

    try {
      // Initialize database
      logger.info('Initializing database...');
      await repository.connect();
      const pool = new Pool({ connectionString: config.databaseUrl });
      await createTables(pool);
      await pool.end();

      // Initialize all layers
      logger.info('Initializing layers...');

      // Execution layer
      await txManager.initialize();

      // AI layer
      await modelTrainer.initialize();
      await regimeDetector.start();

      // Risk layer
      await capitalAllocator.syncWithWallet();
      await positionManager.start();
      await drawdownGuard.start();
      await drawdownGuard.resetAll();  // Clear old state for fresh testing - must be AFTER start

      // Data layer
      await priceFeed.start();
      await whaleTracker.start();

      // Setup event handlers
      this.setupEventHandlers();

      // Start WebSocket connections
      await heliusWs.connect();

      // Connect to PumpPortal for bonding curve data
      try {
        await pumpPortalWs.connect();
        logger.info('PumpPortal WebSocket connected');
      } catch (error) {
        logger.warn({ error }, 'PumpPortal connection failed - will use DexScreener fallback');
      }

      // Start learning
      await modelTrainer.startPeriodicTraining();

      // Start API server for dashboard
      await apiServer.start();

      // Start wallet sync and equity tracking services
      await walletSync.start(30000);      // Sync wallet every 30s
      await equityTracker.start(60000);   // Snapshot equity every 60s

      // Initial position reconciliation to detect any phantoms from previous session
      const reconcileResult = await positionReconciler.reconcile(true);
      if (reconcileResult.phantomsFound.length > 0) {
        logger.warn({
          phantoms: reconcileResult.phantomsFound.length,
          closed: reconcileResult.phantomsClosed,
        }, 'Startup reconciliation found phantom positions');
      }

      this.isRunning = true;
      logger.info('Bot started successfully');

      // Process token queue periodically
      this.startTokenProcessor();

      // Periodic status logging
      this.startStatusLogger();

    } catch (error) {
      logger.error({ error }, 'Failed to start bot');
      await this.stop();
      throw error;
    }
  }

  private setupEventHandlers(): void {
    // New token detection from Helius
    heliusWs.on('newToken', (event: NewTokenEvent) => {
      logger.info({ mint: event.mint }, 'New token detected');
      this.tokenQueue.push(event);
    });

    // PumpPortal bonding curve data - add to watchlist for AI-driven entry
    pumpPortalWs.on('newToken', (data: BondingCurveData) => {
      this.bondingCurveCache.set(data.mint, data);

      // Subscribe to this token's trades for data collection
      pumpPortalWs.subscribeToToken(data.mint);

      // Add to watchlist for AI-driven entry (instead of immediate sniping)
      // Creator is the bonding curve key for pump.fun tokens
      tokenWatchlist.addToken(data.mint, data.bondingCurveKey);

      // Record initial price point
      tokenWatchlist.recordPrice(data.mint, data.priceSol, data.marketCapSol);

      logger.info({
        mint: data.mint.substring(0, 15),
        marketCapSol: data.marketCapSol.toFixed(2),
        liquiditySol: data.liquiditySol.toFixed(2),
      }, 'New token added to watchlist (AI-driven entry)');
    });

    pumpPortalWs.on('trade', (data: BondingCurveData & { txType: 'buy' | 'sell'; traderPublicKey: string; tokenAmount?: number }) => {
      // Update cache with latest bonding curve state
      this.bondingCurveCache.set(data.mint, data);

      // Record trade for velocity tracking (legacy)
      velocityTracker.recordTrade({
        mint: data.mint,
        txType: data.txType,
        traderPublicKey: data.traderPublicKey,
        marketCapSol: data.marketCapSol,
      });

      // Record trade to watchlist for AI-driven entry analysis
      tokenWatchlist.recordTrade(data.mint, {
        txType: data.txType,
        traderPublicKey: data.traderPublicKey,
        tokenAmount: data.tokenAmount || 0,
        marketCapSol: data.marketCapSol,
        priceSol: data.priceSol,
      });

      // Feed to rug monitor for post-entry protection
      rugMonitor.processTrade({
        mint: data.mint,
        txType: data.txType,
        traderPublicKey: data.traderPublicKey,
        tokenAmount: data.tokenAmount || 0,
        marketCapSol: data.marketCapSol,
        priceSol: data.priceSol,
      });
    });

    // Whale activity
    whaleTracker.on('whaleActivity', (activity: WhaleActivity) => {
      logger.info({
        wallet: activity.wallet,
        action: activity.action,
        mint: activity.mint,
        amountSol: activity.amountSol,
      }, 'Whale activity detected');

      // Could trigger analysis of the token
      if (activity.action === 'buy' && activity.amountSol > 50) {
        this.tokenQueue.push({
          mint: activity.mint,
          signature: '',
          timestamp: new Date(),
          creator: activity.wallet,
        });
      }
    });

    // Position events
    positionManager.on('positionOpened', (position) => {
      capitalAllocator.reserveCapital(position.amountSol, position.poolType);
      // Note: rugMonitor.watchPosition is called in analyzeAndTrade where we have creator info
    });

    positionManager.on('positionClosed', async (data) => {
      const { position, reason, pnlSol, pnlPercent, partialClosePnl, actualSolReceived } = data;

      capitalAllocator.releaseCapital(position.amountSol, position.poolType);
      drawdownGuard.recordTrade(pnlSol);
      positionSizer.recordTrade(pnlSol > 0);

      // Stop watching for rug signals
      rugMonitor.unwatchPosition(position.mint);

      // Log exit with accurate PnL including partial closes and actual SOL received
      await tradeLogger.logExit({
        positionId: position.id,
        exitPrice: position.currentPrice,
        exitReason: reason,
        actualSolReceived,
        partialClosePnl: partialClosePnl || 0,
      });

      // Take equity snapshot on trade close
      await equityTracker.onTradeClose();

      // Add to training
      await modelTrainer.addTradeExperience(position.id);

      logger.info({
        positionId: position.id,
        reason,
        pnlSol: pnlSol.toFixed(6),
        pnlPercent: pnlPercent.toFixed(2),
        partialClosePnl: (partialClosePnl || 0).toFixed(6),
      }, 'Position closed');
    });

    // Rug monitor alerts - close position immediately on critical rug signals
    rugMonitor.on('rugAlert', async (warning) => {
      const position = positionManager.getPositionByMint(warning.mint);
      if (position && position.status === 'open') {
        logger.error({
          positionId: position.id,
          mint: warning.mint.substring(0, 12) + '...',
          type: warning.type,
          message: warning.message,
        }, 'RUG DETECTED - Closing position immediately');

        await positionManager.closePosition(position.id, 'rug_detected');
      }
    });

    positionManager.on('partialClose', async (data) => {
      logger.info({
        positionId: data.position.id,
        tpLevel: data.tpLevel + 1,
        sellAmount: data.sellAmount,
      }, 'Partial close executed');
    });

    // Drawdown events
    drawdownGuard.on('tradingPaused', (data) => {
      logger.error(data, 'TRADING PAUSED');
    });

    drawdownGuard.on('tradingResumed', (data) => {
      logger.info(data, 'Trading resumed');
    });

    // Price events
    priceFeed.on('significantPriceChange', (data: { mint: string; change: number; data: PriceData }) => {
      logger.debug({
        mint: data.mint,
        change: data.change.toFixed(2),
      }, 'Significant price change');
    });
  }

  private startTokenProcessor(): void {
    // Process Helius token queue (legacy - for whale activity etc)
    setInterval(() => {
      this.processTokenQueue();
    }, 2000); // Process every 2 seconds

    // NEW: Process watchlist for AI-driven entry
    setInterval(() => {
      this.processWatchlistTokens();
    }, 5000); // Check watchlist every 5 seconds

    // Cleanup old watchlist entries
    setInterval(() => {
      tokenWatchlist.cleanup(600000); // 10 minute max age
    }, 60000); // Cleanup every minute
  }

  // NEW: Process tokens in watchlist that have enough data for AI analysis
  private async processWatchlistTokens(): Promise<void> {
    if (!this.isRunning) return;

    if (!drawdownGuard.canTrade()) {
      return; // Already logged in processTokenQueue
    }

    const readyTokens = tokenWatchlist.getReadyTokens();

    if (readyTokens.length > 0) {
      const stats = tokenWatchlist.getStats();
      logger.info({
        total: stats.total,
        ready: stats.ready,
        devSold: stats.devSold,
      }, 'Watchlist status');
    }

    for (const mint of readyTokens) {
      // Skip if already in a position or recently processed
      if (this.processedMints.has(mint)) continue;
      if (positionManager.getPositionByMint(mint)) continue;

      const filterResult = tokenWatchlist.passesHardFilters(mint);
      if (!filterResult.passes) {
        logger.debug({ mint: mint.substring(0, 15), reason: filterResult.reason }, 'Watchlist token rejected by hard filters');
        continue;
      }

      // Get watchlist features for logging/decision
      const watchlistFeatures = tokenWatchlist.extractFeatures(mint);
      if (!watchlistFeatures) continue;

      logger.info({
        mint: mint.substring(0, 15),
        priceChange: (watchlistFeatures.priceChange * 100).toFixed(2) + '%',
        volatility: watchlistFeatures.volatility.toFixed(4),
        drawdown: (watchlistFeatures.drawdown * 100).toFixed(2) + '%',
        buyPressure: (watchlistFeatures.buyPressure * 100).toFixed(0) + '%',
        uniqueTraders: watchlistFeatures.uniqueTraders,
        ageMinutes: watchlistFeatures.ageMinutes.toFixed(1),
      }, 'Analyzing watchlist token for AI entry');

      // Create synthetic event for analyzeAndTrade
      const token = tokenWatchlist.getToken(mint);
      if (!token) continue;

      const syntheticEvent: NewTokenEvent = {
        mint,
        signature: '',
        timestamp: new Date(token.firstSeen),
        creator: token.creator,
      };

      try {
        await this.analyzeAndTrade(syntheticEvent);
        this.processedMints.add(mint);

        // Cleanup processed token from watchlist
        tokenWatchlist.removeToken(mint);
      } catch (error) {
        logger.error({ mint, error }, 'Failed to analyze watchlist token');
      }
    }
  }

  private async processTokenQueue(): Promise<void> {
    if (!this.isRunning) {
      return;
    }

    if (!drawdownGuard.canTrade()) {
      const ddState = drawdownGuard.getState();
      logger.warn({
        queueLen: this.tokenQueue.length,
        currentDrawdown: (ddState.currentDrawdown * 100).toFixed(2),
        dailyPnl: ddState.dailyPnl.toFixed(4),
        isPaused: ddState.isPaused,
      }, 'Drawdown guard blocking trading');
      return;
    }

    if (this.tokenQueue.length > 0) {
      logger.info({ queueLen: this.tokenQueue.length }, 'Processing token queue');
    }

    while (this.tokenQueue.length > 0) {
      const token = this.tokenQueue.shift();
      if (!token) continue;

      // Skip if already processed recently
      if (this.processedMints.has(token.mint)) continue;

      try {
        logger.info({ mint: token.mint.substring(0, 15) }, 'Analyzing token...');
        await this.analyzeAndTrade(token);
        this.processedMints.add(token.mint);

        // Clean up old processed mints
        if (this.processedMints.size > 1000) {
          const oldest = Array.from(this.processedMints).slice(0, 500);
          oldest.forEach((m) => this.processedMints.delete(m));
        }
      } catch (error) {
        logger.error({ mint: token.mint, error }, 'Failed to analyze token');
      }
    }
  }

  private async analyzeAndTrade(token: NewTokenEvent): Promise<void> {
    const { mint } = token;

    logger.debug({ mint }, 'Analyzing token');

    // Get token info
    const tokenInfo = await priceFeed.getTokenInfo(mint);
    const holderInfo = await priceFeed.getHolderInfo(mint);

    // Quick safety check
    const quickSafety = rugDetector.getQuickSafetyFlags(tokenInfo, mint);
    logger.info({ mint, quickSafety }, 'Quick safety check result');
    if (!quickSafety.isSafe) {
      this.rejectionStats.quickSafety++;
      this.rejectionStats.total++;
      logger.info({ mint, flags: quickSafety.flags }, 'REJECTED: Quick safety check failed');
      return;
    }

    // Get price/liquidity data
    const isPumpFunToken = mint.endsWith('pump');
    let priceData = await priceFeed.fetchTokenPrice(mint);
    let bondingCurveData: BondingCurveData | null = null;

    // For Pump.fun tokens: Try PumpPortal bonding curve data first (instant!)
    if (isPumpFunToken) {
      // Check cache from PumpPortal WebSocket
      bondingCurveData = this.bondingCurveCache.get(mint) || pumpPortalWs.getBondingCurveData(mint);

      if (!bondingCurveData) {
        // Wait briefly for PumpPortal to receive the data
        for (let retry = 0; retry < 3; retry++) {
          logger.info({ mint, retry: retry + 1 }, 'Waiting for PumpPortal bonding curve data...');
          await new Promise(r => setTimeout(r, 2000));
          bondingCurveData = this.bondingCurveCache.get(mint) || pumpPortalWs.getBondingCurveData(mint);
          if (bondingCurveData) break;
        }
      }

      if (bondingCurveData) {
        logger.info({
          mint,
          source: 'PumpPortal',
          marketCapSol: bondingCurveData.marketCapSol.toFixed(2),
          liquiditySol: bondingCurveData.liquiditySol.toFixed(4),
          priceSol: bondingCurveData.priceSol.toExponential(4),
          isGraduated: bondingCurveData.isGraduated,
        }, 'Got bonding curve data');

        // Mark as bonding curve token for trade routing
        txManager.markAsBondingCurve(mint);
      } else if (!priceData) {
        // Try DexScreener as fallback (might be graduated)
        for (let retry = 0; retry < 2; retry++) {
          logger.info({ mint, retry: retry + 1 }, 'Trying DexScreener fallback...');
          await new Promise(r => setTimeout(r, 3000));
          priceData = await priceFeed.fetchTokenPrice(mint);
          if (priceData) {
            txManager.markAsGraduated(mint);
            break;
          }
        }
      }
    }

    // Determine liquidity
    let liquiditySol = 0;
    let priceSol = 0;
    let isBondingCurve = false;

    if (bondingCurveData) {
      // For bonding curve tokens, use marketCapSol as liquidity indicator
      // liquiditySol from bonding curve is essentially 0 for new tokens
      // marketCapSol is a better indicator of whether the token is tradeable
      liquiditySol = bondingCurveData.marketCapSol; // Use marketCap as proxy for new tokens
      priceSol = bondingCurveData.priceSol;
      isBondingCurve = true;
    } else if (priceData) {
      liquiditySol = priceData.liquidity / (priceFeed.getSolPrice() || 200); // Convert USD to SOL
      priceSol = priceData.priceSol;
    }

    // Minimum liquidity threshold - lower for bonding curve tokens
    const minLiquidity = isBondingCurve ? 10 : config.minLiquiditySol; // 10 SOL mcap for new tokens

    logger.info({
      mint,
      source: bondingCurveData ? 'PumpPortal' : (priceData ? 'DexScreener' : 'none'),
      liquiditySol: liquiditySol.toFixed(4),
      priceSol: priceSol.toExponential(4),
      minRequired: minLiquidity,
      isBondingCurve
    }, 'Liquidity check');

    // No data from either source
    if (!bondingCurveData && !priceData) {
      this.rejectionStats.liquidity++;
      this.rejectionStats.total++;
      logger.warn({ mint }, 'REJECTED: No price data from PumpPortal or DexScreener');
      return;
    }

    if (liquiditySol < minLiquidity) {
      this.rejectionStats.liquidity++;
      this.rejectionStats.total++;
      logger.info({ mint, liquiditySol, minRequired: minLiquidity }, 'REJECTED: Insufficient liquidity');
      return;
    }

    // Create unified price data for downstream processing
    // If using bonding curve data, convert to PriceData format
    if (!priceData && bondingCurveData) {
      const solPrice = priceFeed.getSolPrice() || 200;
      priceData = {
        mint,
        priceSol: bondingCurveData.priceSol,
        priceUsd: bondingCurveData.priceSol * solPrice,
        volume24h: 0,
        marketCapSol: bondingCurveData.marketCapSol,
        liquidity: bondingCurveData.liquiditySol * solPrice, // Convert to USD
        priceChange1m: 0,
        priceChange5m: 0,
        priceChange1h: 0,
        timestamp: bondingCurveData.timestamp,
      };
    }

    // Full rug analysis (LP info passed as null - loses 25 potential points)
    const rugScore = await rugDetector.analyzeToken(mint, tokenInfo, holderInfo, null);

    // Get narrative signal (async but don't block critical path too long)
    // We fire and forget the broadcast, or await if we want it in decision (future)
    narrativeSensor.getNarrativeSignal(tokenInfo?.symbol).then((signal: NarrativeSignal) => {
      apiServer.getIO().emit('signal:narrative', {
        mint,
        symbol: tokenInfo?.symbol,
        ...signal
      });
    }).catch((err: unknown) => logger.error({ err }, 'Failed to get narrative signal'));

    logger.info({
      mint,
      rugTotal: rugScore.total,
      minRequired: config.minRugScore,
      mintAuth: rugScore.mintAuthorityScore,
      freezeAuth: rugScore.freezeAuthorityScore,
      lpLocked: rugScore.lpLockedScore,
      concentration: rugScore.concentrationScore,
      bundledBuys: rugScore.bundledBuysScore,
    }, 'Rug analysis breakdown');

    if (!rugDetector.isSafe(rugScore)) {
      this.rejectionStats.rugScore++;
      this.rejectionStats.total++;
      logger.info({ mint, rugTotal: rugScore.total, minRequired: config.minRugScore }, 'REJECTED: Token failed rug check');
      return;
    }

    // Extract features (priceData is guaranteed non-null here due to earlier checks)
    const features = await featureExtractor.extractFeatures(
      mint,
      priceData!,
      holderInfo,
      tokenInfo
    );

    // Entry evaluation: uses pump detector if price history exists, otherwise velocity
    priceFeed.addToWatchList(mint); // Start tracking
    await new Promise((r) => setTimeout(r, 2000)); // Reduced delay for faster entry

    // Use unified entry evaluator
    const entryResult = entryEvaluator.evaluate(mint, bondingCurveData?.marketCapSol);

    // Also get pump metrics for logging/display regardless of entry source
    const pumpMetrics = pumpDetector.analyzePump(mint);
    logger.info({
      mint,
      entrySource: entryResult.source,
      canEnter: entryResult.canEnter,
      entryReason: entryResult.reason,
      phase: pumpMetrics.phase,
      heat: pumpMetrics.heat,
      buyPressure: pumpMetrics.buyPressure,
      confidence: pumpMetrics.confidence,
    }, 'Entry evaluation');

    // Check if good entry
    if (!entryResult.canEnter) {
      this.rejectionStats.entryEval++;
      this.rejectionStats.total++;
      logger.info({ mint, source: entryResult.source, reason: entryResult.reason }, 'REJECTED: Entry evaluation failed');
      priceFeed.removeFromWatchList(mint);
      velocityTracker.clearToken(mint);
      pumpPortalWs.unsubscribeFromToken(mint);
      return;
    }

    // AI Decision
    const decision = this.makeDecision(features, rugScore, pumpMetrics, mint);
    
    // Broadcast AI decision
    apiServer.getIO().emit('ai:decision', {
      ...decision,
      mint,
      symbol: tokenInfo?.symbol || 'UNKNOWN',
    });

    logger.info({
      mint,
      action: Action[decision.action],
      qValues: decision.qValues,
      confidence: decision.confidence,
      regime: decision.regime,
    }, 'AI decision');

    if (decision.action !== Action.BUY) {
      this.rejectionStats.aiDecision++;
      this.rejectionStats.total++;
      logger.info({ mint, action: Action[decision.action], qValues: decision.qValues }, 'REJECTED: AI decided not to buy');
      priceFeed.removeFromWatchList(mint);
      return;
    }

    // Risk check
    const poolType = capitalAllocator.suggestPoolType(rugScore.total);
    const riskCheck = capitalAllocator.checkRisk(decision.positionSize.sizeSol, poolType);
    logger.info({
      mint,
      poolType,
      requestedSize: decision.positionSize.sizeSol,
      openPositions: positionManager.getOpenPositions().length,
      maxPositions: config.maxConcurrentPositions,
      approved: riskCheck.approved,
      adjustedSize: riskCheck.adjustedSize,
    }, 'Risk check input');

    if (!riskCheck.approved) {
      this.rejectionStats.riskCheck++;
      this.rejectionStats.total++;
      logger.info({ mint, reason: riskCheck.reason, poolType, requestedSize: decision.positionSize.sizeSol }, 'REJECTED: Risk check failed');
      priceFeed.removeFromWatchList(mint);
      return;
    }

    // All filters passed!
    this.rejectionStats.passed++;
    logger.info({ mint, rugScore: rugScore.total, heat: pumpMetrics.heat, poolType }, 'PASSED: All filters - proceeding to trade');

    // Execute trade
    await this.executeBuy(
      mint,
      tokenInfo?.symbol || 'UNKNOWN',
      riskCheck.adjustedSize || decision.positionSize.sizeSol,
      priceData!.priceSol,
      features,
      pumpMetrics,
      poolType,
      token.creator
    );
  }

  private makeDecision(
    features: StateVector,
    rugScore: RugScore,
    pumpMetrics: PumpMetrics,
    mint?: string  // NEW: Pass mint for dynamic threshold lookup
  ): AIDecision {
    const stateArray = featureExtractor.toArray(features);
    const { action, qValues } = ddqnAgent.selectAction(stateArray);

    const regime = regimeDetector.getCurrentRegime().regime;
    const availableCapital = capitalAllocator.getAvailableCapital('active');

    // Adjust confidence based on signals
    let confidence = Math.max(...qValues) - Math.min(...qValues);
    confidence *= rugScore.total / 100;
    confidence *= pumpMetrics.confidence;

    // NEW: Get dynamic confidence threshold and momentum override
    let requiredConfidence = config.watchlist?.minConfidence || 0.55;
    let hasMomentumOverride = false;

    if (mint) {
      // Dynamic confidence threshold based on token age
      requiredConfidence = tokenWatchlist.getDynamicConfidenceThreshold(mint);

      // Check momentum override
      const momentumSignal = tokenWatchlist.getMomentumSignal(mint);
      if (momentumSignal?.hasMomentum) {
        hasMomentumOverride = true;
        const momentumFloor = config.momentumOverride?.confidenceFloor || 0.45;
        // If momentum is strong, use lower confidence floor
        requiredConfidence = Math.min(requiredConfidence, momentumFloor);
        logger.info({
          mint: mint.substring(0, 15),
          ...momentumSignal,
          adjustedThreshold: requiredConfidence.toFixed(2),
        }, 'MOMENTUM OVERRIDE - Lowering confidence threshold');
      }
    }

    // NEW: Override action to HOLD if confidence is below threshold
    let finalAction = action;
    if (action === Action.BUY && confidence < requiredConfidence) {
      finalAction = Action.HOLD;
      logger.info({
        mint: mint?.substring(0, 15),
        confidence: confidence.toFixed(2),
        requiredConfidence: requiredConfidence.toFixed(2),
        hasMomentum: hasMomentumOverride,
      }, 'BUY blocked - confidence below dynamic threshold');
    }

    // NEW: Pass confidence to position sizer for dynamic sizing
    const positionSize = positionSizer.calculateSize(
      availableCapital,
      undefined,
      undefined,
      regime,
      confidence  // NEW: Use confidence as size multiplier
    );

    return {
      action: finalAction,
      confidence,
      regime,
      positionSize,
      qValues,
      features: stateArray,
      timestamp: new Date(),
    };
  }

  private async executeBuy(
    mint: string,
    symbol: string,
    sizeSol: number,
    currentPrice: number,
    features: StateVector,
    pumpMetrics: PumpMetrics,
    poolType: 'active' | 'high_risk',
    creator: string
  ): Promise<void> {
    logger.info({
      mint,
      symbol,
      sizeSol,
      currentPrice,
      poolType,
    }, 'Executing buy');

    const result = await txManager.executeBuy(mint, sizeSol, {
      slippageBps: config.defaultSlippageBps,  // 15% slippage
      maxRetries: 3,
    });

    if (!result.success) {
      logger.error({ mint, error: result.error }, 'Buy failed');
      priceFeed.removeFromWatchList(mint);
      return;
    }

    // Calculate actual price and amount from swap result
    // PumpPortal doesn't return outputAmount, so estimate from price
    let amountTokens = result.outputAmount;
    let actualPrice = currentPrice;

    if (amountTokens === 0 && currentPrice > 0) {
      // Estimate tokens received based on input and price
      amountTokens = sizeSol / currentPrice;
      logger.debug({ sizeSol, currentPrice, estimatedTokens: amountTokens }, 'Estimated tokens from price');
    } else if (amountTokens > 0) {
      actualPrice = sizeSol / amountTokens;
    }

    // Open position
    const position = await positionManager.openPosition({
      mint,
      symbol,
      entryPrice: actualPrice,
      amount: amountTokens,
      amountSol: sizeSol,
      poolType,
    });

    // Start watching for rug signals
    const bondingCurveData = this.bondingCurveCache.get(mint);
    rugMonitor.watchPosition({
      mint,
      creator,
      entryPrice: actualPrice,
      entryMarketCapSol: bondingCurveData?.marketCapSol || 0,
    });

    // Log trade entry
    await tradeLogger.logEntry({
      positionId: position.id,
      mint,
      symbol,
      entryPrice: actualPrice,
      amount: amountTokens,
      amountSol: sizeSol,
      features,
      regime: regimeDetector.getCurrentRegime().regime,
      pumpPhase: pumpMetrics.phase,
    });

    logger.info({
      positionId: position.id,
      mint,
      symbol,
      amountSol: sizeSol,
      amountTokens,
      entryPrice: actualPrice,
    }, 'Position opened');
  }

  private startStatusLogger(): void {
    setInterval(async () => {
      if (!this.isRunning) return;

      const allocation = capitalAllocator.getAllocation();
      const positions = positionManager.getOpenPositions();
      const drawdown = drawdownGuard.getState();

      logger.info({
        equity: allocation.totalSol.toFixed(4),
        positions: positions.length,
        drawdown: (drawdown.currentDrawdown * 100).toFixed(2),
        dailyPnl: drawdown.dailyPnl.toFixed(4),
        regime: regimeDetector.getRegimeName(),
        paused: drawdown.isPaused,
      }, 'Status');

      // Log rejection stats
      const stats = this.rejectionStats;
      if (stats.total > 0) {
        logger.info({
          quickSafety: stats.quickSafety,
          liquidity: stats.liquidity,
          rugScore: stats.rugScore,
          entryEval: stats.entryEval,
          aiDecision: stats.aiDecision,
          riskCheck: stats.riskCheck,
          total: stats.total,
          passed: stats.passed,
          passRate: ((stats.passed / (stats.total + stats.passed)) * 100).toFixed(1) + '%',
        }, 'Rejection Stats');
      }

      // Log watchlist stats
      const watchlistStats = tokenWatchlist.getStats();
      if (watchlistStats.total > 0) {
        logger.info({
          watching: watchlistStats.total,
          ready: watchlistStats.ready,
          devSold: watchlistStats.devSold,
        }, 'Watchlist Stats');
      }

    }, 60000); // Log every minute
  }

  async stop(): Promise<void> {
    logger.info('Stopping bot...');
    this.isRunning = false;

    // Stop all components
    modelTrainer.stopPeriodicTraining();
    await heliusWs.disconnect();
    priceFeed.stop();
    whaleTracker.stop();
    regimeDetector.stop();
    positionManager.stop();
    drawdownGuard.stop();

    // Stop new services
    walletSync.stop();
    equityTracker.stop();

    // Stop API server
    await apiServer.stop();

    await repository.close();

    logger.info('Bot stopped');
  }

  async getStatus(): Promise<{
    isRunning: boolean;
    allocation: string;
    drawdown: string;
    training: string;
    performance: string;
  }> {
    const metrics = await performanceAnalytics.calculateMetrics();

    return {
      isRunning: this.isRunning,
      allocation: capitalAllocator.getStatus(),
      drawdown: drawdownGuard.getStatus(),
      training: modelTrainer.getTrainingStatus(),
      performance: performanceAnalytics.formatMetrics(metrics),
    };
  }
}

// Main entry point
const bot = new TradingBot();

process.on('SIGINT', async () => {
  logger.info('Received SIGINT, shutting down...');
  await bot.stop();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('Received SIGTERM, shutting down...');
  await bot.stop();
  process.exit(0);
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error({ reason, promise }, 'Unhandled rejection');
});

process.on('uncaughtException', (error) => {
  logger.error({ error }, 'Uncaught exception');
  process.exit(1);
});

// Start the bot
bot.start().catch((error) => {
  logger.error({ error }, 'Failed to start bot');
  process.exit(1);
});

export { TradingBot, bot };
</file>

</files>
