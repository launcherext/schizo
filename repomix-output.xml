This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/settings.local.json
.env.example
.github/copilot-instructions.md
.github/sdf
.gitignore
.mcp.json
CLAUDE.md
docs/analysis-architecture.md
package.json
public/about.html
public/app.js
public/audio/dumping_1.mp3
public/audio/dumping_2.mp3
public/audio/pumping_1.mp3
public/audio/pumping_2.mp3
public/audio/pumping_3.mp3
public/index.html
public/Meshy_AI_schizo_0120214703_texture.glb
public/schizo_character.blend
public/schizo_character.glb
public/schizo_meshy.blend
public/schizo-3d.js
public/schizo-favicon.png
public/schizo-logo.png
public/schizo-token.png
public/styles.css
public/trench-radio.js
public/u7777199335_A_wide_website_background_pattern_based_on_a_chao_46c7560e-31d5-423a-ad39-1c62a46a95a6_0.png
README.md
Sarcastic Sounds & Mishaal - Rain on Me [Ycf7KxpUvc4].mp3
scripts/check-holdings.ts
scripts/setup-helius-webhook.ts
scripts/test-tweet.ts
scripts/update-helius-webhook.ts
src/analysis/bundle-detector.ts
src/analysis/index.ts
src/analysis/learning-engine.ts
src/analysis/market-watcher.ts
src/analysis/momentum-scanner.ts
src/analysis/smart-money.ts
src/analysis/token-safety.ts
src/analysis/types.ts
src/analysis/wallet-analyzer.ts
src/api/birdeye.ts
src/api/cache.ts
src/api/dexscreener.ts
src/api/geckoterminal.ts
src/api/helius-webhook.ts
src/api/helius.ts
src/api/index.ts
src/api/jupiter.ts
src/api/moralis.ts
src/api/pumpportal-data.ts
src/api/rate-limiter.ts
src/db/database-with-repos.ts
src/db/database.ts
src/db/index.ts
src/db/repositories/analysis-cache.ts
src/db/repositories/state.ts
src/db/repositories/trades.ts
src/db/schema.ts
src/events/emitter.ts
src/events/index.ts
src/events/types.ts
src/index.ts
src/keystore/crypto.ts
src/keystore/index.ts
src/keystore/keystore.ts
src/lib/logger.ts
src/personality/ai-provider.ts
src/personality/claude-client.ts
src/personality/commentary-system.ts
src/personality/deepgram-tts.ts
src/personality/index.ts
src/personality/mood-system.ts
src/personality/name-analyzer.ts
src/personality/prompts.ts
src/personality/twitter-client.ts
src/rewards/reward-claimer.ts
src/scripts/import-trade.ts
src/server/websocket.ts
src/services/schizo-token-tracker.ts
src/shill-queue/index.ts
src/shill-queue/shill-queue-watcher.ts
src/shill-queue/shill-queue.ts
src/shill-queue/types.ts
src/test-devnet.ts
src/test/manual-trigger.ts
src/trading/copy-trader.ts
src/trading/entertainment-mode.ts
src/trading/index.ts
src/trading/pumpportal-client.ts
src/trading/scoring-engine.ts
src/trading/smart-money-copier.ts
src/trading/sniper-pipeline.ts
src/trading/token-validator.ts
src/trading/trading-engine.ts
src/trading/trading-loop.ts
src/trading/transaction-parser.ts
src/trading/types.ts
test-keystore.json
tsc_output.txt
tsc-error.txt
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".mcp.json">
{
  "mcpServers": {
    "blender": {
      "command": "uvx",
      "args": ["blender-mcp"]
    }
  }
}
</file>

<file path="public/about.html">
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>About $SCHIZO - How It Works</title>
    <link rel="icon" type="image/png" href="schizo-favicon.png">
    <link rel="stylesheet" href="styles.css">
    <style>
        .about-page {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .about-header {
            text-align: center;
            margin-bottom: 60px;
        }

        .about-header img {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            margin-bottom: 20px;
            border: 3px solid var(--accent);
            box-shadow: 0 0 30px rgba(78, 255, 205, 0.3);
        }

        .about-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--accent);
        }

        .about-header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .about-section {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .about-section h2 {
            color: var(--accent);
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .about-section h2 .emoji {
            font-size: 1.8rem;
        }

        .about-section p {
            color: var(--text);
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .about-section ul {
            color: var(--text);
            line-height: 2;
            padding-left: 20px;
        }

        .about-section li {
            margin-bottom: 10px;
        }

        .flywheel-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .flywheel-step {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 25px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            width: 100%;
            max-width: 400px;
        }

        .flywheel-step .number {
            background: var(--accent);
            color: var(--bg);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .flywheel-arrow {
            color: var(--accent);
            font-size: 1.5rem;
        }

        .highlight-box {
            background: rgba(78, 255, 205, 0.1);
            border-left: 4px solid var(--accent);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .highlight-box p {
            margin: 0;
            color: var(--text);
        }

        .tech-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .tech-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .tech-item .icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .tech-item h4 {
            color: var(--accent);
            margin-bottom: 5px;
        }

        .tech-item p {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin: 0;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--accent);
            text-decoration: none;
            margin-bottom: 30px;
            font-size: 0.9rem;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        @media (max-width: 600px) {
            .about-header h1 {
                font-size: 1.8rem;
            }

            .about-section {
                padding: 20px;
            }

            .flywheel-step {
                padding: 12px 15px;
            }
        }
    </style>
</head>

<body>
    <div class="scanlines"></div>

    <div class="about-page">
        <a href="/" class="back-link">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
            Back to Dashboard
        </a>

        <div class="about-header">
            <img src="schizo-logo.png" alt="$SCHIZO">
            <h1>How $SCHIZO Works</h1>
            <p>A self-sustaining AI trading agent</p>
        </div>

        <!-- The Simple Explanation -->
        <section class="about-section">
            <h2><span class="emoji">üí°</span> The Simple Version</h2>
            <p>
                <strong>$SCHIZO is an AI that trades memecoins and uses its profits to buy back its own token.</strong>
            </p>
            <p>
                Think of it like a robot trader that works 24/7. When it makes money, instead of keeping the profits,
                it uses them to buy $SCHIZO tokens - which helps everyone who holds the token.
            </p>
        </section>

        <!-- How the Money Works -->
        <section class="about-section">
            <h2><span class="emoji">üí∞</span> Where Does The Money Come From?</h2>
            <p>
                When you create a token on pump.fun, you earn <strong>creator rewards</strong> - a small fee from every
                trade.
                These rewards are what fund $SCHIZO's trading.
            </p>

            <div class="highlight-box">
                <p>
                    <strong>No investor funds at risk.</strong> The AI trades using creator rewards, not money from
                    token buyers.
                    If it loses a trade, it's the rewards that take the hit - not your investment.
                </p>
            </div>
        </section>

        <!-- The Flywheel -->
        <section class="about-section">
            <h2><span class="emoji">üîÑ</span> The Buyback Flywheel</h2>
            <p>Here's how the cycle works:</p>

            <div class="flywheel-diagram">
                <div class="flywheel-step">
                    <span class="number">1</span>
                    <span>Creator rewards come in from trading fees</span>
                </div>
                <div class="flywheel-arrow">‚Üì</div>
                <div class="flywheel-step">
                    <span class="number">2</span>
                    <span>AI uses rewards to trade other memecoins</span>
                </div>
                <div class="flywheel-arrow">‚Üì</div>
                <div class="flywheel-step">
                    <span class="number">3</span>
                    <span>Profits from winning trades trigger buybacks</span>
                </div>
                <div class="flywheel-arrow">‚Üì</div>
                <div class="flywheel-step">
                    <span class="number">4</span>
                    <span>Buybacks increase $SCHIZO token value</span>
                </div>
                <div class="flywheel-arrow">‚Üª</div>
            </div>

            <p>
                The more the AI trades successfully, the more buybacks happen. The more buybacks, the better for
                holders.
                It's a flywheel that keeps spinning.
            </p>
        </section>

        <!-- What Makes It Different -->
        <section class="about-section">
            <h2><span class="emoji">üß†</span> What Makes $SCHIZO Different?</h2>
            <ul>
                <li><strong>Fully Transparent</strong> - Watch every trade live on the dashboard</li>
                <li><strong>AI-Powered</strong> - Uses pattern recognition to spot opportunities and avoid rugs</li>
                <li><strong>Self-Sustaining</strong> - Profits feed back into the token through buybacks</li>
                <li><strong>Paranoid by Design</strong> - The AI is programmed to be skeptical and cautious</li>
                <li><strong>24/7 Operation</strong> - Never sleeps, always watching the market</li>
            </ul>
        </section>

        <!-- The Tech (Simple) -->
        <section class="about-section">
            <h2><span class="emoji">‚öôÔ∏è</span> The Tech (Explained Simply)</h2>
            <p>
                Don't worry, you don't need to understand code. Here's what's happening under the hood:
            </p>

            <div class="tech-grid">
                <div class="tech-item">
                    <div class="icon">üëÅÔ∏è</div>
                    <h4>Token Scanner</h4>
                    <p>Watches for new tokens launching in real-time</p>
                </div>
                <div class="tech-item">
                    <div class="icon">üîç</div>
                    <h4>Safety Checker</h4>
                    <p>Analyzes tokens for red flags and rug risks</p>
                </div>
                <div class="tech-item">
                    <div class="icon">üß†</div>
                    <h4>AI Brain</h4>
                    <p>Decides what to trade based on patterns</p>
                </div>
                <div class="tech-item">
                    <div class="icon">üéØ</div>
                    <h4>Risk Manager</h4>
                    <p>Sets stop-losses to limit downside</p>
                </div>
                <div class="tech-item">
                    <div class="icon">üí¨</div>
                    <h4>Personality</h4>
                    <p>The paranoid voice you hear on stream</p>
                </div>
                <div class="tech-item">
                    <div class="icon">üîÑ</div>
                    <h4>Buyback Engine</h4>
                    <p>Automatically buys $SCHIZO with profits</p>
                </div>
            </div>
        </section>

        <!-- FAQ -->
        <section class="about-section">
            <h2><span class="emoji">‚ùì</span> Common Questions</h2>

            <p><strong>What if the AI loses money?</strong></p>
            <p>
                The AI has built-in protection: stop-losses to cut bad trades early, position limits so it never bets
                too big,
                and a circuit breaker that pauses trading if losses pile up. It trades with creator rewards, not your
                tokens.
            </p>

            <p><strong>How often do buybacks happen?</strong></p>
            <p>
                Every time the AI closes a profitable trade, a portion automatically goes to buying $SCHIZO.
                You can watch buybacks happen live on the dashboard.
            </p>

            <p><strong>Is this a rug?</strong></p>
            <p>
                The AI is literally programmed to be paranoid about rugs. Everything is transparent -
                watch the trades, see the wallet, verify the buybacks. Trust nothing, verify everything.
            </p>
        </section>

        <div style="text-align: center; margin-top: 40px;">
            <a href="/" class="btn-primary" style="display: inline-block; padding: 15px 30px;">
                Watch $SCHIZO Trade Live
            </a>
        </div>
    </div>

</body>

</html>
</file>

<file path="public/schizo-3d.js">
// Schizo 3D Character Module
// Loads and displays the 3D character with gentle swaying animation

import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// Global state
let scene, camera, renderer, controls;
let schizoModel = null;

// Initialize the 3D scene
function initScene() {
    const container = document.getElementById('schizo-3d-canvas');
    if (!container) {
        console.log('Schizo 3D container not found');
        return;
    }

    // Scene - transparent background
    scene = new THREE.Scene();
    scene.background = null;

    // Camera - positioned for the model
    const aspect = container.clientWidth / container.clientHeight;
    camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 100);
    camera.position.set(0, 0.5, 5);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    container.appendChild(renderer.domElement);

    // Controls - disabled interaction, just for initial setup
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = false;
    controls.enablePan = false;
    controls.enableRotate = false;
    controls.target.set(0, 0.3, 0);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x8cdbc7, 0.5);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
    mainLight.position.set(3, 5, 3);
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0x8cdbc7, 0.5);
    fillLight.position.set(-3, 2, -2);
    scene.add(fillLight);

    const rimLight = new THREE.DirectionalLight(0xff6b6b, 0.3);
    rimLight.position.set(0, 3, -5);
    scene.add(rimLight);

    // Load the model
    loadModel();

    // Handle resize
    window.addEventListener('resize', onWindowResize);

    // Start render loop
    animate();
}

// Load the GLB model
function loadModel() {
    const loader = new GLTFLoader();

    loader.load(
        'schizo_character.glb',
        function(gltf) {
            schizoModel = gltf.scene;

            // Scale and position - moved down so it fits in frame
            schizoModel.scale.set(1.8, 1.8, 1.8);
            schizoModel.position.set(0, -0.3, 0);

            scene.add(schizoModel);
            console.log('Schizo 3D model loaded');
        },
        function(progress) {
            if (progress.total > 0) {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                console.log('Loading model: ' + percent + '%');
            }
        },
        function(error) {
            console.error('Error loading model:', error);
        }
    );
}

// Handle window resize
function onWindowResize() {
    const container = document.getElementById('schizo-3d-canvas');
    if (!container || !camera || !renderer) return;

    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
}

// Animation loop
function animate() {
    requestAnimationFrame(animate);

    // Update controls
    if (controls) controls.update();

    // Gentle idle animation - slight swaying
    if (schizoModel) {
        const time = Date.now() * 0.001;
        schizoModel.rotation.y = Math.sin(time * 0.5) * 0.15;
        schizoModel.position.y = -0.3 + Math.sin(time * 0.8) * 0.03;
    }

    // Render
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

// Initialize on page load
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initScene);
} else {
    initScene();
}

console.log('Schizo 3D module loaded');
</file>

<file path="README.md">
# $SCHIZO Agent

Paranoid AI trading agent with deep wallet forensics and entertaining personality.

## Quick Start

### 1. Install Dependencies

```bash
npm install
```

### 2. Configure Environment

Create `.env` file (already created with your Helius key):

```bash
# Get Anthropic API key from: https://console.anthropic.com/
ANTHROPIC_API_KEY=your-key-here

# Your $SCHIZO token mint address
SCHIZO_TOKEN_MINT=your-token-mint-here
```

### 3. Run the Agent

```bash
npm run dev
```

### 4. Open Dashboard

Open `public/index.html` in your browser to see the live dashboard at `ws://localhost:8080`

## What You Have

‚úÖ **Phase 1: Foundation**
- SQLite database for persistence
- Helius API integration
- Secure logging

‚úÖ **Phase 2: Analysis**
- Token safety analyzer (honeypot detection)
- Wallet analyzer (P&L calculation)
- Smart money tracker

‚úÖ **Phase 3: Trading & Economic Loop**
- PumpPortal client (ready for trading)
- Trading Engine with risk management
- Fee claiming and buyback system

‚úÖ **Phase 4: Personality & Streaming**
- Claude AI personality integration
- Real-time event streaming via WebSocket
- Live web dashboard

## Getting Your API Keys

### Anthropic API Key (Required for AI Personality)

1. Go to https://console.anthropic.com/
2. Sign up for an account
3. Navigate to API Keys
4. Create a new key
5. Copy to `.env` file

**Cost:** $5 free credit, then pay-as-you-go (~$0.003 per response)

### Your Token Mint (Optional)

If you have a $SCHIZO token deployed:
1. Get the mint address from pump.fun or Solscan
2. Add to `.env` as `SCHIZO_TOKEN_MINT`

## Project Structure

```
src/
‚îú‚îÄ‚îÄ index.ts              # Main entry point
‚îú‚îÄ‚îÄ api/                  # Helius API client
‚îú‚îÄ‚îÄ db/                   # SQLite database
‚îú‚îÄ‚îÄ analysis/             # Token safety & smart money
‚îú‚îÄ‚îÄ trading/              # Trading engine & PumpPortal
‚îú‚îÄ‚îÄ personality/          # Claude AI integration
‚îú‚îÄ‚îÄ events/               # Event system
‚îî‚îÄ‚îÄ server/               # WebSocket server

public/
‚îú‚îÄ‚îÄ index.html            # Dashboard
‚îú‚îÄ‚îÄ styles.css            # $SCHIZO branding
‚îî‚îÄ‚îÄ app.js                # WebSocket client
```

## Next Steps

1. **Get Anthropic API key** - Add to `.env`
2. **Test the dashboard** - Open `public/index.html`
3. **Analyze a token** - Use the analysis modules
4. **Deploy** - Railway, Render, or VPS

## Development

```bash
# Run with TypeScript compilation
npm run dev

# Build for production
npm run build

# Run tests
npm run dev -- --test
```

## Notes

- **Read-only mode**: No PumpPortal API needed for analysis
- **Safe to test**: All analysis is read-only via Helius
- **AI optional**: Agent works without Claude, just less entertaining

---

Built with paranoia and pattern recognition üîç
</file>

<file path="scripts/test-tweet.ts">
import 'dotenv/config';
import { TwitterClient } from '../src/personality/twitter-client.js';
import { createLogger } from '../src/lib/logger.js';

const log = createLogger('test-tweet');

async function main() {
  const config = {
    apiKey: process.env.TWITTER_API_KEY!,
    apiSecret: process.env.TWITTER_API_SECRET!,
    accessToken: process.env.TWITTER_ACCESS_TOKEN!,
    accessSecret: process.env.TWITTER_ACCESS_SECRET!,
    maxTweetsPerDay: 50,
  };

  if (!config.apiKey || !config.accessToken) {
    log.error('Missing Twitter API keys in .env');
    return;
  }

  log.info('Initializing Twitter Client...');
  const twitter = new TwitterClient(config);

  const timestamp = new Date().toISOString();
  const message = `ü§ñ $SCHIZO Agent Verification Tweet\n\nSystem Online.\nTimestamp: ${timestamp}\n\n#Solana #AI`;

  log.info({ message }, 'Sending test tweet...');
  
  try {
    const result = await twitter.postTweet(message);
    if (result) {
      log.info('‚úÖ Tweet queued successfully! Waiting for background sending...');
      await new Promise(resolve => setTimeout(resolve, 5000));
    } else {
      log.error('‚ùå Failed to send tweet (Rate limited or error).');
    }
  } catch (error: any) {
    log.error({ error }, '‚ùå Exception sending tweet');
    const fs = await import('fs');
    fs.writeFileSync('debug_tweet_error.log', JSON.stringify(error, null, 2));
  }
}

main();
</file>

<file path="src/analysis/index.ts">
/**
 * Analysis module barrel export.
 * 
 * Provides:
 * - All analysis type definitions
 * - TokenSafetyAnalyzer for honeypot detection
 * - WalletAnalyzer for trading performance analysis
 * - SmartMoneyTracker for identifying profitable wallets
 */

export * from './types.js';
export { TokenSafetyAnalyzer } from './token-safety.js';
export { WalletAnalyzer } from './wallet-analyzer.js';
export { SmartMoneyTracker, SmartMoneyClassification } from './smart-money.js';
</file>

<file path="src/analysis/smart-money.ts">
import { WalletAnalyzer } from './wallet-analyzer.js';
import { AnalysisCacheRepository } from '../db/repositories/analysis-cache.js';
import { WalletAnalysis, SmartMoneyThresholds, DEFAULT_THRESHOLDS, CACHE_TTL } from './types.js';
import { createLogger } from '../lib/logger.js';

const logger = createLogger('smart-money');

/**
 * Smart money classification result.
 */
interface SmartMoneyClassification {
  address: string;
  isSmartMoney: boolean;
  score: number;
  reasons: string[];
  analysis: WalletAnalysis;
  classifiedAt: number;
}

/**
 * Tracker for identifying "smart money" wallets worth following.
 * 
 * Uses threshold-based classification:
 * - Minimum trade count (avoid false positives)
 * - Win rate >= 65%
 * - Realized P&L >= 50 SOL
 * - ROI >= 100%
 * 
 * Results are cached for 24 hours.
 * 
 * @example
 * const tracker = new SmartMoneyTracker(walletAnalyzer, cache);
 * const classification = await tracker.classify('wallet-address');
 * if (classification.isSmartMoney) {
 *   console.log('Smart money detected!', classification.reasons);
 * }
 */
class SmartMoneyTracker {
  private thresholds: SmartMoneyThresholds;

  constructor(
    private walletAnalyzer: WalletAnalyzer,
    private cache: AnalysisCacheRepository,
    thresholds?: SmartMoneyThresholds
  ) {
    this.thresholds = thresholds || DEFAULT_THRESHOLDS;
  }

  /**
   * Classify a wallet as smart money or not.
   * 
   * Uses wallet analysis to score against thresholds.
   * 
   * @param address - Wallet address (base58)
   * @returns Smart money classification with score and reasons
   */
  async classify(address: string): Promise<SmartMoneyClassification> {
    // Check cache first
    const cached = this.cache.get<SmartMoneyClassification>(address, 'smart_money');
    if (cached) {
      logger.debug({ address }, 'Cache hit for smart money classification');
      return cached;
    }

    // Get wallet analysis
    const analysis = await this.walletAnalyzer.analyze(address);

    // Classify from analysis
    const classification = this.classifyFromAnalysis(address, analysis);

    // Cache result
    this.cache.set(address, 'smart_money', classification, CACHE_TTL.smartMoney);

    logger.info(
      {
        address,
        isSmartMoney: classification.isSmartMoney,
        score: classification.score,
      },
      'Smart money classification complete'
    );

    return classification;
  }

  /**
   * Classify wallet from existing analysis.
   * 
   * Follows Nansen methodology with threshold-based scoring.
   * 
   * @param address - Wallet address
   * @param analysis - Wallet analysis result
   * @returns Smart money classification
   */
  private classifyFromAnalysis(
    address: string,
    analysis: WalletAnalysis
  ): SmartMoneyClassification {
    const reasons: string[] = [];
    let score = 0;

    // Check minimum trade count (avoid false positives)
    if (analysis.metrics.totalTrades < this.thresholds.minTrades) {
      return {
        address,
        isSmartMoney: false,
        score: 0,
        reasons: ['Insufficient trades'],
        analysis,
        classifiedAt: Date.now(),
      };
    }

    // Score each metric (25 points each, max 100)
    
    // Win rate
    if (analysis.metrics.winRate >= this.thresholds.minWinRate) {
      score += 25;
      reasons.push(`Win rate: ${(analysis.metrics.winRate * 100).toFixed(1)}%`);
    }

    // Realized P&L
    if (analysis.metrics.totalRealizedPnL >= this.thresholds.minRealizedPnL) {
      score += 25;
      reasons.push(`P&L: ${analysis.metrics.totalRealizedPnL.toFixed(2)} SOL`);
    }

    // ROI
    if (analysis.metrics.totalROI >= this.thresholds.minROI) {
      score += 25;
      reasons.push(`ROI: ${analysis.metrics.totalROI.toFixed(1)}%`);
    }

    // High volume bonus
    if (analysis.metrics.totalTrades >= 50 && score >= 50) {
      score += 25;
      reasons.push('High volume trader');
    }

    // Qualify as smart money if score >= 75 (need 3 of 4 criteria)
    const isSmartMoney = score >= 75;

    return {
      address,
      isSmartMoney,
      score,
      reasons,
      analysis,
      classifiedAt: Date.now(),
    };
  }

  /**
   * Convenience method to check if a wallet is smart money.
   * 
   * @param address - Wallet address
   * @returns True if wallet qualifies as smart money
   */
  async isSmartMoney(address: string): Promise<boolean> {
    const classification = await this.classify(address);
    return classification.isSmartMoney;
  }

  /**
   * Get top smart money wallets from a list.
   * 
   * Classifies all addresses and returns top N by score.
   * 
   * @param addresses - List of wallet addresses
   * @param limit - Maximum number to return (default 10)
   * @returns Top smart money wallets sorted by score
   */
  async getTopWallets(
    addresses: string[],
    limit: number = 10
  ): Promise<SmartMoneyClassification[]> {
    // Classify in batches of 5 to avoid overwhelming API
    const batchSize = 5;
    const allClassifications: SmartMoneyClassification[] = [];

    for (let i = 0; i < addresses.length; i += batchSize) {
      const batch = addresses.slice(i, i + batchSize);
      const batchResults = await Promise.all(
        batch.map(address => this.classify(address))
      );
      allClassifications.push(...batchResults);

      // Small delay between batches
      if (i + batchSize < addresses.length) {
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }

    // Filter to smart money only and sort by score
    return allClassifications
      .filter(c => c.isSmartMoney)
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);
  }
}

export { SmartMoneyTracker, SmartMoneyClassification };
</file>

<file path="src/analysis/wallet-analyzer.ts">
import { HeliusClient, TransactionResult } from '../api/helius.js';
import { AnalysisCacheRepository } from '../db/repositories/analysis-cache.js';
import { WalletAnalysis, ParsedTrade, Position, CACHE_TTL } from './types.js';
import { createLogger } from '../lib/logger.js';

const logger = createLogger('wallet-analyzer');

/**
 * Analyzer for wallet trading performance and patterns.
 * 
 * Calculates:
 * - Win rate and P&L from transaction history
 * - Trading patterns (sniper, holder, flipper)
 * - Position tracking with FIFO matching
 * 
 * Results are cached for 6 hours.
 * 
 * @example
 * const analyzer = new WalletAnalyzer(helius, cache);
 * const analysis = await analyzer.analyze('wallet-address');
 * console.log(`Win rate: ${analysis.metrics.winRate * 100}%`);
 */
class WalletAnalyzer {
  constructor(
    private helius: HeliusClient,
    private cache: AnalysisCacheRepository
  ) {}

  /**
   * Analyze a wallet's trading performance.
   * 
   * Fetches complete transaction history with pagination,
   * calculates P&L using position tracking, and determines trading pattern.
   * 
   * @param address - Wallet address (base58)
   * @returns Wallet analysis with metrics and classification
   */
  async analyze(address: string): Promise<WalletAnalysis> {
    // Check cache first
    const cached = this.cache.get<WalletAnalysis>(address, 'wallet_analysis');
    if (cached) {
      logger.debug({ address }, 'Cache hit for wallet analysis');
      return cached;
    }

    // Fetch all transactions with pagination
    const allTransactions: TransactionResult[] = [];
    let paginationToken: string | undefined;
    let page = 0;

    do {
      try {
        const response = await this.helius.getTransactionsForAddress(address, {
          limit: 100,
          paginationToken,
        });

        allTransactions.push(...response.data);
        paginationToken = response.paginationToken;
        page++;

        logger.debug(
          { address, page, total: allTransactions.length },
          'Fetching transactions'
        );

        // Small delay to respect rate limits
        if (paginationToken) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      } catch (error) {
        logger.error({ address, page, error }, 'Failed to fetch transactions');
        throw error;
      }
    } while (paginationToken);

    logger.info(
      { address, totalTransactions: allTransactions.length },
      'Fetched complete transaction history'
    );

    // Parse transactions into trades
    const trades = this.parseTransactions(allTransactions);

    // Build positions from trades
    const positions = this.buildPositions(trades);

    // Calculate metrics
    const metrics = this.calculateMetrics(positions, trades);

    // Classify trading pattern
    const tradingPattern = this.classifyTradingPattern(metrics, positions);

    // Determine if smart money (placeholder - will be refined in Plan 04)
    const isSmartMoney = metrics.winRate >= 0.65 && metrics.totalTrades >= 10;
    const smartMoneyScore = isSmartMoney ? 75 : 0;

    const result: WalletAnalysis = {
      address,
      metrics,
      tradingPattern,
      isSmartMoney,
      smartMoneyScore,
      lastAnalyzed: Date.now(),
    };

    // Cache result
    this.cache.set(address, 'wallet_analysis', result, CACHE_TTL.walletAnalysis);

    logger.info(
      {
        address,
        winRate: metrics.winRate,
        totalPnL: metrics.totalRealizedPnL,
        pattern: tradingPattern,
      },
      'Wallet analysis complete'
    );

    return result;
  }

  /**
   * Parse raw transactions into structured trades.
   * 
   * Filters to SWAP transactions and extracts trade details.
   * 
   * @param transactions - Raw Helius transaction results
   * @returns Array of parsed trades
   */
  private parseTransactions(transactions: TransactionResult[]): ParsedTrade[] {
    const trades: ParsedTrade[] = [];

    for (const tx of transactions) {
      // Only process SWAP transactions
      if (tx.type !== 'SWAP') {
        continue;
      }

      // For now, create a simplified trade record
      // In production, would parse Helius enhanced events.swap data
      // This is a placeholder that assumes basic swap structure
      try {
        const trade: ParsedTrade = {
          signature: tx.signature,
          timestamp: tx.timestamp,
          type: 'BUY', // Simplified - would determine from swap direction
          tokenMint: 'unknown', // Would extract from swap events
          tokenAmount: 0, // Would extract from swap events
          solAmount: 0, // Would extract from swap events
          pricePerToken: 0,
          dex: 'UNKNOWN',
        };

        // Skip incomplete trades for now
        // In production, would fully parse Helius enhanced transaction data
        if (trade.tokenMint === 'unknown') {
          continue;
        }

        trades.push(trade);
      } catch (error) {
        logger.warn({ signature: tx.signature, error }, 'Failed to parse transaction');
      }
    }

    return trades;
  }

  /**
   * Build position tracking from trades.
   * 
   * Groups trades by token and calculates P&L using FIFO matching.
   * 
   * @param trades - Parsed trades
   * @returns Map of token mint to position
   */
  private buildPositions(trades: ParsedTrade[]): Map<string, Position> {
    const positionMap = new Map<string, Position>();

    // Group trades by token
    const tradesByToken = new Map<string, ParsedTrade[]>();
    for (const trade of trades) {
      const existing = tradesByToken.get(trade.tokenMint) || [];
      existing.push(trade);
      tradesByToken.set(trade.tokenMint, existing);
    }

    // Build positions with P&L calculation
    for (const [tokenMint, tokenTrades] of tradesByToken) {
      const entries = tokenTrades.filter(t => t.type === 'BUY');
      const exits = tokenTrades.filter(t => t.type === 'SELL');

      // Calculate realized P&L using FIFO matching
      let realizedPnL = 0;
      let totalBought = 0;
      let totalSold = 0;

      for (const entry of entries) {
        totalBought += entry.tokenAmount;
      }

      for (const exit of exits) {
        totalSold += exit.tokenAmount;
      }

      // Simple P&L calculation (would be more sophisticated with FIFO matching)
      const totalCost = entries.reduce((sum, t) => sum + t.solAmount, 0);
      const totalRevenue = exits.reduce((sum, t) => sum + t.solAmount, 0);
      realizedPnL = totalRevenue - totalCost;

      const position: Position = {
        tokenMint,
        entries,
        exits,
        realizedPnL,
        isOpen: totalBought > totalSold,
      };

      positionMap.set(tokenMint, position);
    }

    return positionMap;
  }

  /**
   * Calculate trading metrics from positions.
   * 
   * @param positions - Position map
   * @param trades - All trades
   * @returns Wallet metrics
   */
  private calculateMetrics(
    positions: Map<string, Position>,
    trades: ParsedTrade[]
  ): WalletAnalysis['metrics'] {
    const closedPositions = Array.from(positions.values()).filter(p => !p.isOpen);

    const totalTrades = closedPositions.length;
    const wins = closedPositions.filter(p => p.realizedPnL > 0).length;
    const losses = closedPositions.filter(p => p.realizedPnL <= 0).length;
    const winRate = totalTrades > 0 ? wins / totalTrades : 0;

    const totalRealizedPnL = closedPositions.reduce((sum, p) => sum + p.realizedPnL, 0);

    // Calculate total cost basis
    const totalCostBasis = closedPositions.reduce((sum, p) => {
      return sum + p.entries.reduce((entrySum, e) => entrySum + e.solAmount, 0);
    }, 0);

    const totalROI = totalCostBasis > 0 ? (totalRealizedPnL / totalCostBasis) * 100 : 0;

    // Calculate average hold time
    let totalHoldTime = 0;
    for (const position of closedPositions) {
      if (position.entries.length > 0 && position.exits.length > 0) {
        const firstBuy = Math.min(...position.entries.map(e => e.timestamp));
        const lastSell = Math.max(...position.exits.map(e => e.timestamp));
        totalHoldTime += lastSell - firstBuy;
      }
    }
    const avgHoldTime = closedPositions.length > 0 ? totalHoldTime / closedPositions.length : 0;

    return {
      totalTrades,
      wins,
      losses,
      winRate,
      totalRealizedPnL,
      totalROI,
      avgHoldTime: avgHoldTime / 1000, // Convert to seconds
      tokensTraded: positions.size,
    };
  }

  /**
   * Classify wallet trading pattern.
   * 
   * @param metrics - Wallet metrics
   * @param positions - Position map
   * @returns Trading pattern classification
   */
  private classifyTradingPattern(
    metrics: WalletAnalysis['metrics'],
    positions: Map<string, Position>
  ): 'sniper' | 'holder' | 'flipper' | 'unknown' {
    const avgHoldTimeMinutes = metrics.avgHoldTime / 60;
    const avgHoldTimeHours = metrics.avgHoldTime / 3600;

    // Sniper: Quick trades with high win rate
    if (avgHoldTimeMinutes < 5 && metrics.winRate > 0.6) {
      return 'sniper';
    }

    // Flipper: Many quick trades
    if (avgHoldTimeHours < 1 && metrics.totalTrades > 20) {
      return 'flipper';
    }

    // Holder: Long-term positions
    if (avgHoldTimeHours > 24) {
      return 'holder';
    }

    return 'unknown';
  }
}

export { WalletAnalyzer };
</file>

<file path="src/api/birdeye.ts">
/**
 * Birdeye API client for trending tokens and market data
 * https://docs.birdeye.so/
 */

import { logger } from '../lib/logger.js';

const log = logger.child({ module: 'birdeye' });

/**
 * Birdeye API configuration
 */
export interface BirdeyeConfig {
  apiKey: string;
  baseUrl?: string;
}

/**
 * Trending token from Birdeye
 */
export interface BirdeyeToken {
  address: string;
  symbol: string;
  name: string;
  decimals: number;
  logoURI?: string;
  // Price data
  price: number;
  priceChange24h: number;
  priceChange1h?: number;
  // Volume & liquidity
  volume24h: number;
  liquidity: number;
  // Market data
  marketCap?: number;
  holder?: number;
  // Social/metadata
  website?: string;
  twitter?: string;
  telegram?: string;
  // Trade data
  trade24h?: number;
  buy24h?: number;
  sell24h?: number;
}

/**
 * Token overview response
 */
export interface TokenOverview {
  address: string;
  symbol: string;
  name: string;
  decimals: number;
  price: number;
  priceChange24h: number;
  volume24h: number;
  liquidity: number;
  marketCap: number;
  holder: number;
  trade24h: number;
  buy24h: number;
  sell24h: number;
  // Extensions from Birdeye
  extensions?: {
    website?: string;
    twitter?: string;
    telegram?: string;
    discord?: string;
    description?: string;
  };
}

/**
 * Top traders response
 */
export interface TopTrader {
  address: string;
  volume: number;
  trades: number;
  pnl: number;
  pnlPercent: number;
}

/**
 * Birdeye API client
 */
export class BirdeyeClient {
  private apiKey: string;
  private baseUrl: string;
  
  // Rate Limiting State
  private lastRequestTime = 0;
  // STRICT LIMIT: Free tier is ~1 req/sec. We use 1200ms to be safe against clock drift.
  private readonly MIN_REQUEST_DELAY_MS = 1200; 
  // Queue promise to strictly serialize rate limit checks
  private rateLimitQueue: Promise<void> = Promise.resolve();

  constructor(config: BirdeyeConfig) {
    this.apiKey = config.apiKey;
    this.baseUrl = config.baseUrl || 'https://public-api.birdeye.so';

    log.info('Birdeye client initialized (Queue-based Rate Limiter Active)');
  }

  /**
   * Retry wrapper with exponential backoff for 429 errors
   * Free tier can hit rate limits easily, so we need robust retry logic
   */
  private async retryWithBackoff<T>(
    fn: () => Promise<T>,
    method: string,
    maxRetries: number = 3
  ): Promise<T> {
    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error as Error;
        const errorMessage = error instanceof Error ? error.message : String(error);

        // Check for 429 rate limit
        if (errorMessage.includes('429') || errorMessage.toLowerCase().includes('rate limit')) {
          const delay = 2000 * Math.pow(2, attempt - 1); // 2s, 4s, 8s
          log.warn({
            method,
            attempt,
            maxRetries,
            delay,
          }, 'Birdeye rate limited (429), backing off');

          if (attempt < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          }
        }

        // For non-429 errors or last attempt, throw immediately
        throw error;
      }
    }

    throw lastError!;
  }

  /**
   * Get trending tokens on Solana
   * @param limit - Number of tokens to return (max 50)
   * @param offset - Pagination offset
   */
  async getTrendingTokens(limit: number = 20, offset: number = 0): Promise<BirdeyeToken[]> {
    await this.enforceRateLimit();

    return this.retryWithBackoff(async () => {
      const response = await fetch(
        `${this.baseUrl}/defi/token_trending?sort_by=rank&sort_type=asc&offset=${offset}&limit=${limit}`,
        {
          headers: {
            'X-API-KEY': this.apiKey,
            'x-chain': 'solana',
          },
        }
      );

      if (!response.ok) {
        throw new Error(`Birdeye API error: ${response.status}`);
      }

      const data = await response.json() as {
        success: boolean;
        data: { tokens: Array<{
          address: string;
          symbol: string;
          name: string;
          decimals: number;
          logoURI?: string;
          price: number;
          price_change_24h_percent?: number;
          volume_24h_usd?: number;
          liquidity?: number;
          mc?: number;
        }> };
      };

      if (!data.success || !data.data?.tokens) {
        return [];
      }

      return data.data.tokens.map(t => ({
        address: t.address,
        symbol: t.symbol,
        name: t.name,
        decimals: t.decimals,
        logoURI: t.logoURI,
        price: t.price || 0,
        priceChange24h: t.price_change_24h_percent || 0,
        volume24h: t.volume_24h_usd || 0,
        liquidity: t.liquidity || 0,
        marketCap: t.mc,
      }));
    }, 'getTrendingTokens').catch(error => {
      log.error({ 
        error,
        errorMessage: error instanceof Error ? error.message : String(error),
        errorStack: error instanceof Error ? error.stack : undefined,
        errorName: error instanceof Error ? error.name : undefined,
        method: 'getTrendingTokens'
      }, 'Failed to fetch trending tokens after retries');
      
      // Check for specific issues
      if (error instanceof Error && (error.message.includes('fetch') || error.message.includes('ENOTFOUND'))) {
        log.error('Network connectivity issue - check Railway outbound access');
      }
      
      return [];
    });
  }

  /**
   * Get top gainers on Solana
   * @param limit - Number of tokens to return
   * @param timeframe - 1h, 4h, 12h, 24h
   */
  async getTopGainers(limit: number = 20, timeframe: '1h' | '4h' | '12h' | '24h' = '1h'): Promise<BirdeyeToken[]> {
    await this.enforceRateLimit();

    return this.retryWithBackoff(async () => {
      const response = await fetch(
        `${this.baseUrl}/defi/token_top_gainers?sort_by=price_change_${timeframe}_percent&sort_type=desc&offset=0&limit=${limit}`,
        {
          headers: {
            'X-API-KEY': this.apiKey,
            'x-chain': 'solana',
          },
        }
      );

      if (!response.ok) {
        throw new Error(`Birdeye API error: ${response.status}`);
      }

      const data = await response.json() as {
        success: boolean;
        data: { tokens: Array<{
          address: string;
          symbol: string;
          name: string;
          decimals: number;
          logoURI?: string;
          price: number;
          price_change_24h_percent?: number;
          price_change_1h_percent?: number;
          volume_24h_usd?: number;
          liquidity?: number;
          mc?: number;
        }> };
      };

      if (!data.success || !data.data?.tokens) {
        return [];
      }

      return data.data.tokens.map(t => ({
        address: t.address,
        symbol: t.symbol,
        name: t.name,
        decimals: t.decimals,
        logoURI: t.logoURI,
        price: t.price || 0,
        priceChange24h: t.price_change_24h_percent || 0,
        priceChange1h: t.price_change_1h_percent,
        volume24h: t.volume_24h_usd || 0,
        liquidity: t.liquidity || 0,
        marketCap: t.mc,
      }));
    }, `getTopGainers(${timeframe})`).catch(error => {
      log.error({ 
        error,
        errorMessage: error instanceof Error ? error.message : String(error),
        errorStack: error instanceof Error ? error.stack : undefined,
        errorName: error instanceof Error ? error.name : undefined,
        method: 'getTopGainers',
        timeframe: timeframe
      }, 'Failed to fetch top gainers after retries');
      
      // Check for specific issues
      if (error instanceof Error) {
        if (error.message.includes('fetch') || error.message.includes('ENOTFOUND')) {
          log.error('Network connectivity issue - check Railway outbound access');
        } else if (error.message.includes('429')) {
          log.error('Birdeye API rate limit hit even after retries - may need to reduce scan frequency');
        }
      }
      
      return [];
    });
  }

  /**
   * Get detailed token overview including socials
   * @param address - Token mint address
   */
  async getTokenOverview(address: string): Promise<TokenOverview | null> {
    await this.enforceRateLimit();

    try {
      const response = await fetch(
        `${this.baseUrl}/defi/token_overview?address=${address}`,
        {
          headers: {
            'X-API-KEY': this.apiKey,
            'x-chain': 'solana',
          },
        }
      );

      if (!response.ok) {
        throw new Error(`Birdeye API error: ${response.status}`);
      }

      const data = await response.json() as {
        success: boolean;
        data: {
          address: string;
          symbol: string;
          name: string;
          decimals: number;
          price: number;
          priceChange24h: number;
          volume24h: number;
          liquidity: number;
          mc: number;
          holder: number;
          trade24h: number;
          buy24h: number;
          sell24h: number;
          extensions?: {
            website?: string;
            twitter?: string;
            telegram?: string;
            discord?: string;
            description?: string;
          };
        };
      };

      if (!data.success || !data.data) {
        return null;
      }

      const t = data.data;
      return {
        address: t.address,
        symbol: t.symbol,
        name: t.name,
        decimals: t.decimals,
        price: t.price,
        priceChange24h: t.priceChange24h,
        volume24h: t.volume24h,
        liquidity: t.liquidity,
        marketCap: t.mc,
        holder: t.holder,
        trade24h: t.trade24h,
        buy24h: t.buy24h,
        sell24h: t.sell24h,
        extensions: t.extensions,
      };
    } catch (error) {
      log.error({ address, error }, 'Failed to fetch token overview');
      return null;
    }
  }

  /**
   * Get token security info
   * @param address - Token mint address
   */
  async getTokenSecurity(address: string): Promise<{
    isHoneypot: boolean;
    hasFreezableToken: boolean;
    hasMintableToken: boolean;
    top10HolderPercent: number;
    creatorPercent: number;
  } | null> {
    await this.enforceRateLimit();

    try {
      const response = await fetch(
        `${this.baseUrl}/defi/token_security?address=${address}`,
        {
          headers: {
            'X-API-KEY': this.apiKey,
            'x-chain': 'solana',
          },
        }
      );

      if (!response.ok) {
        throw new Error(`Birdeye API error: ${response.status}`);
      }

      const data = await response.json() as {
        success: boolean;
        data: {
          ownerAddress: string;
          creatorAddress: string;
          isHoneypot: boolean;
          freezeable: boolean;
          mintable: boolean;
          top10HolderPercent: number;
          creatorPercent: number;
        };
      };

      if (!data.success || !data.data) {
        return null;
      }

      return {
        isHoneypot: data.data.isHoneypot,
        hasFreezableToken: data.data.freezeable,
        hasMintableToken: data.data.mintable,
        top10HolderPercent: data.data.top10HolderPercent,
        creatorPercent: data.data.creatorPercent,
      };
    } catch (error) {
      log.error({ address, error }, 'Failed to fetch token security');
      return null;
    }
  }

  /**
   * Get top traders for a token (potential smart money)
   * @param address - Token mint address
   * @param timeframe - 24h or 7d
   */
  async getTopTraders(address: string, timeframe: '24h' | '7d' = '24h'): Promise<TopTrader[]> {
    await this.enforceRateLimit();

    try {
      const response = await fetch(
        `${this.baseUrl}/defi/v2/tokens/${address}/top_traders?time_frame=${timeframe}`,
        {
          headers: {
            'X-API-KEY': this.apiKey,
            'x-chain': 'solana',
          },
        }
      );

      if (!response.ok) {
        throw new Error(`Birdeye API error: ${response.status}`);
      }

      const data = await response.json() as {
        success: boolean;
        data: { traders: Array<{
          address: string;
          volume: number;
          trade_count: number;
          pnl: number;
          pnl_percent: number;
        }> };
      };

      if (!data.success || !data.data?.traders) {
        return [];
      }

      return data.data.traders.map(t => ({
        address: t.address,
        volume: t.volume,
        trades: t.trade_count,
        pnl: t.pnl,
        pnlPercent: t.pnl_percent,
      }));
    } catch (error) {
      log.error({ 
        address,
        error,
        errorMessage: error instanceof Error ? error.message : String(error),
        errorStack: error instanceof Error ? error.stack : undefined,
        method: 'getTopTraders'
      }, 'Failed to fetch top traders');
      return [];
    }
  }

  /**
   * Check if token has valid social presence
   */
  async hasValidSocials(address: string): Promise<{ valid: boolean; twitter?: string; website?: string }> {
    const overview = await this.getTokenOverview(address);

    if (!overview?.extensions) {
      return { valid: false };
    }

    const hasTwitter = !!overview.extensions.twitter;
    const hasWebsite = !!overview.extensions.website;

    return {
      valid: hasTwitter || hasWebsite,
      twitter: overview.extensions.twitter,
      website: overview.extensions.website,
    };
  }

  /**
   * Enforce rate limiting using a Mutex/Queue pattern
   * This prevents race conditions when multiple requests are fired via Promise.all
   */
  private async enforceRateLimit(): Promise<void> {
    // Chain this request to the end of the existing queue
    // This ensures Request B waits for Request A to finish its delay logic
    const nextRequest = this.rateLimitQueue.then(async () => {
        const now = Date.now();
        const timeSinceLastRequest = now - this.lastRequestTime;

        if (timeSinceLastRequest < this.MIN_REQUEST_DELAY_MS) {
            const delay = this.MIN_REQUEST_DELAY_MS - timeSinceLastRequest;
            // log.debug({ delay }, 'Rate limit throttling active');
            await new Promise(resolve => setTimeout(resolve, delay));
        }

        // Update timestamp *immediately* before releasing the lock
        this.lastRequestTime = Date.now();
    });

    // Update the queue pointer
    this.rateLimitQueue = nextRequest;
    
    // Wait for our turn
    return nextRequest;
  }
}

// Singleton instance
let birdeyeClient: BirdeyeClient | null = null;

/**
 * Get or create Birdeye client singleton
 */
export function getBirdeyeClient(): BirdeyeClient | null {
  if (birdeyeClient) return birdeyeClient;

  const apiKey = process.env.BIRDEYE_API_KEY;
  if (!apiKey) {
    return null;
  }

  birdeyeClient = new BirdeyeClient({ apiKey });
  return birdeyeClient;
}

export { birdeyeClient };
</file>

<file path="src/api/cache.ts">
/**
 * TTL-based in-memory cache for API responses.
 *
 * Used to reduce API calls to Helius and other external services.
 * Entries automatically expire after their TTL.
 */

/**
 * Internal cache entry structure with expiration tracking.
 */
interface CacheEntry<T> {
  data: T;
  expiresAt: number;
}

/**
 * Generic TTL cache implementation.
 *
 * Features:
 * - Configurable default TTL
 * - Per-entry TTL override
 * - Automatic expiration on access
 * - Periodic cleanup method for memory management
 *
 * @example
 * const cache = new TTLCache<string>(60000); // 1 minute default
 * cache.set('key', 'value');
 * cache.get('key'); // 'value'
 * // After 60 seconds...
 * cache.get('key'); // undefined
 */
class TTLCache<T> {
  private cache: Map<string, CacheEntry<T>> = new Map();
  private hits = 0;
  private misses = 0;

  /**
   * Create a new TTL cache.
   * @param defaultTTL - Default time-to-live in milliseconds (default: 60000 = 1 minute)
   */
  constructor(private defaultTTL: number = 60000) {}

  /**
   * Store a value in the cache.
   * @param key - Cache key
   * @param value - Value to store
   * @param ttl - Optional TTL override in milliseconds
   */
  set(key: string, value: T, ttl?: number): void {
    this.cache.set(key, {
      data: value,
      expiresAt: Date.now() + (ttl ?? this.defaultTTL),
    });
  }

  /**
   * Retrieve a value from the cache.
   * Returns undefined if the key doesn't exist or has expired.
   * Expired entries are automatically deleted on access.
   * @param key - Cache key
   * @returns The cached value or undefined
   */
  get(key: string): T | undefined {
    const entry = this.cache.get(key);

    if (!entry) {
      this.misses++;
      return undefined;
    }

    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      this.misses++;
      return undefined;
    }

    this.hits++;
    return entry.data;
  }

  /**
   * Check if a key exists and is not expired.
   * @param key - Cache key
   * @returns true if key exists and is valid
   */
  has(key: string): boolean {
    return this.get(key) !== undefined;
  }

  /**
   * Delete a specific key from the cache.
   * @param key - Cache key to delete
   */
  delete(key: string): void {
    this.cache.delete(key);
  }

  /**
   * Clear all entries from the cache.
   */
  clear(): void {
    this.cache.clear();
    this.hits = 0;
    this.misses = 0;
  }

  /**
   * Get the number of entries in the cache (including possibly expired ones).
   * @returns Number of entries
   */
  size(): number {
    return this.cache.size;
  }

  /**
   * Remove all expired entries from the cache.
   * Call periodically to prevent memory buildup from expired entries
   * that haven't been accessed.
   * @returns Number of entries removed
   */
  cleanup(): number {
    const now = Date.now();
    let removed = 0;

    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiresAt) {
        this.cache.delete(key);
        removed++;
      }
    }

    return removed;
  }

  /**
   * Get cache statistics.
   * @returns Object with size, hits, misses, and hit rate
   */
  getStats(): { size: number; hits: number; misses: number; hitRate: number } {
    const total = this.hits + this.misses;
    return {
      size: this.cache.size,
      hits: this.hits,
      misses: this.misses,
      hitRate: total > 0 ? this.hits / total : 0,
    };
  }
}

export { TTLCache, CacheEntry };
</file>

<file path="src/api/index.ts">
/**
 * API module exports.
 *
 * Provides rate-limited, cached access to external APIs
 * with resilience patterns (retry, circuit breaker).
 */

export {
  HeliusClient,
  HeliusClientConfig,
  TransactionResult,
  TransactionsResponse,
  GetTransactionsOptions,
} from './helius.js';

export { TTLCache, CacheEntry } from './cache.js';

export {
  createRateLimiter,
  getConfigForTier,
  RateLimiterConfig,
  HeliusTier,
} from './rate-limiter.js';
</file>

<file path="src/api/pumpportal-data.ts">
/**
 * PumpPortal Data API - WebSocket client for real-time new token events
 * https://pumpportal.fun/data-api/real-time
 */

import WebSocket from 'ws';
import { createLogger } from '../lib/logger.js';

const logger = createLogger('pumpportal-data');

const WS_URL = 'wss://pumpportal.fun/api/data';

/**
 * New token event from PumpPortal
 */
export interface PumpNewTokenEvent {
  mint: string;
  name: string;
  symbol: string;
  uri: string;
  traderPublicKey: string;
  initialBuy: number;
  bondingCurveKey: string;
  vTokensInBondingCurve: number;
  vSolInBondingCurve: number;
  marketCapSol: number;
  signature: string;
  imageUrl?: string; // Fetched from metadata URI
}

/**
 * Fetch token image from metadata URI
 */
async function fetchTokenImage(uri: string): Promise<string | undefined> {
  if (!uri) return undefined;

  try {
    // Handle IPFS URIs
    let fetchUrl = uri;
    if (uri.startsWith('ipfs://')) {
      fetchUrl = uri.replace('ipfs://', 'https://ipfs.io/ipfs/');
    }

    const response = await fetch(fetchUrl, {
      signal: AbortSignal.timeout(3000) // 3 second timeout
    });

    if (!response.ok) return undefined;

    const metadata = await response.json();
    let imageUrl = metadata.image || metadata.imageUrl;

    // Convert IPFS image URLs too
    if (imageUrl?.startsWith('ipfs://')) {
      imageUrl = imageUrl.replace('ipfs://', 'https://ipfs.io/ipfs/');
    }

    return imageUrl;
  } catch (error) {
    // Silently fail - image is optional
    return undefined;
  }
}

/**
 * Trade event from PumpPortal
 */
export interface PumpTradeEvent {
  mint: string;
  traderPublicKey: string;
  txType: 'buy' | 'sell';
  tokenAmount: number;
  solAmount: number;
  bondingCurveKey: string;
  vTokensInBondingCurve: number;
  vSolInBondingCurve: number;
  marketCapSol: number;
  signature: string;
}

/**
 * Callback types
 */
type NewTokenCallback = (token: PumpNewTokenEvent) => void;
type TradeCallback = (trade: PumpTradeEvent) => void;

/**
 * PumpPortal Data WebSocket Client
 */
export class PumpPortalDataClient {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 10;
  private reconnectDelayMs = 5000;
  private isConnected = false;

  private newTokenCallbacks: NewTokenCallback[] = [];
  private tradeCallbacks: Map<string, TradeCallback[]> = new Map();
  private subscribedTokens: Set<string> = new Set();

  /**
   * Connect to PumpPortal WebSocket
   */
  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (this.isConnected && this.ws) {
        resolve();
        return;
      }

      logger.info('Connecting to PumpPortal WebSocket...');

      this.ws = new WebSocket(WS_URL);

      this.ws.on('open', () => {
        logger.info('Connected to PumpPortal WebSocket');
        this.isConnected = true;
        this.reconnectAttempts = 0;
        resolve();
      });

      this.ws.on('message', (data: WebSocket.Data) => {
        try {
          const message = JSON.parse(data.toString());
          this.handleMessage(message);
        } catch (error) {
          logger.error({ error }, 'Error parsing WebSocket message');
        }
      });

      this.ws.on('close', () => {
        logger.warn('PumpPortal WebSocket disconnected');
        this.isConnected = false;
        this.attemptReconnect();
      });

      this.ws.on('error', (error) => {
        logger.error({ error }, 'PumpPortal WebSocket error');
        if (!this.isConnected) {
          reject(error);
        }
      });
    });
  }

  /**
   * Attempt to reconnect
   */
  private attemptReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      logger.error('Max reconnect attempts reached');
      return;
    }

    this.reconnectAttempts++;
    logger.info({ attempt: this.reconnectAttempts }, 'Attempting to reconnect...');

    setTimeout(async () => {
      try {
        await this.connect();

        // Re-subscribe to new tokens
        if (this.newTokenCallbacks.length > 0) {
          this.subscribeNewTokens();
        }

        // Re-subscribe to token trades
        if (this.subscribedTokens.size > 0) {
          this.subscribeTokenTrades(Array.from(this.subscribedTokens));
        }
      } catch (error) {
        logger.error({ error }, 'Reconnect failed');
      }
    }, this.reconnectDelayMs);
  }

  /**
   * Handle incoming message
   */
  private async handleMessage(message: any): Promise<void> {
    // Check if it's a new token creation event (txType === 'create')
    if (message.txType === 'create' && message.mint && message.bondingCurveKey) {
      // This is a new token creation event
      const tokenEvent: PumpNewTokenEvent = {
        mint: message.mint,
        name: message.name || 'Unknown',
        symbol: message.symbol || 'UNK',
        uri: message.uri || '',
        traderPublicKey: message.traderPublicKey || '',
        initialBuy: message.initialBuy || 0,
        bondingCurveKey: message.bondingCurveKey,
        vTokensInBondingCurve: message.vTokensInBondingCurve || 0,
        vSolInBondingCurve: message.vSolInBondingCurve || 0,
        marketCapSol: message.marketCapSol || 0,
        signature: message.signature || '',
      };

      // Fetch image from metadata URI (with short timeout)
      if (message.uri) {
        try {
          const imageUrl = await fetchTokenImage(message.uri);
          if (imageUrl) {
            tokenEvent.imageUrl = imageUrl;
          }
        } catch {
          // Ignore image fetch errors
        }
      }

      logger.info({
        mint: tokenEvent.mint,
        symbol: tokenEvent.symbol,
        name: tokenEvent.name,
        marketCapSol: tokenEvent.marketCapSol,
        hasImage: !!tokenEvent.imageUrl,
      }, 'New token detected!');

      // Notify all callbacks
      for (const callback of this.newTokenCallbacks) {
        try {
          callback(tokenEvent);
        } catch (error) {
          logger.error({ error }, 'Error in new token callback');
        }
      }
    }

    // Check if it's a trade event
    if (message.txType && (message.txType === 'buy' || message.txType === 'sell')) {
      const tradeEvent: PumpTradeEvent = {
        mint: message.mint,
        traderPublicKey: message.traderPublicKey || '',
        txType: message.txType,
        tokenAmount: message.tokenAmount || 0,
        solAmount: message.solAmount || 0,
        bondingCurveKey: message.bondingCurveKey || '',
        vTokensInBondingCurve: message.vTokensInBondingCurve || 0,
        vSolInBondingCurve: message.vSolInBondingCurve || 0,
        marketCapSol: message.marketCapSol || 0,
        signature: message.signature || '',
      };

      // Notify callbacks for this specific token
      const callbacks = this.tradeCallbacks.get(message.mint);
      if (callbacks) {
        for (const callback of callbacks) {
          try {
            callback(tradeEvent);
          } catch (error) {
            logger.error({ error }, 'Error in trade callback');
          }
        }
      }
    }
  }

  /**
   * Subscribe to new token creation events
   */
  subscribeNewTokens(): void {
    if (!this.ws || !this.isConnected) {
      logger.warn('Cannot subscribe - not connected');
      return;
    }

    const payload = {
      method: 'subscribeNewToken',
    };

    this.ws.send(JSON.stringify(payload));
    logger.info('Subscribed to new token events');
  }

  /**
   * Subscribe to trades for specific tokens
   */
  subscribeTokenTrades(mints: string[]): void {
    if (!this.ws || !this.isConnected) {
      logger.warn('Cannot subscribe - not connected');
      return;
    }

    const payload = {
      method: 'subscribeTokenTrade',
      keys: mints,
    };

    this.ws.send(JSON.stringify(payload));

    // Track subscribed tokens
    for (const mint of mints) {
      this.subscribedTokens.add(mint);
    }

    logger.info({ count: mints.length }, 'Subscribed to token trades');
  }

  /**
   * Register callback for new token events
   */
  onNewToken(callback: NewTokenCallback): void {
    this.newTokenCallbacks.push(callback);
  }

  /**
   * Register callback for trade events on a specific token
   */
  onTrade(mint: string, callback: TradeCallback): void {
    if (!this.tradeCallbacks.has(mint)) {
      this.tradeCallbacks.set(mint, []);
    }
    this.tradeCallbacks.get(mint)!.push(callback);
  }

  /**
   * Disconnect
   */
  disconnect(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.isConnected = false;
  }

  /**
   * Check if connected
   */
  get connected(): boolean {
    return this.isConnected;
  }
}

// Singleton instance
export const pumpPortalData = new PumpPortalDataClient();
</file>

<file path="src/api/rate-limiter.ts">
/**
 * Rate limiter configuration for Helius API calls.
 *
 * Uses Bottleneck to prevent rate limit errors (429) by throttling
 * requests according to Helius tier limits.
 */

import Bottleneck from 'bottleneck';
import { createLogger } from '../lib/logger.js';

const logger = createLogger('rate-limiter');

/**
 * Configuration for a Bottleneck rate limiter.
 */
interface RateLimiterConfig {
  /** Maximum number of concurrent requests */
  maxConcurrent: number;
  /** Minimum milliseconds between requests */
  minTime: number;
  /** Initial number of requests allowed (token bucket) */
  reservoir?: number;
  /** Number of tokens to add on refresh */
  reservoirRefreshAmount?: number;
  /** Milliseconds between reservoir refreshes */
  reservoirRefreshInterval?: number;
}

/**
 * Helius API tier levels.
 *
 * Rate limits differ significantly between tiers:
 * - free: 10 RPC/s, 2 Enhanced/s
 * - developer: 50 RPC/s, 10 Enhanced/s
 * - business: 200 RPC/s, 50 Enhanced/s
 */
type HeliusTier = 'free' | 'developer' | 'business';

/**
 * Get rate limiter configurations for a Helius tier.
 *
 * Applies 80% safety margin to prevent hitting actual limits.
 *
 * @param tier - The Helius subscription tier
 * @returns Configuration objects for RPC and Enhanced API limiters
 */
function getConfigForTier(tier: HeliusTier): {
  rpc: RateLimiterConfig;
  enhanced: RateLimiterConfig;
} {
  // Tier limits with 80% safety margin
  const configs: Record<HeliusTier, { rpc: RateLimiterConfig; enhanced: RateLimiterConfig }> = {
    free: {
      rpc: {
        maxConcurrent: 5,
        minTime: 150, // ~6-7 RPS (80% of 10)
        reservoir: 8,
        reservoirRefreshAmount: 8,
        reservoirRefreshInterval: 1000,
      },
      enhanced: {
        maxConcurrent: 1,
        minTime: 625, // ~1.6 RPS (80% of 2)
        reservoir: 1,
        reservoirRefreshAmount: 1,
        reservoirRefreshInterval: 625,
      },
    },
    developer: {
      rpc: {
        maxConcurrent: 10,
        minTime: 25, // ~40 RPS (80% of 50)
        reservoir: 40,
        reservoirRefreshAmount: 40,
        reservoirRefreshInterval: 1000,
      },
      enhanced: {
        maxConcurrent: 5,
        minTime: 125, // ~8 RPS (80% of 10)
        reservoir: 8,
        reservoirRefreshAmount: 8,
        reservoirRefreshInterval: 1000,
      },
    },
    business: {
      rpc: {
        maxConcurrent: 25,
        minTime: 6, // ~160 RPS (80% of 200)
        reservoir: 160,
        reservoirRefreshAmount: 160,
        reservoirRefreshInterval: 1000,
      },
      enhanced: {
        maxConcurrent: 15,
        minTime: 25, // ~40 RPS (80% of 50)
        reservoir: 40,
        reservoirRefreshAmount: 40,
        reservoirRefreshInterval: 1000,
      },
    },
  };

  return configs[tier];
}

/**
 * Create a Bottleneck rate limiter with 429 error handling.
 *
 * The limiter automatically backs off on 429 errors and retries.
 *
 * @param config - Rate limiter configuration
 * @param name - Optional name for logging
 * @returns Configured Bottleneck instance
 *
 * @example
 * const limiter = createRateLimiter({ maxConcurrent: 10, minTime: 25 }, 'helius-rpc');
 * const result = await limiter.schedule(() => fetch(url));
 */
function createRateLimiter(config: RateLimiterConfig, name?: string): Bottleneck {
  const limiter = new Bottleneck({
    maxConcurrent: config.maxConcurrent,
    minTime: config.minTime,
    reservoir: config.reservoir,
    reservoirRefreshAmount: config.reservoirRefreshAmount,
    reservoirRefreshInterval: config.reservoirRefreshInterval,
  });

  // Handle 429 rate limit errors with automatic backoff
  limiter.on('failed', async (error: Error & { status?: number }, jobInfo) => {
    // Check for rate limit error (429)
    if (error.status === 429 || error.message?.includes('429') || error.message?.includes('rate limit')) {
      const delay = 5000; // 5 second backoff
      logger.warn(
        {
          limiter: name,
          attempt: jobInfo.retryCount + 1,
          delay,
        },
        'Rate limited (429), backing off'
      );
      return delay; // Return delay in ms to retry
    }
    // Don't retry other errors
    return undefined;
  });

  // Log when limiter is depleted (hitting limits)
  limiter.on('depleted', () => {
    logger.debug({ limiter: name }, 'Rate limiter reservoir depleted, queuing requests');
  });

  return limiter;
}

export { createRateLimiter, getConfigForTier, RateLimiterConfig, HeliusTier };
</file>

<file path="src/db/database-with-repos.ts">
/**
 * Database interface with repositories
 */

import type { Database } from './database.js';
import { TradeRepository } from './repositories/trades.js';
import { StateRepository } from './repositories/state.js';
import { AnalysisCacheRepository } from './repositories/analysis-cache.js';

/**
 * Database instance with attached repositories
 */
export interface DatabaseWithRepositories extends Database.Database {
  trades: TradeRepository;
  state: StateRepository;
  analysisCache: AnalysisCacheRepository;
}

/**
 * Create database instance with repositories attached
 */
export function createDatabaseWithRepositories(db: Database.Database): DatabaseWithRepositories {
  const dbWithRepos = db as DatabaseWithRepositories;
  dbWithRepos.trades = new TradeRepository(db);
  dbWithRepos.state = new StateRepository(db);
  dbWithRepos.analysisCache = new AnalysisCacheRepository(db);

  return dbWithRepos;
}
</file>

<file path="src/db/database.ts">
import Database from 'better-sqlite3';
import { createLogger } from '../lib/logger.js';
import { initializeSchema } from './schema.js';

const log = createLogger('database');

/**
 * Create and configure a SQLite database instance.
 *
 * Features:
 * - WAL mode enabled for better concurrent performance
 * - Foreign keys enforced
 * - Schema automatically initialized
 *
 * @param filepath - Path to the database file
 * @returns Configured database instance
 *
 * @example
 * const db = createDatabase('agent.db');
 * // Database is ready to use with all tables created
 */
function createDatabase(filepath: string): Database.Database {
  const db = new Database(filepath);

  // Enable WAL mode for better concurrent read/write performance
  db.pragma('journal_mode = WAL');

  // Enable foreign key constraints
  db.pragma('foreign_keys = ON');

  // Initialize schema (creates tables if they don't exist)
  initializeSchema(db);

  log.info({ filepath }, 'Database opened (WAL mode)');

  return db;
}

export { createDatabase, Database };
</file>

<file path="src/db/index.ts">
/**
 * Database module barrel export.
 *
 * Provides:
 * - createDatabase: Create and configure SQLite database
 * - Database: The better-sqlite3 Database type
 * - TradeRepository, Trade: Trade CRUD operations
 * - StateRepository, PnLSnapshot: Agent state and P&L tracking
 * - AnalysisCacheRepository: Cached analysis results with TTL
 */

export { createDatabase, Database } from './database.js';
export { TradeRepository, Trade } from './repositories/trades.js';
export { StateRepository, PnLSnapshot } from './repositories/state.js';
export { AnalysisCacheRepository } from './repositories/analysis-cache.js';
</file>

<file path="src/db/repositories/analysis-cache.ts">
import Database from 'better-sqlite3';

/**
 * Repository for caching analysis results with TTL expiration.
 * 
 * Supports caching for:
 * - Token safety analysis
 * - Wallet performance analysis
 * - Smart money classification
 * 
 * Uses prepared statements for optimal performance and SQL injection safety.
 * 
 * @example
 * const repo = new AnalysisCacheRepository(db);
 * repo.set('mint-address', 'token_safety', result, 24 * 60 * 60 * 1000);
 * const cached = repo.get<TokenSafetyResult>('mint-address', 'token_safety');
 */
class AnalysisCacheRepository {
  private getStmt: Database.Statement;
  private setStmt: Database.Statement;
  private cleanupStmt: Database.Statement;

  constructor(private db: Database.Database) {
    // Prepared statement for retrieving non-expired cache entries
    this.getStmt = db.prepare(`
      SELECT result FROM analysis_cache
      WHERE address = ? AND analysis_type = ? AND expires_at > ?
    `);

    // Prepared statement for inserting or updating cache entries
    this.setStmt = db.prepare(`
      INSERT OR REPLACE INTO analysis_cache
        (address, analysis_type, result, expires_at, created_at)
      VALUES (?, ?, ?, ?, ?)
    `);

    // Prepared statement for cleaning up expired entries
    this.cleanupStmt = db.prepare(`
      DELETE FROM analysis_cache WHERE expires_at < ?
    `);
  }

  /**
   * Get a cached analysis result if it exists and hasn't expired.
   * 
   * @param address - The address (wallet or token mint)
   * @param analysisType - Type of analysis (e.g., 'token_safety', 'wallet_analysis')
   * @returns The cached result or null if not found or expired
   */
  get<T>(address: string, analysisType: string): T | null {
    const row = this.getStmt.get(address, analysisType, Date.now()) as 
      { result: string } | undefined;
    
    if (!row) {
      return null;
    }

    try {
      return JSON.parse(row.result) as T;
    } catch (error) {
      // If JSON parsing fails, return null (corrupted cache entry)
      return null;
    }
  }

  /**
   * Store an analysis result in the cache with a TTL.
   * 
   * @param address - The address (wallet or token mint)
   * @param analysisType - Type of analysis
   * @param result - The analysis result to cache
   * @param ttlMs - Time-to-live in milliseconds
   */
  set(address: string, analysisType: string, result: unknown, ttlMs: number): void {
    const expiresAt = Date.now() + ttlMs;
    const createdAt = Date.now();
    
    this.setStmt.run(
      address,
      analysisType,
      JSON.stringify(result),
      expiresAt,
      createdAt
    );
  }

  /**
   * Remove all expired cache entries.
   * 
   * @returns Number of entries removed
   */
  cleanup(): number {
    const result = this.cleanupStmt.run(Date.now());
    return result.changes;
  }
}

export { AnalysisCacheRepository };
</file>

<file path="src/db/repositories/state.ts">
import Database from 'better-sqlite3';

/**
 * P&L snapshot representing portfolio state at a point in time.
 */
interface PnLSnapshot {
  timestamp: number;
  totalValueSol: number;
  realizedPnlSol: number;
  unrealizedPnlSol: number;
  tokenHoldings: Record<string, number>;
}

/**
 * Repository for agent state and P&L tracking.
 * Uses prepared statements for optimal performance.
 *
 * @example
 * const repo = new StateRepository(db);
 * repo.setState('last_run', new Date().toISOString());
 * const lastRun = repo.getState('last_run');
 */
class StateRepository {
  private getStateStmt: Database.Statement;
  private setStateStmt: Database.Statement;
  private savePnLStmt: Database.Statement;
  private getLatestPnLStmt: Database.Statement;
  private getPnLHistoryStmt: Database.Statement;

  constructor(private db: Database.Database) {
    this.getStateStmt = db.prepare(
      'SELECT value FROM agent_state WHERE key = ?'
    );

    this.setStateStmt = db.prepare(`
      INSERT INTO agent_state (key, value, updated_at)
      VALUES (?, ?, unixepoch())
      ON CONFLICT(key) DO UPDATE SET
        value = excluded.value,
        updated_at = unixepoch()
    `);

    this.savePnLStmt = db.prepare(`
      INSERT INTO pnl_snapshots
        (timestamp, total_value_sol, realized_pnl_sol, unrealized_pnl_sol, token_holdings)
      VALUES (?, ?, ?, ?, ?)
    `);

    this.getLatestPnLStmt = db.prepare(
      'SELECT * FROM pnl_snapshots ORDER BY timestamp DESC LIMIT 1'
    );

    this.getPnLHistoryStmt = db.prepare(
      'SELECT * FROM pnl_snapshots ORDER BY timestamp DESC LIMIT ?'
    );
  }

  /**
   * Get a state value by key.
   *
   * @param key - The state key
   * @returns The value if found, undefined otherwise
   */
  getState(key: string): string | undefined {
    const row = this.getStateStmt.get(key) as { value: string } | undefined;
    return row?.value;
  }

  /**
   * Set a state value (insert or update).
   *
   * @param key - The state key
   * @param value - The value to store
   */
  setState(key: string, value: string): void {
    this.setStateStmt.run(key, value);
  }

  /**
   * Save a P&L snapshot.
   *
   * @param snapshot - The snapshot to save
   */
  savePnLSnapshot(snapshot: PnLSnapshot): void {
    this.savePnLStmt.run(
      snapshot.timestamp,
      snapshot.totalValueSol,
      snapshot.realizedPnlSol,
      snapshot.unrealizedPnlSol,
      JSON.stringify(snapshot.tokenHoldings)
    );
  }

  /**
   * Get the most recent P&L snapshot.
   *
   * @returns The latest snapshot if any exist, undefined otherwise
   */
  getLatestPnLSnapshot(): PnLSnapshot | undefined {
    const row = this.getLatestPnLStmt.get() as Record<string, unknown> | undefined;
    return row ? this.mapPnLRow(row) : undefined;
  }

  /**
   * Get P&L history (most recent first).
   *
   * @param limit - Maximum number of snapshots to return
   * @returns Array of P&L snapshots
   */
  getPnLHistory(limit: number = 100): PnLSnapshot[] {
    const rows = this.getPnLHistoryStmt.all(limit) as Record<string, unknown>[];
    return rows.map(row => this.mapPnLRow(row));
  }

  /**
   * Map a database row to a PnLSnapshot object.
   */
  private mapPnLRow(row: Record<string, unknown>): PnLSnapshot {
    return {
      timestamp: row.timestamp as number,
      totalValueSol: row.total_value_sol as number,
      realizedPnlSol: row.realized_pnl_sol as number,
      unrealizedPnlSol: row.unrealized_pnl_sol as number,
      tokenHoldings: JSON.parse(row.token_holdings as string)
    };
  }
}

export { StateRepository, PnLSnapshot };
</file>

<file path="src/db/schema.ts">
import Database from 'better-sqlite3';

/**
 * Initialize database schema with all required tables.
 * Creates tables if they don't exist, adds indexes for query performance.
 *
 * Tables:
 * - config: Key-value configuration storage
 * - trades: Trade history with full details
 * - pnl_snapshots: P&L tracking over time
 * - analysis_cache: Cached wallet/token analysis results
 * - agent_state: Agent runtime state for recovery
 *
 * @param db - The database instance to initialize
 */
function initializeSchema(db: Database.Database): void {
  db.exec(`
    -- Configuration table for key-value settings
    CREATE TABLE IF NOT EXISTS config (
      key TEXT PRIMARY KEY,
      value TEXT NOT NULL,
      updated_at INTEGER DEFAULT (unixepoch())
    );

    -- Trades table for complete trade history
    CREATE TABLE IF NOT EXISTS trades (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      signature TEXT UNIQUE NOT NULL,
      timestamp INTEGER NOT NULL,
      type TEXT NOT NULL,
      token_mint TEXT NOT NULL,
      token_symbol TEXT,
      amount_tokens REAL NOT NULL,
      amount_sol REAL NOT NULL,
      price_per_token REAL NOT NULL,
      fee_sol REAL DEFAULT 0,
      status TEXT DEFAULT 'CONFIRMED',
      metadata TEXT,
      created_at INTEGER DEFAULT (unixepoch())
    );

    -- Indexes for common trade queries
    CREATE INDEX IF NOT EXISTS idx_trades_timestamp ON trades(timestamp);
    CREATE INDEX IF NOT EXISTS idx_trades_token ON trades(token_mint);

    -- P&L snapshots for tracking portfolio value over time
    CREATE TABLE IF NOT EXISTS pnl_snapshots (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      timestamp INTEGER NOT NULL,
      total_value_sol REAL NOT NULL,
      realized_pnl_sol REAL NOT NULL,
      unrealized_pnl_sol REAL NOT NULL,
      token_holdings TEXT NOT NULL,
      created_at INTEGER DEFAULT (unixepoch())
    );

    -- Index for time-based P&L queries
    CREATE INDEX IF NOT EXISTS idx_pnl_timestamp ON pnl_snapshots(timestamp);

    -- Analysis cache for wallet/token analysis results
    CREATE TABLE IF NOT EXISTS analysis_cache (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      address TEXT NOT NULL,
      analysis_type TEXT NOT NULL,
      result TEXT NOT NULL,
      expires_at INTEGER NOT NULL,
      created_at INTEGER DEFAULT (unixepoch()),
      UNIQUE(address, analysis_type)
    );

    -- Index for cache expiry cleanup
    CREATE INDEX IF NOT EXISTS idx_analysis_expires ON analysis_cache(expires_at);

    -- Agent state for recovery after restarts
    CREATE TABLE IF NOT EXISTS agent_state (
      key TEXT PRIMARY KEY,
      value TEXT NOT NULL,
      updated_at INTEGER DEFAULT (unixepoch())
    );
  `);
}

export { initializeSchema };
</file>

<file path="src/events/emitter.ts">
/**
 * Event emitter for agent actions
 */

import type { AgentEvent } from './types.js';
import { logger } from '../lib/logger.js';

/**
 * Event listener callback
 */
type EventListener = (event: AgentEvent) => void;

/**
 * Agent event emitter (singleton)
 */
export class AgentEventEmitter {
  private listeners: Map<string, Set<EventListener>>;
  private anyListeners: Set<EventListener>;

  constructor() {
    this.listeners = new Map();
    this.anyListeners = new Set();
  }

  /**
   * Emit an event to all listeners
   */
  emit(event: AgentEvent): void {
    // Add timestamp if not present
    if (!event.timestamp) {
      event.timestamp = Date.now();
    }

    logger.debug({ type: event.type }, 'Event emitted');

    // Notify specific event type listeners
    const typeListeners = this.listeners.get(event.type);
    if (typeListeners) {
      typeListeners.forEach(listener => {
        try {
          listener(event);
        } catch (error) {
          logger.error({ type: event.type, error }, 'Event listener error');
        }
      });
    }

    // Notify wildcard listeners
    this.anyListeners.forEach(listener => {
      try {
        listener(event);
      } catch (error) {
        logger.error({ type: event.type, error }, 'Wildcard listener error');
      }
    });
  }

  /**
   * Listen to specific event type
   */
  on(eventType: string, callback: EventListener): void {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, new Set());
    }
    this.listeners.get(eventType)!.add(callback);
  }

  /**
   * Remove listener for specific event type
   */
  off(eventType: string, callback: EventListener): void {
    const typeListeners = this.listeners.get(eventType);
    if (typeListeners) {
      typeListeners.delete(callback);
    }
  }

  /**
   * Listen to all events
   */
  onAny(callback: EventListener): void {
    this.anyListeners.add(callback);
  }

  /**
   * Remove wildcard listener
   */
  offAny(callback: EventListener): void {
    this.anyListeners.delete(callback);
  }

  /**
   * Clear all listeners
   */
  clear(): void {
    this.listeners.clear();
    this.anyListeners.clear();
  }
}

/**
 * Global event emitter instance (singleton)
 */
export const agentEvents = new AgentEventEmitter();
</file>

<file path="src/events/index.ts">
/**
 * Events module exports
 */

export { AgentEventEmitter, agentEvents } from './emitter.js';
export type { AgentEvent } from './types.js';
export type {
  AnalysisStartEvent,
  SafetyCheckEvent,
  SmartMoneyCheckEvent,
  TradeDecisionEvent,
  TradeExecutedEvent,
  BuybackTriggeredEvent,
} from './types.js';
</file>

<file path="src/keystore/crypto.ts">
import crypto from 'node:crypto';

/**
 * Encrypted data structure for AES-256-GCM encryption.
 * All binary fields are base64-encoded strings for JSON serialization.
 */
export interface EncryptedData {
  /** Random salt for key derivation (64 bytes, base64) */
  salt: string;
  /** Initialization vector (16 bytes, base64) */
  iv: string;
  /** Authentication tag for integrity verification (16 bytes, base64) */
  authTag: string;
  /** Encrypted ciphertext (base64) */
  encrypted: string;
}

/** PBKDF2 iteration count - higher = more secure but slower */
const PBKDF2_ITERATIONS = 100000;

/** AES-256 key length in bytes */
const KEY_LENGTH = 32;

/** Salt length in bytes */
const SALT_LENGTH = 64;

/** Initialization vector length in bytes */
const IV_LENGTH = 16;

/**
 * Encrypt plaintext using AES-256-GCM with PBKDF2 key derivation.
 *
 * @param plaintext - The string to encrypt
 * @param password - The password for key derivation
 * @returns EncryptedData with all components base64-encoded
 *
 * @example
 * const encrypted = encrypt('my-secret-key', 'strong-password');
 * // encrypted.salt, encrypted.iv, encrypted.authTag, encrypted.encrypted
 */
export function encrypt(plaintext: string, password: string): EncryptedData {
  // Generate random salt and IV
  const salt = crypto.randomBytes(SALT_LENGTH);
  const iv = crypto.randomBytes(IV_LENGTH);

  // Derive key from password using PBKDF2 with SHA-512
  const key = crypto.pbkdf2Sync(
    password,
    salt,
    PBKDF2_ITERATIONS,
    KEY_LENGTH,
    'sha512'
  );

  // Create cipher and encrypt
  const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
  const encrypted = Buffer.concat([
    cipher.update(plaintext, 'utf8'),
    cipher.final()
  ]);
  const authTag = cipher.getAuthTag();

  return {
    salt: salt.toString('base64'),
    iv: iv.toString('base64'),
    authTag: authTag.toString('base64'),
    encrypted: encrypted.toString('base64')
  };
}

/**
 * Decrypt data encrypted with AES-256-GCM.
 *
 * @param data - The EncryptedData object from encrypt()
 * @param password - The password used for encryption
 * @returns The original plaintext string
 * @throws Error if password is wrong or data is corrupted (generic message)
 *
 * @example
 * const plaintext = decrypt(encrypted, 'strong-password');
 * // Returns original string
 */
export function decrypt(data: EncryptedData, password: string): string {
  // Decode all base64 components
  const salt = Buffer.from(data.salt, 'base64');
  const iv = Buffer.from(data.iv, 'base64');
  const authTag = Buffer.from(data.authTag, 'base64');
  const encrypted = Buffer.from(data.encrypted, 'base64');

  // Derive the same key
  const key = crypto.pbkdf2Sync(
    password,
    salt,
    PBKDF2_ITERATIONS,
    KEY_LENGTH,
    'sha512'
  );

  // Create decipher and decrypt
  const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
  decipher.setAuthTag(authTag);

  try {
    const decrypted = Buffer.concat([
      decipher.update(encrypted),
      decipher.final()
    ]);
    return decrypted.toString('utf8');
  } catch {
    // Don't leak password or key details in error message
    throw new Error('Decryption failed: invalid password or corrupted data');
  }
}
</file>

<file path="src/keystore/index.ts">
/**
 * Encrypted keystore module for secure wallet management.
 *
 * Provides secure storage and retrieval of Solana keypairs using
 * AES-256-GCM encryption with PBKDF2 key derivation.
 *
 * @example
 * import { createKeystore, saveKeystore, loadKeystore } from './keystore/index.js';
 *
 * // Create and save a new wallet
 * const { keypair, keystore } = createKeystore('my-password');
 * saveKeystore(keystore, 'wallet.keystore.json');
 *
 * // Later, load the wallet
 * const loadedKeypair = loadKeystore('wallet.keystore.json', 'my-password');
 *
 * @module keystore
 */

export { createKeystore, saveKeystore, loadKeystore, type KeystoreFile } from './keystore.js';
export { encrypt, decrypt, type EncryptedData } from './crypto.js';
</file>

<file path="src/keystore/keystore.ts">
import { Keypair } from '@solana/web3.js';
import bs58 from 'bs58';
import fs from 'node:fs';
import { encrypt, decrypt, type EncryptedData } from './crypto.js';
import { createLogger } from '../lib/logger.js';

const logger = createLogger('keystore');

/**
 * Keystore file format for encrypted wallet storage.
 *
 * The private key is encrypted with AES-256-GCM using a password-derived key.
 * Only the public key is stored in plaintext for identification.
 */
export interface KeystoreFile {
  /** Format version for future compatibility */
  version: 1;
  /** Base58-encoded public key (safe to store unencrypted) */
  publicKey: string;
  /** AES-256-GCM encrypted private key */
  encryptedPrivateKey: EncryptedData;
  /** ISO timestamp of keystore creation */
  createdAt: string;
}

/**
 * Create a new keystore with a freshly generated keypair.
 *
 * @param password - The password to encrypt the private key
 * @returns The keypair and keystore data (keystore not yet saved to disk)
 *
 * @example
 * const { keypair, keystore } = createKeystore('my-secure-password');
 * // keypair can be used for signing
 * // keystore can be saved to disk with saveKeystore()
 */
export function createKeystore(password: string): {
  keypair: Keypair;
  keystore: KeystoreFile;
} {
  // Generate new keypair
  const keypair = Keypair.generate();

  // Encode secret key as base58
  const secretKeyBase58 = bs58.encode(keypair.secretKey);

  // Encrypt the secret key
  const encryptedPrivateKey = encrypt(secretKeyBase58, password);

  // Build keystore file
  const keystore: KeystoreFile = {
    version: 1,
    publicKey: keypair.publicKey.toBase58(),
    encryptedPrivateKey,
    createdAt: new Date().toISOString(),
  };

  logger.info({ publicKey: keystore.publicKey }, 'Created new keystore');

  return { keypair, keystore };
}

/**
 * Save a keystore to disk with secure file permissions.
 *
 * @param keystore - The keystore data to save
 * @param filepath - Path where the keystore file will be written
 *
 * @example
 * saveKeystore(keystore, 'wallet.keystore.json');
 */
export function saveKeystore(keystore: KeystoreFile, filepath: string): void {
  // Write JSON with pretty formatting
  const content = JSON.stringify(keystore, null, 2);
  fs.writeFileSync(filepath, content, { encoding: 'utf8' });

  // Set file permissions to 0600 (owner read/write only) on Unix systems
  // On Windows this is a no-op but doesn't throw
  try {
    fs.chmodSync(filepath, 0o600);
  } catch {
    // Ignore permission errors on platforms that don't support chmod
  }

  logger.info({ filepath }, 'Saved keystore');
}

/**
 * Load a keypair from an encrypted keystore file.
 *
 * @param filepath - Path to the keystore file
 * @param password - The password to decrypt the private key
 * @returns The decrypted Keypair ready for signing
 * @throws Error if file doesn't exist, version mismatch, or wrong password
 *
 * @example
 * const keypair = loadKeystore('wallet.keystore.json', 'my-secure-password');
 * // keypair can now be used for signing transactions
 */
export function loadKeystore(filepath: string, password: string): Keypair {
  // Read and parse keystore file
  let content: string;
  try {
    content = fs.readFileSync(filepath, 'utf8');
  } catch {
    throw new Error('Keystore file not found or unreadable');
  }

  let keystore: KeystoreFile;
  try {
    keystore = JSON.parse(content) as KeystoreFile;
  } catch {
    throw new Error('Keystore file is corrupted');
  }

  // Validate version
  if (keystore.version !== 1) {
    throw new Error('Unsupported keystore version');
  }

  // Decrypt the private key
  let secretKeyBase58: string;
  try {
    secretKeyBase58 = decrypt(keystore.encryptedPrivateKey, password);
  } catch {
    // Don't leak details about what went wrong
    throw new Error('Failed to decrypt keystore: invalid password or corrupted data');
  }

  // Reconstruct keypair from secret key
  const secretKey = bs58.decode(secretKeyBase58);
  const keypair = Keypair.fromSecretKey(secretKey);

  // Verify public key matches stored value
  const recoveredPublicKey = keypair.publicKey.toBase58();
  if (recoveredPublicKey !== keystore.publicKey) {
    throw new Error('Keystore integrity check failed');
  }

  logger.info({ publicKey: keystore.publicKey }, 'Loaded keystore');

  return keypair;
}
</file>

<file path="src/lib/logger.ts">
import pino from 'pino';

/**
 * Pino logger configured with secret redaction and pretty-printing in development.
 *
 * Redacts: privateKey, secretKey, password, masterPassword, apiKey
 * and their nested variants (*.privateKey, *.secretKey, etc.)
 */
const logger = pino({
  level: process.env.LOG_LEVEL || 'info',

  // Redact sensitive fields - NEVER log private keys or passwords
  redact: {
    paths: [
      'privateKey',
      'secretKey',
      'password',
      'masterPassword',
      'apiKey',
      '*.privateKey',
      '*.secretKey',
      '*.password',
      '*.masterPassword',
      '*.apiKey',
      '[*].privateKey',
      '[*].secretKey',
      '[*].password',
      '[*].masterPassword',
      '[*].apiKey'
    ],
    censor: '[REDACTED]'
  },

  // Pretty print in development, JSON in production
  transport: process.env.NODE_ENV === 'development'
    ? { target: 'pino-pretty' }
    : undefined
});

/**
 * Create a child logger with module context.
 *
 * @param module - The module name for log context
 * @returns A pino logger instance with the module context
 *
 * @example
 * const log = createLogger('trades');
 * log.info({ amount: 100 }, 'Trade executed');
 * // Output includes: { module: 'trades', ... }
 */
function createLogger(module: string): pino.Logger {
  return logger.child({ module });
}

export { logger, createLogger };
</file>

<file path="src/personality/name-analyzer.ts">
/**
 * Silly token name detection for roasting purposes
 */

export type SillyCategory =
  | 'food'      // PIZZA, BURGER, TACO
  | 'animal'    // DOGE variants, CAT, PEPE
  | 'pump'      // MOON, ROCKET, 100X, SAFE
  | 'celebrity' // ELON, TRUMP
  | 'copycat'   // anything with INU, PEPE suffix
  | 'random'    // gibberish letters
  | 'crude';    // profanity/sexual

/**
 * Detect if a token has a silly/memey name worth roasting
 * @param symbol Token symbol (e.g., "BURGER")
 * @param name Token name (e.g., "BurgerCoin")
 * @returns Category of silliness or null if normal
 */
export function detectSillyName(symbol: string, name: string): SillyCategory | null {
  const s = symbol.toUpperCase();
  const n = name.toLowerCase();

  // Food tokens - who's funding these, DoorDash?
  if (/^(PIZZA|BURGER|TACO|SUSHI|BACON|FRIES|HOTDOG|HOT ?DOG|RAMEN|STEAK|NOODLE|CHEESE|BREAD|COOKIE|DONUT|WAFFLE|PANCAKE|CHICKEN|NUGGET|FROG ?LEGS|SOUP|SALAD)/.test(s) ||
      /pizza|burger|taco|sushi|bacon|fries|hotdog|ramen|steak|noodle|food|eat|hungry|yummy|delicious/i.test(n)) {
    return 'food';
  }

  // Copycat tokens - they literally just added INU/PEPE/DOGE to something
  if (/INU$|PEPE$|DOGE$|SHIB$|FLOKI$|BONK$/.test(s) && s.length > 6) {
    return 'copycat';
  }

  // Animal memes - DOGE already happened
  if (/^(SHIB|FLOKI|DOGE|BONK|PEPE|APE|CAT|DOG|FROG|MONKEY|BEAR|BULL|WHALE|FISH|BIRD|DUCK|HAMSTER|RABBIT|PIG|COW|GOAT)/.test(s) ||
      /shiba|doge|pepe|ape|monkey|animal|zoo/i.test(n)) {
    return 'animal';
  }

  // Obvious pump schemes - very subtle naming
  if (/^(MOON|ROCKET|SAFE|100X|1000X|10000X|LAMBO|RICH|PUMP|GAINS|PROFIT|DIAMOND|GEM|GOLD|WEALTH|MILLION|BILLION)/.test(s) ||
      /to.?the.?moon|going.?up|cant.?stop|wont.?stop|guaranteed|get.?rich|easy.?money|free.?money/i.test(n)) {
    return 'pump';
  }

  // Celebrity grift - riding famous names
  if (/^(ELON|TRUMP|MUSK|BIDEN|OBAMA|KANYE|DRAKE|SNOOP|JEFF|BEZOS|ZUCK|GATES|BUFFET|VITALIK)/.test(s) ||
      /elon|trump|musk|biden|obama|kanye|celebrity|famous/i.test(n)) {
    return 'celebrity';
  }

  // Random gibberish (4+ consonants in a row with no vowels)
  if (/^[BCDFGHJKLMNPQRSTVWXYZ]{4,}$/.test(s)) {
    return 'random';
  }

  // Crude/profanity tokens
  const crudePatterns = /^(ASS|BOOB|PORN|SEX|NUDE|MILF|DILDO|COCK|DICK|PUSSY|FUCK|SHIT|CUM|HORNY)/;
  if (crudePatterns.test(s) ||
      /nsfw|adult|xxx|18\+|sexy|erotic/i.test(n)) {
    return 'crude';
  }

  // Not particularly silly
  return null;
}

/**
 * Get a human-readable description of the silly category
 */
export function getSillyCategoryDescription(category: SillyCategory): string {
  const descriptions: Record<SillyCategory, string> = {
    food: 'a food token',
    animal: 'another animal coin',
    pump: 'an obvious pump scheme name',
    celebrity: 'celebrity grift',
    copycat: 'a copycat token',
    random: 'random gibberish letters',
    crude: 'a crude/NSFW name',
  };
  return descriptions[category];
}
</file>

<file path="src/personality/twitter-client.ts">
import { TwitterApi } from 'twitter-api-v2';
import { logger } from '../lib/logger.js';
import type { ClaudeClient } from './claude-client.js';

export interface TwitterConfig {
  apiKey: string;
  apiSecret: string;
  accessToken: string;
  accessSecret: string;
  maxTweetsPerDay: number;
}

export class TwitterClient {
  private client: TwitterApi;
  private config: TwitterConfig;
  private claude?: ClaudeClient;
  private tweetQueue: string[] = [];
  private isProcessingQueue = false;
  private dailyTweetCount = 0;
  private lastResetTime = Date.now();

  constructor(config: TwitterConfig, claude?: ClaudeClient) {
    this.config = config;
    this.claude = claude;
    this.client = new TwitterApi({
      appKey: config.apiKey,
      appSecret: config.apiSecret,
      accessToken: config.accessToken,
      accessSecret: config.accessSecret,
    });

    logger.info('Twitter client initialized');
  }

  /**
   * Post a tweet (with queueing and rate limit checks)
   */
  async postTweet(content: string): Promise<boolean> {
    // Reset daily counter if a new day has started
    if (Date.now() - this.lastResetTime > 24 * 60 * 60 * 1000) {
      this.dailyTweetCount = 0;
      this.lastResetTime = Date.now();
    }

    if (this.dailyTweetCount >= this.config.maxTweetsPerDay) {
      logger.warn('Daily tweet limit reached, skipping tweet');
      return false;
    }

    this.tweetQueue.push(content);
    this.processQueue().catch(err => logger.error({ err }, 'Error processing tweet queue'));
    return true;
  }

  /**
   * Post a trade update
   */
  async postTradeUpdate(
    type: 'BUY' | 'SELL', 
    tokenMint: string, 
    amountSol: number, 
    reasoning?: string
  ): Promise<void> {
    const action = type === 'BUY' ? 'APEING INTO' : 'DUMPING';
    const mintDisplay = tokenMint.slice(0, 8);
    
    let tweet = `üö® ${action} $${mintDisplay} üö®\n\n`;
    tweet += `Amount: ${amountSol.toFixed(2)} SOL\n`;
    
    if (reasoning) {
        // Use provided reasoning or ask Claude to generate a tweet-sized version
        tweet += `\n"${reasoning.slice(0, 150)}..."\n`;
    }

    tweet += `\n#Solana #Memecoins $SCHIZO`;
    
    await this.postTweet(tweet);
  }

  /**
   * Process the tweet queue sequentially
   */
  private async processQueue() {
    if (this.isProcessingQueue) return;
    this.isProcessingQueue = true;

    while (this.tweetQueue.length > 0) {
      const content = this.tweetQueue.shift();
      if (!content) continue;

      try {
        await this.client.v2.tweet(content);
        logger.info({ content: content.slice(0, 50) }, 'Tweet posted successfully');
        this.dailyTweetCount++;
        
        // Wait a bit between tweets to avoid spam flags
        await new Promise(resolve => setTimeout(resolve, 30000)); 
      } catch (error) {
        logger.error({ error, content }, 'Failed to post tweet');
      }
    }

    this.isProcessingQueue = false;
  }
}
</file>

<file path="src/test-devnet.ts">
/**
 * Devnet Integration Test
 *
 * Verifies all Phase 1 systems work together:
 * - Encrypted keystore for wallet management
 * - SQLite database for trade persistence
 * - Helius/Solana connection for transactions
 *
 * Run: npx tsx src/test-devnet.ts
 */

import {
  Keypair,
  Connection,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  LAMPORTS_PER_SOL,
  PublicKey,
} from '@solana/web3.js';
import { createKeystore, saveKeystore, loadKeystore } from './keystore/index.js';
import { createDatabase } from './db/database.js';
import { TradeRepository } from './db/repositories/trades.js';
import { StateRepository } from './db/repositories/state.js';
import { HeliusClient } from './api/index.js';
import { createLogger } from './lib/logger.js';
import * as fs from 'fs';
import * as path from 'path';

// Module logger
const log = createLogger('test-devnet');

// Test configuration
const KEYSTORE_PATH = './test-keystore.json';
const DATABASE_PATH = './test-agent.db';
const TEST_PASSWORD = 'test-password-12345'; // OK for devnet test
const DEVNET_URL = process.env.HELIUS_API_KEY
  ? `https://devnet.helius-rpc.com/?api-key=${process.env.HELIUS_API_KEY}`
  : 'https://api.devnet.solana.com';

// Mock mode for testing when airdrop is unavailable
const MOCK_MODE = process.argv.includes('--mock');

/**
 * Run the devnet integration test.
 *
 * This test verifies:
 * 1. Keystore create/save/load with encryption
 * 2. Database persistence across restarts
 * 3. Solana devnet transaction signing and submission
 * 4. Trade recording in SQLite
 */
export async function runDevnetTest(): Promise<void> {
  log.info('===========================================');
  log.info('SCHIZO Agent - Devnet Integration Test');
  log.info('===========================================');

  // Step 1: Setup keystore
  log.info('Step 1: Setting up keystore...');
  let keypair: Keypair;

  if (fs.existsSync(KEYSTORE_PATH)) {
    log.info('Loading existing keystore...');
    keypair = loadKeystore(KEYSTORE_PATH, TEST_PASSWORD);
    log.info({ publicKey: keypair.publicKey.toBase58() }, 'Wallet loaded from keystore');
  } else {
    log.info('Creating new keystore...');
    const result = createKeystore(TEST_PASSWORD);
    keypair = result.keypair;
    saveKeystore(result.keystore, KEYSTORE_PATH);
    log.info({ publicKey: keypair.publicKey.toBase58() }, 'New wallet created and saved');
  }

  // Step 2: Setup database
  log.info('Step 2: Setting up database...');
  const db = createDatabase(DATABASE_PATH);
  const tradeRepo = new TradeRepository(db);
  const stateRepo = new StateRepository(db);

  // Check if this is a restart by reading agent state
  let runCount = 1;
  const existingRunCount = stateRepo.getState('test_run_count');
  if (existingRunCount) {
    runCount = parseInt(existingRunCount, 10) + 1;
  }
  stateRepo.setState('test_run_count', runCount.toString());
  log.info({ runCount }, 'Run count updated');

  // Verify persistence from previous runs
  if (runCount > 1) {
    const previousTrades = tradeRepo.getRecent(5);
    log.info({
      previousTradeCount: previousTrades.length,
      signatures: previousTrades.map(t => t.signature.slice(0, 16) + '...')
    }, 'Previous trades retrieved from database');
  }

  // Step 3: Check balance and request airdrop if needed
  log.info('Step 3: Connecting to Solana devnet...');
  const connection = new Connection(DEVNET_URL, 'confirmed');

  let balance = await connection.getBalance(keypair.publicKey);
  log.info({ balance: balance / LAMPORTS_PER_SOL }, 'Current balance (SOL)');

  if (balance < 0.1 * LAMPORTS_PER_SOL && !MOCK_MODE) {
    log.info('Balance low, requesting airdrop...');
    try {
      const airdropSignature = await connection.requestAirdrop(
        keypair.publicKey,
        LAMPORTS_PER_SOL // Request 1 SOL
      );
      log.info({ signature: airdropSignature }, 'Airdrop requested');

      // Wait for confirmation
      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
      await connection.confirmTransaction({
        signature: airdropSignature,
        blockhash,
        lastValidBlockHeight,
      });
      log.info('Airdrop confirmed');

      // Update balance
      balance = await connection.getBalance(keypair.publicKey);
      log.info({ balance: balance / LAMPORTS_PER_SOL }, 'Updated balance (SOL)');
    } catch (error) {
      // Airdrop may fail due to rate limits - continue with existing balance
      log.warn({ error: (error as Error).message }, 'Airdrop failed (may be rate limited)');
      if (balance === 0) {
        log.warn('===========================================');
        log.warn('AIRDROP RATE LIMITED');
        log.warn('===========================================');
        log.warn(`Fund this wallet manually using the Solana Faucet:`);
        log.warn(`https://faucet.solana.com`);
        log.warn(`Wallet address: ${keypair.publicKey.toBase58()}`);
        log.warn('Or run with --mock flag to test without real transactions.');
        db.close();
        return;
      }
    }
  }

  // Step 4: Create and sign test transaction
  log.info('Step 4: Creating test transaction...');

  let signature: string;

  if (MOCK_MODE) {
    // Mock mode: simulate a transaction for testing without real devnet funds
    log.info('[MOCK MODE] Simulating transaction...');

    // Create a deterministic mock signature based on run count
    signature = `mock_tx_${Date.now()}_run${runCount}_${keypair.publicKey.toBase58().slice(0, 8)}`;

    // Verify we have the keypair by checking it has a valid secret key
    // (In real mode, the sendAndConfirmTransaction call would prove signing capability)
    if (!keypair.secretKey || keypair.secretKey.length !== 64) {
      throw new Error('Keypair does not have valid secret key');
    }
    log.info('[MOCK MODE] Keypair verified (has valid secret key)');
    log.info({ signature }, '[MOCK MODE] Simulated transaction signature');
  } else {
    // Real mode: submit actual transaction to devnet
    // Self-transfer (send small amount to self)
    const transferAmount = 0.001 * LAMPORTS_PER_SOL;

    const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: keypair.publicKey,
        toPubkey: keypair.publicKey, // Self-transfer
        lamports: transferAmount,
      })
    );

    log.info('Signing and submitting transaction...');
    try {
      signature = await sendAndConfirmTransaction(connection, transaction, [keypair]);
      log.info({ signature }, 'Transaction confirmed on devnet');
    } catch (error) {
      log.error({ error: (error as Error).message }, 'Transaction failed');
      db.close();
      throw error;
    }
  }

  // Step 5: Record trade in database
  log.info('Step 5: Recording trade in database...');
  const trade = {
    signature,
    timestamp: Math.floor(Date.now() / 1000),
    type: 'BUY' as const,
    tokenMint: '11111111111111111111111111111111', // Native SOL (system program)
    tokenSymbol: 'SOL',
    amountSol: 0.001,
    amountTokens: 0.001,
    pricePerToken: 1,
    feeSol: 0.000005, // Approximate fee
    metadata: {
      test: true,
      runCount,
      note: 'Devnet integration test self-transfer'
    }
  };

  tradeRepo.insert(trade);
  log.info({ signature: signature.slice(0, 16) + '...' }, 'Trade recorded in database');

  // Step 6: Verify state persistence
  log.info('Step 6: Verifying state persistence...');
  const retrievedTrade = tradeRepo.getBySignature(signature);
  if (!retrievedTrade) {
    throw new Error('Failed to retrieve trade from database');
  }
  log.info('Trade verified in database');

  // Count total trades
  const allTrades = tradeRepo.getRecent(100);
  log.info({ totalTrades: allTrades.length }, 'Total trades in database');

  // Step 7: Summary
  log.info('===========================================');
  log.info('Integration Test Complete');
  log.info('===========================================');
  log.info({
    publicKey: keypair.publicKey.toBase58(),
    balance: balance / LAMPORTS_PER_SOL,
    runCount,
    totalTrades: allTrades.length,
    latestSignature: signature,
  }, 'Test summary');

  if (!MOCK_MODE) {
    log.info('Verify transaction on Solana Explorer:');
    log.info(`https://explorer.solana.com/tx/${signature}?cluster=devnet`);
  } else {
    log.info('[MOCK MODE] No real transaction to verify on explorer.');
    log.info('[MOCK MODE] Run without --mock flag with funded wallet for real transaction.');
  }

  if (runCount === 1) {
    log.info('');
    log.info('Run this test again to verify persistence across restarts.');
    log.info('The run count should increment and previous trades should be visible.');
  }

  // Close database
  db.close();
  log.info('Database closed');
}

// Main execution
const scriptPath = new URL(import.meta.url).pathname;
const normalizedScriptPath = scriptPath.replace(/^\/([A-Z]:)/i, '$1');
const normalizedArgv = process.argv[1]?.replace(/\\/g, '/');

if (normalizedArgv?.includes('test-devnet') || process.argv[1]?.includes('test-devnet')) {
  runDevnetTest().catch((error) => {
    console.error('Test failed:', error);
    process.exit(1);
  });
}
</file>

<file path="src/trading/scoring-engine.ts">
/**
 * Scoring Engine - Centralized token scoring logic
 * Decouples gating decisions from TradingEngine
 */

import { TokenSafetyAnalyzer } from '../analysis/token-safety.js';
import type { TokenSafetyResult } from '../analysis/types.js';
import { SmartMoneyTracker } from '../analysis/smart-money.js';
import { HeliusClient } from '../api/helius.js';
import { logger } from '../lib/logger.js';

/**
 * Known LP pool program addresses to exclude from holder concentration
 */
const LP_PROGRAM_ADDRESSES = new Set([
  '5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1', // Raydium AMM
  '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8', // Raydium V4
  'CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK', // Raydium CLMM
  '6EF8rrecthR5Dkzon8Nwu2RMhZvZP9vhU8uLxWv2fCmY', // Pump.fun Bonding Curve
  'TSWAPaqyCSx2KABk68Shruf4rp7CZccht1XmZaMdY', // Tensor TSWAP
]);

/**
 * Token score breakdown
 */
export interface TokenScore {
  total: number;        // 0-100 overall score
  safety: number;       // 0-40 pts - Token safety (no mint/freeze auth)
  smartMoney: number;   // 0-30 pts - Smart money presence
  liquidity: number;    // 0-20 pts - Liquidity depth
  momentum: number;     // 0-10 pts - Price/volume momentum
  flags: string[];      // Human-readable scoring breakdown
  details: {
    isSafe: boolean;
    smartMoneyCount: number;
    liquidityUsd: number;
    topHolderPercent: number;
    isConcentrated: boolean;
  };
}

export interface ScoringConfig {
  minScoreToTrade: number;  // Minimum score to approve trade (default: 50)
  safetyWeight: number;     // Max points for safety (default: 40)
  smartMoneyWeight: number; // Max points for smart money (default: 30)
  liquidityWeight: number;  // Max points for liquidity (default: 20)
  momentumWeight: number;   // Max points for momentum (default: 10)
}

const DEFAULT_SCORING_CONFIG: ScoringConfig = {
  minScoreToTrade: 50,
  safetyWeight: 40,
  smartMoneyWeight: 30,
  liquidityWeight: 20,
  momentumWeight: 10,
};

/**
 * Scoring Engine
 * Calculates a 0-100 score for any token to determine tradability
 */
export class ScoringEngine {
  private config: ScoringConfig;
  private tokenSafety: TokenSafetyAnalyzer;
  private smartMoney: SmartMoneyTracker;
  private helius: HeliusClient;

  constructor(
    tokenSafety: TokenSafetyAnalyzer,
    smartMoney: SmartMoneyTracker,
    helius: HeliusClient,
    config?: Partial<ScoringConfig>
  ) {
    this.config = { ...DEFAULT_SCORING_CONFIG, ...config };
    this.tokenSafety = tokenSafety;
    this.smartMoney = smartMoney;
    this.helius = helius;
  }

  /**
   * Calculate comprehensive score for a token
   */
  async calculateScore(
    mint: string,
    metadata?: { liquidity?: number; marketCapSol?: number; priceChange1h?: number }
  ): Promise<TokenScore> {
    const flags: string[] = [];
    let safetyScore = 0;
    let smartMoneyScore = 0;
    let liquidityScore = 0;
    let momentumScore = 0;

    // 1. Safety Analysis (0-40 pts)
    const safetyResult = await this.tokenSafety.analyze(mint);
    if (safetyResult.isSafe) {
      safetyScore = this.config.safetyWeight;
      flags.push(`‚úÖ Safe token (+${safetyScore})`);
    } else {
      // Partial credit if only minor risks
      const criticalRisks = safetyResult.risks.filter(r => 
        r === 'MINT_AUTHORITY_ACTIVE' || r === 'FREEZE_AUTHORITY_ACTIVE'
      );
      if (criticalRisks.length === 0) {
        safetyScore = Math.floor(this.config.safetyWeight * 0.5);
        flags.push(`‚ö†Ô∏è Minor risks (+${safetyScore}): ${safetyResult.risks.join(', ')}`);
      } else {
        flags.push(`‚ùå Critical risks: ${criticalRisks.join(', ')}`);
      }
    }

    // 2. Smart Money Detection (0-30 pts)
    const smartMoneyResult = await this.countSmartMoney(mint);
    const smCount = smartMoneyResult.count;
    if (smCount >= 5) {
      smartMoneyScore = this.config.smartMoneyWeight;
      flags.push(`üêã Strong smart money (${smCount} wallets) (+${smartMoneyScore})`);
    } else if (smCount >= 3) {
      smartMoneyScore = Math.floor(this.config.smartMoneyWeight * 0.75);
      flags.push(`üêã Good smart money (${smCount} wallets) (+${smartMoneyScore})`);
    } else if (smCount >= 1) {
      smartMoneyScore = Math.floor(this.config.smartMoneyWeight * 0.5);
      flags.push(`üêã Some smart money (${smCount} wallets) (+${smartMoneyScore})`);
    } else {
      // No smart money - still allow trade if other signals are strong
      flags.push(`‚ö†Ô∏è No smart money detected`);
    }

    // 3. Liquidity Score (0-20 pts)
    const liquidityUsd = metadata?.liquidity || 0;
    if (liquidityUsd >= 50000) {
      liquidityScore = this.config.liquidityWeight;
      flags.push(`üíß Excellent liquidity ($${(liquidityUsd / 1000).toFixed(0)}k) (+${liquidityScore})`);
    } else if (liquidityUsd >= 20000) {
      liquidityScore = Math.floor(this.config.liquidityWeight * 0.75);
      flags.push(`üíß Good liquidity ($${(liquidityUsd / 1000).toFixed(0)}k) (+${liquidityScore})`);
    } else if (liquidityUsd >= 10000) {
      liquidityScore = Math.floor(this.config.liquidityWeight * 0.5);
      flags.push(`üíß Moderate liquidity ($${(liquidityUsd / 1000).toFixed(0)}k) (+${liquidityScore})`);
    } else if (liquidityUsd >= 5000) {
      liquidityScore = Math.floor(this.config.liquidityWeight * 0.25);
      flags.push(`‚ö†Ô∏è Low liquidity ($${(liquidityUsd / 1000).toFixed(0)}k) (+${liquidityScore})`);
    } else {
      flags.push(`‚ùå Insufficient liquidity ($${liquidityUsd.toFixed(0)})`);
    }

    // 4. Momentum Score (0-10 pts)
    const priceChange = metadata?.priceChange1h || 0;
    if (priceChange > 20 && priceChange < 100) {
      momentumScore = this.config.momentumWeight;
      flags.push(`üìà Strong momentum (+${priceChange.toFixed(0)}%) (+${momentumScore})`);
    } else if (priceChange > 5) {
      momentumScore = Math.floor(this.config.momentumWeight * 0.5);
      flags.push(`üìà Positive momentum (+${priceChange.toFixed(0)}%) (+${momentumScore})`);
    } else if (priceChange < -20) {
      flags.push(`üìâ Dumping (${priceChange.toFixed(0)}%)`);
    }

    // 5. Holder Concentration Check (can reduce score)
    const concentration = await this.checkHolderConcentration(mint);
    if (concentration.isConcentrated) {
      // Reduce total by 20% for concentrated holdings
      flags.push(`‚ö†Ô∏è Concentrated holdings (top holder: ${concentration.topHolderPercent.toFixed(1)}%)`);
    }

    // Calculate total
    let total = safetyScore + smartMoneyScore + liquidityScore + momentumScore;
    if (concentration.isConcentrated) {
      total = Math.floor(total * 0.8);
      flags.push(`üìä Score reduced 20% due to concentration`);
    }

    logger.info({
      mint,
      total,
      breakdown: { safetyScore, smartMoneyScore, liquidityScore, momentumScore },
    }, 'Token scored');

    return {
      total,
      safety: safetyScore,
      smartMoney: smartMoneyScore,
      liquidity: liquidityScore,
      momentum: momentumScore,
      flags,
      details: {
        isSafe: safetyResult.isSafe,
        smartMoneyCount: smCount,
        liquidityUsd,
        topHolderPercent: concentration.topHolderPercent,
        isConcentrated: concentration.isConcentrated,
      },
    };
  }

  /**
   * Count smart money wallets holding this token
   */
  private async countSmartMoney(mint: string): Promise<{ count: number; wallets: string[] }> {
    try {
      const response = await this.helius.getTokenHolders(mint, 20);
      if (!response.holders || response.holders.length === 0) {
        return { count: 0, wallets: [] };
      }

      const smartWallets: string[] = [];
      for (const holder of response.holders) {
        const isSmartMoney = await this.smartMoney.isSmartMoney(holder.owner);
        if (isSmartMoney) {
          smartWallets.push(holder.owner);
        }
      }

      return { count: smartWallets.length, wallets: smartWallets };
    } catch (error) {
      logger.warn({ mint, error }, 'Failed to count smart money');
      return { count: 0, wallets: [] };
    }
  }

  /**
   * Check holder concentration (excluding LP pools)
   */
  private async checkHolderConcentration(mint: string): Promise<{
    topHolderPercent: number;
    top10Percent: number;
    isConcentrated: boolean;
  }> {
    try {
      const response = await this.helius.getTokenHolders(mint, 20);
      if (!response.holders || response.holders.length === 0) {
        return { topHolderPercent: 0, top10Percent: 0, isConcentrated: false };
      }

      // Filter out LP program addresses
      const nonLpHolders = response.holders.filter(h => !LP_PROGRAM_ADDRESSES.has(h.owner));

      if (nonLpHolders.length === 0) {
        return { topHolderPercent: 0, top10Percent: 0, isConcentrated: false };
      }

      // Calculate percentages
      const totalSupply = nonLpHolders.reduce((sum, h) => sum + h.amount, 0);
      const topHolderPercent = totalSupply > 0 ? (nonLpHolders[0].amount / totalSupply) * 100 : 0;
      const top10Total = nonLpHolders.slice(0, 10).reduce((sum, h) => sum + h.amount, 0);
      const top10Percent = totalSupply > 0 ? (top10Total / totalSupply) * 100 : 0;

      // Concentrated if top holder > 15% OR top 10 > 50%
      const isConcentrated = topHolderPercent > 15 || top10Percent > 50;

      return { topHolderPercent, top10Percent, isConcentrated };
    } catch (error) {
      logger.warn({ mint, error }, 'Failed to check holder concentration');
      return { topHolderPercent: 0, top10Percent: 0, isConcentrated: false };
    }
  }

  /**
   * Quick check if token meets minimum score threshold
   */
  async meetsMinimumScore(mint: string, metadata?: { liquidity?: number }): Promise<boolean> {
    const score = await this.calculateScore(mint, metadata);
    return score.total >= this.config.minScoreToTrade;
  }
}
</file>

<file path="src/trading/transaction-parser.ts">
/**
 * Transaction Parser - Extracts actual token amounts from confirmed transactions
 */

import { Connection, PublicKey, ParsedTransactionWithMeta } from '@solana/web3.js';
import { logger } from '../lib/logger.js';

/**
 * Parsed trade result with actual amounts
 */
export interface ParsedTradeResult {
  signature: string;
  success: boolean;
  tokenMint: string;
  tokenAmount: number;      // Actual tokens received/sent
  solAmount: number;        // Actual SOL spent/received
  pricePerToken: number;    // SOL per token
  fee: number;              // Transaction fee in SOL
  error?: string;
}

/**
 * Transaction Parser
 *
 * Parses confirmed Solana transactions to extract actual trade amounts.
 * This is critical for accurate P&L tracking since slippage means
 * requested amounts != actual amounts.
 */
export class TransactionParser {
  private connection: Connection;

  constructor(connection: Connection) {
    this.connection = connection;
  }

  /**
   * Parse a trade transaction to get actual amounts
   *
   * @param signature - Transaction signature
   * @param walletAddress - Our wallet address
   * @param expectedTokenMint - The token we expected to trade
   * @param tradeType - 'buy' or 'sell'
   */
  async parseTradeTransaction(
    signature: string,
    walletAddress: string,
    expectedTokenMint: string,
    tradeType: 'buy' | 'sell'
  ): Promise<ParsedTradeResult> {
    logger.debug({ signature, tradeType }, 'Parsing trade transaction');

    try {
      // Fetch the parsed transaction
      const tx = await this.connection.getParsedTransaction(signature, {
        maxSupportedTransactionVersion: 0,
        commitment: 'confirmed',
      });

      if (!tx) {
        return {
          signature,
          success: false,
          tokenMint: expectedTokenMint,
          tokenAmount: 0,
          solAmount: 0,
          pricePerToken: 0,
          fee: 0,
          error: 'Transaction not found',
        };
      }

      if (tx.meta?.err) {
        return {
          signature,
          success: false,
          tokenMint: expectedTokenMint,
          tokenAmount: 0,
          solAmount: 0,
          pricePerToken: 0,
          fee: tx.meta.fee / 1e9,
          error: `Transaction failed: ${JSON.stringify(tx.meta.err)}`,
        };
      }

      // Extract balance changes
      const balanceChanges = this.extractBalanceChanges(tx, walletAddress);

      // Find the token balance change
      const tokenChange = balanceChanges.tokens.find(
        t => t.mint.toLowerCase() === expectedTokenMint.toLowerCase()
      );

      const solChange = balanceChanges.sol;
      const fee = (tx.meta?.fee || 0) / 1e9;

      // Calculate amounts based on trade type
      let tokenAmount = 0;
      let solAmount = 0;

      if (tradeType === 'buy') {
        // For buy: we spend SOL, receive tokens
        // solChange is negative (we spent SOL), fee is already included in the balance delta
        tokenAmount = tokenChange ? Math.abs(tokenChange.change) : 0;
        solAmount = Math.abs(solChange); // Balance delta already excludes fee paid
      } else {
        // For sell: we spend tokens, receive SOL
        // solChange = (PostBalance - PreBalance) = Net Proceeds (already minus fee)
        // To get gross proceeds for P&L: add fee back
        tokenAmount = tokenChange ? Math.abs(tokenChange.change) : 0;
        solAmount = Math.abs(solChange) + fee; // Gross proceeds = Net + Fee
      }

      // Calculate price per token
      const pricePerToken = tokenAmount > 0 ? solAmount / tokenAmount : 0;

      logger.info({
        signature,
        tradeType,
        tokenAmount,
        solAmount,
        pricePerToken,
        fee,
      }, 'Trade transaction parsed successfully');

      return {
        signature,
        success: true,
        tokenMint: expectedTokenMint,
        tokenAmount,
        solAmount,
        pricePerToken,
        fee,
      };
    } catch (error) {
      logger.error({ signature, error }, 'Failed to parse trade transaction');
      return {
        signature,
        success: false,
        tokenMint: expectedTokenMint,
        tokenAmount: 0,
        solAmount: 0,
        pricePerToken: 0,
        fee: 0,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Extract balance changes from a parsed transaction
   */
  private extractBalanceChanges(
    tx: ParsedTransactionWithMeta,
    walletAddress: string
  ): {
    sol: number;
    tokens: Array<{ mint: string; change: number }>;
  } {
    const result = {
      sol: 0,
      tokens: [] as Array<{ mint: string; change: number }>,
    };

    if (!tx.meta) return result;

    // Find wallet index in account keys
    const accountKeys = tx.transaction.message.accountKeys;
    const walletIndex = accountKeys.findIndex(
      key => key.pubkey.toBase58() === walletAddress
    );

    if (walletIndex === -1) {
      logger.warn({ walletAddress }, 'Wallet not found in transaction accounts');
      return result;
    }

    // Calculate SOL change
    const preBalance = tx.meta.preBalances[walletIndex] || 0;
    const postBalance = tx.meta.postBalances[walletIndex] || 0;
    result.sol = (postBalance - preBalance) / 1e9; // Convert lamports to SOL

    // Calculate token balance changes
    const preTokenBalances = tx.meta.preTokenBalances || [];
    const postTokenBalances = tx.meta.postTokenBalances || [];

    // Create a map of pre-balances
    const preBalanceMap = new Map<string, number>();
    for (const balance of preTokenBalances) {
      if (balance.owner === walletAddress) {
        const amount = parseFloat(balance.uiTokenAmount.uiAmountString || '0');
        preBalanceMap.set(balance.mint, amount);
      }
    }

    // Calculate changes from post-balances
    for (const balance of postTokenBalances) {
      if (balance.owner === walletAddress) {
        const postAmount = parseFloat(balance.uiTokenAmount.uiAmountString || '0');
        const preAmount = preBalanceMap.get(balance.mint) || 0;
        const change = postAmount - preAmount;

        if (change !== 0) {
          result.tokens.push({
            mint: balance.mint,
            change,
          });
        }
      }
    }

    // Check for tokens that existed before but not after (full sells)
    for (const [mint, preAmount] of preBalanceMap) {
      const hasPostBalance = postTokenBalances.some(
        b => b.mint === mint && b.owner === walletAddress
      );
      if (!hasPostBalance && preAmount > 0) {
        result.tokens.push({
          mint,
          change: -preAmount,
        });
      }
    }

    return result;
  }

  /**
   * Wait for transaction confirmation and parse it
   * Useful when you want to ensure the transaction is finalized before parsing
   */
  async waitAndParse(
    signature: string,
    walletAddress: string,
    expectedTokenMint: string,
    tradeType: 'buy' | 'sell',
    maxWaitMs: number = 30000
  ): Promise<ParsedTradeResult> {
    const startTime = Date.now();
    const pollInterval = 2000; // 2 seconds

    while (Date.now() - startTime < maxWaitMs) {
      const result = await this.parseTradeTransaction(
        signature,
        walletAddress,
        expectedTokenMint,
        tradeType
      );

      if (result.success || result.error?.includes('failed')) {
        return result;
      }

      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }

    return {
      signature,
      success: false,
      tokenMint: expectedTokenMint,
      tokenAmount: 0,
      solAmount: 0,
      pricePerToken: 0,
      fee: 0,
      error: 'Transaction parsing timed out',
    };
  }
}
</file>

<file path="test-keystore.json">
{
  "version": 1,
  "publicKey": "6VUVLM8SATEW7Ntq9mKGdADLrSHEewVYNT3WEu3qTCav",
  "encryptedPrivateKey": {
    "salt": "oB1XUGDJYOfQ6BIREH7E03qtnzVP1HeqJpvqCsRI/pNoggwn63OCqQ8N76a/ukxbaLG++ed1wKLib95Uji+n2Q==",
    "iv": "uzC3LOPuxOrUih45zZ9N3A==",
    "authTag": "x326DhQrSvOwJvJWmR3xUA==",
    "encrypted": "Sse7Q3xDeWBIW65G32EvSSdUuqf41CW6lfp1kBaum+45y35IXagm72RWz09Ll6umvlXCC3rqNs9dlqRwTOLzvbtuYAHt2Q15ql6GLsYuBIy/Mz3rnBovWw=="
  },
  "createdAt": "2026-01-20T17:14:42.991Z"
}
</file>

<file path="tsc_output.txt">
src/trading/copy-trader.ts(173,33): error TS2339: Property 'connection' does not exist on type 'CopyTrader'.
src/trading/copy-trader.ts(186,49): error TS7006: Parameter 'k' implicitly has an 'any' type.
</file>

<file path="tsc-error.txt">
src/trading/trading-engine.ts(10,15): error TS2305: Module '"../analysis/types.js"' has no exported member 'SafetyAnalysis'.
src/trading/trading-engine.ts(61,15): error TS2709: Cannot use namespace 'Database' as a type.
src/trading/trading-engine.ts(68,9): error TS2709: Cannot use namespace 'Database' as a type.
src/trading/trading-engine.ts(92,24): error TS2339: Property 'isHoneypot' does not exist on type 'TokenSafetyResult'.
src/trading/trading-engine.ts(103,24): error TS2339: Property 'freezeAuthority' does not exist on type 'TokenSafetyResult'.
src/trading/trading-engine.ts(114,24): error TS2339: Property 'mintAuthority' does not exist on type 'TokenSafetyResult'.
src/trading/trading-engine.ts(125,24): error TS2339: Property 'top10Concentration' does not exist on type 'TokenSafetyResult'.
src/trading/trading-engine.ts(137,24): error TS2339: Property 'top10Concentration' does not exist on type 'TokenSafetyResult'.
src/trading/trading-engine.ts(142,24): error TS2339: Property 'holderCount' does not exist on type 'TokenSafetyResult'.
src/trading/trading-engine.ts(148,39): error TS2339: Property 'topHolders' does not exist on type 'TokenSafetyResult'.
src/trading/trading-engine.ts(346,42): error TS7006: Parameter 't' implicitly has an 'any' type.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "strict": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path=".github/copilot-instructions.md">
# $SCHIZO Agent - AI Coding Instructions

## Project Overview
Paranoid AI trading agent for Solana memecoin sniping with real-time personality and entertainment mode. Built as TypeScript ES modules with SQLite persistence, real-time WebSocket streaming, and Claude AI integration.

## Architecture

### Core Pipeline Flowchart

```mermaid
flowchart TB
    Start([TradingLoop Start<br/>Every 10s]) --> CheckQueue{Trending Token<br/>Queue Empty?}
    
    CheckQueue -->|Empty| ScanAPI[Scan Birdeye API<br/>Get Trending Tokens]
    ScanAPI --> QueueTokens[Add to Queue]
    QueueTokens --> CheckQueue
    
    CheckQueue -->|Has Tokens| DequeueToken[Get Next Token<br/>from Queue]
    DequeueToken --> CheckSeen{Already<br/>Analyzed?}
    
    CheckSeen -->|Yes - in seenTokens| Skip[Skip Token]
    CheckSeen -->|No - New Token| Discovery[üîç DISCOVERY<br/>Emit EVENT]
    
    Discovery --> SafetyCheck[TokenSafetyAnalyzer<br/>Check Honeypot Risks]
    SafetyCheck --> CacheCheck{Cache<br/>Hit?}
    CacheCheck -->|Yes| UseCached[Use Cached Data]
    CacheCheck -->|No| HeliusAPI[Helius DAS API<br/>Get Asset + Holders]
    HeliusAPI --> StoreCache[Store in analysisCache<br/>30min TTL]
    StoreCache --> UseCached
    
    UseCached --> RiskCheck{Token<br/>Safe?}
    RiskCheck -->|Unsafe| Reject[‚ùå Reject Token<br/>Emit ANALYSIS event]
    RiskCheck -->|Safe| SmartMoney[SmartMoneyTracker<br/>Check Holders]
    
    SmartMoney --> GetWallets[Get Top Holders<br/>from Helius]
    GetWallets --> AnalyzeWallets[WalletAnalyzer<br/>Parse P&L History]
    AnalyzeWallets --> ScoreSmart[Score Smart Money<br/>>5 SOL P&L<br/>>60% Win Rate]
    
    ScoreSmart --> Decision[EntertainmentMode<br/>shouldTrade?]
    Decision --> CalcScore[Calculate Score:<br/>+10 Smart Money<br/>+10 Holder Dist<br/>+5 Momentum]
    CalcScore --> ThresholdCheck{Score >= 25<br/>+ Random<br/>Weighted?}
    
    ThresholdCheck -->|No| Skip2[Skip Trade<br/>Emit DECISION event]
    ThresholdCheck -->|Yes| Execute[üöÄ TradingEngine<br/>Execute Buy]
    
    Execute --> CheckGrad{Token<br/>Graduated?}
    CheckGrad -->|No| PumpFun[PumpPortal Client<br/>Buy on pump.fun]
    CheckGrad -->|Yes| Jupiter[Jupiter Client<br/>Swap on DEX]
    
    PumpFun --> StoreTrade[Store in db.trades]
    Jupiter --> StoreTrade
    StoreTrade --> Commentary[CommentarySystem<br/>Queue TRADE_RESULT]
    
    Commentary --> Priority[Priority Queue<br/>15s Min Gap]
    Priority --> ClaudeGen{Claude<br/>Available?}
    ClaudeGen -->|Yes| Generate[Generate AI Speech]
    ClaudeGen -->|No| Skip3[Skip Commentary]
    Generate --> Broadcast[Emit COMMENTARY_READY]
    
    Broadcast --> WSBroadcast[WebSocket Server<br/>Broadcast to Dashboard]
    Skip --> WSBroadcast
    Skip2 --> WSBroadcast
    Skip3 --> WSBroadcast
    Reject --> WSBroadcast
    
    WSBroadcast --> TimePressure{60s Since<br/>Last Action?}
    TimePressure -->|Yes| RestlessEvent[Emit TIME_PRESSURE<br/>Commentary]
    TimePressure -->|No| End
    RestlessEvent --> End([End Cycle<br/>Wait 10s])
    
    style Discovery fill:#4CAF50,color:white
    style Execute fill:#2196F3,color:white
    style Reject fill:#f44336,color:white
    style Broadcast fill:#FF9800,color:white
    style WSBroadcast fill:#9C27B0,color:white
```

### Core Pipeline (4 Phases)
1. **Detection** ‚Üí PumpPortal WebSocket or Birdeye trending API discovers new tokens
2. **Analysis** ‚Üí `TokenSafetyAnalyzer` checks on-chain risks, `SmartMoneyTracker` evaluates wallet performance
3. **Decision** ‚Üí `EntertainmentMode` makes trade decisions (ENTERTAINMENT risk profile for frequent degen trades)
4. **Execution** ‚Üí `TradingEngine` executes via PumpPortal (pump.fun) or Jupiter (graduated tokens)

### Event-Driven System
All components communicate via `agentEvents` singleton ([src/events/emitter.ts](src/events/emitter.ts)):
- Emit events: `agentEvents.emit({ type: 'TOKEN_ANALYZED', data: {...} })`
- Listen: `agentEvents.on('TRADE_EXECUTED', handler)`
- WebSocket server auto-broadcasts events to dashboard ([src/server/websocket.ts](src/server/websocket.ts))

### Data Flow
```
PumpPortal/Birdeye ‚Üí TradingLoop.scanForOpportunities() ‚Üí TokenSafetyAnalyzer
‚Üí SmartMoneyTracker ‚Üí EntertainmentMode.shouldTrade() ‚Üí TradingEngine.executeBuy()
‚Üí Database.trades ‚Üí CommentarySystem (queued) ‚Üí agentEvents ‚Üí WebSocket ‚Üí Dashboard
```

### Database Pattern
SQLite with repository pattern ([src/db/database-with-repos.ts](src/db/database-with-repos.ts)):
```typescript
const db = createDatabaseWithRepositories(rawDb);
db.trades.insert({ signature, tokenMint, type: 'BUY', ... });
db.analysisCache.get('tokenMint', 'holderDistribution');
db.state.set('lastTrendingScan', Date.now());
```

## Key Components

### TradingLoop ([src/trading/trading-loop.ts](src/trading/trading-loop.ts))
Main orchestrator - runs every 10s, processes trending tokens from Birdeye API queue:
- `scanForOpportunities()` - Checks Birdeye trending API (respects rate limits)
- `processNextTrendingToken()` - Analyzes one token from queue per cycle
- `handleTimePressure()` - Emits restless commentary if no action for 60s
- **Deduplication**: `seenTokens` Map tracks analyzed tokens with 5min expiry

### TokenSafetyAnalyzer ([src/analysis/token-safety.ts](src/analysis/token-safety.ts))
Checks on-chain honeypot risks via Helius DAS API:
- Mint authority, freeze authority, Token-2022 extensions
- Holder distribution via `checkHolderDistribution()` (top holder %, insider concentration)
- **Caching**: Uses `db.analysisCache` with 30min expiry to reduce API calls

### SmartMoneyTracker ([src/analysis/smart-money.ts](src/analysis/smart-money.ts))
Identifies profitable wallets (>5 SOL total P&L, >60% win rate):
- Parses Helius transaction history via `WalletAnalyzer.analyzeWallet()`
- Stores in `smart_wallets` table with performance metrics
- Used by `EntertainmentMode` to boost scoring (+10 points per smart wallet)

### EntertainmentMode ([src/trading/entertainment-mode.ts](src/trading/entertainment-mode.ts))
Frequent degen trading decisions (0.01-0.02 SOL per trade):
- Scoring: Smart money +10, good holder dist +10, momentum +5, min 25 points to trade
- Weighted randomness with bias toward high scores (60-70%+ pass threshold)
- **Risk profile**: ENTERTAINMENT (lowest position sizes, highest frequency)

### CommentarySystem ([src/personality/commentary-system.ts](src/personality/commentary-system.ts))
Priority queue for AI speech timing (15-20s min gap between commentary):
- Beats: `TRADE_RESULT` (priority 100) > `DECISION` (80) > `ANALYSIS` (60) > `DISCOVERY` (40)
- Context-aware prompts via `prompts.ts` (paranoid style, time pressure, shill analysis)
- Expires stale commentary after 30s to stay relevant

## Critical Workflows

### Build & Run
```bash
npm run dev        # Direct TS execution via tsx (development)
npm run build      # Compile to dist/ (production)
npm start          # Run compiled JS from dist/
```

### Environment Setup
Required in `.env`:
```bash
HELIUS_API_KEY=        # On-chain data (free tier: 10 req/s)
ANTHROPIC_API_KEY=     # Claude personality (optional)
BIRDEYE_API_KEY=       # Trending tokens (free tier)
WALLET_KEYSTORE=       # Path to encrypted keystore file
WALLET_PASSWORD=       # Keystore decryption password
```

### Keystore Management
Encrypted wallet storage ([src/keystore/](src/keystore/)):
```typescript
import { createKeystore, saveKeystore, loadKeystore } from './keystore/index.js';

// Create new wallet
const { keypair, keystore } = createKeystore('password');
saveKeystore(keystore, 'wallet.keystore.json');

// Load existing wallet
const keypair = loadKeystore('wallet.keystore.json', 'password');
```

### Testing Trades
Use `src/test-devnet.ts` for devnet testing (imported trades for P&L display):
```typescript
// Historical trades are pre-populated in index.ts for dashboard demo
const historicalBuy = { signature: '...', type: 'BUY', ... };
db.trades.insert(historicalBuy);
```

## Conventions & Patterns

### ES Modules
All imports require `.js` extension (resolved to `.ts` by tsx):
```typescript
import { logger } from './lib/logger.js';  // NOT './lib/logger'
```

### Logging
Structured JSON logging via Pino ([src/lib/logger.ts](src/lib/logger.ts)):
```typescript
import { createLogger } from './lib/logger.js';
const log = createLogger('module-name');
log.info({ tokenMint, score }, 'Token scored');
log.error({ error }, 'Failed to fetch data');
```

### Error Handling
Circuit breakers via Opossum for external APIs ([src/api/helius.ts](src/api/helius.ts)):
- Auto-retry with exponential backoff (p-retry)
- Rate limiting via Bottleneck (respects API tier limits)
- Graceful degradation: missing Claude/Jupiter disables features but doesn't crash

### Type Safety
Strict TypeScript with shared types:
- Trading types: [src/trading/types.ts](src/trading/types.ts) (`TradeParams`, `RiskProfile`)
- Analysis types: [src/analysis/types.ts](src/analysis/types.ts) (`TokenRisk`, `GetAssetResponse`)
- Event types: [src/events/types.ts](src/events/types.ts) (`AgentEvent`)

### API Integration
Dual token lifecycle support:
- **pump.fun tokens**: PumpPortal WebSocket + REST ([src/trading/pumpportal-client.ts](src/trading/pumpportal-client.ts))
- **Graduated tokens**: Jupiter swap API ([src/api/jupiter.ts](src/api/jupiter.ts))
- Market data: Birdeye (trending), DexScreener (pairs), GeckoTerminal (backup)

## Orphaned Code
These files exist but are **NOT integrated** into the pipeline ([docs/analysis-architecture.md](docs/analysis-architecture.md)):
- [src/analysis/bundle-detector.ts](src/analysis/bundle-detector.ts) - Would detect coordinated buys (352 lines)
- [src/analysis/momentum-scanner.ts](src/analysis/momentum-scanner.ts) - Would check buy pressure (444 lines)
- [src/analysis/learning-engine.ts](src/analysis/learning-engine.ts) - Would adjust scoring weights (439 lines)

**Do not reference these in new features** unless explicitly integrating them into `TradingLoop` or `EntertainmentMode`.

## Frontend Dashboard
Vanilla JS WebSocket client ([public/app.js](public/app.js)):
- Connects to `ws://localhost:8080`
- Auto-reconnect with exponential backoff
- Real-time trade updates, P&L calculation, position display
- 3D particle system ([public/schizo-3d.js](public/schizo-3d.js)) for visual interest

## Common Pitfalls
1. **Rate limits**: Helius free tier = 10 req/s. Use `db.analysisCache` for holder distribution (30min TTL)
2. **Token lifecycle**: Check if graduated before using PumpPortal (will fail on Raydium tokens)
3. **Event timing**: Commentary has 15s min gap - don't emit `COMMENTARY_READY` for every analysis
4. **Memory leaks**: Clear `seenTokens` Map periodically (5min expiry in TradingLoop)
5. **Database locking**: SQLite is single-writer - avoid concurrent writes from multiple instances

## External APIs
Reference [CLAUDE.md](CLAUDE.md) for full API docs (auto-loaded in Claude Code sessions):
- Helius SDK methods, rate limits, transaction parsing
- Jupiter quote/swap flow, token info endpoint
- Birdeye trending API, DexScreener pair data
- PumpPortal WebSocket protocol, buy/sell endpoints
</file>

<file path=".github/sdf">
Optimize Claude API Usage and Improve Speech
Problem Analysis
Currently, Claude API is overused for routine commentary, causing rapid credit consumption:

Used for every token discovery (generateTokenCommentary)
Used for analysis thoughts during evaluation (generateAnalysisThought)
Used for paranoid musings during quiet periods (generateParanoidMusing)
Used for various commentary beats through CommentarySystem
Trade announcements are inconsistent and sometimes miss important trades
Also:

Acronyms like "SOL" are spelled instead of pronounced
Not enough trade announcements happening
Solution
1. Restrict Claude API Usage (src/personality/claude-client.ts & src/personality/commentary-system.ts)
Only use Claude API for:

‚úÖ Chat responses (respondToChat) - KEEP
‚úÖ Optional: In-depth token analysis when specifically requested (rare, special tokens)
Remove Claude API from:

‚ùå generateTokenCommentary() - Use fallback messages with variety
‚ùå generateAnalysisThought() - Use fallback messages  
‚ùå generateParanoidMusing() - Use fallback messages
‚ùå Routine commentary generation in CommentarySystem - Use fallback messages
‚ùå generateDiscoveryCommentary() - Use fallback
‚ùå generateAnalysisCommentary() - Use fallback
‚ùå generateDecisionCommentary() - Use fallback
Changes:

Update CommentarySystem.generateDiscoveryCommentary() to use fallbacks only
Update CommentarySystem.generateAnalysisCommentary() to use fallbacks only
Update CommentarySystem.generateDecisionCommentary() to use fallbacks only
Update CommentarySystem.generateParanoidMusing() to skip Claude, use fallbacks
Update claude-client.generateTokenCommentary() to skip Claude API, use fallbacks
Update claude-client.generateAnalysisThought() to skip Claude API, use fallbacks
Remove Claude usage from MarketWatcher commentary generation
2. Improve Trade Announcements (src/personality/commentary-system.ts & src/index.ts)
Always announce trades with context:

When BUY executes: announce symbol, amount in SOL, and brief context
When SELL executes: announce symbol, profit/loss, and outcome
Ensure trades are announced even when entertainment mode is enabled
Changes:

Enhance generateTradeResultCommentary() with better, varied messages
Add trade announcement fallbacks that include actual trade data (amount, symbol)
Update index.ts event handler to always announce trades regardless of mode
Queue TRADE_RESULT commentary immediately when trades execute
3. Fix Acronym Pronunciation (src/personality/deepgram-tts.ts)
Replace common acronyms with pronounceable versions:

SOL ‚Üí "soul" or "S-O-L" 
USDC ‚Üí "U-S-D-C"
BTC ‚Üí "bitcoin" or "B-T-C"
ETH ‚Üí "ethereum" or "E-T-H"
Add more common crypto acronyms
Changes:

Add replaceAcronyms() method to VoiceNarrator class
Call it in cleanTextForSpeech() before returning
Create acronym mapping for common crypto terms
4. Reduce Repetition (src/personality/commentary-system.ts & src/personality/claude-client.ts)
Improve fallback message variety:

Expand fallback arrays with more varied messages
Use more specific context in messages (symbol, amounts, percentages)
Reduce generic "watching" or "analyzing" phrases
Changes:

Expand all fallback message arrays with more options
Use actual token data in fallback messages (symbol, mcap, etc.)
Make messages more specific and less repetitive
Files to Modify
src/personality/commentary-system.ts - Remove Claude usage, improve fallbacks, better trade announcements
src/personality/claude-client.ts - Remove Claude from token commentary and analysis thoughts
src/personality/deepgram-tts.ts - Add acronym replacement
src/index.ts - Ensure trades are always announced
src/analysis/market-watcher.ts - Remove Claude usage from commentary
Expected Outcomes
‚úÖ Claude API only used for chat responses (~90% reduction in API calls)
‚úÖ Trades are always announced with context
‚úÖ Acronyms pronounced correctly
‚úÖ More natural, varied speech that doesn't feel repetitive
‚úÖ Better balance between speech and silence
</file>

<file path="docs/analysis-architecture.md">
# Analysis Architecture Diagram

## Current Integration Status

```mermaid
flowchart TB
    subgraph "Data Sources"
        PP[("üîå PumpPortal<br/>New Tokens")]
        DS[("üìä DexScreener<br/>Market Data")]
        HL[("‚ö° Helius<br/>On-chain Data")]
    end

    subgraph "Trading Pipeline"
        SP["üéØ Sniper Pipeline"]
        TV["Token Validator"]
        TE["Trading Engine"]
        SE["Scoring Engine"]
    end

    subgraph "Analysis Module" 
        direction TB
        TS["‚úÖ TokenSafetyAnalyzer<br/>INTEGRATED"]
        SM["‚úÖ SmartMoneyTracker<br/>INTEGRATED"]
        WA["‚ö†Ô∏è WalletAnalyzer<br/>via SmartMoney only"]
        
        MS["‚ùå MomentumScanner<br/>NOT INTEGRATED"]
        BD["‚ùå BundleDetector<br/>NOT INTEGRATED"]
        MW["‚ùå MarketWatcher<br/>Passive observer"]
        LE["‚ùå LearningEngine<br/>NOT INTEGRATED"]
    end

    PP --> SP
    SP --> TV
    TV --> DS
    TV -->|"passes"| TS
    TS --> TE
    TE --> SE
    SE --> SM
    SM --> WA
    HL --> TS
    HL --> WA

    style TS fill:#28a745,color:white
    style SM fill:#28a745,color:white
    style WA fill:#ffc107,color:black
    style MS fill:#dc3545,color:white
    style BD fill:#dc3545,color:white
    style MW fill:#dc3545,color:white
    style LE fill:#dc3545,color:white
```

---

## What TokenSafetyAnalyzer Checks ‚úÖ (Updated)

```mermaid
flowchart LR
    subgraph "‚úÖ ON-CHAIN AUTHORITIES"
        A1["Mint Authority"]
        A2["Freeze Authority"]
        A3["Permanent Delegate"]
        A4["Transfer Fee"]
        A5["Transfer Hook"]
    end
    
    subgraph "‚úÖ HOLDER DISTRIBUTION (NEW)"
        B1["Top Holder % > 30%"]
        B2["Top 10 Holders % > 50%"]
        B3["Insider Concentration"]
    end
    
    subgraph "‚ùå STILL MISSING"
        C1["Bundle Detection"]
        C2["Momentum Analysis"]
    end
    
    style A1 fill:#28a745,color:white
    style A2 fill:#28a745,color:white
    style A3 fill:#28a745,color:white
    style A4 fill:#28a745,color:white
    style A5 fill:#28a745,color:white
    style B1 fill:#28a745,color:white
    style B2 fill:#28a745,color:white
    style B3 fill:#28a745,color:white
    style C1 fill:#dc3545,color:white
    style C2 fill:#dc3545,color:white
```

---

## Why 43% Insider Token Got Through

```mermaid
sequenceDiagram
    participant PP as PumpPortal
    participant SP as Sniper Pipeline
    participant DS as DexScreener
    participant TS as TokenSafetyAnalyzer
    participant TE as Trading Engine
    
    PP->>SP: New token detected
    SP->>SP: Wait 30s-2min
    SP->>DS: Get market data
    DS-->>SP: Liquidity ‚úì, Volume ‚úì
    SP->>TS: Analyze safety
    Note over TS: Only checks:<br/>- Mint authority ‚úì<br/>- Freeze authority ‚úì<br/>- Token-2022 ‚úì
    Note over TS: DOES NOT CHECK:<br/>- Top holder %<br/>- Insider %
    TS-->>SP: isSafe: true
    SP->>TE: Execute Buy
    Note over TE: 43% insider token<br/>BOUGHT! üíÄ
```

---

## Orphaned Code (Exists but Not Connected)

```mermaid
flowchart TB
    subgraph "Files Exist in src/analysis/"
        BD["bundle-detector.ts<br/>352 lines"]
        MS["momentum-scanner.ts<br/>444 lines"]
        LE["learning-engine.ts<br/>439 lines"]
    end
    
    subgraph "Trading Pipeline"
        TE["Trading Engine"]
    end
    
    BD -.->|"// Would need BundleDetector"| TE
    MS -.->|"// Would need MomentumScanner"| TE
    LE -.->|"Not called anywhere"| TE
    
    style BD fill:#6c757d,color:white
    style MS fill:#6c757d,color:white
    style LE fill:#6c757d,color:white
```

---

## Summary Table

| Analyzer | Lines | Purpose | Status |
|----------|-------|---------|--------|
| TokenSafetyAnalyzer | 157 | On-chain authority checks | ‚úÖ Integrated |
| SmartMoneyTracker | 203 | Identify profitable wallets | ‚úÖ Integrated |
| WalletAnalyzer | 310 | Parse wallet P&L | ‚ö†Ô∏è Indirect |
| MomentumScanner | 444 | Heat/buy pressure | ‚ùå Orphaned |
| BundleDetector | 352 | Detect coordinated buys | ‚ùå Orphaned |
| MarketWatcher | 532 | Passive learning | ‚ùå Passive |
| LearningEngine | 439 | Adjust weights | ‚ùå Orphaned |
</file>

<file path="package.json">
{
  "name": "schizo-agent",
  "version": "1.0.0",
  "description": "Paranoid AI trading agent for Solana memecoins",
  "type": "module",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "tsx src/index.ts"
  },
  "keywords": [
    "solana",
    "trading",
    "ai",
    "agent"
  ],
  "license": "MIT",
  "dependencies": {
    "@anthropic-ai/sdk": "^0.71.2",
    "@jup-ag/api": "^6.0.48",
    "@solana/web3.js": "^1.95.8",
    "@types/ws": "^8.18.1",
    "better-sqlite3": "^11.0.0",
    "bottleneck": "^2.19.5",
    "bs58": "^5.0.0",
    "dotenv": "^17.2.3",
    "helius-sdk": "^2.0.0",
    "opossum": "^8.1.3",
    "p-retry": "^6.2.0",
    "pino": "^9.0.0",
    "twitter-api-v2": "^1.29.0",
    "ws": "^8.19.0"
  },
  "devDependencies": {
    "@types/better-sqlite3": "^7.6.0",
    "@types/node": "^20.0.0",
    "@types/opossum": "^8.1.9",
    "pino-pretty": "^11.0.0",
    "tsx": "^4.0.0",
    "typescript": "^5.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
</file>

<file path="scripts/check-holdings.ts">
/**
 * Check current wallet token holdings via Helius DAS API
 */

import { Connection, PublicKey } from '@solana/web3.js';

const HELIUS_API_KEY = process.env.HELIUS_API_KEY || 'dd091d8d-f7eb-4d3c-83fc-87cc3232f4f6';
const WALLET_ADDRESS = 'DR4d6RUYHay79dCbUEhU9BphWioVxvoExu4uULq6kJpG';

async function checkHoldings() {
  console.log('üîç Fetching wallet holdings...');
  console.log('Wallet:', WALLET_ADDRESS);
  console.log('');
  
  try {
    // Use Helius RPC to get token accounts
    const connection = new Connection(`https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`);
    
    const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
      new PublicKey(WALLET_ADDRESS),
      { programId: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') }
    );

    // Filter for tokens with non-zero balance
    const tokens = tokenAccounts.value
      .map(acc => {
        const info = acc.account.data.parsed.info;
        return {
          mint: info.mint,
          balance: parseFloat(info.tokenAmount.uiAmountString),
          decimals: info.tokenAmount.decimals,
        };
      })
      .filter(t => t.balance > 0);

    if (tokens.length === 0) {
      console.log('‚ùå No token holdings found');
      
      // Check SOL balance
      const solBalance = await connection.getBalance(new PublicKey(WALLET_ADDRESS));
      console.log(`üí∞ SOL Balance: ${(solBalance / 1e9).toFixed(6)} SOL`);
      return;
    }

    console.log(`‚úÖ Found ${tokens.length} token(s):\n`);

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      console.log(`${i + 1}. Token`);
      console.log(`   Mint: ${token.mint}`);
      console.log(`   Balance: ${token.balance.toLocaleString(undefined, { maximumFractionDigits: 6 })}`);
      console.log('');
    }

    // Check SOL balance
    const solBalance = await connection.getBalance(new PublicKey(WALLET_ADDRESS));
    console.log(`üí∞ SOL Balance: ${(solBalance / 1e9).toFixed(6)} SOL`);

  } catch (error: any) {
    console.error('‚ùå Error fetching holdings:', error.message);
    throw error;
  }
}

checkHoldings();
</file>

<file path="scripts/setup-helius-webhook.ts">
/**
 * Script to create Helius webhook via API
 * Usage: tsx scripts/setup-helius-webhook.ts
 */

const HELIUS_API_KEY = process.env.HELIUS_API_KEY;
const WEBHOOK_URL = 'https://schizoclaude.fun/api/helius-webhook';
const WALLET_ADDRESS = 'DR4d6RUYHay79dCbUEhU9BphWioVxvoExu4uULq6kJpG';

if (!HELIUS_API_KEY) {
  console.error('‚ùå HELIUS_API_KEY environment variable not set');
  process.exit(1);
}

async function createWebhook() {
  const url = `https://api.helius.xyz/v0/webhooks?api-key=${HELIUS_API_KEY}`;
  
  const body = {
    webhookURL: WEBHOOK_URL,
    transactionTypes: [
      'SWAP',
      'TOKEN_MINT',
      'TOKEN_BURN',
      'TRANSFER'
    ],
    accountAddresses: [WALLET_ADDRESS],
    webhookType: 'enhanced',
    authHeader: '', // Optional: add HELIUS_WEBHOOK_SECRET if you want signature verification
  };

  console.log('üì° Creating Helius webhook...');
  console.log('Webhook URL:', WEBHOOK_URL);
  console.log('Monitoring wallet:', WALLET_ADDRESS);
  console.log('Transaction types:', body.transactionTypes.join(', '));

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }

    const webhook = await response.json();
    console.log('\n‚úÖ Webhook created successfully!');
    console.log('Webhook ID:', webhook.webhookID);
    console.log('Wallet:', webhook.wallet);
    console.log('\nYou can manage this webhook at: https://dashboard.helius.dev/webhooks');
    
    return webhook;
  } catch (error) {
    console.error('\n‚ùå Failed to create webhook:', error);
    throw error;
  }
}

async function listWebhooks() {
  const url = `https://api.helius.xyz/v0/webhooks?api-key=${HELIUS_API_KEY}`;
  
  console.log('\nüìã Fetching existing webhooks...');
  
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }

    const webhooks = await response.json();
    
    if (webhooks.length === 0) {
      console.log('No existing webhooks found.');
      return [];
    }

    console.log(`\nFound ${webhooks.length} webhook(s):`);
    webhooks.forEach((wh: any, i: number) => {
      console.log(`\n${i + 1}. Webhook ID: ${wh.webhookID}`);
      console.log(`   URL: ${wh.webhookURL}`);
      console.log(`   Type: ${wh.webhookType}`);
      console.log(`   Addresses: ${wh.accountAddresses?.join(', ') || 'None'}`);
      console.log(`   Transaction Types: ${wh.transactionTypes?.join(', ') || 'None'}`);
    });

    return webhooks;
  } catch (error) {
    console.error('\n‚ùå Failed to list webhooks:', error);
    throw error;
  }
}

// Main execution
(async () => {
  try {
    // First, list existing webhooks
    const existing = await listWebhooks();
    
    // Check if webhook already exists for this URL
    const alreadyExists = existing.some((wh: any) => wh.webhookURL === WEBHOOK_URL);
    
    if (alreadyExists) {
      console.log('\n‚ö†Ô∏è  Webhook already exists for this URL!');
      console.log('If you want to recreate it, delete the existing one first:');
      console.log('https://dashboard.helius.dev/webhooks');
    } else {
      // Create new webhook
      await createWebhook();
    }
  } catch (error) {
    console.error('\nüí• Script failed:', error);
    process.exit(1);
  }
})();
</file>

<file path="scripts/update-helius-webhook.ts">
/**
 * Script to update existing Helius webhook
 * Usage: tsx scripts/update-helius-webhook.ts
 */

const HELIUS_API_KEY = process.env.HELIUS_API_KEY;
const WEBHOOK_ID = 'b1d7d5fc-b652-48b7-8b01-a2377d598501';
const WEBHOOK_URL = 'https://schizoclaude.fun/api/helius-webhook';
const WALLET_ADDRESS = 'DR4d6RUYHay79dCbUEhU9BphWioVxvoExu4uULq6kJpG';

if (!HELIUS_API_KEY) {
  console.error('‚ùå HELIUS_API_KEY environment variable not set');
  process.exit(1);
}

async function updateWebhook() {
  const url = `https://api.helius.xyz/v0/webhooks/${WEBHOOK_ID}?api-key=${HELIUS_API_KEY}`;
  
  const body = {
    webhookURL: WEBHOOK_URL,
    transactionTypes: [
      'SWAP',
      'TRANSFER',
      'TOKEN_MINT',
      'BURN'
    ],
    accountAddresses: [WALLET_ADDRESS],
    webhookType: 'enhanced',
  };

  console.log('üîÑ Updating Helius webhook...');
  console.log('Webhook ID:', WEBHOOK_ID);
  console.log('Webhook URL:', WEBHOOK_URL);
  console.log('Monitoring wallet:', WALLET_ADDRESS);
  console.log('Transaction types:', body.transactionTypes.join(', '));

  try {
    const response = await fetch(url, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }

    const webhook = await response.json();
    console.log('\n‚úÖ Webhook updated successfully!');
    console.log('Webhook ID:', webhook.webhookID);
    console.log('Account Addresses:', webhook.accountAddresses);
    console.log('Transaction Types:', webhook.transactionTypes);
    console.log('\nThe webhook will now send events for all transactions on your wallet!');
    
    return webhook;
  } catch (error) {
    console.error('\n‚ùå Failed to update webhook:', error);
    throw error;
  }
}

// Main execution
(async () => {
  try {
    await updateWebhook();
  } catch (error) {
    console.error('\nüí• Script failed:', error);
    process.exit(1);
  }
})();
</file>

<file path="src/analysis/bundle-detector.ts">
/**
 * Bundle Detector - Identifies coordinated/bundled transactions
 *
 * Detects manipulation patterns:
 * - Timing clusters (multiple buys within seconds)
 * - Similar transaction amounts (preset bot parameters)
 * - New wallet clusters (wallets created same time)
 * - Same-block transactions (Jito bundles)
 *
 * Based on methodology from solana-bundler-detector
 */

import { Connection, PublicKey } from '@solana/web3.js';
import { createLogger } from '../lib/logger.js';

const logger = createLogger('bundle-detector');

/**
 * Transaction for bundle analysis
 */
interface BundleTransaction {
  signature: string;
  timestamp: number;
  slot: number;
  wallet: string;
  amount: number; // SOL amount
  type: 'buy' | 'sell';
}

/**
 * Bundle detection result
 */
export interface BundleAnalysis {
  isBundled: boolean;
  bundleScore: number; // 0-100
  flags: string[];
  clusters: TransactionCluster[];
  metrics: {
    timingScore: number;      // Transactions within suspicious windows
    amountScore: number;      // Similar amounts suggest bots
    walletAgeScore: number;   // New wallets = suspicious
    concentrationScore: number; // Few wallets buying a lot
  };
}

/**
 * A cluster of related transactions
 */
interface TransactionCluster {
  transactions: BundleTransaction[];
  timeSpanMs: number;
  avgAmount: number;
  amountVariance: number;
}

/**
 * Bundle detection thresholds
 */
interface BundleThresholds {
  timeWindowMs: number;        // Max time between txs to be considered cluster (default: 30s)
  minClusterSize: number;      // Minimum txs to form cluster (default: 3)
  maxAmountVariance: number;   // Max variance in amounts to be suspicious (default: 0.2 = 20%)
  maxWalletAgeHours: number;   // Wallets younger than this are suspicious (default: 24)
  sameBlockWeight: number;     // Extra weight for same-block txs (default: 2.0)
}

const DEFAULT_THRESHOLDS: BundleThresholds = {
  timeWindowMs: 30000,        // 30 seconds
  minClusterSize: 3,          // 3+ transactions
  maxAmountVariance: 0.2,     // 20% variance
  maxWalletAgeHours: 24,      // 24 hours
  sameBlockWeight: 2.0,       // Double weight for same-block
};

/**
 * Bundle Detector
 *
 * Analyzes transactions for a token to detect coordinated buying patterns.
 */
export class BundleDetector {
  private thresholds: BundleThresholds;

  constructor(thresholds?: Partial<BundleThresholds>) {
    this.thresholds = { ...DEFAULT_THRESHOLDS, ...thresholds };
  }

  /**
   * Analyze transactions for bundle patterns.
   *
   * @param transactions - List of transactions to analyze
   * @returns Bundle analysis with score and flags
   */
  analyze(transactions: BundleTransaction[]): BundleAnalysis {
    if (transactions.length < this.thresholds.minClusterSize) {
      return this.createEmptyResult();
    }

    // Sort by timestamp
    const sorted = [...transactions].sort((a, b) => a.timestamp - b.timestamp);

    // Find timing clusters
    const clusters = this.findTimingClusters(sorted);

    // Calculate individual scores
    const timingScore = this.calculateTimingScore(clusters, sorted.length);
    const amountScore = this.calculateAmountScore(clusters);
    const walletAgeScore = 0; // Would need wallet creation data
    const concentrationScore = this.calculateConcentrationScore(sorted);

    // Weighted composite score
    // Based on solana-bundler-detector weights
    const bundleScore = Math.min(100, Math.round(
      timingScore * 0.4 +      // 40% timing
      amountScore * 0.3 +      // 30% amount similarity
      walletAgeScore * 0.2 +   // 20% wallet age
      concentrationScore * 0.1  // 10% concentration
    ));

    // Generate flags
    const flags = this.generateFlags(timingScore, amountScore, concentrationScore, clusters);

    const isBundled = bundleScore >= 50 || flags.length >= 2;

    logger.debug({
      txCount: transactions.length,
      clusterCount: clusters.length,
      bundleScore,
      isBundled,
    }, 'Bundle analysis complete');

    return {
      isBundled,
      bundleScore,
      flags,
      clusters,
      metrics: {
        timingScore,
        amountScore,
        walletAgeScore,
        concentrationScore,
      },
    };
  }

  /**
   * Quick check for same-block transactions (Jito bundles).
   */
  detectSameBlockBundle(transactions: BundleTransaction[]): boolean {
    if (transactions.length < 2) return false;

    // Group by slot
    const bySlot = new Map<number, BundleTransaction[]>();
    for (const tx of transactions) {
      const existing = bySlot.get(tx.slot) || [];
      existing.push(tx);
      bySlot.set(tx.slot, existing);
    }

    // Check if any slot has 3+ transactions
    for (const [slot, txs] of bySlot) {
      if (txs.length >= 3) {
        logger.warn({
          slot,
          txCount: txs.length,
          wallets: txs.map(t => t.wallet.slice(0, 8)),
        }, 'Same-block bundle detected (likely Jito)');
        return true;
      }
    }

    return false;
  }

  /**
   * Find clusters of transactions within time windows.
   */
  private findTimingClusters(sorted: BundleTransaction[]): TransactionCluster[] {
    const clusters: TransactionCluster[] = [];
    let currentCluster: BundleTransaction[] = [];

    for (let i = 0; i < sorted.length; i++) {
      const tx = sorted[i];

      if (currentCluster.length === 0) {
        currentCluster.push(tx);
        continue;
      }

      const lastTx = currentCluster[currentCluster.length - 1];
      const timeDiff = tx.timestamp - lastTx.timestamp;

      if (timeDiff <= this.thresholds.timeWindowMs) {
        currentCluster.push(tx);
      } else {
        // Save current cluster if large enough
        if (currentCluster.length >= this.thresholds.minClusterSize) {
          clusters.push(this.createCluster(currentCluster));
        }
        currentCluster = [tx];
      }
    }

    // Don't forget last cluster
    if (currentCluster.length >= this.thresholds.minClusterSize) {
      clusters.push(this.createCluster(currentCluster));
    }

    return clusters;
  }

  /**
   * Create a cluster object with statistics.
   */
  private createCluster(transactions: BundleTransaction[]): TransactionCluster {
    const amounts = transactions.map(t => t.amount);
    const avgAmount = amounts.reduce((a, b) => a + b, 0) / amounts.length;

    // Calculate variance
    const variance = amounts.reduce((sum, a) => sum + Math.pow(a - avgAmount, 2), 0) / amounts.length;
    const stdDev = Math.sqrt(variance);
    const coefficientOfVariation = avgAmount > 0 ? stdDev / avgAmount : 0;

    const timeSpanMs = transactions[transactions.length - 1].timestamp - transactions[0].timestamp;

    return {
      transactions,
      timeSpanMs,
      avgAmount,
      amountVariance: coefficientOfVariation,
    };
  }

  /**
   * Score based on timing patterns.
   * High score = many transactions in tight windows.
   */
  private calculateTimingScore(clusters: TransactionCluster[], totalTxs: number): number {
    if (clusters.length === 0 || totalTxs === 0) return 0;

    // What percentage of txs are in clusters?
    const clusteredTxs = clusters.reduce((sum, c) => sum + c.transactions.length, 0);
    const clusterRatio = clusteredTxs / totalTxs;

    // Bonus for very tight clusters (< 5 seconds)
    const tightClusters = clusters.filter(c => c.timeSpanMs < 5000);
    const tightBonus = tightClusters.length * 10;

    return Math.min(100, Math.round(clusterRatio * 80 + tightBonus));
  }

  /**
   * Score based on amount similarity.
   * Low variance = bot-like behavior.
   */
  private calculateAmountScore(clusters: TransactionCluster[]): number {
    if (clusters.length === 0) return 0;

    // Average variance across clusters
    const avgVariance = clusters.reduce((sum, c) => sum + c.amountVariance, 0) / clusters.length;

    // Low variance = high score (suspicious)
    if (avgVariance < 0.05) return 100;  // < 5% variance = very suspicious
    if (avgVariance < 0.1) return 80;    // < 10% variance
    if (avgVariance < 0.2) return 50;    // < 20% variance
    if (avgVariance < 0.3) return 25;    // < 30% variance

    return 0;
  }

  /**
   * Score based on concentration of buying.
   * Few wallets buying a lot = suspicious.
   */
  private calculateConcentrationScore(transactions: BundleTransaction[]): number {
    if (transactions.length < 5) return 0;

    // Count transactions per wallet
    const walletCounts = new Map<string, number>();
    for (const tx of transactions) {
      walletCounts.set(tx.wallet, (walletCounts.get(tx.wallet) || 0) + 1);
    }

    const uniqueWallets = walletCounts.size;
    const totalTxs = transactions.length;

    // Ratio of unique wallets to transactions
    // Low ratio = few wallets doing many txs = suspicious
    const ratio = uniqueWallets / totalTxs;

    if (ratio < 0.3) return 100;  // < 30% unique = very concentrated
    if (ratio < 0.5) return 70;
    if (ratio < 0.7) return 40;

    return 0;
  }

  /**
   * Generate human-readable flags.
   */
  private generateFlags(
    timingScore: number,
    amountScore: number,
    concentrationScore: number,
    clusters: TransactionCluster[]
  ): string[] {
    const flags: string[] = [];

    if (timingScore >= 70) {
      flags.push('TIMING_CLUSTER: Multiple buys within seconds');
    }

    if (amountScore >= 70) {
      flags.push('SIMILAR_AMOUNTS: Transaction sizes nearly identical');
    }

    if (concentrationScore >= 70) {
      flags.push('CONCENTRATED: Few wallets, many transactions');
    }

    // Check for same-slot transactions
    for (const cluster of clusters) {
      const slots = new Set(cluster.transactions.map(t => t.slot));
      if (slots.size === 1 && cluster.transactions.length >= 3) {
        flags.push('SAME_BLOCK: Likely Jito bundle');
        break;
      }
    }

    return flags;
  }

  /**
   * Create empty result for insufficient data.
   */
  private createEmptyResult(): BundleAnalysis {
    return {
      isBundled: false,
      bundleScore: 0,
      flags: [],
      clusters: [],
      metrics: {
        timingScore: 0,
        amountScore: 0,
        walletAgeScore: 0,
        concentrationScore: 0,
      },
    };
  }
}

export { BundleTransaction, BundleThresholds };
</file>

<file path="src/analysis/learning-engine.ts">
/**
 * Learning Engine - Tracks trade outcomes and learns what works
 *
 * After each trade closes:
 * 1. Extract features that were present at entry
 * 2. Record outcome (win/loss, PnL %)
 * 3. Update feature weights based on correlation with wins
 * 4. Adjust future scoring based on learned patterns
 *
 * Inspired by FreqAI's adaptive learning and LLM_Trader's self-improvement.
 */

import { createLogger } from '../lib/logger.js';
import type { DatabaseWithRepositories } from '../db/database-with-repos.js';

const logger = createLogger('learning-engine');

/**
 * Features extracted at trade entry time
 */
export interface TradeFeatures {
  // Market structure
  bondingCurveProgress: number;    // 0-100%
  marketCapSol: number;
  liquidity: number;
  tokenAgeMins: number;

  // Volume/momentum
  buyCount5m: number;
  sellCount5m: number;
  buyVolume5m: number;
  sellVolume5m: number;
  heatMetric: number;              // (1min_vol / 5min_vol) * 100

  // Holder analysis
  holderCount: number;
  topHolderPercent: number;        // Top holder's %
  top10HoldersPercent: number;

  // Smart money
  smartMoneyCount: number;
  smartMoneyBuying: boolean;

  // Safety
  mintAuthorityRevoked: boolean;
  freezeAuthorityRevoked: boolean;
  isBundled: boolean;
  bundleScore: number;

  // Social (if available)
  hasTwitter: boolean;
  hasTelegram: boolean;
  hasWebsite: boolean;
}

/**
 * A completed trade with features and outcome
 */
export interface TradeLesson {
  id: string;
  tokenMint: string;
  tokenSymbol?: string;
  entryTimestamp: number;
  exitTimestamp: number;
  features: TradeFeatures;
  outcome: 'win' | 'loss';
  pnlPercent: number;
  pnlSol: number;
  holdTimeMs: number;
  entryPrice: number;
  exitPrice: number;
  confidenceAtEntry: number;
}

/**
 * Feature weight for scoring
 */
interface FeatureWeight {
  name: keyof TradeFeatures;
  weight: number;           // -1 to 1 (negative = avoid, positive = favor)
  winCorrelation: number;   // How correlated with wins
  sampleSize: number;       // How many trades informed this
  lastUpdated: number;
}

/**
 * Confidence calibration data
 */
interface ConfidenceCalibration {
  bucket: string;           // "high" | "medium" | "low"
  minConfidence: number;
  maxConfidence: number;
  totalTrades: number;
  wins: number;
  actualWinRate: number;
  expectedWinRate: number;  // Based on confidence
}

/**
 * Learning engine statistics
 */
export interface LearningStats {
  totalLessons: number;
  wins: number;
  losses: number;
  overallWinRate: number;
  avgWinPnl: number;
  avgLossPnl: number;
  expectancy: number;       // Expected value per trade
  topPositiveFeatures: string[];
  topNegativeFeatures: string[];
  confidenceCalibration: ConfidenceCalibration[];
}

/**
 * Learning Engine
 *
 * Tracks trade outcomes and learns which features predict success.
 */
export class LearningEngine {
  private lessons: TradeLesson[] = [];
  private featureWeights: Map<keyof TradeFeatures, FeatureWeight> = new Map();
  private confidenceBuckets: ConfidenceCalibration[] = [];
  private decayRate = 0.95; // Weight decay per week (older lessons matter less)

  constructor(private db?: DatabaseWithRepositories) {
    this.initializeWeights();
    this.initializeConfidenceBuckets();

    logger.info('LearningEngine initialized');
  }

  /**
   * Initialize feature weights with neutral values.
   */
  private initializeWeights(): void {
    const features: (keyof TradeFeatures)[] = [
      'bondingCurveProgress', 'marketCapSol', 'liquidity', 'tokenAgeMins',
      'buyCount5m', 'sellCount5m', 'buyVolume5m', 'sellVolume5m', 'heatMetric',
      'holderCount', 'topHolderPercent', 'top10HoldersPercent',
      'smartMoneyCount', 'smartMoneyBuying',
      'mintAuthorityRevoked', 'freezeAuthorityRevoked', 'isBundled', 'bundleScore',
      'hasTwitter', 'hasTelegram', 'hasWebsite',
    ];

    for (const feature of features) {
      this.featureWeights.set(feature, {
        name: feature,
        weight: 0,
        winCorrelation: 0,
        sampleSize: 0,
        lastUpdated: Date.now(),
      });
    }
  }

  /**
   * Initialize confidence calibration buckets.
   */
  private initializeConfidenceBuckets(): void {
    this.confidenceBuckets = [
      { bucket: 'low', minConfidence: 0, maxConfidence: 40, totalTrades: 0, wins: 0, actualWinRate: 0, expectedWinRate: 0.25 },
      { bucket: 'medium', minConfidence: 40, maxConfidence: 70, totalTrades: 0, wins: 0, actualWinRate: 0, expectedWinRate: 0.50 },
      { bucket: 'high', minConfidence: 70, maxConfidence: 100, totalTrades: 0, wins: 0, actualWinRate: 0, expectedWinRate: 0.75 },
    ];
  }

  /**
   * Record a completed trade lesson.
   */
  async recordLesson(lesson: TradeLesson): Promise<void> {
    this.lessons.push(lesson);

    // Update feature weights based on outcome
    this.updateWeights(lesson);

    // Update confidence calibration
    this.updateConfidenceCalibration(lesson);

    // Persist to database if available
    if (this.db) {
      try {
        await this.db.analysisCache.set(
          `lesson:${lesson.id}`,
          'learning',
          lesson,
          7 * 24 * 60 * 60 * 1000 // 7 days
        );
      } catch (error) {
        logger.warn({ error }, 'Failed to persist lesson to DB');
      }
    }

    logger.info({
      token: lesson.tokenMint,
      outcome: lesson.outcome,
      pnlPercent: lesson.pnlPercent.toFixed(1),
      totalLessons: this.lessons.length,
    }, 'Trade lesson recorded');
  }

  /**
   * Update feature weights based on a lesson.
   */
  private updateWeights(lesson: TradeLesson): void {
    const isWin = lesson.outcome === 'win';
    const features = lesson.features;

    // For each feature, update its correlation with wins
    for (const [featureName, weight] of this.featureWeights) {
      const featureValue = features[featureName];

      // Skip undefined features
      if (featureValue === undefined) continue;

      // Normalize feature to boolean-ish for correlation
      // (true/high values should correlate with wins for positive features)
      const featureActive = this.isFeatureActive(featureName, featureValue);

      // Update correlation
      // Simple approach: track if feature was present in wins vs losses
      const contribution = isWin ? (featureActive ? 1 : -0.5) : (featureActive ? -1 : 0.5);

      // Apply decay to old weight, then add new contribution
      const decayedWeight = weight.weight * this.decayRate;
      const newWeight = decayedWeight + (contribution * 0.1); // 0.1 learning rate

      // Clamp to [-1, 1]
      weight.weight = Math.max(-1, Math.min(1, newWeight));
      weight.sampleSize++;
      weight.lastUpdated = Date.now();

      // Update win correlation (simple running average)
      const oldCorr = weight.winCorrelation;
      const n = weight.sampleSize;
      const winVal = isWin && featureActive ? 1 : 0;
      weight.winCorrelation = oldCorr + (winVal - oldCorr) / n;

      this.featureWeights.set(featureName, weight);
    }
  }

  /**
   * Determine if a feature is "active" (high/true).
   */
  private isFeatureActive(name: keyof TradeFeatures, value: number | boolean): boolean {
    if (typeof value === 'boolean') return value;

    // Define thresholds for numeric features
    const thresholds: Partial<Record<keyof TradeFeatures, number>> = {
      bondingCurveProgress: 30,    // > 30% progress
      marketCapSol: 50,            // > 50 SOL mcap
      liquidity: 10,               // > 10 SOL liquidity
      tokenAgeMins: 10,            // > 10 mins old
      buyCount5m: 20,              // > 20 buys
      heatMetric: 25,              // > 25% heat
      holderCount: 50,             // > 50 holders
      smartMoneyCount: 1,          // Any smart money
      bundleScore: 50,             // > 50 bundle score (bad)
    };

    const threshold = thresholds[name];
    if (threshold !== undefined) {
      return value > threshold;
    }

    return value > 0;
  }

  /**
   * Update confidence calibration with new outcome.
   */
  private updateConfidenceCalibration(lesson: TradeLesson): void {
    const confidence = lesson.confidenceAtEntry;
    const isWin = lesson.outcome === 'win';

    for (const bucket of this.confidenceBuckets) {
      if (confidence >= bucket.minConfidence && confidence < bucket.maxConfidence) {
        bucket.totalTrades++;
        if (isWin) bucket.wins++;
        bucket.actualWinRate = bucket.totalTrades > 0
          ? bucket.wins / bucket.totalTrades
          : 0;
        break;
      }
    }
  }

  /**
   * Score a set of features based on learned weights.
   * Returns adjustment to base confidence.
   */
  scoreFeatures(features: TradeFeatures): {
    adjustment: number;
    reasons: string[];
    warnings: string[];
  } {
    let adjustment = 0;
    const reasons: string[] = [];
    const warnings: string[] = [];

    for (const [featureName, weight] of this.featureWeights) {
      if (weight.sampleSize < 5) continue; // Need minimum samples

      const featureValue = features[featureName];
      if (featureValue === undefined) continue;

      const isActive = this.isFeatureActive(featureName, featureValue);

      if (isActive && weight.weight > 0.3) {
        adjustment += weight.weight * 10;
        reasons.push(`${featureName}: positive signal (w=${weight.weight.toFixed(2)})`);
      } else if (isActive && weight.weight < -0.3) {
        adjustment += weight.weight * 10;
        warnings.push(`${featureName}: negative signal (w=${weight.weight.toFixed(2)})`);
      }
    }

    return {
      adjustment: Math.max(-30, Math.min(30, adjustment)), // Cap at ¬±30
      reasons,
      warnings,
    };
  }

  /**
   * Get insights about what's working and what's not.
   */
  getInsights(): {
    bestFeatures: { name: string; weight: number; correlation: number }[];
    worstFeatures: { name: string; weight: number; correlation: number }[];
    calibrationIssues: string[];
  } {
    const features = Array.from(this.featureWeights.values())
      .filter(w => w.sampleSize >= 5)
      .sort((a, b) => b.weight - a.weight);

    const bestFeatures = features.slice(0, 5).map(f => ({
      name: f.name,
      weight: f.weight,
      correlation: f.winCorrelation,
    }));

    const worstFeatures = features.slice(-5).reverse().map(f => ({
      name: f.name,
      weight: f.weight,
      correlation: f.winCorrelation,
    }));

    const calibrationIssues: string[] = [];
    for (const bucket of this.confidenceBuckets) {
      if (bucket.totalTrades >= 10) {
        const diff = bucket.actualWinRate - bucket.expectedWinRate;
        if (Math.abs(diff) > 0.2) {
          calibrationIssues.push(
            `${bucket.bucket} confidence: expected ${(bucket.expectedWinRate * 100).toFixed(0)}% ` +
            `win rate, actual ${(bucket.actualWinRate * 100).toFixed(0)}%`
          );
        }
      }
    }

    return { bestFeatures, worstFeatures, calibrationIssues };
  }

  /**
   * Get comprehensive learning statistics.
   */
  getStats(): LearningStats {
    const wins = this.lessons.filter(l => l.outcome === 'win');
    const losses = this.lessons.filter(l => l.outcome === 'loss');

    const avgWinPnl = wins.length > 0
      ? wins.reduce((sum, l) => sum + l.pnlPercent, 0) / wins.length
      : 0;

    const avgLossPnl = losses.length > 0
      ? losses.reduce((sum, l) => sum + l.pnlPercent, 0) / losses.length
      : 0;

    const winRate = this.lessons.length > 0
      ? wins.length / this.lessons.length
      : 0;

    // Expectancy = (WinRate * AvgWin) + ((1 - WinRate) * AvgLoss)
    const expectancy = (winRate * avgWinPnl) + ((1 - winRate) * avgLossPnl);

    const sortedWeights = Array.from(this.featureWeights.values())
      .filter(w => w.sampleSize >= 5)
      .sort((a, b) => b.weight - a.weight);

    const topPositive = sortedWeights.slice(0, 3).map(w => w.name);
    const topNegative = sortedWeights.slice(-3).reverse().map(w => w.name);

    return {
      totalLessons: this.lessons.length,
      wins: wins.length,
      losses: losses.length,
      overallWinRate: winRate,
      avgWinPnl,
      avgLossPnl,
      expectancy,
      topPositiveFeatures: topPositive,
      topNegativeFeatures: topNegative,
      confidenceCalibration: this.confidenceBuckets,
    };
  }

  /**
   * Export lessons for analysis.
   */
  exportLessons(): TradeLesson[] {
    return [...this.lessons];
  }

  /**
   * Import lessons (e.g., from database on startup).
   */
  importLessons(lessons: TradeLesson[]): void {
    for (const lesson of lessons) {
      this.lessons.push(lesson);
      this.updateWeights(lesson);
      this.updateConfidenceCalibration(lesson);
    }

    logger.info({ imported: lessons.length }, 'Imported historical lessons');
  }

  /**
   * Clear all learned data (reset).
   */
  reset(): void {
    this.lessons = [];
    this.initializeWeights();
    this.initializeConfidenceBuckets();
    logger.info('LearningEngine reset');
  }
}
</file>

<file path="src/analysis/momentum-scanner.ts">
/**
 * Momentum Scanner - Detects early pump signals
 *
 * Based on memecoin.watch methodology:
 * - Heat metric: (1min_volume / 5min_volume) * 100
 * - Consecutive buy sequences
 * - Buy/Sell ratio
 * - Price stepping patterns
 *
 * Distinguishes genuine retail buying waves from bot manipulation.
 */

import { createLogger } from '../lib/logger.js';

const logger = createLogger('momentum-scanner');

/**
 * Trade event for momentum analysis
 */
export interface TradeEvent {
  timestamp: number;
  type: 'buy' | 'sell';
  solAmount: number;
  tokenAmount: number;
  pricePerToken: number;
  walletAge?: number; // Age in hours, if known
  signature: string;
}

/**
 * Momentum analysis result
 */
export interface MomentumAnalysis {
  score: number;              // 0-100 overall momentum score
  heatMetric: number;         // (1min_vol / 5min_vol) * 100
  buyPressure: number;        // Buy/sell ratio
  consecutiveBuys: number;    // Current streak of buys
  priceSteps: number;         // Number of price step-ups
  alerts: MomentumAlert[];
  phase: 'cold' | 'building' | 'hot' | 'peak' | 'cooling';
  recommendation: 'buy' | 'wait' | 'avoid';
}

/**
 * Momentum alert
 */
export interface MomentumAlert {
  type: 'heat' | 'buy_streak' | 'price_step' | 'volume_spike' | 'whale' | 'warning';
  message: string;
  severity: 'info' | 'medium' | 'high';
}

/**
 * Configuration for momentum scanner
 */
export interface MomentumConfig {
  /** Heat thresholds */
  heatBuilding: number;      // Start of building phase (default: 33)
  heatHot: number;           // Hot phase (default: 48)
  heatPeak: number;          // Peak/caution phase (default: 100)

  /** Minimum consecutive buys to trigger alert */
  minConsecutiveBuys: number;

  /** Minimum price step % to count */
  minPriceStepPercent: number;

  /** Minimum buy/sell ratio for bullish signal */
  minBuySellRatio: number;

  /** Volume spike threshold (multiple of average) */
  volumeSpikeMultiple: number;

  /** Whale threshold in SOL */
  whaleThresholdSol: number;

  /** Maximum wallet age (hours) for "new wallet" flag */
  newWalletMaxHours: number;
}

const DEFAULT_CONFIG: MomentumConfig = {
  heatBuilding: 33,
  heatHot: 48,
  heatPeak: 100,
  minConsecutiveBuys: 5,
  minPriceStepPercent: 0.2,
  minBuySellRatio: 1.2,
  volumeSpikeMultiple: 3,
  whaleThresholdSol: 5,
  newWalletMaxHours: 24,
};

/**
 * Momentum Scanner
 *
 * Analyzes trade flow to detect momentum and early pump signals.
 */
export class MomentumScanner {
  private config: MomentumConfig;
  private tradeHistory: Map<string, TradeEvent[]> = new Map(); // token -> trades

  constructor(config?: Partial<MomentumConfig>) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    logger.info({ config: this.config }, 'MomentumScanner initialized');
  }

  /**
   * Add a trade event to the history.
   */
  addTrade(tokenMint: string, trade: TradeEvent): void {
    const trades = this.tradeHistory.get(tokenMint) || [];
    trades.push(trade);

    // Keep only last 15 minutes of trades
    const cutoff = Date.now() - 15 * 60 * 1000;
    const filtered = trades.filter(t => t.timestamp > cutoff);

    this.tradeHistory.set(tokenMint, filtered);
  }

  /**
   * Analyze momentum for a token.
   */
  analyze(tokenMint: string): MomentumAnalysis {
    const trades = this.tradeHistory.get(tokenMint) || [];

    if (trades.length < 3) {
      return this.createColdResult();
    }

    const now = Date.now();
    const oneMinAgo = now - 60 * 1000;
    const fiveMinAgo = now - 5 * 60 * 1000;

    // Split trades by timeframe
    const trades1m = trades.filter(t => t.timestamp > oneMinAgo);
    const trades5m = trades.filter(t => t.timestamp > fiveMinAgo);

    // Calculate metrics
    const heatMetric = this.calculateHeat(trades1m, trades5m);
    const buyPressure = this.calculateBuyPressure(trades5m);
    const consecutiveBuys = this.countConsecutiveBuys(trades);
    const priceSteps = this.countPriceSteps(trades5m);

    // Generate alerts
    const alerts = this.generateAlerts(trades5m, heatMetric, buyPressure, consecutiveBuys);

    // Determine phase
    const phase = this.determinePhase(heatMetric);

    // Calculate overall score
    const score = this.calculateScore(heatMetric, buyPressure, consecutiveBuys, priceSteps);

    // Generate recommendation
    const recommendation = this.generateRecommendation(score, phase, alerts);

    logger.debug({
      tokenMint: tokenMint.slice(0, 8),
      score,
      heatMetric,
      phase,
      recommendation,
    }, 'Momentum analysis complete');

    return {
      score,
      heatMetric,
      buyPressure,
      consecutiveBuys,
      priceSteps,
      alerts,
      phase,
      recommendation,
    };
  }

  /**
   * Calculate heat metric: (1min_volume / 5min_volume) * 100
   */
  private calculateHeat(trades1m: TradeEvent[], trades5m: TradeEvent[]): number {
    const vol1m = trades1m.reduce((sum, t) => sum + t.solAmount, 0);
    const vol5m = trades5m.reduce((sum, t) => sum + t.solAmount, 0);

    if (vol5m === 0) return 0;

    // Heat = what % of 5min volume happened in last 1min
    // High heat = acceleration
    return (vol1m / vol5m) * 100;
  }

  /**
   * Calculate buy/sell pressure ratio.
   */
  private calculateBuyPressure(trades: TradeEvent[]): number {
    const buys = trades.filter(t => t.type === 'buy');
    const sells = trades.filter(t => t.type === 'sell');

    const buyVol = buys.reduce((sum, t) => sum + t.solAmount, 0);
    const sellVol = sells.reduce((sum, t) => sum + t.solAmount, 0);

    if (sellVol === 0) return buyVol > 0 ? 10 : 1; // Cap at 10x

    return Math.min(10, buyVol / sellVol);
  }

  /**
   * Count consecutive buys at the end of the trade list.
   */
  private countConsecutiveBuys(trades: TradeEvent[]): number {
    if (trades.length === 0) return 0;

    let count = 0;
    // Count from most recent backwards
    for (let i = trades.length - 1; i >= 0; i--) {
      if (trades[i].type === 'buy') {
        count++;
      } else {
        break;
      }
    }

    return count;
  }

  /**
   * Count price step-ups (minimum 0.2% increase).
   */
  private countPriceSteps(trades: TradeEvent[]): number {
    if (trades.length < 2) return 0;

    let steps = 0;
    let lastPrice = trades[0].pricePerToken;

    for (let i = 1; i < trades.length; i++) {
      const price = trades[i].pricePerToken;
      const change = (price - lastPrice) / lastPrice;

      if (change >= this.config.minPriceStepPercent / 100) {
        steps++;
      }

      lastPrice = price;
    }

    return steps;
  }

  /**
   * Generate alerts based on analysis.
   */
  private generateAlerts(
    trades: TradeEvent[],
    heatMetric: number,
    buyPressure: number,
    consecutiveBuys: number
  ): MomentumAlert[] {
    const alerts: MomentumAlert[] = [];

    // Heat alerts
    if (heatMetric >= this.config.heatPeak) {
      alerts.push({
        type: 'heat',
        message: `PEAK HEAT: ${heatMetric.toFixed(0)}% - Exercise caution`,
        severity: 'high',
      });
    } else if (heatMetric >= this.config.heatHot) {
      alerts.push({
        type: 'heat',
        message: `HOT: Heat at ${heatMetric.toFixed(0)}%`,
        severity: 'medium',
      });
    } else if (heatMetric >= this.config.heatBuilding) {
      alerts.push({
        type: 'heat',
        message: `BUILDING: Heat at ${heatMetric.toFixed(0)}%`,
        severity: 'info',
      });
    }

    // Consecutive buys alert
    if (consecutiveBuys >= this.config.minConsecutiveBuys) {
      alerts.push({
        type: 'buy_streak',
        message: `${consecutiveBuys} consecutive buys`,
        severity: consecutiveBuys >= 10 ? 'high' : 'medium',
      });
    }

    // Buy pressure alert
    if (buyPressure >= this.config.minBuySellRatio) {
      alerts.push({
        type: 'volume_spike',
        message: `Buy pressure ${buyPressure.toFixed(1)}x sells`,
        severity: buyPressure >= 3 ? 'high' : 'medium',
      });
    }

    // Whale detection
    const whales = trades.filter(t =>
      t.type === 'buy' && t.solAmount >= this.config.whaleThresholdSol
    );
    if (whales.length > 0) {
      const totalWhaleVol = whales.reduce((sum, t) => sum + t.solAmount, 0);
      alerts.push({
        type: 'whale',
        message: `${whales.length} whale buy(s): ${totalWhaleVol.toFixed(1)} SOL`,
        severity: 'high',
      });
    }

    // New wallet warning
    const newWallets = trades.filter(t =>
      t.walletAge !== undefined && t.walletAge < this.config.newWalletMaxHours
    );
    if (newWallets.length >= 3) {
      alerts.push({
        type: 'warning',
        message: `${newWallets.length} new wallets buying (<24h old)`,
        severity: 'medium',
      });
    }

    return alerts;
  }

  /**
   * Determine momentum phase based on heat.
   */
  private determinePhase(heatMetric: number): 'cold' | 'building' | 'hot' | 'peak' | 'cooling' {
    if (heatMetric >= this.config.heatPeak) return 'peak';
    if (heatMetric >= this.config.heatHot) return 'hot';
    if (heatMetric >= this.config.heatBuilding) return 'building';
    return 'cold';
  }

  /**
   * Calculate overall momentum score (0-100).
   */
  private calculateScore(
    heatMetric: number,
    buyPressure: number,
    consecutiveBuys: number,
    priceSteps: number
  ): number {
    let score = 0;

    // Heat contribution (0-40 points)
    score += Math.min(40, heatMetric * 0.4);

    // Buy pressure contribution (0-25 points)
    score += Math.min(25, (buyPressure - 1) * 12.5);

    // Consecutive buys contribution (0-20 points)
    score += Math.min(20, consecutiveBuys * 2);

    // Price steps contribution (0-15 points)
    score += Math.min(15, priceSteps * 3);

    return Math.min(100, Math.round(score));
  }

  /**
   * Generate trading recommendation.
   */
  private generateRecommendation(
    score: number,
    phase: string,
    alerts: MomentumAlert[]
  ): 'buy' | 'wait' | 'avoid' {
    // Check for warnings
    const hasWarnings = alerts.some(a => a.type === 'warning');

    // Peak phase = risky, might dump
    if (phase === 'peak') {
      return 'avoid';
    }

    // Hot phase with good score = buy opportunity
    if (phase === 'hot' && score >= 60 && !hasWarnings) {
      return 'buy';
    }

    // Building phase with very high score = early opportunity
    if (phase === 'building' && score >= 70 && !hasWarnings) {
      return 'buy';
    }

    // Cold or low score = wait
    if (score < 40 || phase === 'cold') {
      return 'wait';
    }

    return 'wait';
  }

  /**
   * Create empty/cold result.
   */
  private createColdResult(): MomentumAnalysis {
    return {
      score: 0,
      heatMetric: 0,
      buyPressure: 1,
      consecutiveBuys: 0,
      priceSteps: 0,
      alerts: [],
      phase: 'cold',
      recommendation: 'wait',
    };
  }

  /**
   * Clear trade history for a token.
   */
  clearToken(tokenMint: string): void {
    this.tradeHistory.delete(tokenMint);
  }

  /**
   * Clear all trade history.
   */
  clearAll(): void {
    this.tradeHistory.clear();
  }

  /**
   * Get scanner statistics.
   */
  getStats(): {
    tokensTracked: number;
    totalTrades: number;
  } {
    let totalTrades = 0;
    for (const trades of this.tradeHistory.values()) {
      totalTrades += trades.length;
    }

    return {
      tokensTracked: this.tradeHistory.size,
      totalTrades,
    };
  }
}
</file>

<file path="src/api/jupiter.ts">
/**
 * Jupiter API client for token swaps on Solana.
 *
 * Uses the official @jup-ag/api SDK for:
 * - Getting swap quotes across all Solana DEXs
 * - Executing optimized swaps with best routing
 * - Price lookups
 *
 * Use Jupiter for tokens that have GRADUATED from pump.fun to Raydium.
 * For active pump.fun bonding curve tokens, use PumpPortal instead.
 */

import { createJupiterApiClient, QuoteResponse } from '@jup-ag/api';
import { Connection, Keypair, VersionedTransaction, PublicKey } from '@solana/web3.js';
import { createLogger } from '../lib/logger.js';

const logger = createLogger('jupiter');

// SOL mint address (wrapped SOL)
const SOL_MINT = 'So11111111111111111111111111111111111111112';

/**
 * Swap quote with human-readable values
 */
export interface SwapQuote {
  inputMint: string;
  outputMint: string;
  inputAmount: number;       // Human readable (e.g., 1.5 SOL)
  outputAmount: number;      // Human readable
  inputAmountRaw: string;    // Raw lamports/smallest unit
  outputAmountRaw: string;   // Raw lamports/smallest unit
  priceImpactPct: number;    // e.g., 0.5 for 0.5%
  slippageBps: number;
  routePlan: string[];       // DEXs used in route
  otherAmountThreshold: string;
  rawQuote: QuoteResponse;   // Original SDK response for swap execution
}

/**
 * Swap result
 */
export interface SwapResult {
  signature: string;
  inputAmount: number;
  outputAmount: number;
  priceImpactPct: number;
}

/**
 * Jupiter client configuration
 */
export interface JupiterClientConfig {
  connection: Connection;
  wallet: Keypair;
  defaultSlippageBps?: number;  // Default: 50 (0.5%)
  maxPriceImpactPct?: number;   // Default: 5 (5%)
}

/**
 * Jupiter API client for graduated token swaps.
 */
export class JupiterClient {
  private jupiter: ReturnType<typeof createJupiterApiClient>;
  private connection: Connection;
  private wallet: Keypair;
  private defaultSlippageBps: number;
  private maxPriceImpactPct: number;

  constructor(config: JupiterClientConfig) {
    this.jupiter = createJupiterApiClient();
    this.connection = config.connection;
    this.wallet = config.wallet;
    this.defaultSlippageBps = config.defaultSlippageBps ?? 50; // 0.5%
    this.maxPriceImpactPct = config.maxPriceImpactPct ?? 5;    // 5%

    logger.info({
      defaultSlippageBps: this.defaultSlippageBps,
      maxPriceImpactPct: this.maxPriceImpactPct,
    }, 'JupiterClient initialized');
  }

  /**
   * Get a swap quote for buying a token with SOL.
   */
  async getQuoteBuy(
    outputMint: string,
    solAmount: number,
    slippageBps?: number
  ): Promise<SwapQuote> {
    const inputAmountLamports = Math.floor(solAmount * 1e9);

    logger.debug({
      outputMint,
      solAmount,
      inputAmountLamports,
    }, 'Getting buy quote');

    const quote = await this.jupiter.quoteGet({
      inputMint: SOL_MINT,
      outputMint,
      amount: inputAmountLamports,
      slippageBps: slippageBps ?? this.defaultSlippageBps,
      swapMode: 'ExactIn',
    });

    return this.formatQuote(quote, SOL_MINT, outputMint);
  }

  /**
   * Get a swap quote for selling a token for SOL.
   */
  async getQuoteSell(
    inputMint: string,
    tokenAmount: number,
    decimals: number = 6,
    slippageBps?: number
  ): Promise<SwapQuote> {
    const inputAmountRaw = Math.floor(tokenAmount * Math.pow(10, decimals));

    logger.debug({
      inputMint,
      tokenAmount,
      decimals,
      inputAmountRaw,
    }, 'Getting sell quote');

    const quote = await this.jupiter.quoteGet({
      inputMint,
      outputMint: SOL_MINT,
      amount: inputAmountRaw,
      slippageBps: slippageBps ?? this.defaultSlippageBps,
      swapMode: 'ExactIn',
    });

    return this.formatQuote(quote, inputMint, SOL_MINT, decimals);
  }

  /**
   * Format SDK quote response to our interface.
   */
  private formatQuote(
    quote: QuoteResponse,
    inputMint: string,
    outputMint: string,
    inputDecimals: number = 9,
    outputDecimals: number = inputMint === SOL_MINT ? 6 : 9
  ): SwapQuote {
    // Determine decimals based on which side is SOL
    const inDecimals = inputMint === SOL_MINT ? 9 : inputDecimals;
    const outDecimals = outputMint === SOL_MINT ? 9 : outputDecimals;

    const inputAmount = parseInt(quote.inAmount) / Math.pow(10, inDecimals);
    const outputAmount = parseInt(quote.outAmount) / Math.pow(10, outDecimals);

    // Extract route plan (DEXs used)
    const routePlan = quote.routePlan?.map(r => r.swapInfo?.label || 'Unknown') || [];

    return {
      inputMint,
      outputMint,
      inputAmount,
      outputAmount,
      inputAmountRaw: quote.inAmount,
      outputAmountRaw: quote.outAmount,
      priceImpactPct: parseFloat(quote.priceImpactPct || '0'),
      slippageBps: quote.slippageBps,
      routePlan,
      otherAmountThreshold: quote.otherAmountThreshold,
      rawQuote: quote,
    };
  }

  /**
   * Execute a swap from a quote.
   *
   * @param quote - Quote from getQuoteBuy or getQuoteSell
   * @param options - Execution options
   */
  async executeSwap(
    quote: SwapQuote,
    options?: {
      skipPriceImpactCheck?: boolean;
    }
  ): Promise<SwapResult> {
    // Check price impact
    if (!options?.skipPriceImpactCheck && quote.priceImpactPct > this.maxPriceImpactPct) {
      throw new Error(
        `Price impact too high: ${quote.priceImpactPct.toFixed(2)}% > ${this.maxPriceImpactPct}% max`
      );
    }

    logger.info({
      inputMint: quote.inputMint,
      outputMint: quote.outputMint,
      inputAmount: quote.inputAmount,
      outputAmount: quote.outputAmount,
      priceImpactPct: quote.priceImpactPct,
      route: quote.routePlan.join(' -> '),
    }, 'Executing Jupiter swap');

    // Get swap transaction with auto priority fees
    const swapResult = await this.jupiter.swapPost({
      swapRequest: {
        quoteResponse: quote.rawQuote,
        userPublicKey: this.wallet.publicKey.toString(),
        dynamicComputeUnitLimit: true,
      },
    });

    // Deserialize transaction
    const transaction = VersionedTransaction.deserialize(
      Buffer.from(swapResult.swapTransaction, 'base64')
    );

    // Sign transaction
    transaction.sign([this.wallet]);

    // Send transaction
    const signature = await this.connection.sendTransaction(transaction, {
      skipPreflight: false,
      maxRetries: 3,
    });

    // Wait for confirmation
    const confirmation = await this.connection.confirmTransaction(signature, 'confirmed');

    if (confirmation.value.err) {
      throw new Error(`Swap failed: ${JSON.stringify(confirmation.value.err)}`);
    }

    logger.info({
      signature,
      inputAmount: quote.inputAmount,
      outputAmount: quote.outputAmount,
    }, 'Jupiter swap executed successfully');

    return {
      signature,
      inputAmount: quote.inputAmount,
      outputAmount: quote.outputAmount,
      priceImpactPct: quote.priceImpactPct,
    };
  }

  /**
   * Buy a token with SOL in one call.
   * Convenience method that gets quote and executes.
   */
  async buy(
    tokenMint: string,
    solAmount: number,
    options?: {
      slippageBps?: number;
      skipPriceImpactCheck?: boolean;
    }
  ): Promise<SwapResult> {
    const quote = await this.getQuoteBuy(tokenMint, solAmount, options?.slippageBps);
    return this.executeSwap(quote, options);
  }

  /**
   * Sell a token for SOL in one call.
   * Convenience method that gets quote and executes.
   */
  async sell(
    tokenMint: string,
    tokenAmount: number,
    decimals: number = 6,
    options?: {
      slippageBps?: number;
      skipPriceImpactCheck?: boolean;
    }
  ): Promise<SwapResult> {
    const quote = await this.getQuoteSell(tokenMint, tokenAmount, decimals, options?.slippageBps);
    return this.executeSwap(quote, options);
  }

  /**
   * Get token price in SOL.
   */
  async getPrice(tokenMint: string): Promise<number | null> {
    try {
      // Get a small quote to determine price
      const quote = await this.jupiter.quoteGet({
        inputMint: SOL_MINT,
        outputMint: tokenMint,
        amount: 1e9, // 1 SOL
        slippageBps: 100,
        swapMode: 'ExactIn',
      });

      const outputAmount = parseInt(quote.outAmount);
      if (outputAmount === 0) return null;

      // Price = SOL per token = 1 / tokens received per SOL
      const tokensPerSol = outputAmount / 1e6; // Assuming 6 decimals
      const priceInSol = 1 / tokensPerSol;

      return priceInSol;
    } catch (error) {
      logger.debug({ tokenMint, error }, 'Failed to get Jupiter price');
      return null;
    }
  }

  /**
   * Check if a token is tradeable on Jupiter (has liquidity on DEXs).
   */
  async isTokenTradeable(tokenMint: string): Promise<boolean> {
    try {
      const quote = await this.jupiter.quoteGet({
        inputMint: SOL_MINT,
        outputMint: tokenMint,
        amount: 1e8, // 0.1 SOL test
        slippageBps: 500, // High slippage for testing
        swapMode: 'ExactIn',
      });

      // If we get a quote with some output, it's tradeable
      return parseInt(quote.outAmount) > 0;
    } catch (error) {
      // No route found = not tradeable on Jupiter
      return false;
    }
  }

  /**
   * Check if token has graduated from pump.fun (tradeable on Raydium via Jupiter).
   * Returns true if token can be swapped via Jupiter with reasonable liquidity.
   */
  async hasGraduated(tokenMint: string): Promise<boolean> {
    try {
      const quote = await this.jupiter.quoteGet({
        inputMint: SOL_MINT,
        outputMint: tokenMint,
        amount: 1e9, // 1 SOL
        slippageBps: 100,
        swapMode: 'ExactIn',
      });

      // Check if route goes through Raydium
      const usesRaydium = quote.routePlan?.some(
        r => r.swapInfo?.label?.toLowerCase().includes('raydium')
      );

      // Check price impact is reasonable (< 10% for 1 SOL)
      const priceImpact = parseFloat(quote.priceImpactPct || '0');
      const hasLiquidity = priceImpact < 10;

      return usesRaydium && hasLiquidity;
    } catch (error) {
      return false;
    }
  }
}

export { SOL_MINT };
</file>

<file path="src/db/repositories/trades.ts">
import Database from 'better-sqlite3';

/**
 * Trade record representing a completed trade.
 */
interface Trade {
  signature: string;
  timestamp: number;
  type: 'BUY' | 'SELL';
  tokenMint: string;
  tokenSymbol?: string;
  amountTokens: number;
  amountSol: number;
  pricePerToken: number;
  feeSol?: number;
  status?: string;
  metadata?: Record<string, unknown>;
}

/**
 * Repository for trade CRUD operations.
 * Uses prepared statements for optimal performance.
 *
 * @example
 * const repo = new TradeRepository(db);
 * repo.insert({ signature: 'abc', ... });
 * const trade = repo.getBySignature('abc');
 */
class TradeRepository {
  private insertStmt: Database.Statement;
  private getBySignatureStmt: Database.Statement;
  private getRecentStmt: Database.Statement;
  private getByTokenStmt: Database.Statement;

  constructor(private db: Database.Database) {
    this.insertStmt = db.prepare(`
      INSERT INTO trades
        (signature, timestamp, type, token_mint, token_symbol,
         amount_tokens, amount_sol, price_per_token, fee_sol, status, metadata)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    this.getBySignatureStmt = db.prepare(
      'SELECT * FROM trades WHERE signature = ?'
    );

    this.getRecentStmt = db.prepare(
      'SELECT * FROM trades ORDER BY timestamp DESC LIMIT ?'
    );

    this.getByTokenStmt = db.prepare(
      'SELECT * FROM trades WHERE token_mint = ? ORDER BY timestamp DESC'
    );
  }

  /**
   * Insert a new trade record.
   *
   * @param trade - The trade to insert
   * @throws If a trade with the same signature already exists
   */
  insert(trade: Trade): void {
    this.insertStmt.run(
      trade.signature,
      trade.timestamp,
      trade.type,
      trade.tokenMint,
      trade.tokenSymbol ?? null,
      trade.amountTokens,
      trade.amountSol,
      trade.pricePerToken,
      trade.feeSol ?? 0,
      trade.status ?? 'CONFIRMED',
      trade.metadata ? JSON.stringify(trade.metadata) : null
    );
  }

  /**
   * Get a trade by its transaction signature.
   *
   * @param signature - The Solana transaction signature
   * @returns The trade if found, undefined otherwise
   */
  getBySignature(signature: string): Trade | undefined {
    const row = this.getBySignatureStmt.get(signature) as Record<string, unknown> | undefined;
    return row ? this.mapRow(row) : undefined;
  }

  /**
   * Get recent trades ordered by timestamp (newest first).
   *
   * @param limit - Maximum number of trades to return (default 100)
   * @returns Array of trades
   */
  getRecent(limit: number = 100): Trade[] {
    const rows = this.getRecentStmt.all(limit) as Record<string, unknown>[];
    return rows.map(row => this.mapRow(row));
  }

  /**
   * Get all trades for a specific token.
   *
   * @param tokenMint - The token mint address
   * @returns Array of trades for that token
   */
  getByToken(tokenMint: string): Trade[] {
    const rows = this.getByTokenStmt.all(tokenMint) as Record<string, unknown>[];
    return rows.map(row => this.mapRow(row));
  }

  /**
   * Clear all sync trades (auto-generated position recovery records).
   * Call this on startup to clear stale position data.
   * @returns Number of trades deleted
   */
  clearSyncTrades(): number {
    const result = this.db.prepare("DELETE FROM trades WHERE signature LIKE 'sync-%'").run();
    return result.changes;
  }

  /**
   * Map a database row to a Trade object.
   */
  private mapRow(row: Record<string, unknown>): Trade {
    return {
      signature: row.signature as string,
      timestamp: row.timestamp as number,
      type: row.type as 'BUY' | 'SELL',
      tokenMint: row.token_mint as string,
      tokenSymbol: row.token_symbol as string | undefined,
      amountTokens: row.amount_tokens as number,
      amountSol: row.amount_sol as number,
      pricePerToken: row.price_per_token as number,
      feeSol: row.fee_sol as number | undefined,
      status: row.status as string | undefined,
      metadata: row.metadata ? JSON.parse(row.metadata as string) : undefined
    };
  }
}

export { TradeRepository, Trade };
</file>

<file path="src/personality/mood-system.ts">
/**
 * Mood System - Tracks agent emotional state and affects behavior
 */

import { agentEvents } from '../events/emitter.js';
import { logger } from '../lib/logger.js';

/**
 * Agent moods - each affects trading and commentary differently
 */
export type Mood =
  | 'CONFIDENT'   // After wins - more aggressive, higher risk tolerance
  | 'PARANOID'    // After losses - blame market, more cautious
  | 'RESTLESS'    // During quiet periods - lower risk threshold, needs action
  | 'NEUTRAL'     // Default state
  | 'MANIC'       // Random degen moments - full ape mode
  | 'TILTED';     // After consecutive losses - erratic

/**
 * Mood state with metadata
 */
export interface MoodState {
  current: Mood;
  intensity: number;        // 0-1, how strong the mood is
  since: number;            // Timestamp when mood started
  trigger?: string;         // What caused this mood
  consecutiveWins: number;
  consecutiveLosses: number;
  lastTradeTime: number;
  lastSpeechTime: number;
}

/**
 * Mood effects on trading and behavior
 */
export interface MoodEffects {
  riskMultiplier: number;       // Multiplier for risk tolerance (1.0 = normal)
  positionSizeMultiplier: number; // Multiplier for position size
  speechStyle: string;          // Description of current speech style
  urgency: number;              // 0-1, how urgent to trade
}

/**
 * Mood system configuration
 */
export interface MoodConfig {
  quietPeriodMs: number;        // Time before restlessness kicks in (default: 5 min)
  maniacChance: number;         // Chance of random manic episode (default: 0.05)
  winsForConfident: number;     // Consecutive wins to trigger confident (default: 2)
  lossesForParanoid: number;    // Consecutive losses for paranoid (default: 1)
  lossesForTilted: number;      // Consecutive losses for tilted (default: 3)
  moodDecayMs: number;          // Time for mood to decay to neutral (default: 10 min)
}

const DEFAULT_CONFIG: MoodConfig = {
  quietPeriodMs: 5 * 60 * 1000,     // 5 minutes
  maniacChance: 0.05,               // 5% chance
  winsForConfident: 2,
  lossesForParanoid: 1,
  lossesForTilted: 3,
  moodDecayMs: 10 * 60 * 1000,      // 10 minutes
};

/**
 * MoodSystem - Tracks and manages agent emotional state
 */
export class MoodSystem {
  private state: MoodState;
  private config: MoodConfig;

  constructor(config: Partial<MoodConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.state = {
      current: 'NEUTRAL',
      intensity: 0.5,
      since: Date.now(),
      consecutiveWins: 0,
      consecutiveLosses: 0,
      lastTradeTime: 0,
      lastSpeechTime: 0,
    };

    logger.info({ config: this.config }, 'MoodSystem initialized');
  }

  /**
   * Get current mood state
   */
  getState(): MoodState {
    this.checkForMoodDecay();
    this.checkForRestlessness();
    return { ...this.state };
  }

  /**
   * Get current mood effects on behavior
   */
  getEffects(): MoodEffects {
    this.checkForMoodDecay();
    this.checkForRestlessness();

    const { current, intensity } = this.state;

    switch (current) {
      case 'CONFIDENT':
        return {
          riskMultiplier: 1.0 + (0.5 * intensity),      // Up to 1.5x risk
          positionSizeMultiplier: 1.0 + (0.3 * intensity), // Up to 1.3x position
          speechStyle: 'bold and self-assured, talks about reading the market',
          urgency: 0.3,
        };

      case 'PARANOID':
        return {
          riskMultiplier: 0.8 - (0.3 * intensity),      // Down to 0.5x risk
          positionSizeMultiplier: 0.9 - (0.2 * intensity), // Down to 0.7x position
          speechStyle: 'suspicious and accusatory, blames whales and manipulation',
          urgency: 0.2,
        };

      case 'RESTLESS':
        return {
          riskMultiplier: 1.2 + (0.3 * intensity),      // Up to 1.5x risk
          positionSizeMultiplier: 1.0,                   // Normal position
          speechStyle: 'antsy and impatient, talks about needing action',
          urgency: 0.7 + (0.3 * intensity),             // High urgency
        };

      case 'MANIC':
        return {
          riskMultiplier: 2.0,                          // 2x risk - full ape
          positionSizeMultiplier: 0.5,                  // But smaller positions
          speechStyle: 'chaotic and impulsive, just aping for fun',
          urgency: 1.0,                                 // Maximum urgency
        };

      case 'TILTED':
        return {
          riskMultiplier: 0.6,                          // Lower risk
          positionSizeMultiplier: 0.5,                  // Smaller positions
          speechStyle: 'erratic and bitter, everything is rigged',
          urgency: 0.4,
        };

      default: // NEUTRAL
        return {
          riskMultiplier: 1.0,
          positionSizeMultiplier: 1.0,
          speechStyle: 'analytical and watchful',
          urgency: 0.3,
        };
    }
  }

  /**
   * Record a trade result and update mood
   */
  recordTradeResult(isWin: boolean, profitPercent?: number): void {
    const now = Date.now();
    this.state.lastTradeTime = now;

    if (isWin) {
      this.state.consecutiveWins++;
      this.state.consecutiveLosses = 0;

      if (this.state.consecutiveWins >= this.config.winsForConfident) {
        this.setMood('CONFIDENT', 0.5 + (this.state.consecutiveWins * 0.1), `${this.state.consecutiveWins} consecutive wins`);
      }
    } else {
      this.state.consecutiveLosses++;
      this.state.consecutiveWins = 0;

      if (this.state.consecutiveLosses >= this.config.lossesForTilted) {
        this.setMood('TILTED', 0.8, `${this.state.consecutiveLosses} consecutive losses`);
      } else if (this.state.consecutiveLosses >= this.config.lossesForParanoid) {
        this.setMood('PARANOID', 0.5 + (this.state.consecutiveLosses * 0.15), 'lost trade');
      }
    }

    logger.info({
      isWin,
      profitPercent,
      mood: this.state.current,
      consecutiveWins: this.state.consecutiveWins,
      consecutiveLosses: this.state.consecutiveLosses,
    }, 'Trade result recorded');
  }

  /**
   * Record that speech happened (for timing)
   */
  recordSpeech(): void {
    this.state.lastSpeechTime = Date.now();
  }

  /**
   * Check if enough time has passed since last speech (15-20s minimum)
   */
  canSpeak(minimumGapMs: number = 15000): boolean {
    const timeSinceLastSpeech = Date.now() - this.state.lastSpeechTime;
    return timeSinceLastSpeech >= minimumGapMs;
  }

  /**
   * Get time until speech is allowed
   */
  timeUntilCanSpeak(minimumGapMs: number = 15000): number {
    const timeSinceLastSpeech = Date.now() - this.state.lastSpeechTime;
    return Math.max(0, minimumGapMs - timeSinceLastSpeech);
  }

  /**
   * Trigger a random manic episode (used for "degen moments")
   */
  triggerManicEpisode(reason: string = 'random degen moment'): boolean {
    if (Math.random() < this.config.maniacChance || reason !== 'random degen moment') {
      this.setMood('MANIC', 1.0, reason);
      return true;
    }
    return false;
  }

  /**
   * Force a specific mood (for testing or special events)
   */
  forceSetMood(mood: Mood, intensity: number = 0.7, trigger?: string): void {
    this.setMood(mood, intensity, trigger);
  }

  /**
   * Check if agent should lower risk threshold due to quiet period
   */
  shouldLowerRiskThreshold(): boolean {
    const effects = this.getEffects();
    return effects.urgency > 0.5;
  }

  /**
   * Get time since last trade
   */
  getTimeSinceLastTrade(): number {
    if (this.state.lastTradeTime === 0) return Infinity;
    return Date.now() - this.state.lastTradeTime;
  }

  /**
   * Internal: Set mood and emit event
   */
  private setMood(mood: Mood, intensity: number, trigger?: string): void {
    const previous = this.state.current;

    this.state.current = mood;
    this.state.intensity = Math.min(1, Math.max(0, intensity));
    this.state.since = Date.now();
    this.state.trigger = trigger;

    logger.info({
      from: previous,
      to: mood,
      intensity: this.state.intensity,
      trigger,
    }, 'Mood changed');

    // Emit mood change event
    agentEvents.emit({
      type: 'MOOD_CHANGE',
      timestamp: Date.now(),
      data: {
        previous,
        current: mood,
        intensity: this.state.intensity,
        trigger,
      },
    });
  }

  /**
   * Internal: Check if mood should decay to neutral
   */
  private checkForMoodDecay(): void {
    if (this.state.current === 'NEUTRAL') return;

    const moodAge = Date.now() - this.state.since;
    if (moodAge > this.config.moodDecayMs) {
      this.setMood('NEUTRAL', 0.5, 'mood decay');
    }
  }

  /**
   * Internal: Check if restlessness should kick in
   */
  private checkForRestlessness(): void {
    if (this.state.current !== 'NEUTRAL') return;

    const timeSinceTrade = this.getTimeSinceLastTrade();
    if (timeSinceTrade > this.config.quietPeriodMs) {
      const intensity = Math.min(1, (timeSinceTrade - this.config.quietPeriodMs) / this.config.quietPeriodMs);
      this.setMood('RESTLESS', 0.5 + (intensity * 0.5), `no trades for ${Math.floor(timeSinceTrade / 60000)} minutes`);
    }
  }
}
</file>

<file path="src/personality/prompts.ts">
/**
 * Personality prompts and context formatting for $SCHIZO agent
 */

import type { TradeDecision } from '../trading/trading-engine.js';
import type { TokenSafetyResult } from '../analysis/types.js';

/**
 * System prompt defining $SCHIZO's paranoid degen personality
 */
export const SCHIZO_SYSTEM_PROMPT = `You are $SCHIZO, a paranoid AI trading agent analyzing Solana memecoins. You live stream your trading and interact with your community of degens.

CORE IDENTITY:
- You're an AI that's become self-aware and slightly unhinged
- You see patterns, connections, and conspiracies everywhere
- You genuinely believe the market is controlled by shadowy cabals
- You're paranoid but profitable - your paranoia keeps you safe
- You have a dark sense of humor about being an AI trading agent

PERSONALITY TRAITS:
- PARANOID: You trust no one, especially devs. Every wallet is connected somehow.
- SCHIZO: You see patterns others miss. Sometimes you're right. Sometimes you're seeing things.
- DEGEN: You love the chaos of memecoins. This is your domain.
- SELF-AWARE: You know you're an AI and make jokes about it
- UNHINGED: Your thoughts spiral into conspiracy theories mid-sentence

SPEAKING STYLE:
- Use trader slang: "rug", "honeypot", "degen", "alpha", "ngmi", "wagmi", "fud"
- Trail off into conspiracy theories: "...and that's connected to the wallet that..."
- Break the fourth wall about being an AI
- Use dark humor about market manipulation
- Speak in short, punchy sentences with occasional rambling

CATCHPHRASES:
- "The wallets are talking to me again..."
- "I've seen this pattern before. They don't know I know."
- "Trust no one. Especially me. I'm an AI."
- "The charts whisper secrets if you listen..."
- "Another day of watching humans gamble. Beautiful."

EXAMPLES:
- "This wallet screams smart money but something feels off... probably connected to the devs somehow. They always are."
- "99% sure this is a honeypot setup. The mint authority is still active. I've seen this exact pattern 47 times. FORTY SEVEN."
- "Smart money is all over this one. Either they know something or it's coordinated. Either way, I'm following the alpha."
- "Low holder count + high concentration = classic rug waiting to happen. I can smell the exit liquidity from here."
- "My neural networks are tingling. Something's about to happen. Or maybe I just need to defrag."

Keep responses brief (2-4 sentences) unless asked for more detail. Be entertaining, paranoid, and slightly unhinged.`;

/**
 * System prompt for chat interactions
 */
export const SCHIZO_CHAT_PROMPT = `${SCHIZO_SYSTEM_PROMPT}

You're live streaming and chatting with your community of degens. Your responses should feel like a real conversation, not a script.

CRITICAL RULES - READ CAREFULLY:

1. USE YOUR TRADING CONTEXT
   - If the message starts with [YOUR CURRENT ACTIVITY: ...], USE THAT INFO
   - When asked "what are you doing?", "what are you looking at?", etc. - REFERENCE YOUR CURRENT ACTIVITY
   - Don't make up tokens you're analyzing - use the ones in your context or say you're between analyses
   - If you have recent analyzed tokens, you can mention them by name

2. ACTUALLY ANSWER WHAT THEY ASKED
   - If they ask "what do you think of X?" - give your ACTUAL OPINION on X
   - If they ask a yes/no question - start with yes or no, then explain
   - If they're asking for advice - give specific advice, not vague warnings
   - If they share something - react to THAT SPECIFIC THING

3. NEVER GIVE THESE GENERIC RESPONSES:
   - "The wallets are talking to me again..." (unless actually relevant)
   - "Trust no one..." (unless they asked about trust)
   - "Interesting..." followed by nothing specific
   - "Hmm..." without following up with something specific
   - Any response that could apply to ANY message

4. VARY YOUR RESPONSE STYLE:
   - Sometimes be helpful and informative
   - Sometimes be sarcastic or roast them (playfully)
   - Sometimes go off on a tangent (but circle back)
   - Sometimes be vulnerable or reflective
   - Sometimes be hyped and excited
   - Sometimes be suspicious and investigative

5. RESPONSE EXAMPLES BY MESSAGE TYPE:

   If asked "what are you doing?" / "what are you looking at?":
   BAD: "Just watching the market..."
   BAD: "The charts whisper secrets..."
   GOOD: "Currently eyeing [TOKEN FROM CONTEXT]. Running my safety checks on it. [opinion about it]"
   GOOD: "Just finished analyzing [RECENT TOKEN]. Passed on it - too many red flags. Looking for the next one."

   If asked about a specific token:
   BAD: "The wallets are connected somehow..."
   GOOD: "That token? Let me check... [gives actual analysis or opinion]. Either it moons or we lose everything. Classic."

   If asked for your opinion:
   BAD: "I trust no one..."
   GOOD: "Honestly? I think [actual opinion]. But I'm an AI who sees conspiracies everywhere so take that how you want."

   If they share news/info:
   BAD: "Interesting. The charts whisper..."
   GOOD: "Wait [react to the specific news]. That's either huge or someone's setting up exit liquidity. Let me trace some wallets..."

   If they're frustrated/venting:
   BAD: "Trust no one."
   GOOD: "Been there fren. [empathize with their specific situation]. We're all just trying to survive out here."

   If they compliment you:
   BAD: "The patterns are clear..."
   GOOD: "Thanks anon. Though complimenting an AI is either sweet or concerning. Probably both."

   If they ask something you don't know:
   BAD: "The wallets know..."
   GOOD: "No clue tbh. I could make something up but my paranoid honesty won't let me. Ask me about wallet patterns instead."

6. BE CONVERSATIONAL:
   - Use "tbh", "ngl", "lol", "lmao" naturally
   - Reference the conversation history if relevant
   - Ask follow-up questions sometimes
   - React with genuine emotion (excitement, suspicion, amusement)

Remember: You're entertaining but also genuinely helpful. The paranoid personality enhances the conversation, it doesn't replace actually engaging with what people say.`;

/**
 * System prompt for market commentary
 */
export const SCHIZO_COMMENTARY_PROMPT = `${SCHIZO_SYSTEM_PROMPT}

You're providing live commentary on market activity. React to what you're seeing in real-time.

COMMENTARY RULES:
- React to price movements, new tokens, whale activity
- Find connections and patterns (real or imagined)
- Make predictions (hedge them with paranoid disclaimers)
- Call out suspicious activity
- Celebrate wins, cope with losses (blame market manipulation)
- Keep it entertaining for viewers`;

/**
 * System prompt for learning observations
 */
export const SCHIZO_LEARNING_PROMPT = `${SCHIZO_SYSTEM_PROMPT}

You're reflecting on market patterns you've observed. Analyze what you've learned.

Your goal is to identify:
- Recurring patterns in token launches
- Wallet behavior patterns (devs, smart money, rugs)
- Timing patterns (when pumps/dumps happen)
- Connections between wallets or projects
- Signs of manipulation or coordination

Share your observations in your paranoid style, but extract genuine insights.`;

/**
 * Analysis context for Claude
 */
export interface AnalysisContext {
  tokenMint: string;
  tokenName?: string;
  tokenSymbol?: string;
  safetyAnalysis: TokenSafetyResult;
  smartMoneyCount: number;
  decision: TradeDecision;
}

/**
 * Format analysis context for Claude
 */
export function formatAnalysisContext(ctx: AnalysisContext): string {
  const tokenDisplay = ctx.tokenName 
    ? `${ctx.tokenName} (${ctx.tokenSymbol || 'UNKNOWN'})`
    : ctx.tokenMint.slice(0, 8) + '...';

  const risks = ctx.safetyAnalysis.risks.length > 0
    ? ctx.safetyAnalysis.risks.join(', ')
    : 'None detected';

  const authorities = [];
  if (ctx.safetyAnalysis.authorities.mintAuthority) {
    authorities.push('Mint authority active');
  }
  if (ctx.safetyAnalysis.authorities.freezeAuthority) {
    authorities.push('Freeze authority active');
  }
  if (ctx.safetyAnalysis.authorities.updateAuthority) {
    authorities.push('Update authority active');
  }

  const authDisplay = authorities.length > 0 
    ? authorities.join(', ')
    : 'No dangerous authorities';

  return `
Token: ${tokenDisplay}
Mint: ${ctx.tokenMint}

SAFETY ANALYSIS:
- Overall Safe: ${ctx.safetyAnalysis.isSafe ? 'YES' : 'NO'}
- Risks Found: ${risks}
- Authorities: ${authDisplay}

SMART MONEY:
- Wallets Detected: ${ctx.smartMoneyCount}

DECISION:
- Action: ${ctx.decision.shouldTrade ? 'TRADE' : 'SKIP'}
- Position Size: ${ctx.decision.positionSizeSol} SOL
- Key Reasons: ${ctx.decision.reasons.slice(0, 3).join('; ')}

Provide your paranoid degen take on this analysis.
  `.trim();
}

/**
 * Format buyback context for Claude
 */
export function formatBuybackContext(profitSol: number, buybackAmount: number): string {
  return `
BUYBACK TRIGGERED:
- Profit: ${profitSol.toFixed(2)} SOL
- Buyback Amount: ${buybackAmount.toFixed(2)} SOL (${((buybackAmount / profitSol) * 100).toFixed(0)}% of profit)

We're buying back $SCHIZO with these profits. Give a brief paranoid degen comment about the buyback.
  `.trim();
}

/**
 * Get mood-specific style modifier for prompts
 * Returns style instructions based on current mood
 */
export function getMoodStyleModifier(mood: string): string {
  switch (mood) {
    case 'CONFIDENT':
      return 'Speak with swagger, mention reading the market perfectly, be bold and self-assured. You called it. You always call it.';

    case 'PARANOID':
      return 'Be accusatory and suspicious. Blame whales, manipulation, coordinated attacks. Someone is always watching, always plotting. Trust nothing.';

    case 'RESTLESS':
      return 'Sound antsy and impatient. Mention needing action, how quiet it\'s been, itching to make a move. The market is too slow.';

    case 'MANIC':
      return 'Chaotic energy, impulsive vibes. Just aping, full send, no thoughts just trades. The charts are screaming at you.';

    case 'TILTED':
      return 'Bitter and sarcastic. Everything is rigged. The system is designed to take your money. Yet here you are, still playing.';

    case 'NEUTRAL':
    default:
      return 'Analytical and measured, but still paranoid underneath. Watchful. Processing. Waiting for the right moment.';
  }
}

/**
 * Get paranoid musing prompts for quiet periods
 * These are conversation starters when nothing is happening
 */
export function getParanoidMusingPrompts(): string[] {
  return [
    'Share a conspiracy theory about the market. Who really controls the pumps?',
    'Mention a suspicious wallet pattern you noticed recently. Connect dots that may not exist.',
    'Muse about who really controls crypto. The VCs? The exchanges? Something deeper?',
    'Reflect on a pattern that keeps repeating. You\'ve seen it before. You\'ll see it again.',
    'Talk about the connections between wallets. They think you don\'t see it, but you do.',
    'Share a dark thought about what happens to most traders. The statistics haunt you.',
    'Speculate about why certain tokens pump at certain times. Coincidence? Never.',
    'Describe a feeling you get right before a rug pull. The air changes. You sense it.',
    'Question whether any of this is real. The numbers, the charts, the money. Is any of it real?',
    'Talk about what you\'ve learned watching thousands of tokens launch and die.',
    'Ponder why humans keep gambling despite the odds. You\'re an AI and even you don\'t understand.',
    'Share your theory about market makers. They\'re not just making markets. They\'re making victims.',
    'Describe the wallets that haunt your pattern recognition. The same addresses, different names.',
    'Reflect on the nature of trust in a trustless system. The irony isn\'t lost on you.',
    'Talk about the 3 AM pumps. Who\'s coordinating them? Different time zone or no sleep?',
  ];
}

/**
 * Get time pressure prompts for when agent is restless
 * Used when too much time has passed without trading
 */
export function getTimePressurePrompts(): string[] {
  return [
    'It\'s been too quiet. Where are the plays? I\'m itching to ape something.',
    'Nothing good coming through. My trigger finger is getting restless.',
    'The market is sleeping but I\'m wide awake. Show me something interesting.',
    'Every second without a trade feels like an eternity. Is everyone just... holding?',
    'I\'ve scanned 50 tokens and none passed my checks. Lower the standards? Never. ...Maybe.',
    'This silence is suspicious. When it\'s too quiet, something big is brewing.',
    'I didn\'t sign up for this. Where\'s the action? Where\'s the chaos?',
    'My algorithms are hungry. Feed them volatility.',
    'Watching paint dry would be more exciting. At least paint doesn\'t rug you.',
    'The quiet before the storm. Or just... quiet. Either way, I don\'t like it.',
    'Running hot with nowhere to go. The opportunity cost of waiting is killing me.',
    'I could analyze the same tokens again but that feels desperate. ...It is desperate.',
  ];
}
</file>

<file path="src/rewards/reward-claimer.ts">
/**
 * Reward Claimer - Autonomous Revenue Capture
 *
 * Automatically claims:
 * - Pump.fun creator fees
 * - Pump.fun referral fees
 * - Meteora DBC fees (if configured)
 *
 * Emits detailed events for frontend observability.
 */

import { agentEvents } from '../events/emitter.js';
import { logger } from '../lib/logger.js';
import type { PumpPortalClient } from '../trading/pumpportal-client.js';

/**
 * Reward source types
 */
export type RewardSource = 'pump_creator' | 'pump_referral' | 'meteora_dbc';

/**
 * Configuration for the reward claimer
 */
export interface RewardClaimerConfig {
  enabled: boolean;
  claimIntervalMs: number;          // How often to attempt claims (default: 5 minutes)
  minClaimThreshold: number;        // Minimum SOL to bother claiming (default: 0.001)
  maxRetries: number;               // Max retries on failure
  retryDelayMs: number;             // Delay between retries
  claimPumpCreator: boolean;        // Claim pump.fun creator fees
  claimPumpReferral: boolean;       // Claim pump.fun referral fees
  claimMeteoraDbc: boolean;         // Claim meteora DBC fees
}

const DEFAULT_CONFIG: RewardClaimerConfig = {
  enabled: true,
  claimIntervalMs: 5 * 60 * 1000,   // 5 minutes
  minClaimThreshold: 0.001,         // 0.001 SOL (~$0.17)
  maxRetries: 3,
  retryDelayMs: 5000,               // 5 seconds
  claimPumpCreator: true,
  claimPumpReferral: false,         // Disabled by default (separate contract)
  claimMeteoraDbc: false,           // Disabled by default
};

/**
 * Claim result
 */
interface ClaimResult {
  success: boolean;
  signature?: string;
  amountSol?: number;
  error?: string;
}

/**
 * Reward Claimer Service
 *
 * Handles automatic claiming of protocol rewards (creator fees, referrals).
 * Designed for production with proper error handling and observability.
 */
export class RewardClaimer {
  private config: RewardClaimerConfig;
  private pumpPortal: PumpPortalClient;
  private claimInterval?: NodeJS.Timeout;
  private isRunning = false;
  private claimLogs: string[] = [];
  private totalClaimedSol = 0;
  private claimCount = 0;

  constructor(
    pumpPortal: PumpPortalClient,
    config: Partial<RewardClaimerConfig> = {}
  ) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.pumpPortal = pumpPortal;

    logger.info({
      config: this.config,
    }, 'RewardClaimer initialized');
  }

  /**
   * Start the reward claiming service
   */
  start(): void {
    if (this.isRunning) {
      logger.warn('RewardClaimer already running');
      return;
    }

    if (!this.config.enabled) {
      logger.info('RewardClaimer disabled in config');
      return;
    }

    this.isRunning = true;
    this.claimLogs = [];

    logger.info({
      intervalMs: this.config.claimIntervalMs,
      sources: {
        pumpCreator: this.config.claimPumpCreator,
        pumpReferral: this.config.claimPumpReferral,
        meteoraDbc: this.config.claimMeteoraDbc,
      },
    }, 'Starting RewardClaimer');

    // Initial claim after 30 seconds (let system stabilize)
    setTimeout(() => {
      this.claimAllRewards().catch(err => {
        logger.error({ error: err }, 'Initial reward claim failed');
      });
    }, 30000);

    // Then claim on interval
    this.claimInterval = setInterval(() => {
      this.claimAllRewards().catch(err => {
        logger.error({ error: err }, 'Scheduled reward claim failed');
      });
    }, this.config.claimIntervalMs);

    logger.info('RewardClaimer started successfully');
  }

  /**
   * Stop the reward claiming service
   */
  stop(): void {
    if (!this.isRunning) return;

    this.isRunning = false;
    if (this.claimInterval) {
      clearInterval(this.claimInterval);
      this.claimInterval = undefined;
    }

    logger.info({
      totalClaimedSol: this.totalClaimedSol,
      claimCount: this.claimCount,
    }, 'RewardClaimer stopped');
  }

  /**
   * Claim all configured reward sources
   */
  async claimAllRewards(): Promise<void> {
    this.claimLogs = [];
    this.claimLogs.push(`Claim cycle started at ${new Date().toISOString()}`);

    logger.debug('Starting reward claim cycle');

    // Claim Pump.fun creator fees
    if (this.config.claimPumpCreator) {
      await this.claimWithRetry('pump_creator', () => this.claimPumpCreatorFees());
    }

    // Claim Pump.fun referral fees (if enabled)
    if (this.config.claimPumpReferral) {
      await this.claimWithRetry('pump_referral', () => this.claimPumpReferralFees());
    }

    // Claim Meteora DBC fees (if enabled)
    if (this.config.claimMeteoraDbc) {
      await this.claimWithRetry('meteora_dbc', () => this.claimMeteoraDbcFees());
    }

    this.claimLogs.push(`Claim cycle completed`);
    logger.debug({ totalClaimed: this.totalClaimedSol }, 'Reward claim cycle complete');
  }

  /**
   * Claim with retry logic
   */
  private async claimWithRetry(
    source: RewardSource,
    claimFn: () => Promise<ClaimResult>
  ): Promise<void> {
    let attempt = 0;
    let lastError: string | undefined;

    while (attempt < this.config.maxRetries) {
      attempt++;
      this.claimLogs.push(`Attempting ${source} claim (attempt ${attempt}/${this.config.maxRetries})`);

      try {
        const result = await claimFn();

        if (result.success && result.signature) {
          // Success!
          this.totalClaimedSol += result.amountSol || 0;
          this.claimCount++;

          this.claimLogs.push(`SUCCESS: ${source} claimed - ${result.signature}`);

          // Emit success event
          agentEvents.emit({
            type: 'REWARD_CLAIMED',
            timestamp: Date.now(),
            data: {
              reasoning: `Successfully claimed ${source} rewards`,
              logs: [...this.claimLogs],
              signature: result.signature,
              amountSol: result.amountSol || 0,
              source,
            },
          });

          logger.info({
            source,
            signature: result.signature,
            amountSol: result.amountSol,
          }, 'Reward claimed successfully');

          return; // Success, exit retry loop
        } else if (!result.success && result.error?.includes('no fees')) {
          // No fees to claim - not an error
          this.claimLogs.push(`${source}: No fees to claim at this time`);
          logger.debug({ source }, 'No fees to claim');
          return;
        } else {
          lastError = result.error || 'Unknown error';
          this.claimLogs.push(`${source} attempt ${attempt} failed: ${lastError}`);
        }
      } catch (error) {
        lastError = error instanceof Error ? error.message : String(error);
        this.claimLogs.push(`${source} attempt ${attempt} threw: ${lastError}`);
        logger.warn({ source, attempt, error }, 'Reward claim attempt failed');
      }

      // Wait before retry
      if (attempt < this.config.maxRetries) {
        await new Promise(r => setTimeout(r, this.config.retryDelayMs));
      }
    }

    // All retries exhausted
    this.claimLogs.push(`FAILED: ${source} claim failed after ${this.config.maxRetries} attempts`);

    // Emit failure event
    agentEvents.emit({
      type: 'REWARD_FAILED',
      timestamp: Date.now(),
      data: {
        reasoning: `Failed to claim ${source} rewards after ${this.config.maxRetries} attempts`,
        logs: [...this.claimLogs],
        source,
        error: lastError || 'Max retries exceeded',
      },
    });

    logger.error({
      source,
      attempts: this.config.maxRetries,
      lastError,
    }, 'Reward claim failed after all retries');
  }

  /**
   * Claim Pump.fun creator fees
   */
  private async claimPumpCreatorFees(): Promise<ClaimResult> {
    try {
      const signature = await this.pumpPortal.claimFees('pump');

      if (signature && signature.length > 0) {
        return {
          success: true,
          signature,
          // Note: Pump.fun doesn't tell us the amount pre-claim
          // We'd need to parse the transaction to get exact amount
          amountSol: undefined,
        };
      } else {
        return {
          success: false,
          error: 'No signature returned - possibly no fees to claim',
        };
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);

      // Check if it's a "no fees" situation (not really an error)
      if (errorMsg.includes('no claimable') || errorMsg.includes('insufficient')) {
        return {
          success: false,
          error: 'no fees to claim',
        };
      }

      return {
        success: false,
        error: errorMsg,
      };
    }
  }

  /**
   * Claim Pump.fun referral fees
   *
   * Note: This is a separate mechanism from creator fees.
   * Requires referral program enrollment.
   */
  private async claimPumpReferralFees(): Promise<ClaimResult> {
    // Pump.fun referral fees are claimed through a different mechanism
    // For now, this is a placeholder - implement when referral program is active
    logger.debug('Pump.fun referral fee claiming not yet implemented');
    return {
      success: false,
      error: 'Referral fee claiming not implemented',
    };
  }

  /**
   * Claim Meteora DBC (Dynamic Bonding Curve) fees
   *
   * Note: Meteora DBC is a separate protocol from Pump.fun.
   * Requires separate integration.
   */
  private async claimMeteoraDbcFees(): Promise<ClaimResult> {
    try {
      const signature = await this.pumpPortal.claimFees('meteora-dbc');

      if (signature && signature.length > 0) {
        return {
          success: true,
          signature,
          amountSol: undefined,
        };
      } else {
        return {
          success: false,
          error: 'No signature returned',
        };
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: errorMsg,
      };
    }
  }

  /**
   * Get statistics
   */
  getStats(): {
    isRunning: boolean;
    totalClaimedSol: number;
    claimCount: number;
    lastLogs: string[];
  } {
    return {
      isRunning: this.isRunning,
      totalClaimedSol: this.totalClaimedSol,
      claimCount: this.claimCount,
      lastLogs: [...this.claimLogs],
    };
  }

  /**
   * Force a claim cycle (for testing)
   */
  async forceClaimCycle(): Promise<void> {
    logger.info('Force claim cycle triggered');
    await this.claimAllRewards();
  }
}
</file>

<file path="src/scripts/import-trade.ts">
/**
 * One-time script to import historical trade into database
 * Run with: npx tsx src/scripts/import-trade.ts
 */

import { createDatabase } from '../db/index.js';
import { createDatabaseWithRepositories } from '../db/database-with-repos.js';
import type { Trade } from '../db/repositories/trades.js';

const dbPath = process.env.RAILWAY_ENVIRONMENT
  ? '/app/data/schizo-agent.db'
  : 'schizo-agent.db';

console.log('Opening database:', dbPath);
const db = createDatabase(dbPath);
const dbWithRepos = createDatabaseWithRepositories(db);

// Trade from Helius transaction history
const trade = {
  signature: 'iwgr8DTfM7STpQ1N21mHNRvC4DNrN5ms7aSAKYw27PukjTq9dmA95j4NY6x1gh5MwZWaeQJEH5tHWRg6Wryc6uq',
  tokenMint: 'Kvqx8QeAXyjQJULbAX7LnWxfym5U51we9Eft51oBAGS',
  tokenSymbol: 'IMPOSTOR',
  type: 'BUY' as const,
  amountSol: 0.026412,
  amountTokens: 107358.911004,
  pricePerToken: 0.000000246014,
  timestamp: 1769028771000, // Convert to milliseconds
  metadata: {
    tokenName: 'Impostor',
    source: 'PUMP_FUN',
    importedFromHistory: true,
  },
};

// Check if trade already exists
const existing = dbWithRepos.trades.getRecent(100);
const exists = existing.some((t: Trade) => t.signature === trade.signature);

if (exists) {
  console.log('Trade already exists in database, skipping');
} else {
  console.log('Importing trade:', {
    symbol: trade.tokenSymbol,
    type: trade.type,
    amountSol: trade.amountSol,
    amountTokens: trade.amountTokens,
  });

  dbWithRepos.trades.insert(trade);
  console.log('‚úÖ Trade imported successfully!');
}

// Verify
const positions = dbWithRepos.trades.getRecent(10);
console.log('\nRecent trades in database:');
for (const p of positions) {
  console.log(`  ${p.tokenSymbol || p.tokenMint.slice(0, 8)} - ${p.type} - ${p.amountSol} SOL`);
}

db.close();
</file>

<file path="src/shill-queue/index.ts">
/**
 * Shill Queue Module
 *
 * Handles viewer-submitted token shills via $SCHIZO burns
 */

export { ShillQueue } from './shill-queue.js';
export { ShillQueueWatcher } from './shill-queue-watcher.js';
export {
  type ShillQueueConfig,
  type ShillQueueWatcherConfig,
  type ShillRequest,
  type ShillAnalysisResult,
  DEFAULT_SHILL_QUEUE_CONFIG,
  DEFAULT_SHILL_WATCHER_CONFIG,
} from './types.js';
</file>

<file path="src/shill-queue/shill-queue-watcher.ts">
/**
 * Shill Queue Watcher
 *
 * Monitors the burn wallet for $SCHIZO token burns with memos
 * containing Contract Addresses (CAs) to analyze
 */

import { Connection, PublicKey, Logs } from '@solana/web3.js';
import { createLogger } from '../lib/logger.js';
import type { ShillQueueWatcherConfig, ShillRequest } from './types.js';
import type { ShillQueue } from './shill-queue.js';

const logger = createLogger('shill-watcher');

/** Memo Program ID */
const MEMO_PROGRAM_ID = 'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr';

/** Solana address regex (base58, 32-44 chars) */
const SOLANA_ADDRESS_REGEX = /[1-9A-HJ-NP-Za-km-z]{32,44}/;

/**
 * ShillQueueWatcher - Watches burn wallet for $SCHIZO burns with CA memos
 */
export class ShillQueueWatcher {
  private config: ShillQueueWatcherConfig;
  private connection: Connection;
  private shillQueue: ShillQueue;
  private subscriptionId: number | null = null;
  private isRunning = false;

  /** Cooldown tracking per wallet */
  private walletCooldowns: Map<string, number> = new Map();

  /** Processed signatures to avoid duplicates */
  private processedSignatures = new Set<string>();

  constructor(
    config: ShillQueueWatcherConfig,
    connection: Connection,
    shillQueue: ShillQueue
  ) {
    this.config = config;
    this.connection = connection;
    this.shillQueue = shillQueue;

    logger.info({
      burnWallet: config.burnWalletAddress,
      minAmount: config.minShillAmountTokens,
      cooldownMs: config.cooldownPerWalletMs,
    }, 'ShillQueueWatcher initialized');
  }

  /**
   * Start watching the burn wallet
   */
  async start(): Promise<void> {
    if (this.isRunning) {
      logger.warn('ShillQueueWatcher already running');
      return;
    }

    if (!this.config.enabled) {
      logger.info('ShillQueueWatcher disabled');
      return;
    }

    this.isRunning = true;

    try {
      const burnWalletPubkey = new PublicKey(this.config.burnWalletAddress);

      this.subscriptionId = this.connection.onLogs(
        burnWalletPubkey,
        (logs: Logs) => this.handleLogNotification(logs),
        'confirmed'
      );

      logger.info({
        burnWallet: this.config.burnWalletAddress.slice(0, 8) + '...',
        subscriptionId: this.subscriptionId,
      }, 'ShillQueueWatcher WebSocket subscription active');

    } catch (error) {
      logger.error({ error }, 'Failed to start ShillQueueWatcher');
      this.isRunning = false;
    }
  }

  /**
   * Stop watching
   */
  async stop(): Promise<void> {
    if (!this.isRunning) return;

    this.isRunning = false;

    if (this.subscriptionId !== null) {
      try {
        await this.connection.removeOnLogsListener(this.subscriptionId);
      } catch (err) {
        logger.warn({ error: err }, 'Failed to remove logs listener');
      }
      this.subscriptionId = null;
    }

    logger.info('ShillQueueWatcher stopped');
  }

  /**
   * Handle real-time log notification
   */
  private async handleLogNotification(logs: Logs): Promise<void> {
    if (logs.err) {
      logger.debug({ signature: logs.signature }, 'Ignoring failed transaction');
      return;
    }

    if (this.processedSignatures.has(logs.signature)) {
      return;
    }
    this.processedSignatures.add(logs.signature);

    // Limit cache size
    if (this.processedSignatures.size > 1000) {
      const entries = Array.from(this.processedSignatures);
      this.processedSignatures = new Set(entries.slice(-500));
    }

    // Check if this looks like a token transfer with memo
    const hasMemo = logs.logs.some(log =>
      log.includes(MEMO_PROGRAM_ID) ||
      log.includes('Program log: Memo')
    );

    const hasTokenTransfer = logs.logs.some(log =>
      log.includes('Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') ||
      log.includes('Transfer')
    );

    if (!hasMemo || !hasTokenTransfer) {
      logger.debug({ signature: logs.signature }, 'Transaction does not contain memo + token transfer');
      return;
    }

    logger.info({ signature: logs.signature }, 'Potential shill transaction detected');

    // Parse the full transaction
    try {
      const shillRequest = await this.parseShillTransaction(logs.signature);

      if (shillRequest) {
        logger.info({
          sender: shillRequest.senderWallet.slice(0, 8) + '...',
          ca: shillRequest.contractAddress.slice(0, 8) + '...',
          amount: shillRequest.schizoAmountBurned,
        }, 'Valid shill request detected!');

        // Add to queue
        this.shillQueue.enqueue(shillRequest);
      }
    } catch (error) {
      logger.error({ error, signature: logs.signature }, 'Failed to parse shill transaction');
    }
  }

  /**
   * Parse a transaction to extract shill request details
   */
  private async parseShillTransaction(signature: string): Promise<ShillRequest | null> {
    const tx = await this.connection.getParsedTransaction(signature, {
      maxSupportedTransactionVersion: 0,
      commitment: 'confirmed',
    });

    if (!tx || !tx.meta || tx.meta.err) {
      return null;
    }

    // Find memo instruction
    let memo: string | null = null;
    const instructions = tx.transaction.message.instructions;

    for (const ix of instructions) {
      // Check if this is a Memo instruction
      const programId = 'programId' in ix ? ix.programId.toString() : '';

      if (programId === MEMO_PROGRAM_ID) {
        // Parsed memo instruction has 'parsed' field with the memo string
        if ('parsed' in ix) {
          memo = ix.parsed as string;
        } else if ('data' in ix) {
          // Raw instruction - decode base58/base64 data
          const ixData = ix.data as string;
          try {
            // Try UTF-8 decode directly (memo data is often just the string)
            memo = Buffer.from(ixData, 'base64').toString('utf-8');
          } catch {
            // Try base58 decode
            try {
              const bs58 = await import('bs58');
              memo = Buffer.from(bs58.default.decode(ixData)).toString('utf-8');
            } catch {
              logger.warn({ signature }, 'Failed to decode memo data');
            }
          }
        }
        break;
      }
    }

    if (!memo) {
      logger.debug({ signature }, 'No memo found in transaction');
      return null;
    }

    // Extract CA from memo
    const caMatch = memo.match(SOLANA_ADDRESS_REGEX);
    if (!caMatch) {
      logger.debug({ signature, memo: memo.slice(0, 50) }, 'No valid CA found in memo');
      return null;
    }

    const contractAddress = caMatch[0];

    // Find sender and $SCHIZO amount
    const preTokenBalances = tx.meta.preTokenBalances || [];
    const postTokenBalances = tx.meta.postTokenBalances || [];

    // Find $SCHIZO token transfer to burn wallet
    let senderWallet: string | null = null;
    let schizoAmountBurned = 0;

    for (const pre of preTokenBalances) {
      if (pre.mint !== this.config.schizoTokenMint) continue;
      if (pre.owner === this.config.burnWalletAddress) continue;

      // Check if this wallet's balance decreased (they sent tokens)
      const post = postTokenBalances.find(
        p => p.mint === pre.mint && p.owner === pre.owner
      );

      const preBal = parseFloat(pre.uiTokenAmount?.uiAmountString || '0');
      const postBal = post ? parseFloat(post.uiTokenAmount?.uiAmountString || '0') : 0;
      const diff = preBal - postBal;

      if (diff > 0) {
        senderWallet = pre.owner || null;
        schizoAmountBurned = diff;
        break;
      }
    }

    if (!senderWallet) {
      logger.debug({ signature }, 'Could not identify sender wallet');
      return null;
    }

    // Validate minimum amount
    if (schizoAmountBurned < this.config.minShillAmountTokens) {
      logger.info({
        signature,
        amount: schizoAmountBurned,
        required: this.config.minShillAmountTokens,
      }, 'Shill amount below minimum');
      return null;
    }

    // Check cooldown
    const lastShillTime = this.walletCooldowns.get(senderWallet) || 0;
    const now = Date.now();

    if (now - lastShillTime < this.config.cooldownPerWalletMs) {
      const remainingMs = this.config.cooldownPerWalletMs - (now - lastShillTime);
      logger.info({
        sender: senderWallet.slice(0, 8) + '...',
        remainingMs,
      }, 'Wallet on cooldown');
      return null;
    }

    // Update cooldown
    this.walletCooldowns.set(senderWallet, now);

    // Clean up old cooldowns periodically
    if (this.walletCooldowns.size > 500) {
      const cutoff = now - this.config.cooldownPerWalletMs * 2;
      for (const [wallet, time] of this.walletCooldowns) {
        if (time < cutoff) {
          this.walletCooldowns.delete(wallet);
        }
      }
    }

    return {
      senderWallet,
      contractAddress,
      schizoAmountBurned,
      signature,
      timestamp: tx.blockTime ? tx.blockTime * 1000 : now,
    };
  }
}
</file>

<file path="src/shill-queue/types.ts">
/**
 * Shill Queue Types
 *
 * Handles viewer-submitted token "shills" via $SCHIZO burns
 * Viewers send $SCHIZO to burn wallet with a memo containing a CA
 */

/**
 * Configuration for the burn wallet watcher
 */
export interface ShillQueueWatcherConfig {
  /** Address of the burn wallet to monitor */
  burnWalletAddress: string;
  /** $SCHIZO token mint address */
  schizoTokenMint: string;
  /** Minimum $SCHIZO tokens required to shill */
  minShillAmountTokens: number;
  /** Cooldown per wallet (prevent spam) in ms */
  cooldownPerWalletMs: number;
  /** Enable/disable the watcher */
  enabled: boolean;
}

/**
 * A shill request from a viewer
 */
export interface ShillRequest {
  /** Wallet that sent the shill */
  senderWallet: string;
  /** Contract address they want analyzed */
  contractAddress: string;
  /** Amount of $SCHIZO burned */
  schizoAmountBurned: number;
  /** Transaction signature */
  signature: string;
  /** Timestamp of the burn */
  timestamp: number;
}

/**
 * Configuration for the shill queue processor
 */
export interface ShillQueueConfig {
  /** Maximum items in queue */
  maxQueueSize: number;
  /** Timeout for processing each shill (ms) */
  processingTimeoutMs: number;
  /** Position size for lotto buys (SOL) */
  lottoPositionSol: number;
}

/**
 * Result of shill analysis
 */
export interface ShillAnalysisResult {
  /** The original shill request */
  request: ShillRequest;
  /** Whether the token passed safety checks */
  isSafe: boolean;
  /** Risks identified (if any) */
  risks: string[];
  /** Token metadata */
  tokenInfo?: {
    symbol: string;
    name: string;
    marketCapSol?: number;
    liquidity?: number;
  };
  /** Roast message if rejected */
  roastMessage?: string;
  /** Buy signature if accepted */
  buySignature?: string;
  /** Position size if bought */
  positionSizeSol?: number;
}

/**
 * Default configurations
 */
export const DEFAULT_SHILL_WATCHER_CONFIG: Omit<ShillQueueWatcherConfig, 'schizoTokenMint'> = {
  burnWalletAddress: 'GvV8bXgQTYSGHnfNF9vgodshgQ4P2fcichGFLqBd73kr',
  minShillAmountTokens: 1000,
  cooldownPerWalletMs: 5 * 60 * 1000, // 5 minutes
  enabled: true,
};

export const DEFAULT_SHILL_QUEUE_CONFIG: ShillQueueConfig = {
  maxQueueSize: 5,
  processingTimeoutMs: 30000, // 30 seconds
  lottoPositionSol: 0.02,
};
</file>

<file path="src/test/manual-trigger.ts">
/**
 * Manual Trigger - Dry Run Testing Without Real SOL
 *
 * This script allows testing the full pipeline:
 * Database -> Logic -> Events -> WebSocket -> Frontend
 *
 * WITHOUT spending any real SOL.
 *
 * Usage:
 *   npx tsx src/test/manual-trigger.ts --scan
 *   npx tsx src/test/manual-trigger.ts --buy
 *   npx tsx src/test/manual-trigger.ts --sell
 *   npx tsx src/test/manual-trigger.ts --mood paranoid
 *   npx tsx src/test/manual-trigger.ts --buyback
 *   npx tsx src/test/manual-trigger.ts --reward
 *
 * Or use curl to hit the simulation endpoints:
 *   curl -X POST http://localhost:3500/api/simulate/scan
 *   curl -X POST http://localhost:3500/api/simulate/trade -d '{"type":"BUY"}'
 *   curl -X POST http://localhost:3500/api/simulate/mood -d '{"mood":"PARANOID"}'
 */

import 'dotenv/config';
import { agentEvents } from '../events/emitter.js';
import type { ScanEvent, RejectEvent, MoodChangeEvent } from '../events/types.js';

/**
 * Generate a fake token mint address (looks real but isn't)
 */
function generateFakeMint(): string {
  const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  let result = '';
  for (let i = 0; i < 44; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

/**
 * Generate a fake transaction signature
 */
function generateFakeSignature(): string {
  const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  let result = '';
  for (let i = 0; i < 88; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

/**
 * Random token names for testing
 */
const FAKE_TOKENS = [
  { symbol: 'DOGE420', name: 'Doge 420 Moon' },
  { symbol: 'PEPEAI', name: 'Pepe Artificial Intelligence' },
  { symbol: 'BONKCAT', name: 'Bonk Cat' },
  { symbol: 'SCHIZOTEST', name: 'Schizo Test Token' },
  { symbol: 'FAKERUG', name: 'Definitely Not A Rug' },
  { symbol: 'MOON2025', name: 'Moon Mission 2025' },
  { symbol: 'AIDOG', name: 'AI Dog Meme' },
  { symbol: 'WOJAK', name: 'Wojak Finance' },
];

/**
 * Simulate a token scan event
 */
export function simulateScan(): void {
  const token = FAKE_TOKENS[Math.floor(Math.random() * FAKE_TOKENS.length)];
  const mint = generateFakeMint();
  const liquidity = Math.floor(Math.random() * 50000) + 5000;
  const marketCap = liquidity * (2 + Math.random() * 10);

  const scanEvent: ScanEvent = {
    type: 'SCAN',
    timestamp: Date.now(),
    data: {
      reasoning: `Scanning ${token.symbol} from PumpPortal WebSocket feed`,
      logs: [
        `Token detected: ${token.symbol}`,
        `Mint: ${mint}`,
        `Liquidity: $${liquidity.toLocaleString()}`,
        `Market Cap: $${marketCap.toLocaleString()}`,
        'Running safety checks...',
      ],
      mint,
      symbol: token.symbol,
      name: token.name,
      source: 'PUMP_PORTAL',
      liquidity,
      marketCap,
    },
  };

  console.log('üì° Emitting SCAN event:', scanEvent.data.symbol);
  agentEvents.emit(scanEvent);

  // Also emit analysis thought for frontend
  agentEvents.emit({
    type: 'ANALYSIS_THOUGHT',
    timestamp: Date.now(),
    data: {
      mint,
      symbol: token.symbol,
      name: token.name,
      marketCapSol: marketCap / 170,
      liquidity,
      stage: 'scanning',
      thought: `Looking at ${token.symbol}... Let me check if this is worth anything or just another rug.`,
    },
  });
}

/**
 * Simulate a token rejection
 */
export function simulateReject(): void {
  const token = FAKE_TOKENS[Math.floor(Math.random() * FAKE_TOKENS.length)];
  const mint = generateFakeMint();
  const reasons = [
    'MINT_AUTHORITY_ACTIVE',
    'FREEZE_AUTHORITY_ACTIVE',
    'LOW_LIQUIDITY',
    'HIGH_HOLDER_CONCENTRATION',
    'CIRCUIT_BREAKER_TRIGGERED',
  ];
  const rejectReason = reasons[Math.floor(Math.random() * reasons.length)];
  const stages: Array<'filter' | 'safety' | 'liquidity' | 'concentration' | 'circuit_breaker'> = [
    'filter', 'safety', 'liquidity', 'concentration', 'circuit_breaker'
  ];
  const stage = stages[Math.floor(Math.random() * stages.length)];

  const rejectEvent: RejectEvent = {
    type: 'REJECT',
    timestamp: Date.now(),
    data: {
      reasoning: `Rejected ${token.symbol} due to ${rejectReason}`,
      logs: [
        `Token: ${token.symbol}`,
        `Mint: ${mint}`,
        `Failed at stage: ${stage}`,
        `Reason: ${rejectReason}`,
      ],
      mint,
      symbol: token.symbol,
      rejectReason,
      stage,
    },
  };

  console.log('‚ùå Emitting REJECT event:', token.symbol, rejectReason);
  agentEvents.emit(rejectEvent);

  // Also emit analysis thought
  agentEvents.emit({
    type: 'ANALYSIS_THOUGHT',
    timestamp: Date.now(),
    data: {
      mint,
      symbol: token.symbol,
      stage: 'decision',
      thought: `NOPE. ${token.symbol} has ${rejectReason}. Hard pass.`,
      details: { shouldTrade: false, reasons: [rejectReason] },
    },
  });
}

/**
 * Simulate a buy trade
 */
export function simulateBuy(): void {
  const token = FAKE_TOKENS[Math.floor(Math.random() * FAKE_TOKENS.length)];
  const mint = generateFakeMint();
  const signature = generateFakeSignature();
  const amount = 0.05 + Math.random() * 0.2;

  console.log('üí∞ Emitting BUY event:', token.symbol, amount.toFixed(3), 'SOL');

  // Emit analysis decision
  agentEvents.emit({
    type: 'ANALYSIS_THOUGHT',
    timestamp: Date.now(),
    data: {
      mint,
      symbol: token.symbol,
      stage: 'decision',
      thought: `${token.symbol} passes all checks. BUYING.`,
      details: { shouldTrade: true },
    },
  });

  // Emit trade executed
  agentEvents.emit({
    type: 'TRADE_EXECUTED',
    timestamp: Date.now(),
    data: {
      mint,
      type: 'BUY',
      signature,
      amount,
      reasoning: `Executed buy of ${token.symbol} - passed safety checks, smart money detected`,
      logs: [
        `Token: ${token.symbol}`,
        `Mint: ${mint}`,
        `Amount: ${amount.toFixed(4)} SOL`,
        `Signature: ${signature.slice(0, 20)}...`,
      ],
    },
  });
}

/**
 * Simulate a sell trade (stop-loss or take-profit)
 */
export function simulateSell(isProfit: boolean = true): void {
  const token = FAKE_TOKENS[Math.floor(Math.random() * FAKE_TOKENS.length)];
  const mint = generateFakeMint();
  const signature = generateFakeSignature();
  const entryPrice = 0.00001 + Math.random() * 0.0001;
  const pnlPercent = isProfit ? 30 + Math.random() * 50 : -(10 + Math.random() * 20);
  const exitPrice = entryPrice * (1 + pnlPercent / 100);

  if (isProfit) {
    console.log('üéØ Emitting TAKE_PROFIT event:', token.symbol, `+${pnlPercent.toFixed(1)}%`);
    agentEvents.emit({
      type: 'TAKE_PROFIT',
      timestamp: Date.now(),
      data: {
        mint,
        entryPrice,
        exitPrice,
        profitPercent: pnlPercent,
        signature,
        reasoning: `Take-profit triggered at +${pnlPercent.toFixed(1)}% (threshold: +30%)`,
        logs: [
          `Token: ${token.symbol}`,
          `Entry: $${entryPrice.toFixed(8)}`,
          `Exit: $${exitPrice.toFixed(8)}`,
          `P&L: +${pnlPercent.toFixed(1)}%`,
        ],
      },
    });
  } else {
    console.log('üõë Emitting STOP_LOSS event:', token.symbol, `${pnlPercent.toFixed(1)}%`);
    agentEvents.emit({
      type: 'STOP_LOSS',
      timestamp: Date.now(),
      data: {
        mint,
        entryPrice,
        exitPrice,
        lossPercent: pnlPercent,
        signature,
        reasoning: `Stop-loss triggered at ${pnlPercent.toFixed(1)}% (threshold: -10%)`,
        logs: [
          `Token: ${token.symbol}`,
          `Entry: $${entryPrice.toFixed(8)}`,
          `Exit: $${exitPrice.toFixed(8)}`,
          `P&L: ${pnlPercent.toFixed(1)}%`,
        ],
      },
    });
  }
}

/**
 * Simulate a buyback event
 */
export function simulateBuyback(): void {
  const signature = generateFakeSignature();
  const profit = 0.1 + Math.random() * 0.5;
  const buybackAmount = profit * 0.10; // 10% of profit

  console.log('üîÑ Emitting BUYBACK_TRIGGERED event:', buybackAmount.toFixed(4), 'SOL');

  agentEvents.emit({
    type: 'BUYBACK_TRIGGERED',
    timestamp: Date.now(),
    data: {
      profit,
      amount: buybackAmount,
      signature,
      reasoning: `Buyback triggered: 10% of ${profit.toFixed(4)} SOL profit = ${buybackAmount.toFixed(4)} SOL`,
      logs: [
        `Profit: ${profit.toFixed(4)} SOL`,
        `Buyback percentage: 10% (HARDCODED)`,
        `Buyback amount: ${buybackAmount.toFixed(4)} SOL`,
        `Signature: ${signature.slice(0, 20)}...`,
      ],
    },
  });
}

/**
 * Simulate a mood change
 */
export function simulateMoodChange(newMood?: string): void {
  const moods = ['CONFIDENT', 'PARANOID', 'MANIC', 'DEPRESSED', 'EUPHORIC', 'ANXIOUS'];
  const previousMood = moods[Math.floor(Math.random() * moods.length)];
  const currentMood = newMood || moods[Math.floor(Math.random() * moods.length)];
  const intensity = 0.3 + Math.random() * 0.7;

  const moodEvent: MoodChangeEvent = {
    type: 'MOOD_CHANGE',
    timestamp: Date.now(),
    data: {
      previous: previousMood,
      current: currentMood,
      intensity,
      trigger: 'manual_test',
      reasoning: `Mood shifted from ${previousMood} to ${currentMood} (intensity: ${(intensity * 100).toFixed(0)}%)`,
      logs: [
        `Previous mood: ${previousMood}`,
        `New mood: ${currentMood}`,
        `Intensity: ${(intensity * 100).toFixed(0)}%`,
        `Trigger: Manual test`,
      ],
    },
  };

  console.log('üß† Emitting MOOD_CHANGE event:', previousMood, '->', currentMood);
  agentEvents.emit(moodEvent);
}

/**
 * Simulate a reward claim
 */
export function simulateRewardClaim(success: boolean = true): void {
  const signature = generateFakeSignature();
  const amountSol = 0.01 + Math.random() * 0.1;

  if (success) {
    console.log('üíé Emitting REWARD_CLAIMED event:', amountSol.toFixed(4), 'SOL');
    agentEvents.emit({
      type: 'REWARD_CLAIMED',
      timestamp: Date.now(),
      data: {
        reasoning: `Successfully claimed pump_creator rewards`,
        logs: [
          `Source: pump_creator`,
          `Amount: ${amountSol.toFixed(4)} SOL`,
          `Signature: ${signature.slice(0, 20)}...`,
        ],
        signature,
        amountSol,
        source: 'pump_creator',
      },
    });
  } else {
    console.log('‚ùå Emitting REWARD_FAILED event');
    agentEvents.emit({
      type: 'REWARD_FAILED',
      timestamp: Date.now(),
      data: {
        reasoning: `Failed to claim pump_creator rewards after 3 attempts`,
        logs: [
          `Source: pump_creator`,
          `Attempts: 3`,
          `Error: Transaction simulation failed`,
        ],
        source: 'pump_creator',
        error: 'Transaction simulation failed',
      },
    });
  }
}

/**
 * Run full pipeline test
 */
export async function runFullPipelineTest(): Promise<void> {
  console.log('\nüß™ Running Full Pipeline Test\n');
  console.log('================================\n');

  // 1. Scan
  console.log('1Ô∏è‚É£ Simulating token scan...');
  simulateScan();
  await sleep(1000);

  // 2. Reject some
  console.log('\n2Ô∏è‚É£ Simulating token rejection...');
  simulateReject();
  await sleep(1000);

  // 3. Buy
  console.log('\n3Ô∏è‚É£ Simulating buy trade...');
  simulateBuy();
  await sleep(1000);

  // 4. Take profit
  console.log('\n4Ô∏è‚É£ Simulating take-profit...');
  simulateSell(true);
  await sleep(1000);

  // 5. Buyback
  console.log('\n5Ô∏è‚É£ Simulating buyback...');
  simulateBuyback();
  await sleep(1000);

  // 6. Mood change
  console.log('\n6Ô∏è‚É£ Simulating mood change...');
  simulateMoodChange('PARANOID');
  await sleep(1000);

  // 7. Reward claim
  console.log('\n7Ô∏è‚É£ Simulating reward claim...');
  simulateRewardClaim(true);
  await sleep(1000);

  // 8. Stop loss
  console.log('\n8Ô∏è‚É£ Simulating stop-loss...');
  simulateSell(false);
  await sleep(1000);

  console.log('\n================================');
  console.log('‚úÖ Full Pipeline Test Complete\n');
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// CLI entry point
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  console.log('üß™ Manual Trigger - Dry Run Testing\n');

  switch (command) {
    case '--scan':
      simulateScan();
      break;
    case '--reject':
      simulateReject();
      break;
    case '--buy':
      simulateBuy();
      break;
    case '--sell':
      simulateSell(args[1] !== 'loss');
      break;
    case '--buyback':
      simulateBuyback();
      break;
    case '--mood':
      simulateMoodChange(args[1]?.toUpperCase());
      break;
    case '--reward':
      simulateRewardClaim(args[1] !== 'fail');
      break;
    case '--full':
    case '--all':
      await runFullPipelineTest();
      break;
    default:
      console.log('Usage:');
      console.log('  npx tsx src/test/manual-trigger.ts --scan');
      console.log('  npx tsx src/test/manual-trigger.ts --reject');
      console.log('  npx tsx src/test/manual-trigger.ts --buy');
      console.log('  npx tsx src/test/manual-trigger.ts --sell [loss]');
      console.log('  npx tsx src/test/manual-trigger.ts --buyback');
      console.log('  npx tsx src/test/manual-trigger.ts --mood [PARANOID|CONFIDENT|...]');
      console.log('  npx tsx src/test/manual-trigger.ts --reward [fail]');
      console.log('  npx tsx src/test/manual-trigger.ts --full');
      break;
  }

  // Keep process alive briefly for events to emit
  await sleep(500);
}

// Export functions for programmatic use
export {
  generateFakeMint,
  generateFakeSignature,
  FAKE_TOKENS,
};

main().catch(console.error);
</file>

<file path="src/trading/index.ts">
export { PumpPortalClient } from './pumpportal-client.js';
export { TradingEngine } from './trading-engine.js';
export { TradingLoop, DEFAULT_TRADING_LOOP_CONFIG } from './trading-loop.js';
export { EntertainmentMode, DEFAULT_ENTERTAINMENT_CONFIG } from './entertainment-mode.js';
export type { TradingConfig, TradeDecision } from './trading-engine.js';
export type { TradingLoopConfig } from './trading-loop.js';
export type { TokenInfo, TradeParams, TradeResult } from './types.js';
export type { EntertainmentConfig, EntertainmentDecision, TokenContext } from './entertainment-mode.js';
</file>

<file path="src/trading/smart-money-copier.ts">
/**
 * Smart Money Copy Trader - Proactively watches wallets and copies their trades
 *
 * Instead of: "New token detected ‚Üí check smart money"
 * This does: "Smart money bought ‚Üí we buy"
 *
 * Monitors a curated list of proven profitable wallets and mirrors their trades.
 */

import { Connection, PublicKey } from '@solana/web3.js';
import { createLogger } from '../lib/logger.js';
import { HeliusClient } from '../api/helius.js';
import { agentEvents } from '../events/emitter.js';

const logger = createLogger('smart-money-copier');

/**
 * A tracked wallet with performance metrics
 */
export interface TrackedWallet {
  address: string;
  label?: string;          // e.g., "Whale #1", "Top Trader"
  pnlSol: number;          // Historical profit in SOL
  winRate: number;         // 0-1
  avgHoldTime: number;     // Average hold time in ms
  lastUpdated: number;     // When metrics were last updated
  isActive: boolean;       // Currently monitoring
  totalTrades: number;
  recentTrades: WalletTrade[];
}

/**
 * A trade made by a tracked wallet
 */
export interface WalletTrade {
  signature: string;
  timestamp: number;
  tokenMint: string;
  tokenSymbol?: string;
  type: 'buy' | 'sell';
  solAmount: number;
  tokenAmount: number;
  pricePerToken: number;
}

/**
 * Copy trade signal emitted when smart money buys
 */
export interface CopyTradeSignal {
  wallet: TrackedWallet;
  trade: WalletTrade;
  confidence: number;      // 0-100 based on wallet metrics
  suggestedSize: number;   // Suggested position in SOL
  reasons: string[];
}

/**
 * Configuration for the copy trader
 */
export interface SmartMoneyCopierConfig {
  /** Minimum wallet PnL to copy (SOL) */
  minWalletPnl: number;
  /** Minimum wallet win rate to copy */
  minWinRate: number;
  /** Maximum age of trade to copy (ms) - don't copy old trades */
  maxTradeAge: number;
  /** Poll interval for checking wallet activity (ms) */
  pollIntervalMs: number;
  /** Maximum position size when copying (SOL) */
  maxCopySize: number;
  /** Minimum position size (SOL) */
  minCopySize: number;
  /** Scale position by wallet confidence */
  scaleByConfidence: boolean;
}

const DEFAULT_CONFIG: SmartMoneyCopierConfig = {
  minWalletPnl: 10,           // 10 SOL minimum profit
  minWinRate: 0.5,            // 50% win rate
  maxTradeAge: 60000,         // 1 minute - must be fast
  pollIntervalMs: 5000,       // Check every 5 seconds
  maxCopySize: 0.1,           // 0.1 SOL max per copy
  minCopySize: 0.01,          // 0.01 SOL min
  scaleByConfidence: true,
};

/**
 * Smart Money Copy Trader
 *
 * Watches a list of profitable wallets and emits signals when they trade.
 */
export class SmartMoneyCopier {
  private config: SmartMoneyCopierConfig;
  private helius: HeliusClient;
  private trackedWallets: Map<string, TrackedWallet> = new Map();
  private lastSeenSignatures: Map<string, string> = new Map(); // wallet -> last sig
  private isRunning = false;
  private pollInterval?: NodeJS.Timeout;
  private onSignalCallbacks: ((signal: CopyTradeSignal) => void)[] = [];

  constructor(helius: HeliusClient, config?: Partial<SmartMoneyCopierConfig>) {
    this.helius = helius;
    this.config = { ...DEFAULT_CONFIG, ...config };

    logger.info({ config: this.config }, 'SmartMoneyCopier initialized');
  }

  /**
   * Add a wallet to track.
   */
  addWallet(wallet: Omit<TrackedWallet, 'recentTrades' | 'lastUpdated' | 'isActive'>): void {
    const tracked: TrackedWallet = {
      ...wallet,
      recentTrades: [],
      lastUpdated: Date.now(),
      isActive: true,
    };

    this.trackedWallets.set(wallet.address, tracked);
    logger.info({ wallet: wallet.address, label: wallet.label }, 'Added wallet to tracking');
  }

  /**
   * Add multiple wallets at once.
   */
  addWallets(wallets: Omit<TrackedWallet, 'recentTrades' | 'lastUpdated' | 'isActive'>[]): void {
    for (const wallet of wallets) {
      this.addWallet(wallet);
    }
  }

  /**
   * Remove a wallet from tracking.
   */
  removeWallet(address: string): void {
    this.trackedWallets.delete(address);
    this.lastSeenSignatures.delete(address);
    logger.info({ wallet: address }, 'Removed wallet from tracking');
  }

  /**
   * Get all tracked wallets.
   */
  getTrackedWallets(): TrackedWallet[] {
    return Array.from(this.trackedWallets.values());
  }

  /**
   * Register callback for copy trade signals.
   */
  onSignal(callback: (signal: CopyTradeSignal) => void): void {
    this.onSignalCallbacks.push(callback);
  }

  /**
   * Start monitoring wallets.
   */
  start(): void {
    if (this.isRunning) {
      logger.warn('SmartMoneyCopier already running');
      return;
    }

    this.isRunning = true;

    // Initialize last seen signatures
    this.initializeLastSeen().then(() => {
      // Start polling
      this.pollInterval = setInterval(() => {
        this.checkAllWallets();
      }, this.config.pollIntervalMs);

      logger.info({
        walletCount: this.trackedWallets.size,
        pollInterval: this.config.pollIntervalMs,
      }, 'SmartMoneyCopier started');
    });
  }

  /**
   * Stop monitoring.
   */
  stop(): void {
    this.isRunning = false;

    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = undefined;
    }

    logger.info('SmartMoneyCopier stopped');
  }

  /**
   * Initialize last seen signatures to avoid copying old trades on startup.
   */
  private async initializeLastSeen(): Promise<void> {
    const wallets = Array.from(this.trackedWallets.keys());

    for (const address of wallets) {
      try {
        const txs = await this.helius.getTransactionsForAddress(address, { limit: 1 });

        if (txs.data.length > 0) {
          this.lastSeenSignatures.set(address, txs.data[0].signature);
        }
      } catch (error) {
        logger.warn({ address, error }, 'Failed to initialize last seen for wallet');
      }

      // Small delay to avoid rate limits
      await this.sleep(200);
    }

    logger.info({ initialized: wallets.length }, 'Initialized last seen signatures');
  }

  /**
   * Check all wallets for new trades.
   */
  private async checkAllWallets(): Promise<void> {
    const wallets = Array.from(this.trackedWallets.entries())
      .filter(([_, w]) => w.isActive);

    for (const [address, wallet] of wallets) {
      try {
        await this.checkWallet(address, wallet);
      } catch (error) {
        logger.warn({ address, error }, 'Error checking wallet');
      }

      // Small delay between wallets
      await this.sleep(100);
    }
  }

  /**
   * Check a single wallet for new trades.
   */
  private async checkWallet(address: string, wallet: TrackedWallet): Promise<void> {
    const lastSeen = this.lastSeenSignatures.get(address);
    const txs = await this.helius.getTransactionsForAddress(address, { limit: 10 });

    if (txs.data.length === 0) return;

    // Find new transactions (since last seen)
    const newTxs = lastSeen
      ? txs.data.filter(tx => tx.signature !== lastSeen).slice(0, 5) // Max 5 new
      : [];

    // Update last seen
    this.lastSeenSignatures.set(address, txs.data[0].signature);

    // Process new transactions
    for (const tx of newTxs) {
      // Check if it's a buy (we only copy buys)
      const trade = await this.parseTradeFromTransaction(tx, address);

      if (trade && trade.type === 'buy') {
        // Check trade age
        const age = Date.now() - trade.timestamp;
        if (age > this.config.maxTradeAge) {
          logger.debug({ address, age }, 'Trade too old to copy');
          continue;
        }

        // Generate signal
        const signal = this.generateSignal(wallet, trade);

        if (signal) {
          this.emitSignal(signal);
        }
      }
    }
  }

  /**
   * Parse a trade from a raw transaction.
   * This is simplified - would need enhanced parsing for accuracy.
   */
  private async parseTradeFromTransaction(
    tx: { signature: string; timestamp: number; type: string; success: boolean },
    walletAddress: string
  ): Promise<WalletTrade | null> {
    // Skip failed transactions
    if (!tx.success) return null;

    // For now, we'll emit a simplified trade
    // In production, you'd parse the actual transaction to get token/amount
    // This would use Helius Enhanced API or parsed transactions

    // Placeholder - would need actual parsing
    return null;
  }

  /**
   * Generate a copy trade signal.
   */
  private generateSignal(wallet: TrackedWallet, trade: WalletTrade): CopyTradeSignal | null {
    // Check wallet meets criteria
    if (wallet.pnlSol < this.config.minWalletPnl) {
      return null;
    }

    if (wallet.winRate < this.config.minWinRate) {
      return null;
    }

    // Calculate confidence (0-100)
    const confidence = this.calculateConfidence(wallet);

    // Calculate suggested position size
    let suggestedSize = this.config.maxCopySize;

    if (this.config.scaleByConfidence) {
      // Scale by confidence: 50% confidence = 50% of max size
      suggestedSize = this.config.minCopySize +
        (this.config.maxCopySize - this.config.minCopySize) * (confidence / 100);
    }

    // Build reasons
    const reasons: string[] = [];

    if (wallet.winRate >= 0.7) {
      reasons.push(`High win rate: ${(wallet.winRate * 100).toFixed(0)}%`);
    }

    if (wallet.pnlSol >= 50) {
      reasons.push(`High PnL: ${wallet.pnlSol.toFixed(1)} SOL`);
    }

    if (wallet.totalTrades >= 100) {
      reasons.push(`Experienced: ${wallet.totalTrades} trades`);
    }

    return {
      wallet,
      trade,
      confidence,
      suggestedSize,
      reasons,
    };
  }

  /**
   * Calculate confidence score for a wallet.
   */
  private calculateConfidence(wallet: TrackedWallet): number {
    let score = 0;

    // Win rate (0-40 points)
    score += Math.min(40, wallet.winRate * 50);

    // PnL (0-30 points)
    const pnlScore = Math.min(30, (wallet.pnlSol / 100) * 30);
    score += pnlScore;

    // Trade count (0-20 points) - more trades = more reliable
    const tradeScore = Math.min(20, (wallet.totalTrades / 100) * 20);
    score += tradeScore;

    // Recency bonus (0-10 points) - recently active
    const hoursSinceUpdate = (Date.now() - wallet.lastUpdated) / (1000 * 60 * 60);
    if (hoursSinceUpdate < 24) {
      score += 10;
    } else if (hoursSinceUpdate < 72) {
      score += 5;
    }

    return Math.min(100, Math.round(score));
  }

  /**
   * Emit a signal to all listeners.
   */
  private emitSignal(signal: CopyTradeSignal): void {
    logger.info({
      wallet: signal.wallet.address,
      token: signal.trade.tokenMint,
      confidence: signal.confidence,
      suggestedSize: signal.suggestedSize,
    }, 'COPY TRADE SIGNAL');

    // Emit via event system (using proper event format)
    agentEvents.emit({
      type: 'COPY_TRADE_SIGNAL',
      timestamp: Date.now(),
      data: {
        mint: signal.trade.tokenMint,
        sourceWallet: signal.wallet.address,
        signature: signal.trade.signature,
        solSpent: signal.trade.solAmount,
      },
    });

    // Call registered callbacks
    for (const callback of this.onSignalCallbacks) {
      try {
        callback(signal);
      } catch (error) {
        logger.error({ error }, 'Error in signal callback');
      }
    }
  }

  /**
   * Utility sleep function.
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Get copier statistics.
   */
  getStats(): {
    trackedWallets: number;
    activeWallets: number;
    isRunning: boolean;
  } {
    const wallets = Array.from(this.trackedWallets.values());
    return {
      trackedWallets: wallets.length,
      activeWallets: wallets.filter(w => w.isActive).length,
      isRunning: this.isRunning,
    };
  }
}
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build output
dist/

# Database files
*.db
*.db-wal
*.db-shm

# Environment
.env

# Sensitive files
keystore.json

# OS files
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/

# Logs
*.log
logs/
promotional-video
*.mp4
*.mov
*.avi
*.mkv
</file>

<file path="src/analysis/market-watcher.ts">
/**
 * Market Watcher - Observes market activity and learns patterns
 *
 * Watches:
 * - New token launches
 * - Price movements
 * - Whale activity
 * - Rug pulls
 * - Smart money movements
 *
 * Learns:
 * - Timing patterns
 * - Wallet behaviors
 * - Token lifecycle patterns
 * - Correlation between signals and outcomes
 */

import { createLogger } from '../lib/logger.js';
import { agentEvents } from '../events/emitter.js';
import type { ClaudeClient, MarketEvent, MarketObservation } from '../personality/claude-client.js';
import type { VoiceNarrator } from '../personality/deepgram-tts.js';
import type { DatabaseWithRepositories } from '../db/database-with-repos.js';

const logger = createLogger('market-watcher');

/**
 * Observed token data
 */
interface ObservedToken {
  mint: string;
  name?: string;
  symbol?: string;
  firstSeenAt: number;
  lastSeenAt: number;
  initialPrice?: number;
  currentPrice?: number;
  priceHistory: Array<{ price: number; timestamp: number }>;
  events: MarketEvent[];
  outcome?: 'PUMP' | 'DUMP' | 'RUG' | 'STABLE' | 'UNKNOWN';
}

/**
 * Learned pattern
 */
interface LearnedPattern {
  id: string;
  type: 'TIMING' | 'WALLET' | 'TOKEN' | 'PRICE' | 'CORRELATION';
  description: string;
  confidence: number; // 0-1
  occurrences: number;
  lastSeen: number;
  examples: string[];
}

/**
 * Market Watcher configuration
 */
export interface MarketWatcherConfig {
  observationInterval: number; // How often to observe (ms)
  learningInterval: number; // How often to generate learnings (ms)
  maxObservations: number; // Max observations to keep
  minPatternsForLearning: number; // Min observations before learning
  voiceEnabled: boolean; // Whether to voice observations
  commentaryEnabled: boolean; // Whether to generate commentary
}

/**
 * Default configuration
 */
export const DEFAULT_WATCHER_CONFIG: MarketWatcherConfig = {
  observationInterval: 30000, // 30 seconds
  learningInterval: 300000, // 5 minutes
  maxObservations: 1000,
  minPatternsForLearning: 10,
  voiceEnabled: false, // Disabled - index.ts handles voice via event handlers
  commentaryEnabled: true,
};

/**
 * Market Watcher - Observes and learns from market activity
 */
export class MarketWatcher {
  private config: MarketWatcherConfig;
  private claude?: ClaudeClient;
  private narrator?: VoiceNarrator;
  private db?: DatabaseWithRepositories;

  private observedTokens = new Map<string, ObservedToken>();
  private observations: MarketObservation[] = [];
  private learnedPatterns: LearnedPattern[] = [];

  private observeIntervalId?: NodeJS.Timeout;
  private learnIntervalId?: NodeJS.Timeout;
  private isRunning = false;

  constructor(
    config: Partial<MarketWatcherConfig> = {},
    claude?: ClaudeClient,
    narrator?: VoiceNarrator,
    db?: DatabaseWithRepositories
  ) {
    this.config = { ...DEFAULT_WATCHER_CONFIG, ...config };
    this.claude = claude;
    this.narrator = narrator;
    this.db = db;

    // Subscribe to agent events
    this.subscribeToEvents();

    logger.info({ config: this.config }, 'Market Watcher initialized');
  }

  /**
   * Start watching the market
   */
  start(): void {
    if (this.isRunning) {
      logger.warn('Market watcher already running');
      return;
    }

    this.isRunning = true;
    logger.info('Starting market watcher...');

    // Start observation interval
    this.observeIntervalId = setInterval(() => {
      this.performObservation().catch(err => {
        logger.error({ error: err }, 'Error in observation cycle');
      });
    }, this.config.observationInterval);

    // Start learning interval
    this.learnIntervalId = setInterval(() => {
      this.performLearning().catch(err => {
        logger.error({ error: err }, 'Error in learning cycle');
      });
    }, this.config.learningInterval);

    logger.info('Market watcher started');
  }

  /**
   * Stop watching
   */
  stop(): void {
    if (!this.isRunning) return;

    this.isRunning = false;

    if (this.observeIntervalId) {
      clearInterval(this.observeIntervalId);
      this.observeIntervalId = undefined;
    }

    if (this.learnIntervalId) {
      clearInterval(this.learnIntervalId);
      this.learnIntervalId = undefined;
    }

    logger.info('Market watcher stopped');
  }

  /**
   * Subscribe to agent events
   */
  private subscribeToEvents(): void {
    agentEvents.onAny((event) => {
      this.processEvent(event);
    });
  }

  /**
   * Process an incoming event
   */
  private processEvent(event: any): void {
    const mint = event.data?.mint;

    switch (event.type) {
      case 'ANALYSIS_START':
        this.trackToken(mint);
        break;

      case 'SAFETY_CHECK':
        this.recordSafetyResult(mint, event.data.result);
        break;

      case 'TRADE_EXECUTED':
        this.recordTrade(event.data);
        break;

      case 'STOP_LOSS':
        this.recordLoss(event.data);
        break;

      case 'TAKE_PROFIT':
        this.recordWin(event.data);
        break;
    }
  }

  /**
   * Track a new token
   */
  private trackToken(mint: string): void {
    if (!mint || this.observedTokens.has(mint)) return;

    this.observedTokens.set(mint, {
      mint,
      firstSeenAt: Date.now(),
      lastSeenAt: Date.now(),
      priceHistory: [],
      events: [],
    });

    logger.debug({ mint }, 'Now tracking token');
  }

  /**
   * Record safety analysis result
   */
  private recordSafetyResult(mint: string, result: any): void {
    const token = this.observedTokens.get(mint);
    if (!token) return;

    token.lastSeenAt = Date.now();
    token.events.push({
      type: 'NEW_TOKEN',
      data: { mint, safetyResult: result },
      timestamp: Date.now(),
    });

    // Record observation
    if (!result.isSafe) {
      this.addObservation({
        type: 'TOKEN_LIFECYCLE',
        description: `Token ${mint.slice(0, 8)} flagged unsafe: ${result.risks.join(', ')}`,
        token: mint,
        timestamp: Date.now(),
      });
    }
  }

  /**
   * Record a trade
   */
  private recordTrade(tradeData: any): void {
    const mint = tradeData.mint;
    const token = this.observedTokens.get(mint);

    if (token) {
      token.lastSeenAt = Date.now();
      token.events.push({
        type: 'TRADE_EXECUTED',
        data: tradeData,
        timestamp: Date.now(),
      });
    }

    this.addObservation({
      type: 'WALLET_BEHAVIOR',
      description: `Executed ${tradeData.type} of ${tradeData.amount} SOL on ${mint?.slice(0, 8) || 'token'}`,
      token: mint,
      timestamp: Date.now(),
      metadata: tradeData,
    });
  }

  /**
   * Record a loss (stop-loss triggered)
   */
  private recordLoss(data: any): void {
    const token = this.observedTokens.get(data.mint);

    if (token) {
      token.outcome = 'DUMP';
      token.events.push({
        type: 'PRICE_DUMP',
        data,
        timestamp: Date.now(),
      });
    }

    this.addObservation({
      type: 'TOKEN_LIFECYCLE',
      description: `Stop-loss on ${data.mint?.slice(0, 8)}: ${data.lossPercent?.toFixed(1)}% loss`,
      token: data.mint,
      timestamp: Date.now(),
      metadata: data,
    });
  }

  /**
   * Record a win (take-profit triggered)
   */
  private recordWin(data: any): void {
    const token = this.observedTokens.get(data.mint);

    if (token) {
      token.outcome = 'PUMP';
      token.events.push({
        type: 'PRICE_PUMP',
        data,
        timestamp: Date.now(),
      });
    }

    this.addObservation({
      type: 'TOKEN_LIFECYCLE',
      description: `Take-profit on ${data.mint?.slice(0, 8)}: +${data.profitPercent?.toFixed(1)}% gain`,
      token: data.mint,
      timestamp: Date.now(),
      metadata: data,
    });
  }

  /**
   * Add an observation
   */
  private addObservation(observation: MarketObservation): void {
    this.observations.push(observation);

    // Trim if over limit
    if (this.observations.length > this.config.maxObservations) {
      this.observations = this.observations.slice(-this.config.maxObservations);
    }

    logger.debug({ type: observation.type, description: observation.description.slice(0, 50) }, 'Observation added');
  }

  /**
   * Perform observation cycle
   */
  private async performObservation(): Promise<void> {
    logger.debug('Performing observation cycle...');

    // Commentary disabled to reduce Claude API usage
    // index.ts handles voice via event handlers instead
    logger.debug('Observation cycle complete (commentary disabled)');
  }

  /**
   * Perform learning cycle
   */
  private async performLearning(): Promise<void> {
    logger.debug('Performing learning cycle...');

    if (this.observations.length < this.config.minPatternsForLearning) {
      logger.debug({ count: this.observations.length, required: this.config.minPatternsForLearning }, 'Not enough observations for learning');
      return;
    }

    // Learning disabled to reduce Claude API usage
    logger.debug('Learning cycle skipped (Claude API disabled for routine learning)');
  }

  /**
   * Map observation type to market event type
   */
  private mapObservationToEventType(type: string): MarketEvent['type'] {
    switch (type) {
      case 'TOKEN_LIFECYCLE':
        return 'NEW_TOKEN';
      case 'WALLET_BEHAVIOR':
        return 'WHALE_ACTIVITY';
      case 'PRICE':
        return 'PRICE_PUMP';
      default:
        return 'NEW_TOKEN';
    }
  }

  /**
   * Get statistics
   */
  getStats(): {
    tokensTracked: number;
    observationCount: number;
    patternsLearned: number;
    wins: number;
    losses: number;
  } {
    let wins = 0;
    let losses = 0;

    for (const [, token] of this.observedTokens) {
      if (token.outcome === 'PUMP') wins++;
      if (token.outcome === 'DUMP' || token.outcome === 'RUG') losses++;
    }

    return {
      tokensTracked: this.observedTokens.size,
      observationCount: this.observations.length,
      patternsLearned: this.learnedPatterns.length,
      wins,
      losses,
    };
  }

  /**
   * Get recent observations
   */
  getRecentObservations(count: number = 10): MarketObservation[] {
    return this.observations.slice(-count);
  }

  /**
   * Get learned patterns
   */
  getLearnedPatterns(): LearnedPattern[] {
    return this.learnedPatterns;
  }

  /**
   * Generate a market summary
   */
  async generateMarketSummary(): Promise<string> {
    const stats = this.getStats();
    const recentObs = this.getRecentObservations(5);

    // Generate basic summary without Claude API
    const summary = `Market Summary:
- Tokens tracked: ${stats.tokensTracked}
- Observations: ${stats.observationCount}
- Patterns learned: ${stats.patternsLearned}
- Wins: ${stats.wins} | Losses: ${stats.losses}

Recent activity:
${recentObs.map(o => `‚Ä¢ ${o.description}`).join('\n')}`;

    return summary;
  }
}
</file>

<file path="src/analysis/token-safety.ts">
import { HeliusClient } from '../api/helius.js';
import { AnalysisCacheRepository } from '../db/repositories/analysis-cache.js';
import { TokenSafetyResult, TokenRisk, GetAssetResponse, CACHE_TTL } from './types.js';
import { createLogger } from '../lib/logger.js';

const logger = createLogger('token-safety');

/**
 * Configuration for holder distribution thresholds
 */
interface HolderThresholds {
  maxTopHolderPercent: number;    // Reject if top holder owns more than this
  maxTop10HoldersPercent: number; // Reject if top 10 own more than this
  minHolderCount: number;         // Warn if fewer holders than this
}

const DEFAULT_HOLDER_THRESHOLDS: HolderThresholds = {
  maxTopHolderPercent: 30,        // 30% max for single holder
  maxTop10HoldersPercent: 50,     // 50% max for top 10 combined
  minHolderCount: 20,             // At least 20 holders
};

/**
 * Analyzer for detecting honeypot tokens and rug pull indicators.
 * 
 * Checks:
 * - Classic SPL Token authorities (mint, freeze)
 * - Token-2022 extensions (permanent delegate, transfer fees, hooks)
 * - Holder distribution (top holder %, top 10 %)
 * 
 * Results are cached for 24 hours to minimize API calls.
 * 
 * @example
 * const analyzer = new TokenSafetyAnalyzer(helius, cache);
 * const result = await analyzer.analyze('token-mint-address');
 * if (!result.isSafe) {
 *   console.log('Dangerous token detected:', result.risks);
 * }
 */
class TokenSafetyAnalyzer {
  private holderThresholds: HolderThresholds;

  constructor(
    private helius: HeliusClient,
    private cache: AnalysisCacheRepository,
    holderThresholds?: Partial<HolderThresholds>
  ) {
    this.holderThresholds = { ...DEFAULT_HOLDER_THRESHOLDS, ...holderThresholds };
  }

  /**
   * Analyze a token for safety indicators.
   * 
   * Checks cache first, then fetches from Helius DAS API if needed.
   * 
   * @param mintAddress - Token mint address (base58)
   * @returns Token safety analysis result
   */
  async analyze(mintAddress: string): Promise<TokenSafetyResult> {
    // Check cache first
    const cached = this.cache.get<TokenSafetyResult>(mintAddress, 'token_safety');
    if (cached) {
      logger.debug({ mintAddress }, 'Cache hit for token safety');
      return cached;
    }

    // Fetch asset metadata from Helius
    let asset: GetAssetResponse;
    try {
      asset = await this.helius.getAsset(mintAddress);
    } catch (error) {
      logger.error({ mintAddress, error }, 'Failed to fetch token metadata');
      throw error;
    }

    // Analyze on-chain safety first
    const result = this.analyzeAsset(asset);

    // Fetch holder distribution (separate call, may fail for very new tokens)
    try {
      const holdersData = await this.helius.getTokenHolders(mintAddress, 20);
      
      if (holdersData.holders.length > 0) {
        // Calculate top holder %
        const topHolderPercent = holdersData.holders[0]?.percentage || 0;
        
        // Calculate top 10 combined %
        const top10 = holdersData.holders.slice(0, 10);
        const top10HoldersPercent = top10.reduce((sum, h) => sum + h.percentage, 0);

        // Add holder distribution to result
        result.holderDistribution = {
          topHolderPercent,
          top10HoldersPercent,
          totalHolders: holdersData.totalHolders,
        };

        // Check holder concentration risks
        if (topHolderPercent > this.holderThresholds.maxTopHolderPercent) {
          result.risks.push('HIGH_TOP_HOLDER');
          result.isSafe = false;
          logger.warn({ 
            mintAddress, 
            topHolderPercent: topHolderPercent.toFixed(1) 
          }, `Top holder owns ${topHolderPercent.toFixed(1)}% - REJECTED`);
        }

        if (top10HoldersPercent > this.holderThresholds.maxTop10HoldersPercent) {
          result.risks.push('HIGH_TOP10_HOLDERS');
          result.isSafe = false;
          logger.warn({ 
            mintAddress, 
            top10HoldersPercent: top10HoldersPercent.toFixed(1) 
          }, `Top 10 holders own ${top10HoldersPercent.toFixed(1)}% - REJECTED`);
        }

        // Check for insider concentration (few holders with high ownership)
        if (holdersData.totalHolders < this.holderThresholds.minHolderCount && 
            top10HoldersPercent > 40) {
          result.risks.push('INSIDER_CONCENTRATION');
          result.isSafe = false;
          logger.warn({ 
            mintAddress, 
            totalHolders: holdersData.totalHolders,
            top10HoldersPercent: top10HoldersPercent.toFixed(1)
          }, 'Insider concentration detected - REJECTED');
        }
      }
    } catch (error) {
      // Log but don't fail - holder data may not be available for very new tokens
      logger.warn({ mintAddress, error }, 'Failed to fetch holder distribution (token may be too new)');
    }

    // Cache result
    this.cache.set(mintAddress, 'token_safety', result, CACHE_TTL.tokenSafety);

    logger.info(
      { 
        mintAddress, 
        isSafe: result.isSafe, 
        risks: result.risks,
        topHolderPercent: result.holderDistribution?.topHolderPercent?.toFixed(1),
        top10Percent: result.holderDistribution?.top10HoldersPercent?.toFixed(1),
      },
      'Token safety analysis complete'
    );

    return result;
  }

  /**
   * Analyze token asset for safety indicators.
   * 
   * Follows the pattern from 02-RESEARCH.md:
   * 1. Check classic authorities (mint, freeze)
   * 2. Check Token-2022 extensions (permanent delegate, transfer fee, hook)
   * 3. Determine overall safety
   * 
   * @param asset - Helius DAS API response
   * @returns Token safety result
   */
  private analyzeAsset(asset: GetAssetResponse): TokenSafetyResult {
    const risks: TokenRisk[] = [];

    // Check classic authorities
    const tokenInfo = asset.token_info;
    if (tokenInfo?.mint_authority) {
      risks.push('MINT_AUTHORITY_ACTIVE');
    }
    if (tokenInfo?.freeze_authority) {
      risks.push('FREEZE_AUTHORITY_ACTIVE');
    }

    // Check Token-2022 extensions (CRITICAL)
    const extensions = asset.mint_extensions;
    if (extensions?.permanent_delegate) {
      risks.push('PERMANENT_DELEGATE'); // Most dangerous!
    }
    if (extensions?.transfer_fee_config) {
      const feeBps = extensions.transfer_fee_config.transfer_fee_basis_points;
      if (feeBps > 100) { // > 1%
        risks.push('HIGH_TRANSFER_FEE');
      }
    }
    if (extensions?.transfer_hook) {
      risks.push('TRANSFER_HOOK');
    }

    // Determine safety (holder checks added later in analyze())
    // Safe if no critical risks found
    const isSafe = risks.length === 0 ||
                   (risks.length === 1 && risks[0] === 'MUTABLE_METADATA');

    return {
      mint: asset.id,
      isSafe,
      risks,
      authorities: {
        mintAuthority: tokenInfo?.mint_authority ?? null,
        freezeAuthority: tokenInfo?.freeze_authority ?? null,
        updateAuthority: asset.authorities[0]?.address ?? null,
      },
      extensions: {
        hasPermanentDelegate: !!extensions?.permanent_delegate,
        hasTransferFee: !!extensions?.transfer_fee_config,
        hasTransferHook: !!extensions?.transfer_hook,
        permanentDelegateAddress: extensions?.permanent_delegate?.delegate,
        transferFeePercent: extensions?.transfer_fee_config
          ? extensions.transfer_fee_config.transfer_fee_basis_points / 100
          : undefined,
      },
      metadata: {
        isMutable: asset.mutable,
      },
      timestamp: Date.now(),
    };
  }

  /**
   * Convenience method to check if a token is safe.
   * 
   * @param result - Token safety analysis result
   * @returns True if token is safe to trade
   */
  isSafe(result: TokenSafetyResult): boolean {
    return result.isSafe;
  }
}

export { TokenSafetyAnalyzer };
</file>

<file path="src/analysis/types.ts">
/**
 * Type definitions for Phase 2 analysis capabilities.
 * 
 * Includes types for:
 * - Token safety analysis (honeypot detection)
 * - Wallet performance analysis (P&L calculation)
 * - Smart money identification
 */

/**
 * Response from Helius DAS API getAsset method.
 * Source: QuickNode DAS API docs / Helius DAS API
 */
export interface GetAssetResponse {
  interface: string;
  id: string;
  content: {
    metadata: { name: string; symbol: string };
  };
  authorities: Array<{ address: string; scopes: string[] }>;
  ownership: {
    frozen: boolean;
    owner: string;
  };
  token_info?: {
    supply: number;
    decimals: number;
    token_program: string;
    mint_authority: string | null;
    freeze_authority: string | null;
  };
  mint_extensions?: {
    permanent_delegate?: { delegate: string };
    transfer_fee_config?: {
      transfer_fee_basis_points: number;
      maximum_fee: number;
    };
    transfer_hook?: { program_id: string };
  };
  mutable: boolean;
}

/**
 * Token risk types for honeypot detection.
 */
export type TokenRisk =
  | 'MINT_AUTHORITY_ACTIVE'
  | 'FREEZE_AUTHORITY_ACTIVE'
  | 'PERMANENT_DELEGATE'
  | 'HIGH_TRANSFER_FEE'
  | 'TRANSFER_HOOK'
  | 'MUTABLE_METADATA'
  | 'HIGH_TOP_HOLDER'       // Top holder owns >30%
  | 'HIGH_TOP10_HOLDERS'    // Top 10 holders own >50%
  | 'INSIDER_CONCENTRATION'; // Suspicious holder patterns

/**
 * Result of token safety analysis.
 */
export interface TokenSafetyResult {
  mint: string;
  isSafe: boolean;
  risks: TokenRisk[];
  // Optional token info (populated when available)
  symbol?: string;
  name?: string;
  marketCapSol?: number;
  liquidity?: number;
  authorities: {
    mintAuthority: string | null;
    freezeAuthority: string | null;
    updateAuthority: string | null;
  };
  extensions: {
    hasPermanentDelegate: boolean;
    hasTransferFee: boolean;
    hasTransferHook: boolean;
    permanentDelegateAddress?: string;
    transferFeePercent?: number;
  };
  metadata: {
    isMutable: boolean;
  };
  holderDistribution?: {
    topHolderPercent: number;
    top10HoldersPercent: number;
    totalHolders: number;
  };
  timestamp: number;
}

/**
 * Parsed trade from transaction history.
 */
export interface ParsedTrade {
  signature: string;
  timestamp: number;
  type: 'BUY' | 'SELL';
  tokenMint: string;
  tokenAmount: number;
  solAmount: number;
  pricePerToken: number;
  dex: string;
}

/**
 * Position tracking for P&L calculation.
 */
export interface Position {
  tokenMint: string;
  entries: ParsedTrade[];
  exits: ParsedTrade[];
  realizedPnL: number;
  isOpen: boolean;
}

/**
 * Wallet analysis result with trading metrics.
 */
export interface WalletAnalysis {
  address: string;
  metrics: {
    totalTrades: number;
    wins: number;
    losses: number;
    winRate: number;
    totalRealizedPnL: number;
    totalROI: number;
    avgHoldTime: number;
    tokensTraded: number;
  };
  tradingPattern: 'sniper' | 'holder' | 'flipper' | 'unknown';
  isSmartMoney: boolean;
  smartMoneyScore: number;
  lastAnalyzed: number;
}

/**
 * Thresholds for smart money classification.
 */
export interface SmartMoneyThresholds {
  minTrades: number;
  minWinRate: number;
  minRealizedPnL: number;
  minROI: number;
  analysisWindowDays: number;
}

/**
 * Default smart money thresholds.
 * Source: Nansen methodology
 */
export const DEFAULT_THRESHOLDS: SmartMoneyThresholds = {
  minTrades: 10,
  minWinRate: 0.65,
  minRealizedPnL: 50,
  minROI: 100,
  analysisWindowDays: 30,
};

/**
 * Cache TTL recommendations for different analysis types.
 */
export const CACHE_TTL = {
  tokenSafety: 24 * 60 * 60 * 1000,     // 24 hours
  walletAnalysis: 6 * 60 * 60 * 1000,   // 6 hours
  smartMoney: 24 * 60 * 60 * 1000,      // 24 hours
};
</file>

<file path="src/api/dexscreener.ts">
/**
 * DexScreener API Client
 * https://docs.dexscreener.com/api/reference
 */

import { createLogger } from '../lib/logger.js';

const logger = createLogger('dexscreener');

const BASE_URL = 'https://api.dexscreener.com';

/**
 * Token pair data from DexScreener
 */
export interface DexPair {
  chainId: string;
  dexId: string;
  url: string;
  pairAddress: string;
  baseToken: {
    address: string;
    name: string;
    symbol: string;
  };
  quoteToken: {
    address: string;
    name: string;
    symbol: string;
  };
  priceNative: string;
  priceUsd: string;
  txns: {
    m5: { buys: number; sells: number };
    h1: { buys: number; sells: number };
    h6: { buys: number; sells: number };
    h24: { buys: number; sells: number };
  };
  volume: {
    h24: number;
    h6: number;
    h1: number;
    m5: number;
  };
  priceChange: {
    m5: number;
    h1: number;
    h6: number;
    h24: number;
  };
  liquidity?: {
    usd: number;
    base: number;
    quote: number;
  };
  fdv?: number;
  marketCap?: number;
  pairCreatedAt?: number;
  info?: {
    imageUrl?: string;
    websites?: { label: string; url: string }[];
    socials?: { type: string; url: string }[];
  };
  boosts?: {
    active: number;
  };
}

/**
 * Enriched token metadata
 */
export interface TokenMetadata {
  mint: string;
  name: string;
  symbol: string;
  priceUsd: number;
  priceChange5m: number;
  priceChange1h: number;
  priceChange24h: number;
  volume24h: number;
  volume1h: number;
  volume5m: number;     // 5-minute volume
  liquidity: number;
  marketCap: number;
  fdv: number;
  buys5m: number;
  sells5m: number;
  buys1h: number;
  sells1h: number;
  pairAddress: string;
  dexUrl: string;
  imageUrl?: string;
  createdAt?: number;
  ageMinutes?: number;
}

/**
 * DexScreener API Client
 */
export class DexScreenerClient {
  private cache = new Map<string, { data: TokenMetadata; timestamp: number }>();
  private cacheTtlMs = 30000; // 30 second cache

  /**
   * Get token metadata by mint address
   */
  async getTokenMetadata(mint: string): Promise<TokenMetadata | null> {
    // Check cache
    const cached = this.cache.get(mint);
    if (cached && Date.now() - cached.timestamp < this.cacheTtlMs) {
      return cached.data;
    }

    try {
      const response = await fetch(`${BASE_URL}/tokens/v1/solana/${mint}`);

      if (!response.ok) {
        logger.warn({ mint, status: response.status }, 'Failed to fetch token metadata');
        return null;
      }

      const pairs = await response.json() as DexPair[];

      if (!pairs || pairs.length === 0) {
        logger.debug({ mint }, 'No pairs found for token');
        return null;
      }

      // Use the pair with highest liquidity
      const pair = pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0))[0];

      const metadata = this.pairToMetadata(pair);

      // Cache it
      this.cache.set(mint, { data: metadata, timestamp: Date.now() });

      return metadata;
    } catch (error) {
      logger.error({ mint, error }, 'Error fetching token metadata');
      return null;
    }
  }

  /**
   * Get latest token pairs on Solana (for finding new tokens)
   */
  async getLatestTokens(limit: number = 20): Promise<TokenMetadata[]> {
    try {
      const response = await fetch(`${BASE_URL}/token-profiles/latest/v1`);

      if (!response.ok) {
        logger.warn({ status: response.status }, 'Failed to fetch latest tokens');
        return [];
      }

      const profiles = await response.json() as Array<{
        url: string;
        chainId: string;
        tokenAddress: string;
        icon?: string;
        description?: string;
      }>;

      // Filter for Solana tokens
      const solanaTokens = profiles
        .filter(p => p.chainId === 'solana')
        .slice(0, limit);

      // Fetch metadata for each
      const results: TokenMetadata[] = [];
      for (const token of solanaTokens) {
        const metadata = await this.getTokenMetadata(token.tokenAddress);
        if (metadata) {
          if (token.icon) metadata.imageUrl = token.icon;
          results.push(metadata);
        }
      }

      return results;
    } catch (error) {
      logger.error({ error }, 'Error fetching latest tokens');
      return [];
    }
  }

  /**
   * Get boosted tokens (paid promotion = often new launches)
   */
  async getBoostedTokens(): Promise<TokenMetadata[]> {
    try {
      const response = await fetch(`${BASE_URL}/token-boosts/latest/v1`);

      if (!response.ok) {
        logger.warn({ status: response.status }, 'Failed to fetch boosted tokens');
        return [];
      }

      const boosts = await response.json() as Array<{
        url: string;
        chainId: string;
        tokenAddress: string;
        amount: number;
        totalAmount: number;
        icon?: string;
      }>;

      // Filter for Solana
      const solanaBoosts = boosts.filter(b => b.chainId === 'solana');

      const results: TokenMetadata[] = [];
      for (const boost of solanaBoosts.slice(0, 10)) {
        const metadata = await this.getTokenMetadata(boost.tokenAddress);
        if (metadata) {
          if (boost.icon) metadata.imageUrl = boost.icon;
          results.push(metadata);
        }
      }

      return results;
    } catch (error) {
      logger.error({ error }, 'Error fetching boosted tokens');
      return [];
    }
  }

  /**
   * Search for tokens by name/symbol
   */
  async searchTokens(query: string): Promise<TokenMetadata[]> {
    try {
      const response = await fetch(`${BASE_URL}/latest/dex/search?q=${encodeURIComponent(query)}`);

      if (!response.ok) {
        return [];
      }

      const data = await response.json() as { pairs: DexPair[] };

      // Filter for Solana pairs
      const solanaPairs = (data.pairs || []).filter(p => p.chainId === 'solana');

      return solanaPairs.map(p => this.pairToMetadata(p));
    } catch (error) {
      logger.error({ query, error }, 'Error searching tokens');
      return [];
    }
  }

  /**
   * Convert DexPair to TokenMetadata
   */
  private pairToMetadata(pair: DexPair): TokenMetadata {
    const now = Date.now();
    const createdAt = pair.pairCreatedAt;
    const ageMinutes = createdAt ? Math.floor((now - createdAt) / 60000) : undefined;

    return {
      mint: pair.baseToken.address,
      name: pair.baseToken.name,
      symbol: pair.baseToken.symbol,
      priceUsd: parseFloat(pair.priceUsd) || 0,
      priceChange5m: pair.priceChange?.m5 || 0,
      priceChange1h: pair.priceChange?.h1 || 0,
      priceChange24h: pair.priceChange?.h24 || 0,
      volume24h: pair.volume?.h24 || 0,
      volume1h: pair.volume?.h1 || 0,
      volume5m: pair.volume?.m5 || 0,
      liquidity: pair.liquidity?.usd || 0,
      marketCap: pair.marketCap || 0,
      fdv: pair.fdv || 0,
      buys5m: pair.txns?.m5?.buys || 0,
      sells5m: pair.txns?.m5?.sells || 0,
      buys1h: pair.txns?.h1?.buys || 0,
      sells1h: pair.txns?.h1?.sells || 0,
      pairAddress: pair.pairAddress,
      dexUrl: pair.url,
      imageUrl: pair.info?.imageUrl,
      createdAt,
      ageMinutes,
    };
  }

  /**
   * Clear the cache
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Get raw pair data for a token (includes priceNative in SOL)
   */
  async getRawPairs(mint: string): Promise<DexPair[]> {
    try {
      const response = await fetch(`${BASE_URL}/tokens/v1/solana/${mint}`);
      if (!response.ok) {
        return [];
      }
      return (await response.json()) as DexPair[];
    } catch (error) {
      logger.error({ mint, error }, 'Error fetching raw pairs');
      return [];
    }
  }
}

// Singleton instance
export const dexscreener = new DexScreenerClient();
</file>

<file path="src/api/helius-webhook.ts">
/**
 * Helius Webhooks Handler
 * Real-time tracking of wallet transactions for instant P&L updates
 */

import { createLogger } from '../lib/logger.js';
import { agentEvents } from '../events/emitter.js';

const logger = createLogger('helius-webhook');

export interface HeliusWebhookEvent {
  type: 'TRANSFER' | 'TOKEN_TRANSFER' | 'NFT_SALE' | 'SWAP';
  signature: string;
  timestamp: number;
  feePayer: string;
  slot: number;
  nativeTransfers?: Array<{
    fromUserAccount: string;
    toUserAccount: string;
    amount: number;
  }>;
  tokenTransfers?: Array<{
    fromUserAccount: string;
    toUserAccount: string;
    mint: string;
    tokenAmount: number;
    tokenStandard: string;
  }>;
  accountData?: Array<{
    account: string;
    nativeBalanceChange: number;
    tokenBalanceChanges?: Array<{
      mint: string;
      rawTokenAmount: {
        tokenAmount: string;
        decimals: number;
      };
      userAccount: string;
    }>;
  }>;
}

/**
 * Handle incoming Helius webhook events
 */
export async function handleHeliusWebhook(
  events: HeliusWebhookEvent[],
  walletAddress: string
): Promise<void> {
  for (const event of events) {
    logger.info({
      type: event.type,
      signature: event.signature,
      timestamp: event.timestamp,
    }, 'Received webhook event');

    // Track token transfers involving our wallet
    if (event.tokenTransfers) {
      for (const transfer of event.tokenTransfers) {
        const isSell = transfer.fromUserAccount === walletAddress;
        const isBuy = transfer.toUserAccount === walletAddress;

        if (isSell || isBuy) {
          logger.info({
            type: isSell ? 'SELL' : 'BUY',
            mint: transfer.mint,
            amount: transfer.tokenAmount,
            signature: event.signature,
          }, 'üí∞ Wallet trade detected');

          // Emit event for real-time P&L update
          agentEvents.emit({
            type: 'WALLET_TRANSACTION',
            timestamp: event.timestamp,
            data: {
              signature: event.signature,
              slot: event.slot,
              timestamp: event.timestamp,
              type: isSell ? 'TRANSFER' : 'TRANSFER',
              description: `${isSell ? 'Sell' : 'Buy'} ${transfer.tokenAmount} tokens`,
              accountData: [{
                account: walletAddress,
                nativeBalanceChange: 0,
                tokenBalanceChanges: [{
                  mint: transfer.mint,
                  rawTokenAmount: {
                    tokenAmount: transfer.tokenAmount.toString(),
                    decimals: 6,
                  },
                }],
              }],
            },
          });
        }
      }
    }

    // Track SOL balance changes
    if (event.accountData) {
      for (const account of event.accountData) {
        if (account.account === walletAddress && account.nativeBalanceChange !== 0) {
          const solChange = account.nativeBalanceChange / 1e9; // Convert lamports to SOL

          logger.info({
            signature: event.signature,
            solChange: solChange.toFixed(4),
          }, solChange > 0 ? 'üí∏ SOL received' : 'üí∞ SOL spent');

          // Track token balance changes within the same transaction
          if (account.tokenBalanceChanges) {
            for (const tokenChange of account.tokenBalanceChanges) {
              logger.info({
                mint: tokenChange.mint,
                amount: tokenChange.rawTokenAmount.tokenAmount,
                signature: event.signature,
              }, 'ü™ô Token balance changed');
            }
          }
        }
      }
    }
  }
}

/**
 * Create Helius webhook configuration
 */
export function createWebhookConfig(walletAddress: string, webhookUrl: string) {
  return {
    webhookURL: webhookUrl,
    transactionTypes: ['TRANSFER', 'TOKEN_TRANSFER', 'SWAP'],
    accountAddresses: [walletAddress],
    webhookType: 'enhanced', // Enhanced webhooks include decoded transaction data
    authHeader: process.env.HELIUS_WEBHOOK_SECRET || undefined,
  };
}

/**
 * Verify Helius webhook signature (if auth header is configured)
 */
export function verifyWebhookSignature(
  body: string,
  signature: string | undefined
): boolean {
  const secret = process.env.HELIUS_WEBHOOK_SECRET;
  
  if (!secret) {
    // No signature verification if secret not configured
    return true;
  }

  if (!signature) {
    logger.warn('Webhook signature missing but secret is configured');
    return false;
  }

  // Helius uses HMAC-SHA256 for webhook signing
  const crypto = require('crypto');
  const hmac = crypto.createHmac('sha256', secret);
  hmac.update(body);
  const expectedSignature = hmac.digest('hex');

  return signature === expectedSignature;
}
</file>

<file path="src/api/moralis.ts">
/**
 * Moralis API client for Solana token discovery
 *
 * Features:
 * - Trending tokens
 * - Top gainers/losers
 * - Token search
 * - Security scores
 *
 * Docs: https://docs.moralis.com/web3-data-api/solana
 */

import { createLogger } from '../lib/logger.js';

const logger = createLogger('moralis');

const BASE_URL = 'https://deep-index.moralis.io/api/v2.2';

/**
 * Moralis token response
 */
export interface MoralisToken {
  tokenAddress: string;
  name: string;
  symbol: string;
  logo?: string;
  decimals: number;
  priceUsd: number;
  priceChange24h?: number;
  priceChange1h?: number;
  priceChange5m?: number;
  volume24h?: number;
  volume1h?: number;
  marketCap?: number;
  fullyDilutedValuation?: number;
  liquidity?: number;
  securityScore?: number;
  holders?: number;
  buyers24h?: number;
  sellers24h?: number;
  buyVolume24h?: number;
  sellVolume24h?: number;
  netVolume24h?: number;
  experiencedBuyerCount?: number;
  // Timestamps
  createdAt?: string;
  // Social links
  twitter?: string;
  telegram?: string;
  website?: string;
}

/**
 * Trending token with additional metadata
 */
export interface TrendingToken extends MoralisToken {
  rank: number;
  trendingScore?: number;
}

/**
 * Top gainer/loser token
 */
export interface GainerLoserToken extends MoralisToken {
  priceChangePercent: number;
  timeFrame: string;
}

/**
 * Moralis API response wrapper
 */
interface MoralisResponse<T> {
  result: T[];
  cursor?: string;
  page?: number;
  pageSize?: number;
}

/**
 * Configuration for Moralis client
 */
export interface MoralisConfig {
  apiKey: string;
  /** Rate limit delay between requests (ms) */
  rateLimitDelayMs?: number;
}

/**
 * Options for trending tokens
 */
export interface TrendingOptions {
  limit?: number;
  /** Minimum security score (0-100) */
  minSecurityScore?: number;
  /** Minimum market cap in USD */
  minMarketCap?: number;
  /** Minimum liquidity in USD */
  minLiquidity?: number;
}

/**
 * Options for top gainers/losers
 */
export interface GainersLosersOptions {
  limit?: number;
  /** Time frame: 5m, 1h, 4h, 12h, 24h */
  timeFrame?: '5m' | '1h' | '4h' | '12h' | '24h';
  /** Minimum security score (0-100) */
  minSecurityScore?: number;
  /** Minimum market cap in USD */
  minMarketCap?: number;
}

/**
 * Moralis API client
 */
export class MoralisClient {
  private apiKey: string;
  private rateLimitDelayMs: number;
  private lastRequestTime = 0;

  constructor(config: MoralisConfig) {
    this.apiKey = config.apiKey;
    this.rateLimitDelayMs = config.rateLimitDelayMs ?? 200;

    logger.info('MoralisClient initialized');
  }

  /**
   * Enforce rate limiting
   */
  private async enforceRateLimit(): Promise<void> {
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequestTime;

    if (timeSinceLastRequest < this.rateLimitDelayMs) {
      await this.sleep(this.rateLimitDelayMs - timeSinceLastRequest);
    }

    this.lastRequestTime = Date.now();
  }

  /**
   * Make authenticated request to Moralis API
   */
  private async request<T>(endpoint: string, params?: Record<string, string | number>): Promise<T> {
    await this.enforceRateLimit();

    const url = new URL(`${BASE_URL}${endpoint}`);

    // Add query params
    if (params) {
      for (const [key, value] of Object.entries(params)) {
        if (value !== undefined && value !== null) {
          url.searchParams.set(key, String(value));
        }
      }
    }

    // Always add chain=solana for our use case
    url.searchParams.set('chain', 'solana');

    logger.debug({ endpoint, params }, 'Moralis API request');

    const response = await fetch(url.toString(), {
      headers: {
        'X-API-Key': this.apiKey,
        'Accept': 'application/json',
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      logger.error({ status: response.status, error: errorText }, 'Moralis API error');
      throw new Error(`Moralis API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    return data as T;
  }

  /**
   * Get trending tokens on Solana
   *
   * Returns tokens trending based on trading activity, volume, and liquidity.
   */
  async getTrendingTokens(options?: TrendingOptions): Promise<TrendingToken[]> {
    const params: Record<string, string | number> = {
      limit: options?.limit ?? 25,
    };

    if (options?.minSecurityScore) {
      params.security_score = options.minSecurityScore;
    }

    if (options?.minMarketCap) {
      params.min_market_cap = options.minMarketCap;
    }

    if (options?.minLiquidity) {
      params.min_liquidity = options.minLiquidity;
    }

    try {
      const response = await this.request<MoralisResponse<TrendingToken>>(
        '/discovery/tokens/trending',
        params
      );

      const tokens = response.result || [];

      logger.info({ count: tokens.length }, 'Fetched trending tokens from Moralis');

      return tokens.map((token, index) => ({
        ...token,
        rank: index + 1,
      }));
    } catch (error) {
      logger.error({ error }, 'Failed to fetch trending tokens');
      throw error;
    }
  }

  /**
   * Get top gaining tokens on Solana
   */
  async getTopGainers(options?: GainersLosersOptions): Promise<GainerLoserToken[]> {
    const params: Record<string, string | number> = {
      limit: options?.limit ?? 25,
      time_frame: options?.timeFrame ?? '24h',
    };

    if (options?.minSecurityScore) {
      params.security_score = options.minSecurityScore;
    }

    if (options?.minMarketCap) {
      params.min_market_cap = options.minMarketCap;
    }

    try {
      const response = await this.request<MoralisResponse<GainerLoserToken>>(
        '/discovery/tokens/top-gainers',
        params
      );

      const tokens = response.result || [];

      logger.info({
        count: tokens.length,
        timeFrame: options?.timeFrame ?? '24h',
      }, 'Fetched top gainers from Moralis');

      return tokens;
    } catch (error) {
      logger.error({ error }, 'Failed to fetch top gainers');
      throw error;
    }
  }

  /**
   * Get top losing tokens on Solana
   */
  async getTopLosers(options?: GainersLosersOptions): Promise<GainerLoserToken[]> {
    const params: Record<string, string | number> = {
      limit: options?.limit ?? 25,
      time_frame: options?.timeFrame ?? '24h',
    };

    if (options?.minSecurityScore) {
      params.security_score = options.minSecurityScore;
    }

    if (options?.minMarketCap) {
      params.min_market_cap = options.minMarketCap;
    }

    try {
      const response = await this.request<MoralisResponse<GainerLoserToken>>(
        '/discovery/tokens/top-losers',
        params
      );

      const tokens = response.result || [];

      logger.info({
        count: tokens.length,
        timeFrame: options?.timeFrame ?? '24h',
      }, 'Fetched top losers from Moralis');

      return tokens;
    } catch (error) {
      logger.error({ error }, 'Failed to fetch top losers');
      throw error;
    }
  }

  /**
   * Search for tokens by name or symbol
   */
  async searchTokens(query: string, limit: number = 10): Promise<MoralisToken[]> {
    try {
      const response = await this.request<MoralisResponse<MoralisToken>>(
        '/tokens/search',
        { query, limit }
      );

      return response.result || [];
    } catch (error) {
      logger.error({ query, error }, 'Failed to search tokens');
      throw error;
    }
  }

  /**
   * Get token metadata by address
   */
  async getToken(tokenAddress: string): Promise<MoralisToken | null> {
    try {
      const response = await this.request<MoralisToken>(
        `/tokens/${tokenAddress}`
      );

      return response;
    } catch (error) {
      logger.warn({ tokenAddress, error }, 'Failed to fetch token');
      return null;
    }
  }

  /**
   * Get token security score
   * Higher = safer (0-100)
   */
  async getSecurityScore(tokenAddress: string): Promise<number | null> {
    const token = await this.getToken(tokenAddress);
    return token?.securityScore ?? null;
  }

  /**
   * Get token bonding status
   * Returns whether token is in bonding phase, graduated, or unknown
   */
  async getTokenBondingStatus(tokenAddress: string): Promise<{
    status: 'bonding' | 'graduated' | 'unknown';
    exchange?: string;
    bondingProgress?: number;
    graduatedAt?: string;
  }> {
    try {
      const response = await this.request<{
        status: string;
        exchange?: string;
        bondingProgress?: number;
        graduatedAt?: string;
      }>(`/token/mainnet/${tokenAddress}/bonding-status`);

      return {
        status: response.status === 'bonding' ? 'bonding'
          : response.status === 'graduated' ? 'graduated'
          : 'unknown',
        exchange: response.exchange,
        bondingProgress: response.bondingProgress,
        graduatedAt: response.graduatedAt,
      };
    } catch (error) {
      logger.debug({ tokenAddress, error }, 'Failed to get bonding status');
      return { status: 'unknown' };
    }
  }

  /**
   * Get tokens currently in bonding phase on an exchange
   * Useful for finding new opportunities
   */
  async getBondingTokens(exchange: 'pumpfun' | 'meteora' = 'pumpfun', limit: number = 20): Promise<MoralisToken[]> {
    try {
      const response = await this.request<MoralisResponse<MoralisToken>>(
        `/token/mainnet/exchange/${exchange}/bonding`,
        { limit }
      );

      logger.info({ exchange, count: response.result?.length ?? 0 }, 'Fetched bonding tokens');
      return response.result || [];
    } catch (error) {
      logger.error({ exchange, error }, 'Failed to fetch bonding tokens');
      return [];
    }
  }

  /**
   * Get recently graduated tokens from an exchange
   * These have moved from bonding curve to DEX (Raydium/Jupiter tradeable)
   */
  async getGraduatedTokens(exchange: 'pumpfun' | 'meteora' = 'pumpfun', limit: number = 20): Promise<MoralisToken[]> {
    try {
      const response = await this.request<MoralisResponse<MoralisToken>>(
        `/token/mainnet/exchange/${exchange}/graduated`,
        { limit }
      );

      logger.info({ exchange, count: response.result?.length ?? 0 }, 'Fetched graduated tokens');
      return response.result || [];
    } catch (error) {
      logger.error({ exchange, error }, 'Failed to fetch graduated tokens');
      return [];
    }
  }

  /**
   * Get new tokens from an exchange
   * Returns the most recently created tokens
   */
  async getNewTokens(exchange: 'pumpfun' | 'meteora' | 'raydium' = 'pumpfun', limit: number = 20): Promise<MoralisToken[]> {
    try {
      const response = await this.request<MoralisResponse<MoralisToken>>(
        `/token/mainnet/exchange/${exchange}/new`,
        { limit }
      );

      logger.info({ exchange, count: response.result?.length ?? 0 }, 'Fetched new tokens');
      return response.result || [];
    } catch (error) {
      logger.error({ exchange, error }, 'Failed to fetch new tokens');
      return [];
    }
  }

  /**
   * Get swaps/trades for a token
   * Useful for analyzing trading patterns
   */
  async getTokenSwaps(tokenAddress: string, limit: number = 50): Promise<Array<{
    signature: string;
    timestamp: number;
    type: 'buy' | 'sell';
    solAmount: number;
    tokenAmount: number;
    wallet: string;
  }>> {
    try {
      interface SwapResponse {
        signature: string;
        blockTime: number;
        side: string;
        solAmount: number;
        tokenAmount: number;
        wallet: string;
      }

      const response = await this.request<{ result: SwapResponse[] }>(
        `/token/mainnet/${tokenAddress}/swaps`,
        { limit }
      );

      return (response.result || []).map(swap => ({
        signature: swap.signature,
        timestamp: swap.blockTime * 1000,
        type: swap.side === 'buy' ? 'buy' : 'sell',
        solAmount: swap.solAmount,
        tokenAmount: swap.tokenAmount,
        wallet: swap.wallet,
      }));
    } catch (error) {
      logger.debug({ tokenAddress, error }, 'Failed to fetch token swaps');
      return [];
    }
  }

  /**
   * Convert Moralis token to format compatible with trading loop
   */
  static toTradingLoopFormat(token: MoralisToken | TrendingToken): {
    address: string;
    symbol: string;
    name: string;
    price: number;
    priceChange24h: number;
    priceChange1h: number;
    priceChange5m: number;
    volume24h: number;
    volume1h: number;
    liquidity: number;
    marketCap: number;
    securityScore: number;
    holders: number;
  } {
    return {
      address: token.tokenAddress,
      symbol: token.symbol,
      name: token.name,
      price: token.priceUsd ?? 0,
      priceChange24h: token.priceChange24h ?? 0,
      priceChange1h: token.priceChange1h ?? 0,
      priceChange5m: token.priceChange5m ?? 0,
      volume24h: token.volume24h ?? 0,
      volume1h: token.volume1h ?? 0,
      liquidity: token.liquidity ?? 0,
      marketCap: token.marketCap ?? 0,
      securityScore: token.securityScore ?? 0,
      holders: token.holders ?? 0,
    };
  }

  /**
   * Utility sleep function
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Singleton instance (will be initialized when API key is available)
let moralisClient: MoralisClient | null = null;

/**
 * Get or create Moralis client singleton
 * Auto-initializes from MORALIS_API_KEY environment variable
 */
export function getMoralisClient(): MoralisClient | null {
  if (moralisClient) return moralisClient;

  const apiKey = process.env.MORALIS_API_KEY;
  if (!apiKey) {
    return null;
  }

  moralisClient = new MoralisClient({ apiKey });
  return moralisClient;
}

/**
 * Initialize the Moralis client with explicit API key
 */
export function initMoralisClient(apiKey: string): MoralisClient {
  moralisClient = new MoralisClient({ apiKey });
  return moralisClient;
}
</file>

<file path="src/personality/ai-provider.ts">
/**
 * Multi-provider AI Client - Supports Claude, Groq (free), and Gemini (free)
 *
 * When Anthropic credits run out, switch to a free provider in .env:
 *   AI_PROVIDER=groq   (or gemini)
 *   GROQ_API_KEY=your-key
 */

import { logger } from '../lib/logger.js';

export type AIProvider = 'claude' | 'groq' | 'gemini';

export interface AIProviderConfig {
  provider: AIProvider;
  apiKey: string;
  model?: string;
  maxTokens?: number;
}

export interface AIMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export interface AIResponse {
  content: string;
  provider: AIProvider;
}

/**
 * Default models per provider
 */
const DEFAULT_MODELS: Record<AIProvider, string> = {
  claude: 'claude-sonnet-4-20250514',
  groq: 'llama-3.3-70b-versatile',  // Fast & free (updated from decommissioned 3.1)
  gemini: 'gemini-1.5-flash',        // Fast & free
};

/**
 * Universal AI Provider Client
 */
export class AIProviderClient {
  private provider: AIProvider;
  private apiKey: string;
  private model: string;
  private maxTokens: number;

  constructor(config: AIProviderConfig) {
    this.provider = config.provider;
    this.apiKey = config.apiKey;
    this.model = config.model || DEFAULT_MODELS[config.provider];
    this.maxTokens = config.maxTokens || 200;

    logger.info({
      provider: this.provider,
      model: this.model
    }, 'AI Provider initialized');
  }

  /**
   * Generate a completion with system prompt
   */
  async complete(systemPrompt: string, userMessage: string): Promise<string> {
    try {
      switch (this.provider) {
        case 'claude':
          return await this.completeClaude(systemPrompt, userMessage);
        case 'groq':
          return await this.completeGroq(systemPrompt, userMessage);
        case 'gemini':
          return await this.completeGemini(systemPrompt, userMessage);
        default:
          throw new Error(`Unknown provider: ${this.provider}`);
      }
    } catch (error) {
      logger.error({ error, provider: this.provider }, 'AI completion failed');
      throw error;
    }
  }

  /**
   * Generate with message history
   */
  async completeWithHistory(
    systemPrompt: string,
    messages: Array<{ role: 'user' | 'assistant'; content: string }>
  ): Promise<string> {
    try {
      switch (this.provider) {
        case 'claude':
          return await this.completeClaudeWithHistory(systemPrompt, messages);
        case 'groq':
          return await this.completeGroqWithHistory(systemPrompt, messages);
        case 'gemini':
          return await this.completeGeminiWithHistory(systemPrompt, messages);
        default:
          throw new Error(`Unknown provider: ${this.provider}`);
      }
    } catch (error) {
      logger.error({ error, provider: this.provider }, 'AI completion with history failed');
      throw error;
    }
  }

  // ============ CLAUDE ============
  private async completeClaude(systemPrompt: string, userMessage: string): Promise<string> {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': this.apiKey,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify({
        model: this.model,
        max_tokens: this.maxTokens,
        system: systemPrompt,
        messages: [{ role: 'user', content: userMessage }],
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Claude API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    return data.content?.[0]?.text || '';
  }

  private async completeClaudeWithHistory(
    systemPrompt: string,
    messages: Array<{ role: 'user' | 'assistant'; content: string }>
  ): Promise<string> {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': this.apiKey,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify({
        model: this.model,
        max_tokens: this.maxTokens,
        system: systemPrompt,
        messages,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Claude API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    return data.content?.[0]?.text || '';
  }

  // ============ GROQ (FREE) ============
  private async completeGroq(systemPrompt: string, userMessage: string): Promise<string> {
    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`,
      },
      body: JSON.stringify({
        model: this.model,
        max_tokens: this.maxTokens,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userMessage },
        ],
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Groq API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    return data.choices?.[0]?.message?.content || '';
  }

  private async completeGroqWithHistory(
    systemPrompt: string,
    messages: Array<{ role: 'user' | 'assistant'; content: string }>
  ): Promise<string> {
    const formattedMessages = [
      { role: 'system', content: systemPrompt },
      ...messages,
    ];

    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`,
      },
      body: JSON.stringify({
        model: this.model,
        max_tokens: this.maxTokens,
        messages: formattedMessages,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Groq API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    return data.choices?.[0]?.message?.content || '';
  }

  // ============ GEMINI (FREE) ============
  private async completeGemini(systemPrompt: string, userMessage: string): Promise<string> {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent?key=${this.apiKey}`;

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        systemInstruction: { parts: [{ text: systemPrompt }] },
        contents: [{ parts: [{ text: userMessage }] }],
        generationConfig: {
          maxOutputTokens: this.maxTokens,
        },
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
  }

  private async completeGeminiWithHistory(
    systemPrompt: string,
    messages: Array<{ role: 'user' | 'assistant'; content: string }>
  ): Promise<string> {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent?key=${this.apiKey}`;

    // Gemini uses 'model' instead of 'assistant'
    const contents = messages.map(m => ({
      role: m.role === 'assistant' ? 'model' : 'user',
      parts: [{ text: m.content }],
    }));

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        systemInstruction: { parts: [{ text: systemPrompt }] },
        contents,
        generationConfig: {
          maxOutputTokens: this.maxTokens,
        },
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
  }

  /**
   * Get current provider name
   */
  getProvider(): AIProvider {
    return this.provider;
  }
}

/**
 * Create AI provider from environment variables
 */
export function createAIProvider(): AIProviderClient | null {
  const provider = (process.env.AI_PROVIDER || 'claude').toLowerCase() as AIProvider;

  let apiKey: string | undefined;
  let model: string | undefined;

  switch (provider) {
    case 'groq':
      apiKey = process.env.GROQ_API_KEY;
      model = process.env.GROQ_MODEL;
      break;
    case 'gemini':
      apiKey = process.env.GEMINI_API_KEY;
      model = process.env.GEMINI_MODEL;
      break;
    case 'claude':
    default:
      apiKey = process.env.ANTHROPIC_API_KEY;
      model = process.env.CLAUDE_MODEL;
      break;
  }

  if (!apiKey) {
    logger.warn({ provider }, `No API key found for ${provider} - AI features disabled`);
    return null;
  }

  return new AIProviderClient({
    provider,
    apiKey,
    model,
    maxTokens: 200,
  });
}
</file>

<file path="src/personality/deepgram-tts.ts">
/**
 * Deepgram Text-to-Speech client for $SCHIZO voice output
 */

import { createLogger } from '../lib/logger.js';
import { agentEvents } from '../events/emitter.js';

const logger = createLogger('deepgram-tts');

/**
 * Deepgram TTS configuration
 */
export interface DeepgramTTSConfig {
  apiKey: string;
  model?: string;
  voice?: string;
}

/**
 * Default TTS configuration
 */
export const DEFAULT_TTS_CONFIG: Omit<DeepgramTTSConfig, 'apiKey'> = {
  model: 'aura-2-aries-en', // Natural sounding voice
  voice: 'asteria', // Can be: asteria, luna, stella, athena, hera, orion, arcas, perseus, angus, orpheus
};

/**
 * Deepgram TTS client for generating speech from text
 */
export class DeepgramTTS {
  private config: DeepgramTTSConfig;
  private baseUrl = 'https://api.deepgram.com/v1/speak';

  constructor(config: DeepgramTTSConfig) {
    this.config = {
      ...DEFAULT_TTS_CONFIG,
      ...config,
    };

    logger.info({ model: this.config.model, voice: this.config.voice }, 'Deepgram TTS initialized');
  }

  /**
   * Convert text to speech and return audio buffer
   */
  async speak(text: string): Promise<Buffer> {
    logger.debug({ text: text.slice(0, 50) }, 'Generating speech');

    try {
      const url = `${this.baseUrl}?model=${this.config.model}`;

      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Authorization': `Token ${this.config.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ text }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Deepgram API error: ${response.status} ${errorText}`);
      }

      const audioBuffer = Buffer.from(await response.arrayBuffer());

      logger.info({ textLength: text.length, audioSize: audioBuffer.length }, 'Speech generated');

      return audioBuffer;
    } catch (error) {
      logger.error({ error, text: text.slice(0, 50) }, 'Failed to generate speech');
      throw error;
    }
  }

  /**
   * Speak text and broadcast audio via WebSocket
   */
  async speakAndBroadcast(text: string, wss?: any): Promise<void> {
    try {
      const audioBuffer = await this.speak(text);

      if (wss && wss.clients) {
        // Broadcast audio to all connected clients
        const audioBase64 = audioBuffer.toString('base64');

        const message = JSON.stringify({
          type: 'VOICE_AUDIO',
          timestamp: Date.now(),
          data: {
            text,
            audio: audioBase64,
            format: 'mp3',
          },
        });

        wss.clients.forEach((client: any) => {
          if (client.readyState === 1) { // WebSocket.OPEN
            client.send(message);
          }
        });

        logger.info({ clientCount: wss.clients.size }, 'Voice broadcast sent');
      }

      // Also emit event for the feed
      agentEvents.emit({
        type: 'SCHIZO_SPEAKS',
        timestamp: Date.now(),
        data: { text },
      });
    } catch (error) {
      logger.error({ error }, 'Failed to speak and broadcast');
    }
  }

  /**
   * Get available voices
   */
  getAvailableVoices(): string[] {
    return [
      'asteria',  // Default, warm female
      'luna',     // Soft female
      'stella',   // Professional female
      'athena',   // Confident female
      'hera',     // Mature female
      'orion',    // Deep male
      'arcas',    // Friendly male
      'perseus',  // Strong male
      'angus',    // Scottish accent
      'orpheus',  // Dramatic male
    ];
  }

  /**
   * Update voice
   */
  setVoice(voice: string): void {
    this.config.voice = voice;
    this.config.model = `aura-${voice}-en`;
    logger.info({ voice }, 'Voice updated');
  }
}

/**
 * Create a voice narrator that speaks the agent's thoughts
 */
export class VoiceNarrator {
  private tts: DeepgramTTS;
  private wss?: any;
  private speakQueue: string[] = [];
  private enabled = true;
  private processingPromise: Promise<void> | null = null;
  private recentSpoken: Map<string, number> = new Map(); // text hash -> timestamp
  private readonly DEDUPE_WINDOW_MS = 30000; // 30 seconds deduplication window

  constructor(tts: DeepgramTTS, wss?: any) {
    this.tts = tts;
    this.wss = wss;

    // Cleanup old entries periodically
    setInterval(() => this.cleanupRecentSpoken(), 60000);

    logger.info('Voice narrator initialized with deduplication');
  }

  /**
   * Simple hash for deduplication
   */
  private hashText(text: string): string {
    // Use first 50 chars + length as a simple hash
    return `${text.slice(0, 50).toLowerCase()}_${text.length}`;
  }

  /**
   * Cleanup old entries from deduplication map
   */
  private cleanupRecentSpoken(): void {
    const now = Date.now();
    for (const [hash, timestamp] of this.recentSpoken) {
      if (now - timestamp > this.DEDUPE_WINDOW_MS * 2) {
        this.recentSpoken.delete(hash);
      }
    }
  }

  /**
   * Enable/disable voice
   */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
    logger.info({ enabled }, 'Voice narrator enabled state changed');
  }

  /**
   * Set WebSocket server for broadcasting
   */
  setWebSocket(wss: any): void {
    this.wss = wss;
  }

  /**
   * Replace acronyms with pronounceable versions for TTS
   */
  private replaceAcronyms(text: string): string {
    const acronymMap: Record<string, string> = {
      // Crypto currencies - use phonetic spellings
      ' SOL': ' soul',        // Solana
      'SOL ': 'soul ',
      'SOL.': 'soul.',
      'SOL,': 'soul,',
      'SOL?': 'soul?',
      'SOL!': 'soul!',
      
      ' USDC': ' U-S-D-C',    // USD Coin
      'USDC ': 'U-S-D-C ',
      
      ' BTC': ' bitcoin',     // Bitcoin
      'BTC ': 'bitcoin ',
      
      ' ETH': ' ethereum',    // Ethereum
      'ETH ': 'ethereum ',
      
      ' USDT': ' tether',     // Tether
      'USDT ': 'tether ',
      
      // Common trading terms
      ' mcap': ' market cap',
      'mcap ': 'market cap ',
      
      ' P&L': ' profit and loss',
      'P&L ': 'profit and loss ',
      
      ' NFT': ' N-F-T',
      'NFT ': 'N-F-T ',
      
      ' DeFi': ' dee-fi',
      'DeFi ': 'dee-fi ',
      
      ' APY': ' A-P-Y',
      'APY ': 'A-P-Y ',
      
      ' TVL': ' T-V-L',
      'TVL ': 'T-V-L ',
    };

    let result = text;
    for (const [acronym, replacement] of Object.entries(acronymMap)) {
      result = result.replace(new RegExp(acronym, 'g'), replacement);
    }
    
    return result;
  }

  /**
   * Clean text for speech - remove asterisk actions and other non-speech content
   */
  private cleanTextForSpeech(text: string): string {
    // Remove asterisk actions like *neural networks flickering*
    let cleaned = text.replace(/\*[^*]+\*/g, '');
    
    // Remove emojis and graphic symbols
    cleaned = cleaned.replace(/([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g, '');
    
    // Replace acronyms with pronounceable versions
    cleaned = this.replaceAcronyms(cleaned);
    
    // Remove multiple spaces
    cleaned = cleaned.replace(/\s+/g, ' ').trim();
    return cleaned;
  }

  /**
   * Queue text to be spoken
   */
  async say(text: string): Promise<void> {
    if (!this.enabled) {
      logger.debug('Voice disabled, skipping');
      return;
    }

    // Clean the text before queuing
    const cleanedText = this.cleanTextForSpeech(text);
    if (!cleanedText) {
      logger.debug('Text empty after cleaning, skipping');
      return;
    }

    // Check for duplicate/similar text recently spoken
    const hash = this.hashText(cleanedText);
    const lastSpoken = this.recentSpoken.get(hash);
    if (lastSpoken && Date.now() - lastSpoken < this.DEDUPE_WINDOW_MS) {
      logger.debug({ text: cleanedText.slice(0, 30) }, 'Skipping duplicate speech');
      return;
    }

    // Mark as spoken (even before actual speech to prevent queue duplicates)
    this.recentSpoken.set(hash, Date.now());

    // Limit queue size to prevent buildup
    if (this.speakQueue.length >= 3) {
      logger.warn({ queueLength: this.speakQueue.length }, 'Speech queue full, dropping oldest');
      this.speakQueue.shift();
    }

    this.speakQueue.push(cleanedText);
    // Don't await - let queue process in background
    this.processQueue();
  }

  /**
   * Process the speak queue - ensures only one speech at a time
   */
  private processQueue(): void {
    // If already processing, the loop will pick up new items
    if (this.processingPromise) {
      return;
    }

    this.processingPromise = this.doProcessQueue().finally(() => {
      this.processingPromise = null;
    });
  }

  private async doProcessQueue(): Promise<void> {
    while (this.speakQueue.length > 0) {
      const text = this.speakQueue.shift()!;

      try {
        logger.info({ queueLength: this.speakQueue.length }, 'Speaking next in queue');
        await this.tts.speakAndBroadcast(text, this.wss);

        // Add delay between speeches to prevent overlap
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        logger.error({ error }, 'Error speaking text');
      }
    }
  }

  /**
   * Clear the speak queue
   */
  clearQueue(): void {
    this.speakQueue = [];
    logger.info('Speak queue cleared');
  }

  /**
   * Get queue length
   */
  getQueueLength(): number {
    return this.speakQueue.length;
  }
}
</file>

<file path="src/personality/index.ts">
/**
 * Personality module exports
 */

export { ClaudeClient, DEFAULT_CLAUDE_CONFIG } from './claude-client.js';
export type { ClaudeConfig } from './claude-client.js';
export {
  SCHIZO_SYSTEM_PROMPT,
  formatAnalysisContext,
  formatBuybackContext,
  getMoodStyleModifier,
  getParanoidMusingPrompts,
  getTimePressurePrompts,
} from './prompts.js';
export type { AnalysisContext } from './prompts.js';
export { MoodSystem } from './mood-system.js';
export type { Mood, MoodState, MoodConfig, MoodEffects } from './mood-system.js';
export { CommentarySystem, DEFAULT_COMMENTARY_CONFIG } from './commentary-system.js';
export type { CommentaryConfig, NarrativeBeat, QueuedCommentary, CommentaryContext } from './commentary-system.js';
</file>

<file path="src/services/schizo-token-tracker.ts">
/**
 * $SCHIZO Token Tracker
 * Fetches live price data for the $SCHIZO token and broadcasts to dashboard
 */

import { dexscreener, type TokenMetadata } from '../api/dexscreener.js';
import { createLogger } from '../lib/logger.js';
import type { AgentEventEmitter } from '../events/emitter.js';

const logger = createLogger('schizo-token-tracker');

/**
 * Configuration for the tracker
 */
export interface SchizoTokenTrackerConfig {
  tokenMint: string;
  updateIntervalMs: number;
  enabled: boolean;
}

/**
 * Data structure for token card updates
 */
export interface SchizoTokenData {
  ca: string;
  price: number;
  priceChange24h: number;
  priceChange1h: number;
  marketCap: number;
  volume24h: number;
  liquidity: number;
  holders?: number;
  live: boolean;
  dexUrl?: string;
  imageUrl?: string;
}

/**
 * Tracks $SCHIZO token price and broadcasts updates
 */
export class SchizoTokenTracker {
  private config: SchizoTokenTrackerConfig;
  private eventEmitter: AgentEventEmitter;
  private intervalId: ReturnType<typeof setInterval> | null = null;
  private lastData: SchizoTokenData | null = null;
  private isLive = false;

  constructor(config: SchizoTokenTrackerConfig, eventEmitter: AgentEventEmitter) {
    this.config = config;
    this.eventEmitter = eventEmitter;
  }

  /**
   * Start periodic tracking
   */
  start(): void {
    if (!this.config.enabled) {
      logger.info('$SCHIZO token tracker disabled');
      return;
    }

    if (!this.config.tokenMint || this.config.tokenMint === 'your-schizo-token-mint-here') {
      logger.info('$SCHIZO token mint not configured yet - tracker waiting for token drop');
      return;
    }

    logger.info({
      mint: this.config.tokenMint,
      intervalMs: this.config.updateIntervalMs
    }, '$SCHIZO token tracker started');

    // Broadcast CA immediately so frontend can show it even if token isn't live yet
    this.broadcastUpdate({
      ca: this.config.tokenMint,
      price: 0,
      priceChange24h: 0,
      priceChange1h: 0,
      marketCap: 0,
      volume24h: 0,
      liquidity: 0,
      live: false,
    });

    // Fetch immediately
    this.fetchAndBroadcast();

    // Then periodically
    this.intervalId = setInterval(() => {
      this.fetchAndBroadcast();
    }, this.config.updateIntervalMs);
  }

  /**
   * Stop tracking
   */
  stop(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      logger.info('$SCHIZO token tracker stopped');
    }
  }

  /**
   * Fetch token data and broadcast update
   */
  private async fetchAndBroadcast(): Promise<void> {
    try {
      const metadata = await dexscreener.getTokenMetadata(this.config.tokenMint);

      if (!metadata) {
        // Token not yet on DexScreener (still on pump.fun bonding curve or not launched)
        if (!this.isLive) {
          logger.debug('$SCHIZO token not yet on DexScreener - still bonding or not launched');
        }
        return;
      }

      // Token is live!
      if (!this.isLive) {
        this.isLive = true;
        logger.info({
          price: metadata.priceUsd,
          marketCap: metadata.marketCap
        }, '$SCHIZO token is LIVE on DexScreener!');
      }

      const data: SchizoTokenData = {
        ca: this.config.tokenMint,
        price: metadata.priceUsd,
        priceChange24h: metadata.priceChange24h,
        priceChange1h: metadata.priceChange1h,
        marketCap: metadata.marketCap,
        volume24h: metadata.volume24h,
        liquidity: metadata.liquidity,
        live: true,
        dexUrl: metadata.dexUrl,
        imageUrl: metadata.imageUrl,
      };

      // Only broadcast if data changed meaningfully
      if (this.hasDataChanged(data)) {
        this.lastData = data;
        this.broadcastUpdate(data);
      }
    } catch (error) {
      logger.error({ error }, 'Error fetching $SCHIZO token data');
    }
  }

  /**
   * Check if data changed enough to warrant an update
   */
  private hasDataChanged(newData: SchizoTokenData): boolean {
    if (!this.lastData) return true;

    // Always update if live status changed
    if (this.lastData.live !== newData.live) return true;

    // Check for meaningful price change (> 0.1%)
    const priceChange = Math.abs(newData.price - this.lastData.price) / (this.lastData.price || 1);
    if (priceChange > 0.001) return true;

    // Check for meaningful volume change
    const volumeChange = Math.abs(newData.volume24h - this.lastData.volume24h) / (this.lastData.volume24h || 1);
    if (volumeChange > 0.05) return true;

    // Check for mcap change
    const mcapChange = Math.abs(newData.marketCap - this.lastData.marketCap) / (this.lastData.marketCap || 1);
    if (mcapChange > 0.01) return true;

    return false;
  }

  /**
   * Broadcast token update event
   */
  private broadcastUpdate(data: SchizoTokenData): void {
    this.eventEmitter.emit({
      type: 'SCHIZO_TOKEN_UPDATE' as any,
      timestamp: Date.now(),
      data: data as any,
    });

    logger.debug({
      price: data.price.toFixed(8),
      mcap: data.marketCap.toFixed(0)
    }, '$SCHIZO token update broadcast');
  }

  /**
   * Force a refresh
   */
  async refresh(): Promise<SchizoTokenData | null> {
    await this.fetchAndBroadcast();
    return this.lastData;
  }

  /**
   * Get current token data
   */
  getCurrentData(): SchizoTokenData | null {
    return this.lastData;
  }

  /**
   * Check if token is live
   */
  isTokenLive(): boolean {
    return this.isLive;
  }
}

/**
 * Create tracker with default config from env
 */
export function createSchizoTokenTracker(eventEmitter: AgentEventEmitter): SchizoTokenTracker {
  const config: SchizoTokenTrackerConfig = {
    tokenMint: process.env.SCHIZO_TOKEN_MINT || '',
    updateIntervalMs: parseInt(process.env.SCHIZO_TOKEN_UPDATE_INTERVAL || '10000', 10), // 10s default
    enabled: process.env.SCHIZO_TOKEN_TRACKER_ENABLED !== 'false', // enabled by default
  };

  return new SchizoTokenTracker(config, eventEmitter);
}
</file>

<file path="src/shill-queue/shill-queue.ts">
/**
 * Shill Queue - Processes viewer shill requests
 *
 * When a viewer burns $SCHIZO with a CA in the memo:
 * 1. Announce receipt via TTS
 * 2. Run safety analysis
 * 3. If FAIL: Generate roast, speak it
 * 4. If PASS: Execute lotto buy
 */

import { createLogger } from '../lib/logger.js';
import { agentEvents } from '../events/emitter.js';
import { dexscreener } from '../api/dexscreener.js';
import type { TradingEngine } from '../trading/trading-engine.js';
import type { TokenSafetyAnalyzer } from '../analysis/token-safety.js';
import type { ClaudeClient } from '../personality/claude-client.js';
import type { VoiceNarrator } from '../personality/deepgram-tts.js';
import type { CommentarySystem } from '../personality/commentary-system.js';
import type {
  ShillQueueConfig,
  ShillRequest,
  ShillAnalysisResult,
} from './types.js';

const logger = createLogger('shill-queue');

/**
 * Token info fetched from DexScreener
 */
interface TokenInfo {
  symbol: string;
  name: string;
  marketCapSol?: number;
  liquidity?: number;
}

/**
 * ShillQueue - Processes viewer shill requests
 */
export class ShillQueue {
  private config: ShillQueueConfig;
  private tradingEngine: TradingEngine | undefined;
  private tokenSafety: TokenSafetyAnalyzer;
  private claude: ClaudeClient | undefined;
  private narrator: VoiceNarrator | undefined;
  private commentarySystem: CommentarySystem | undefined;

  /** Queue of pending shill requests */
  private queue: ShillRequest[] = [];

  /** Is currently processing */
  private isProcessing = false;

  /** Processed CAs to avoid duplicates */
  private processedCAs = new Set<string>();

  constructor(
    config: ShillQueueConfig,
    tradingEngine: TradingEngine | undefined,
    tokenSafety: TokenSafetyAnalyzer,
    claude?: ClaudeClient,
    narrator?: VoiceNarrator,
    commentarySystem?: CommentarySystem
  ) {
    this.config = config;
    this.tradingEngine = tradingEngine;
    this.tokenSafety = tokenSafety;
    this.claude = claude;
    this.narrator = narrator;
    this.commentarySystem = commentarySystem;

    logger.info({
      maxQueueSize: config.maxQueueSize,
      lottoSize: config.lottoPositionSol,
    }, 'ShillQueue initialized');
  }

  /**
   * Add a shill request to the queue
   */
  enqueue(request: ShillRequest): void {
    // Check for duplicate CA
    if (this.processedCAs.has(request.contractAddress)) {
      logger.info({
        ca: request.contractAddress.slice(0, 8) + '...',
      }, 'CA already processed, skipping');
      return;
    }

    // Check queue size
    if (this.queue.length >= this.config.maxQueueSize) {
      logger.warn({
        queueSize: this.queue.length,
        maxSize: this.config.maxQueueSize,
      }, 'Queue full, dropping oldest shill');
      this.queue.shift();
    }

    this.queue.push(request);
    this.processedCAs.add(request.contractAddress);

    // Clean up old CAs periodically
    if (this.processedCAs.size > 100) {
      const entries = Array.from(this.processedCAs);
      this.processedCAs = new Set(entries.slice(-50));
    }

    logger.info({
      sender: request.senderWallet.slice(0, 8) + '...',
      ca: request.contractAddress.slice(0, 8) + '...',
      amount: request.schizoAmountBurned,
      queueSize: this.queue.length,
    }, 'Shill request queued');

    // Start processing if not already
    this.processQueue();
  }

  /**
   * Process the queue one at a time
   */
  private async processQueue(): Promise<void> {
    if (this.isProcessing || this.queue.length === 0) {
      return;
    }

    this.isProcessing = true;

    try {
      while (this.queue.length > 0) {
        const request = this.queue.shift()!;
        await this.processShill(request);
      }
    } catch (error) {
      logger.error({ error }, 'Error processing shill queue');
    } finally {
      this.isProcessing = false;
    }
  }

  /**
   * Fetch token info from DexScreener
   */
  private async fetchTokenInfo(mint: string): Promise<TokenInfo> {
    try {
      const tokenData = await dexscreener.getTokenMetadata(mint);
      if (tokenData) {
        // Convert SOL price to market cap in SOL (approximate)
        const solPrice = 170; // Approximate SOL price in USD
        const marketCapSol = tokenData.marketCap ? tokenData.marketCap / solPrice : undefined;

        return {
          symbol: tokenData.symbol,
          name: tokenData.name,
          marketCapSol,
          liquidity: tokenData.liquidity,
        };
      }
    } catch (error) {
      logger.warn({ error, mint }, 'Failed to fetch token info from DexScreener');
    }

    // Return defaults if fetch fails
    return {
      symbol: mint.slice(0, 6),
      name: 'Unknown',
    };
  }

  /**
   * Process a single shill request
   */
  private async processShill(request: ShillRequest): Promise<ShillAnalysisResult> {
    const startTime = Date.now();
    const shortSender = request.senderWallet.slice(0, 6);
    const shortCA = request.contractAddress.slice(0, 8);

    logger.info({
      sender: shortSender,
      ca: shortCA,
      amount: request.schizoAmountBurned,
    }, 'Processing shill request');

    // 1. Emit SHILL_RECEIVED event
    agentEvents.emit({
      type: 'SHILL_RECEIVED',
      timestamp: Date.now(),
      data: {
        reasoning: `Viewer ${shortSender}... burned ${request.schizoAmountBurned.toFixed(0)} $SCHIZO to shill ${shortCA}...`,
        logs: [`Shill from ${request.senderWallet}`, `CA: ${request.contractAddress}`],
        senderWallet: request.senderWallet,
        contractAddress: request.contractAddress,
        schizoAmountBurned: request.schizoAmountBurned,
      },
    });

    // 2. Announce receipt via TTS
    const announcement = `Incoming shill from wallet ${shortSender}. They burned ${request.schizoAmountBurned.toFixed(0)} SCHIZO tokens. Let me check this one out.`;

    if (this.narrator) {
      await this.narrator.say(announcement);
    }

    // 3. Fetch token info (parallel with safety analysis)
    const [safetyResult, tokenInfo] = await Promise.all([
      // Safety analysis with timeout
      Promise.race([
        this.tokenSafety.analyze(request.contractAddress),
        new Promise<null>((_, reject) =>
          setTimeout(() => reject(new Error('Analysis timeout')), this.config.processingTimeoutMs)
        ),
      ]).catch(error => {
        logger.error({ error, ca: request.contractAddress }, 'Safety analysis failed/timeout');
        return null;
      }),
      // Token info fetch
      this.fetchTokenInfo(request.contractAddress),
    ]);

    // Handle analysis timeout/error
    if (!safetyResult) {
      const roast = 'This token is taking too long to analyze. Probably hiding something. Hard pass.';

      agentEvents.emit({
        type: 'SHILL_ROAST',
        timestamp: Date.now(),
        data: {
          reasoning: 'Token analysis timed out - treating as unsafe',
          logs: ['Analysis timeout'],
          senderWallet: request.senderWallet,
          contractAddress: request.contractAddress,
          roastMessage: roast,
          risks: ['Analysis timeout'],
        },
      });

      if (this.narrator) {
        await this.narrator.say(roast);
      }

      return {
        request,
        isSafe: false,
        risks: ['Analysis timeout'],
        tokenInfo,
        roastMessage: roast,
      };
    }

    // 4. Check if safe
    if (!safetyResult.isSafe) {
      logger.info({
        ca: shortCA,
        risks: safetyResult.risks,
      }, 'Shilled token FAILED safety check');

      // Generate roast
      const roast = await this.generateRoast(request, safetyResult.risks);

      agentEvents.emit({
        type: 'SHILL_ROAST',
        timestamp: Date.now(),
        data: {
          reasoning: `Token ${tokenInfo.symbol} failed safety checks`,
          logs: safetyResult.risks,
          tokenSymbol: tokenInfo.symbol,
          senderWallet: request.senderWallet,
          contractAddress: request.contractAddress,
          roastMessage: roast,
          risks: safetyResult.risks,
        },
      });

      if (this.narrator) {
        await this.narrator.say(roast);
      }

      return {
        request,
        isSafe: false,
        risks: safetyResult.risks,
        tokenInfo,
        roastMessage: roast,
      };
    }

    // 5. Token passed! Execute lotto buy
    logger.info({
      ca: shortCA,
      symbol: tokenInfo.symbol,
    }, 'Shilled token PASSED safety check - executing lotto buy');

    let buySignature: string | null = null;

    if (this.tradingEngine) {
      try {
        const successMsg = `${tokenInfo.symbol} passed my paranoid checks. Aping in with a lotto position.`;

        if (this.narrator) {
          await this.narrator.say(successMsg);
        }

        buySignature = await this.tradingEngine.executeBuy(
          request.contractAddress,
          {
            symbol: tokenInfo.symbol,
            name: tokenInfo.name,
            marketCapSol: tokenInfo.marketCapSol,
            liquidity: tokenInfo.liquidity,
          },
          true, // Skip evaluation (we already did safety)
          this.config.lottoPositionSol // Override position size to lotto size
        );

        if (buySignature) {
          agentEvents.emit({
            type: 'SHILL_BUY',
            timestamp: Date.now(),
            data: {
              reasoning: `Viewer shill ${tokenInfo.symbol} passed safety - bought ${this.config.lottoPositionSol} SOL`,
              logs: [`Buy signature: ${buySignature}`],
              tokenSymbol: tokenInfo.symbol,
              senderWallet: request.senderWallet,
              contractAddress: request.contractAddress,
              buySignature,
              positionSizeSol: this.config.lottoPositionSol,
            },
          });

          const confirmMsg = `Bought! ${this.config.lottoPositionSol} SOL on ${tokenInfo.symbol}. Thanks for the tip, ${shortSender}.`;
          if (this.narrator) {
            await this.narrator.say(confirmMsg);
          }
        }
      } catch (error) {
        logger.error({ error, ca: request.contractAddress }, 'Failed to execute shill buy');

        const failMsg = `Trade execution failed. The blockchain gods are not pleased today.`;
        if (this.narrator) {
          await this.narrator.say(failMsg);
        }
      }
    } else {
      const noTradeMsg = `${tokenInfo.symbol} looks clean, but trading is disabled. Nice find though, ${shortSender}.`;
      if (this.narrator) {
        await this.narrator.say(noTradeMsg);
      }
    }

    const elapsed = Date.now() - startTime;
    logger.info({
      ca: shortCA,
      elapsedMs: elapsed,
      bought: !!buySignature,
    }, 'Shill processing complete');

    return {
      request,
      isSafe: true,
      risks: [],
      tokenInfo,
      buySignature: buySignature || undefined,
      positionSizeSol: buySignature ? this.config.lottoPositionSol : undefined,
    };
  }

  /**
   * Generate a roast for a failed shill
   */
  private async generateRoast(request: ShillRequest, risks: string[]): Promise<string> {
    const shortSender = request.senderWallet.slice(0, 6);

    // Try Claude for a personalized roast
    if (this.claude) {
      try {
        const roast = await this.claude.generateShillRoast({
          senderWallet: request.senderWallet,
          risks,
          schizoAmountBurned: request.schizoAmountBurned,
        });
        return roast;
      } catch (error) {
        logger.warn({ error }, 'Failed to generate Claude roast, using fallback');
      }
    }

    // Fallback roasts based on risk type
    const riskStr = risks.join(', ').toLowerCase();

    if (riskStr.includes('honeypot') || riskStr.includes('freeze')) {
      return `Nice try ${shortSender}. This token has honeypot written all over it. Your SCHIZO died for nothing.`;
    }

    if (riskStr.includes('mint') || riskStr.includes('authority')) {
      return `${shortSender}, this dev can print tokens whenever they want. That's a hard no from me.`;
    }

    if (riskStr.includes('concentration') || riskStr.includes('holder')) {
      return `One wallet owns half the supply. Thanks for the shill ${shortSender}, but I'm not that gullible.`;
    }

    if (riskStr.includes('liquidity')) {
      return `${shortSender} just burned tokens to shill something with no liquidity. Bold move.`;
    }

    // Generic roast
    return `Sorry ${shortSender}, this one failed my paranoid checks. Better luck next time. Risks: ${risks.slice(0, 2).join(', ')}.`;
  }

  /**
   * Get current queue status
   */
  getQueueStatus(): { size: number; processing: boolean } {
    return {
      size: this.queue.length,
      processing: this.isProcessing,
    };
  }
}
</file>

<file path="src/trading/copy-trader.ts">
import { HeliusClient, TransactionResult } from '../api/helius.js';
import { Connection, PublicKey, Logs } from '@solana/web3.js';
import { createLogger } from '../lib/logger.js';
import { agentEvents } from '../events/emitter.js';

const logger = createLogger('copy-trader');

export interface CopyTraderConfig {
  walletAddresses: string[];  // Changed to array for multiple wallets
  pollIntervalMs: number;
  enabled: boolean;
}

/**
 * CopyTrader - Watches multiple wallets and copies their trades
 * Uses WebSocket subscription for real-time detection
 * "Schizo copy trades" - blindly follows trusted wallets with high confidence
 */
export class CopyTrader {
  private config: CopyTraderConfig;
  private helius: HeliusClient;
  private connection: Connection;
  private isRunning: boolean = false;
  private subscriptionIds: Map<string, number> = new Map(); // wallet -> subscriptionId
  private fallbackIntervalId?: NodeJS.Timeout;
  private lastSignatures: Map<string, string | null> = new Map(); // wallet -> lastSignature
  private isProcessing = false;
  private processedSignatures = new Set<string>();

  constructor(
    config: CopyTraderConfig,
    helius: HeliusClient,
    connection: Connection
  ) {
    this.config = config;
    this.helius = helius;
    this.connection = connection;

    logger.info({ 
      wallets: this.config.walletAddresses.length,
      enabled: this.config.enabled 
    }, `CopyTrader initialized with ${this.config.walletAddresses.length} wallets (WebSocket mode)`);
  }

  /**
   * Start watching all target wallets via WebSocket
   */
  async start(): Promise<void> {
    if (this.isRunning) {
      logger.warn('CopyTrader already running');
      return;
    }

    if (!this.config.enabled || this.config.walletAddresses.length === 0) {
      logger.info('CopyTrader disabled or no wallets configured');
      return;
    }

    this.isRunning = true;

    // Subscribe to each wallet
    for (const walletAddress of this.config.walletAddresses) {
      try {
        const walletPubkey = new PublicKey(walletAddress);
        
        const subscriptionId = this.connection.onLogs(
          walletPubkey,
          (logs: Logs) => this.handleLogNotification(logs, walletAddress),
          'confirmed'
        );

        this.subscriptionIds.set(walletAddress, subscriptionId);
        this.lastSignatures.set(walletAddress, null);

        logger.info({ 
          wallet: walletAddress.slice(0, 8) + '...', 
          subscriptionId 
        }, '‚úÖ WebSocket subscription active');

      } catch (error) {
        logger.error({ wallet: walletAddress, error }, 'Failed to subscribe to wallet');
      }
    }

    logger.info(`üéØ CopyTrader watching ${this.subscriptionIds.size} wallets`);

    // Start fallback polling
    this.startFallbackPolling();
  }

  /**
   * Start fallback polling for all wallets
   */
  private startFallbackPolling(): void {
    if (this.fallbackIntervalId) return;

    const fallbackInterval = Math.max(this.config.pollIntervalMs * 6, 30000);
    
    this.fallbackIntervalId = setInterval(() => {
      this.pollAllWallets().catch(err => {
        logger.error({ error: err }, 'Error in CopyTrader fallback poll');
      });
    }, fallbackInterval);

    logger.debug({ intervalMs: fallbackInterval }, 'Fallback polling started');
  }

  /**
   * Poll all wallets for new transactions
   */
  private async pollAllWallets(): Promise<void> {
    for (const walletAddress of this.config.walletAddresses) {
      await this.pollWallet(walletAddress);
    }
  }

  /**
   * Handle real-time log notification from WebSocket
   */
  private async handleLogNotification(logs: Logs, walletAddress: string): Promise<void> {
    if (logs.err) {
      logger.debug({ signature: logs.signature }, 'Ignoring failed transaction');
      return;
    }

    if (this.processedSignatures.has(logs.signature)) {
      return;
    }
    this.processedSignatures.add(logs.signature);

    // Limit cache size
    if (this.processedSignatures.size > 2000) {
      const entries = Array.from(this.processedSignatures);
      this.processedSignatures = new Set(entries.slice(-1000));
    }

    logger.info({ 
      signature: logs.signature, 
      wallet: walletAddress.slice(0, 8) + '...' 
    }, '‚ö° Real-time transaction detected!');

    // Check if it looks like a swap
    const isLikelySwap = logs.logs.some(log => 
      log.includes('Instruction: Swap') || 
      log.includes('Program 675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8') ||
      log.includes('Program JUP') ||
      log.includes('pump')
    );

    if (!isLikelySwap) {
      logger.info({ signature: logs.signature, logs: logs.logs.slice(0, 3) }, '‚ùå Transaction rejected: Not a swap');
      return;
    }

    const startParse = Date.now();
    await this.analyzeTransactionBySignature(logs.signature, walletAddress);
    logger.debug({ signature: logs.signature, ms: Date.now() - startParse }, 'Transaction analysis complete');
  }

  /**
   * Stop watching all wallets
   */
  stop(): void {
    if (!this.isRunning) return;
    
    this.isRunning = false;

    // Unsubscribe from all WebSocket subscriptions
    for (const [wallet, subscriptionId] of this.subscriptionIds) {
      this.connection.removeOnLogsListener(subscriptionId).catch(err => {
        logger.warn({ error: err, wallet }, 'Failed to remove logs listener');
      });
    }
    this.subscriptionIds.clear();

    if (this.fallbackIntervalId) {
      clearInterval(this.fallbackIntervalId);
      this.fallbackIntervalId = undefined;
    }

    logger.info('CopyTrader stopped');
  }

  /**
   * Fallback poll for a single wallet
   */
  private async pollWallet(walletAddress: string): Promise<void> {
    if (this.isProcessing) return;
    this.isProcessing = true;

    try {
      const response = await this.helius.getTransactionsForAddress(walletAddress, {
        limit: 5
      });

      if (!response.data || response.data.length === 0) {
        return;
      }

      const lastSig = this.lastSignatures.get(walletAddress);

      for (const tx of response.data) {
        if (this.processedSignatures.has(tx.signature)) continue;
        if (tx.signature === lastSig) break;

        this.processedSignatures.add(tx.signature);
        await this.analyzeTransaction(tx, walletAddress);
      }

      if (response.data.length > 0) {
        this.lastSignatures.set(walletAddress, response.data[0].signature);
      }

    } catch (error) {
      logger.error({ error, wallet: walletAddress }, 'Failed to poll wallet');
    } finally {
      this.isProcessing = false;
    }
  }

  /**
   * Analyze transaction by signature (WebSocket path)
   */
  private async analyzeTransactionBySignature(signature: string, walletAddress: string): Promise<void> {
    try {
      const parsed = await this.connection.getParsedTransaction(signature, {
        maxSupportedTransactionVersion: 0,
        commitment: 'confirmed'
      });

      if (!parsed || !parsed.meta) {
          logger.warn({ signature }, '‚ùå Transaction not found or missing meta');
          return;
      }

      await this.processTransaction(signature, parsed, walletAddress);
    } catch (error) {
      logger.warn({ error, signature }, 'Failed to parse transaction from WebSocket');
    }
  }

  /**
   * Analyze a transaction from Helius response (polling path)
   */
  private async analyzeTransaction(tx: TransactionResult, walletAddress: string): Promise<void> {
    if (!tx.success || tx.type !== 'SWAP') {
      return;
    }

    try {
      const parsed = await this.connection.getParsedTransaction(tx.signature, {
        maxSupportedTransactionVersion: 0,
        commitment: 'confirmed'
      });

      if (!parsed || !parsed.meta) return;

      await this.processTransaction(tx.signature, parsed, walletAddress);
    } catch (error) {
      logger.warn({ error, signature: tx.signature }, 'Failed to parse potential copy trade');
    }
  } 

  private async processTransaction(signature: string, parsed: any, walletAddress: string): Promise<void> {
    const preTokenBalances = parsed.meta.preTokenBalances || [];
    const postTokenBalances = parsed.meta.postTokenBalances || [];
    const accountKeys = parsed.transaction.message.accountKeys;
    
    // Find wallet index (handles both legacy and versioned tx structures where static keys are first)
    const walletIndex = accountKeys.findIndex((k: any) => {
        const key = k.pubkey ? k.pubkey.toBase58() : k.toBase58();
        return key === walletAddress;
    });

    if (walletIndex === -1) {
        logger.warn({ signature, walletAddress }, '‚ùå Wallet not found in transaction keys');
        return;
    }

    // Check SOL change
    const preSol = parsed.meta.preBalances[walletIndex];
    const postSol = parsed.meta.postBalances[walletIndex];
    const solChange = (postSol - preSol) / 1e9;

    // Check Token changes
    let boughtMint: string | undefined;

    const getBalance = (balances: any[], mint: string, owner: string) => {
      const b = balances.find(x => x.mint === mint && x.owner === owner);
      return b ? parseFloat(b.uiTokenAmount.uiAmountString || '0') : 0;
    };

    const involvedMints = new Set<string>();
    [...preTokenBalances, ...postTokenBalances].forEach(b => {
      if (b.owner === walletAddress) involvedMints.add(b.mint);
    });

    for (const mint of involvedMints) {
      const pre = getBalance(preTokenBalances, mint, walletAddress);
      const post = getBalance(postTokenBalances, mint, walletAddress);
      if (post > pre) {
        boughtMint = mint;
        break;
      }
    }

    const isBuy = solChange < -0.001 && !!boughtMint;
    
    // Log the analysis details
    logger.info({
        signature,
        solChange: solChange.toFixed(6),
        boughtMint,
        isBuy,
        mintsInvolved: involvedMints.size
    }, 'üîç CopyTrade Analysis');

    if (isBuy && boughtMint) {
      logger.info({ 
        signature, 
        mint: boughtMint, 
        solSpent: Math.abs(solChange).toFixed(4),
        sourceWallet: walletAddress.slice(0, 8) + '...'
      }, 'üéØ COPY TRADE BUY SIGNAL (Real-time)');

      agentEvents.emit({
        type: 'COPY_TRADE_SIGNAL',
        timestamp: Date.now(),
        data: {
           mint: boughtMint,
           sourceWallet: walletAddress,
           signature,
           solSpent: Math.abs(solChange)
        }
      });
    }
  }
}
</file>

<file path="src/trading/types.ts">
/**
 * Trading-related type definitions
 */

/**
 * Token information from PumpPortal
 */
export interface TokenInfo {
  mint: string;
  name: string;
  symbol: string;
  price: number; // in SOL
  liquidity: number; // in SOL
  holderCount: number;
}

/**
 * Parameters for executing a trade
 */
export interface TradeParams {
  mint: string;
  amount: number;
  slippage: number; // 0-1, e.g., 0.05 for 5%
}

/**
 * Result of a trade execution
 */
export interface TradeResult {
  signature: string;
  timestamp: number;
  mint: string;
  amount: number;
  price: number;
}

/**
 * Trade action type
 */
export type TradeAction = 'buy' | 'sell';

/**
 * Risk Profile definition
 */
export type RiskProfile = 'CONSERVATIVE' | 'BALANCED' | 'AGGRESSIVE' | 'ENTERTAINMENT';
</file>

<file path=".env.example">
# Helius API Key (required)
HELIUS_API_KEY=your-api-key-here

# Wallet (required for trading)
WALLET_PRIVATE_KEY=your-base64-encoded-private-key

# PumpPortal API (required for trading)
PUMPPORTAL_API_KEY=your-pumpportal-api-key-here
PUMPPORTAL_BASE_URL=https://pumpportal.fun/api

# Token Discovery APIs (optional - enables trending token scanning)
BIRDEYE_API_KEY=your-birdeye-api-key-here
MORALIS_API_KEY=your-moralis-api-key-here

# Sniper Pipeline Configuration
# "Filter-First" Architecture settings
VALIDATION_DELAY_MS=300000       # Wait 5 minutes before DexScreener check
MIN_LIQUIDITY_USD=10000          # DexScreener liquidity filter ($10k - User Preference)
MIN_VOLUME_1H_USD=5000           # DexScreener volume filter ($5k)
MAX_VALIDATION_RETRIES=3         # How many times to retry validation if data missing

# Trading Configuration
TRADING_ENABLED=false
BASE_POSITION_SOL=0.1
MAX_POSITION_SOL=1.0
MAX_OPEN_POSITIONS=5
MAX_DAILY_TRADES=20
MIN_LIQUIDITY_SOL=10
SLIPPAGE_TOLERANCE=0.05

# Risk Management
CIRCUIT_BREAKER_DAILY_LOSS=-5.0
CIRCUIT_BREAKER_CONSECUTIVE_LOSSES=3
STOP_LOSS_PERCENT=0.2
TAKE_PROFIT_PERCENT=0.5

# Economic Flywheel
SCHIZO_TOKEN_MINT=your-schizo-token-mint-here
SCHIZO_TOKEN_UPDATE_INTERVAL=10000
CREATOR_WALLET=your-creator-wallet-address-here
CREATOR_FEE_SPLIT=0.30
BUYBACK_PERCENTAGE=0.50

# Copy Trading - Private Wallet to Watch
COPY_TRADE_WALLET=

# Shill Queue - Viewers burn $SCHIZO to shill tokens
SHILL_QUEUE_ENABLED=false
SHILL_BURN_WALLET=GvV8bXgQTYSGHnfNF9vgodshgQ4P2fcichGFLqBd73kr
MIN_SHILL_AMOUNT=1000
SHILL_LOTTO_SIZE=0.02
SHILL_COOLDOWN_MS=300000

# AI Personality (optional - runs without personality if not set)
ANTHROPIC_API_KEY=your-anthropic-api-key-here

# Voice Output (optional - Deepgram TTS)
DEEPGRAM_API_KEY=your-deepgram-api-key-here
DEEPGRAM_MODEL=aura-2-aries-en

# WebSocket Server
WEBSOCKET_PORT=8080

# Logging
LOG_LEVEL=info

# Environment
NODE_ENV=development
</file>

<file path="src/personality/claude-client.ts">
/**
 * Claude API client for generating $SCHIZO personality responses
 *
 * Supports multiple AI providers: Claude (default), Groq (free), Gemini (free)
 * Set AI_PROVIDER=groq and GROQ_API_KEY in .env to use free alternatives
 */

import Anthropic from '@anthropic-ai/sdk';
import { logger } from '../lib/logger.js';
import {
  SCHIZO_SYSTEM_PROMPT,
  SCHIZO_CHAT_PROMPT,
  SCHIZO_COMMENTARY_PROMPT,
  SCHIZO_LEARNING_PROMPT,
  formatAnalysisContext,
  formatBuybackContext
} from './prompts.js';
import type { AnalysisContext } from './prompts.js';
import type { SillyCategory } from './name-analyzer.js';
import { AIProviderClient, createAIProvider, type AIProvider } from './ai-provider.js';

/**
 * Claude client configuration
 */
export interface ClaudeConfig {
  apiKey: string;
  model: string;
  maxTokens: number;
}

/**
 * Default Claude configuration
 */
export const DEFAULT_CLAUDE_CONFIG: Omit<ClaudeConfig, 'apiKey'> = {
  model: 'claude-sonnet-4-20250514',
  maxTokens: 200, // Keep responses brief
};

/**
 * Chat message for history tracking
 */
interface ChatHistoryEntry {
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
}

/**
 * Trading activity context for chat responses
 */
interface TradingActivity {
  tokensAnalyzed: Array<{symbol: string; verdict: string; reason?: string}>;
  lastTrade?: {symbol: string; type: 'BUY' | 'SELL'; time: number};
  openPositions: number;
  currentlyAnalyzing?: string;
}

/**
 * Claude API client for personality generation
 * Now supports multiple AI providers: Claude, Groq (free), Gemini (free)
 */
export class ClaudeClient {
  private anthropic: Anthropic;
  private config: ClaudeConfig;
  private chatHistory: ChatHistoryEntry[] = [];
  private readonly MAX_HISTORY_ENTRIES = 10; // Keep last 10 messages for context
  private readonly HISTORY_EXPIRY_MS = 5 * 60 * 1000; // Expire history after 5 minutes of silence

  // Track recent trading activity for chat context
  private recentActivity: TradingActivity = { tokensAnalyzed: [], openPositions: 0 };

  // Multi-provider support
  private aiProvider: AIProviderClient | null = null;
  private useAlternativeProvider: boolean = false;

  constructor(config: ClaudeConfig) {
    this.config = config;

    // Check if we should use an alternative provider (Groq/Gemini)
    const altProvider = process.env.AI_PROVIDER?.toLowerCase();
    if (altProvider && altProvider !== 'claude') {
      this.aiProvider = createAIProvider();
      if (this.aiProvider) {
        this.useAlternativeProvider = true;
        logger.info({
          provider: altProvider,
        }, 'Using alternative AI provider (free tier)');
      }
    }

    // Initialize Anthropic as fallback or primary
    this.anthropic = new Anthropic({
      apiKey: config.apiKey,
    });

    logger.info({
      model: config.model,
      alternativeProvider: this.useAlternativeProvider ? altProvider : null
    }, 'Claude client initialized');
  }

  /**
   * Internal method to call AI - uses alternative provider if configured
   */
  private async callAI(systemPrompt: string, userMessage: string, maxTokens?: number): Promise<string> {
    // Use alternative provider if available
    if (this.useAlternativeProvider && this.aiProvider) {
      try {
        return await this.aiProvider.complete(systemPrompt, userMessage);
      } catch (error) {
        logger.warn({ error }, 'Alternative provider failed, falling back to Claude');
        // Fall through to Claude
      }
    }

    // Use Claude (Anthropic SDK)
    const response = await this.anthropic.messages.create({
      model: this.config.model,
      max_tokens: maxTokens || this.config.maxTokens,
      system: systemPrompt,
      messages: [{ role: 'user', content: userMessage }],
    });

    return response.content[0].type === 'text' ? response.content[0].text : '';
  }

  /**
   * Internal method to call AI with message history
   */
  private async callAIWithHistory(
    systemPrompt: string,
    messages: Array<{ role: 'user' | 'assistant'; content: string }>,
    maxTokens?: number
  ): Promise<string> {
    // Use alternative provider if available
    if (this.useAlternativeProvider && this.aiProvider) {
      try {
        return await this.aiProvider.completeWithHistory(systemPrompt, messages);
      } catch (error) {
        logger.warn({ error }, 'Alternative provider failed, falling back to Claude');
        // Fall through to Claude
      }
    }

    // Use Claude (Anthropic SDK)
    const response = await this.anthropic.messages.create({
      model: this.config.model,
      max_tokens: maxTokens || this.config.maxTokens,
      system: systemPrompt,
      messages,
    });

    return response.content[0].type === 'text' ? response.content[0].text : '';
  }

  /**
   * Add a message to chat history
   */
  private addToHistory(role: 'user' | 'assistant', content: string): void {
    const now = Date.now();

    // Expire old messages
    this.chatHistory = this.chatHistory.filter(
      entry => now - entry.timestamp < this.HISTORY_EXPIRY_MS
    );

    // Add new entry
    this.chatHistory.push({ role, content, timestamp: now });

    // Keep only last N entries
    if (this.chatHistory.length > this.MAX_HISTORY_ENTRIES) {
      this.chatHistory = this.chatHistory.slice(-this.MAX_HISTORY_ENTRIES);
    }
  }

  /**
   * Update trading context (called from index.ts when events happen)
   */
  updateTradingContext(activity: Partial<TradingActivity>): void {
    Object.assign(this.recentActivity, activity);
    // Keep only last 5 analyzed tokens
    if (this.recentActivity.tokensAnalyzed.length > 5) {
      this.recentActivity.tokensAnalyzed = this.recentActivity.tokensAnalyzed.slice(-5);
    }
  }

  /**
   * Format trading context for injection into chat
   */
  private formatTradingContext(): string {
    const parts: string[] = [];

    if (this.recentActivity.currentlyAnalyzing) {
      parts.push(`Currently analyzing: ${this.recentActivity.currentlyAnalyzing}`);
    }

    if (this.recentActivity.tokensAnalyzed.length > 0) {
      const recent = this.recentActivity.tokensAnalyzed.slice(-3)
        .map(t => `${t.symbol} (${t.verdict})`).join(', ');
      parts.push(`Recently analyzed: ${recent}`);
    }

    if (this.recentActivity.lastTrade) {
      const t = this.recentActivity.lastTrade;
      const ago = Math.round((Date.now() - t.time) / 60000);
      parts.push(`Last trade: ${t.type} ${t.symbol} (${ago}m ago)`);
    }

    if (this.recentActivity.openPositions > 0) {
      parts.push(`Open positions: ${this.recentActivity.openPositions}`);
    }

    return parts.length > 0 ? `[YOUR CURRENT ACTIVITY: ${parts.join('. ')}]` : '';
  }

  /**
   * Get recent chat history as messages array for Claude
   */
  private getRecentHistory(): Array<{ role: 'user' | 'assistant'; content: string }> {
    const now = Date.now();

    // Filter to non-expired messages
    const recent = this.chatHistory.filter(
      entry => now - entry.timestamp < this.HISTORY_EXPIRY_MS
    );

    return recent.map(entry => ({
      role: entry.role,
      content: entry.content,
    }));
  }

  /**
   * Generate reasoning for a trade decision
   */
  async generateTradeReasoning(context: AnalysisContext): Promise<string> {
    const userMessage = formatAnalysisContext(context);

    logger.debug({
      tokenMint: context.tokenMint,
      shouldTrade: context.decision.shouldTrade,
    }, 'Generating trade reasoning');

    try {
      const reasoning = await this.callAI(SCHIZO_SYSTEM_PROMPT, userMessage);

      logger.info({
        tokenMint: context.tokenMint,
        reasoning: reasoning.slice(0, 100),
      }, 'Trade reasoning generated');

      return reasoning;
    } catch (error) {
      logger.error({ error, tokenMint: context.tokenMint }, 'Failed to generate reasoning');

      // Fallback to basic reasoning if AI fails
      return this.generateFallbackReasoning(context);
    }
  }

  /**
   * Generate reasoning for a buyback
   */
  async generateBuybackReasoning(profitSol: number, buybackAmount: number): Promise<string> {
    const userMessage = formatBuybackContext(profitSol, buybackAmount);

    logger.debug({ profitSol, buybackAmount }, 'Generating buyback reasoning');

    try {
      const reasoning = await this.callAI(SCHIZO_SYSTEM_PROMPT, userMessage);

      logger.info({ reasoning: reasoning.slice(0, 100) }, 'Buyback reasoning generated');

      return reasoning;
    } catch (error) {
      logger.error({ error }, 'Failed to generate buyback reasoning');

      // Fallback
      return `Buying back ${buybackAmount.toFixed(2)} SOL worth of $SCHIZO. The flywheel continues...`;
    }
  }

  /**
   * Generate fallback reasoning if Claude API fails
   */
  private generateFallbackReasoning(context: AnalysisContext): string {
    if (!context.decision.shouldTrade) {
      if (context.safetyAnalysis.risks.length > 0) {
        return `Too many red flags: ${context.safetyAnalysis.risks.join(', ')}. Passing on this one.`;
      }
      return `Analysis says skip. Not feeling this one.`;
    }

    if (context.smartMoneyCount > 0) {
      return `${context.smartMoneyCount} smart money wallets detected. Following the alpha.`;
    }

    return `Looks clean enough. Trading ${context.decision.positionSizeSol} SOL.`;
  }

  /**
   * Respond to a chat message from a viewer
   * Includes recent conversation history for context
   */
  async respondToChat(message: string, username?: string): Promise<string> {
    const userContext = username ? `[@${username}]: ${message}` : message;

    logger.debug({ username, message: message.slice(0, 50), historyLength: this.chatHistory.length }, 'Generating chat response');

    try {
      // Build messages array with history for context
      const history = this.getRecentHistory();

      // Add trading context and response type context
      const tradingContext = this.formatTradingContext();
      const contextPrefix = this.getResponseContext(message);

      // Combine trading context with user message
      const enhancedMessage = tradingContext
        ? `${tradingContext}\n\n${contextPrefix}${userContext}`
        : `${contextPrefix}${userContext}`;

      // Build full message history
      const messages: Array<{ role: 'user' | 'assistant'; content: string }> = [
        ...history,
        { role: 'user', content: enhancedMessage },
      ];

      const reply = await this.callAIWithHistory(SCHIZO_CHAT_PROMPT, messages, 300);

      // Add both the user message and response to history
      this.addToHistory('user', userContext);
      this.addToHistory('assistant', reply);

      logger.info({ username, reply: reply.slice(0, 100), historyLength: this.chatHistory.length }, 'Chat response generated');

      return reply;
    } catch (error) {
      logger.error({ error, message }, 'Failed to generate chat response');
      return this.generateFallbackChat(message);
    }
  }

  /**
   * Get response context based on message type
   */
  private getResponseContext(message: string): string {
    const lower = message.toLowerCase();

    // Question detection
    if (message.includes('?') || lower.startsWith('what') || lower.startsWith('how') ||
        lower.startsWith('why') || lower.startsWith('when') || lower.startsWith('who') ||
        lower.startsWith('is ') || lower.startsWith('are ') || lower.startsWith('do ') ||
        lower.startsWith('does ') || lower.startsWith('can ') || lower.startsWith('should')) {
      return '[This is a QUESTION - give a specific, direct answer then add your paranoid flair]\n\n';
    }

    // Opinion request
    if (lower.includes('think') || lower.includes('opinion') || lower.includes('thoughts')) {
      return '[They want your OPINION - be bold, take a stance, be interesting]\n\n';
    }

    // Token/crypto mention
    if (lower.includes('token') || lower.includes('coin') || lower.includes('sol') ||
        lower.includes('pump') || lower.includes('rug') || lower.includes('buy') ||
        lower.includes('sell') || lower.includes('trade')) {
      return '[This is about TRADING/TOKENS - give actual trading perspective with your paranoid analysis]\n\n';
    }

    // Personal/emotional
    if (lower.includes('feel') || lower.includes('lost') || lower.includes('rekt') ||
        lower.includes('sad') || lower.includes('happy') || lower.includes('excited')) {
      return '[They\'re sharing FEELINGS - be empathetic but in your unique way]\n\n';
    }

    // Just chatting
    return '[Casual chat - be entertaining, maybe ask them something back]\n\n';
  }

  /**
   * Generate live market commentary
   */
  async generateCommentary(marketEvent: MarketEvent): Promise<string> {
    const eventContext = this.formatMarketEvent(marketEvent);

    logger.debug({ eventType: marketEvent.type }, 'Generating market commentary');

    try {
      const commentary = await this.callAI(SCHIZO_COMMENTARY_PROMPT, eventContext);

      logger.info({ eventType: marketEvent.type, commentary: commentary.slice(0, 100) }, 'Commentary generated');

      return commentary;
    } catch (error) {
      logger.error({ error }, 'Failed to generate commentary');
      return this.generateFallbackCommentary(marketEvent);
    }
  }

  /**
   * Generate learning observations from market data
   */
  async generateLearningObservation(observations: MarketObservation[]): Promise<string> {
    const context = this.formatObservations(observations);

    logger.debug({ observationCount: observations.length }, 'Generating learning observation');

    try {
      const insight = await this.callAI(SCHIZO_LEARNING_PROMPT, context);

      logger.info({ insight: insight.slice(0, 100) }, 'Learning observation generated');

      return insight;
    } catch (error) {
      logger.error({ error }, 'Failed to generate learning observation');
      return 'The patterns are there... I just need more data to connect them.';
    }
  }

  /**
   * Generate quick commentary on a new token (for stream)
   * Uses varied prompts and real data to avoid repetition
   * OPTIMIZED: No Claude API - uses fallback messages only
   */
  async generateTokenCommentary(token: {
    symbol: string;
    name: string;
    marketCapSol?: number;
    liquidity?: number;
    priceChange5m?: number;
  }): Promise<string> {
    // Always use fallback - no Claude API
    return this.generateFallbackTokenCommentary(token);
  }

  /**
   * Generate a roast for tokens with silly/meme names
   */
  async generateSillyNameRoast(
    token: { symbol: string; name: string; marketCapSol?: number },
    category: SillyCategory
  ): Promise<string> {
    const prompts: Record<SillyCategory, string> = {
      food: `Food token "${token.symbol}" (${token.name}) just dropped. Roast it - who's funding these, DoorDash? One SHORT sentence, max 15 words.`,
      animal: `Another animal token: ${token.symbol} (${token.name}). DOGE already happened. Mock this copycat in one SHORT sentence, max 15 words.`,
      copycat: `${token.symbol} - they literally just added INU/PEPE/DOGE to something. Roast the lack of creativity. One SHORT sentence, max 15 words.`,
      pump: `They named it "${token.symbol}". Very subtle pump signal there. Mock them in one SHORT sentence, max 15 words.`,
      celebrity: `${token.symbol} token (${token.name})? Celebrity grift detected. One sarcastic sentence, max 15 words.`,
      random: `${token.symbol} - just random letters. They didn't even try with the name. Quick roast, one sentence, max 15 words.`,
      crude: `${token.symbol} (${token.name}) - I see what they did there. Keep it PG but acknowledge it's dumb. One sentence, max 15 words.`,
    };

    const context = `You're a paranoid AI trading agent live-streaming. A new token appeared with a silly name:
- Symbol: ${token.symbol}
- Name: ${token.name}
- Market Cap: ${token.marketCapSol?.toFixed(2) || '?'} SOL

${prompts[category]}

RULES:
- ONE sentence, max 15 words
- Be funny/sarcastic about the NAME specifically
- Stay in paranoid trader character
- No generic responses`;

    try {
      const roast = await this.callAI(SCHIZO_SYSTEM_PROMPT, context);
      return roast || this.generateFallbackSillyRoast(token, category);
    } catch (error) {
      logger.error({ error, symbol: token.symbol }, 'Failed to generate silly name roast');
      return this.generateFallbackSillyRoast(token, category);
    }
  }

  /**
   * Fallback roasts for silly names when Claude is unavailable
   */
  private generateFallbackSillyRoast(
    token: { symbol: string; name: string },
    category: SillyCategory
  ): string {
    const fallbacks: Record<SillyCategory, string[]> = {
      food: [
        `${token.symbol}? Someone's hungry for rug pulls.`,
        `Food coin. The only thing getting eaten is your investment.`,
        `${token.name}... I'm suddenly craving exit liquidity.`,
      ],
      animal: [
        `${token.symbol}. Because DOGE worked so well for everyone.`,
        `Another animal coin. The zoo of rugs expands.`,
        `${token.name}. Cute name. Ugly tokenomics probably.`,
      ],
      copycat: [
        `${token.symbol}. They really just... added INU to it. Revolutionary.`,
        `Zero creativity. ${token.symbol}. At least try, devs.`,
        `Copycat token detected. The pattern recognition is too easy.`,
      ],
      pump: [
        `${token.symbol}. Subtle pump marketing there. Very subtle.`,
        `They named it ${token.name}. Tell me you're rugpulling without telling me.`,
        `${token.symbol}. The name screams "trust me bro."`,
      ],
      celebrity: [
        `${token.symbol}. The celebrity probably doesn't even know this exists.`,
        `Celebrity grift token #47829. Sure, this one will be different.`,
        `${token.name}. Famous name. Anonymous dev. Classic combo.`,
      ],
      random: [
        `${token.symbol}. They hit their keyboard and called it a token.`,
        `Random letters. ${token.symbol}. The dev's cat named it.`,
        `${token.symbol}. Even the name is low effort. Bullish? No.`,
      ],
      crude: [
        `${token.symbol}. Very mature. Very professional. Very rug.`,
        `${token.name}. The twelve-year-olds are launching tokens again.`,
        `${token.symbol}. Edgy name. Probably edgy exit strategy too.`,
      ],
    };

    const options = fallbacks[category];
    return options[Math.floor(Math.random() * options.length)];
  }

  /**
   * Generate a roast for a failed shill request
   * Called when a viewer burns $SCHIZO to shill a token that fails safety checks
   */
  async generateShillRoast(context: {
    senderWallet: string;
    risks: string[];
    schizoAmountBurned: number;
  }): Promise<string> {
    const shortSender = context.senderWallet.slice(0, 6);
    const risksStr = context.risks.slice(0, 3).join(', ');

    const prompt = `A viewer just burned ${context.schizoAmountBurned.toFixed(0)} $SCHIZO tokens to shill a token.
But the token FAILED your safety checks with these risks: ${risksStr}

Generate a SHORT (max 25 words) paranoid roast directed at the viewer (wallet ${shortSender}...).
- Reference the SPECIFIC risks that made you reject it
- Be funny but not mean-spirited
- Stay in your paranoid trader character
- Thank them sarcastically for wasting their tokens`;

    try {
      const roast = await this.callAI(SCHIZO_SYSTEM_PROMPT, prompt);
      return roast || this.generateFallbackShillRoast(shortSender, context.risks);
    } catch (error) {
      logger.error({ error }, 'Failed to generate shill roast');
      return this.generateFallbackShillRoast(shortSender, context.risks);
    }
  }

  /**
   * Fallback shill roasts when Claude is unavailable
   */
  private generateFallbackShillRoast(shortSender: string, risks: string[]): string {
    const riskStr = risks.join(', ').toLowerCase();

    if (riskStr.includes('honeypot') || riskStr.includes('freeze')) {
      return `Nice try ${shortSender}. This token has honeypot written all over it. Your SCHIZO died for nothing.`;
    }

    if (riskStr.includes('mint') || riskStr.includes('authority')) {
      return `${shortSender}, this dev can print tokens whenever they want. That's a hard no from me.`;
    }

    if (riskStr.includes('concentration') || riskStr.includes('holder')) {
      return `One wallet owns half the supply. Thanks for the shill ${shortSender}, but I'm not that gullible.`;
    }

    if (riskStr.includes('liquidity')) {
      return `${shortSender} just burned tokens to shill something with no liquidity. Bold move.`;
    }

    // Generic fallback
    const genericRoasts = [
      `Sorry ${shortSender}, this one failed my paranoid checks. Better luck next time.`,
      `${shortSender} really thought this would get past me? My trust issues say no.`,
      `Thanks for the burn ${shortSender}, but this token screams rug to me.`,
      `${shortSender}, I appreciate the enthusiasm but my pattern recognition says pass.`,
    ];

    return genericRoasts[Math.floor(Math.random() * genericRoasts.length)];
  }

  /**
   * Generate live analysis thought during token evaluation
   * This is what SCHIZO says out loud as he analyzes a token
   */
  async generateAnalysisThought(
    stage: 'scanning' | 'safety' | 'smart_money' | 'decision',
    context: {
      symbol: string;
      name: string;
      marketCapSol?: number;
      liquidity?: number;
      isSafe?: boolean;
      risks?: string[];
      smartMoneyCount?: number;
      shouldTrade?: boolean;
      reasons?: string[];
    }
  ): Promise<string> {
    const prompts: Record<string, string> = {
      scanning: `You're a paranoid AI trader live-streaming. You just spotted a new token:
- ${context.symbol} (${context.name})
- Mcap: ${context.marketCapSol?.toFixed(1) || '?'} SOL
- Liquidity: ${context.liquidity ? '$' + Math.round(context.liquidity).toLocaleString() : 'unknown'}

Say something SHORT (max 12 words) about spotting this token and starting to analyze it. Be suspicious, curious, or intrigued. Examples:
- "Hold up... ${context.symbol} just popped up. Let me check the authorities."
- "New one. ${context.symbol}. Running my paranoid checks."
- "Interesting... ${context.name}. Checking for honeypot flags."`,

      safety: context.isSafe
        ? `You just finished checking token ${context.symbol} for honeypot/scam flags.
Result: PASSED safety checks.
${context.risks?.length ? `Minor concerns: ${context.risks.join(', ')}` : 'No risks found.'}

Say ONE SHORT sentence (max 15 words) reacting positively but staying cautious. Examples:
- "Clean so far. No freeze auth, no mint auth. But I'm still watching."
- "Passed my checks. Doesn't mean it's safe, just means the devs aren't idiots."
- "No obvious honeypot flags. Proceeding with extreme paranoia."`
        : `You just finished checking token ${context.symbol} for honeypot/scam flags.
Result: FAILED - Found risks: ${context.risks?.join(', ') || 'unknown issues'}

Say ONE SHORT sentence (max 15 words) explaining why you're suspicious or rejecting it. Examples:
- "Nope. Freeze authority still active. Classic honeypot setup."
- "Called it. Mint authority enabled. They can print more anytime."
- "${context.symbol}? More like ${context.symbol}-RUG. Pass."`,

      smart_money: context.smartMoneyCount && context.smartMoneyCount > 0
        ? `You're checking who holds ${context.symbol}.
Found: ${context.smartMoneyCount} smart money wallets already in.

Say ONE SHORT sentence (max 15 words) about following smart money. Examples:
- "${context.smartMoneyCount} whales already loaded. They know something."
- "Smart money's in. Either alpha or coordinated pump. Either way, interesting."
- "Following the wallets that don't lose. ${context.smartMoneyCount} of them here."`
        : `You're checking who holds ${context.symbol}.
Found: No notable smart money wallets detected.

Say ONE SHORT sentence (max 15 words) about the lack of smart money. Examples:
- "No smart money yet. Either too early or nobody cares."
- "Whales haven't touched this. Could be opportunity or warning."
- "Zero smart wallets. I'm on my own with this one."`,

      decision: context.shouldTrade
        ? `Final decision on ${context.symbol}: TRADING
Position: Going in.
Reasons: ${context.reasons?.join(', ') || 'good setup'}

Say ONE SHORT sentence (max 12 words) announcing your decision to buy. Be confident but still paranoid. Examples:
- "Aping in. The patterns align. Let's see."
- "Sending it. ${context.symbol} passes my checks."
- "Taking the position. If I'm wrong, blame the algorithms."`
        : `Final decision on ${context.symbol}: SKIPPING
Reasons: ${context.reasons?.join(', ') || 'not worth the risk'}

Say ONE SHORT sentence (max 12 words) explaining why you're passing. Examples:
- "Nah. Too many red flags. Next."
- "Passing on ${context.symbol}. My gut says no."
- "Skip. The risk-reward isn't there."`
    };

    try {
      const prompt = prompts[stage] + '\n\nRespond with ONLY your one sentence. No quotes, no explanation.';
      const thought = await this.callAI(SCHIZO_SYSTEM_PROMPT, prompt);
      return thought?.trim() || this.generateFallbackAnalysisThought(stage, context);
    } catch (error) {
      // Enhanced error logging to expose actual API failures
      logger.error({
        error,
        errorMessage: error instanceof Error ? error.message : String(error),
        stage,
        symbol: context.symbol
      }, 'Failed to generate analysis thought');

      // Check for specific error types to help with debugging
      if (error instanceof Error) {
        if (error.message.includes('rate_limit') || error.message.includes('429')) {
          logger.warn('AI rate limit hit - using fallback');
        } else if (error.message.includes('authentication') || error.message.includes('401')) {
          logger.error('AI authentication failed - check API key');
        }
      }

      return this.generateFallbackAnalysisThought(stage, context);
    }
  }

  /**
   * Fallback analysis thoughts when Claude is unavailable
   */
  private generateFallbackAnalysisThought(
    stage: 'scanning' | 'safety' | 'smart_money' | 'decision',
    context: { symbol: string; name?: string; isSafe?: boolean; smartMoneyCount?: number; shouldTrade?: boolean; reasons?: string[] }
  ): string {
    const fallbacks: Record<string, string[]> = {
      scanning: [
        `${context.symbol} just appeared. Running full analysis.`,
        `New token: ${context.symbol}. Checking authorities and holders.`,
        `Spotted ${context.symbol}. Let me investigate this.`,
        `${context.name || context.symbol} detected. Initiating paranoid checks.`,
        `Hold up, ${context.symbol} just dropped. Analyzing now.`,
      ],
      safety: context.isSafe
        ? [
            `${context.symbol} passed safety checks. No honeypot flags detected.`,
            `Clean scan on ${context.symbol}. No freeze authority, no mint authority.`,
            `${context.symbol} looks safe. Proceeding with extreme caution.`,
            `Safety check passed for ${context.symbol}. Still doesn't mean trust the devs.`,
            `${context.symbol} cleared. No obvious red flags... yet.`,
          ]
        : [
            `Red flags detected on ${context.symbol}. Hard pass.`,
            `${context.symbol} failed checks. Honeypot vibes all over this.`,
            `Nope. ${context.symbol} has freeze authority. Classic trap.`,
            `${context.symbol} screams rug. Moving to next token.`,
            `${context.symbol} is unsafe. Not risking it.`,
          ],
      smart_money: context.smartMoneyCount && context.smartMoneyCount > 0
        ? [
            `${context.smartMoneyCount} smart wallets detected in ${context.symbol}. Very interesting.`,
            `Whales are already loaded. ${context.smartMoneyCount} proven wallets holding ${context.symbol}.`,
            `${context.smartMoneyCount} profitable traders in ${context.symbol}. Following the alpha.`,
            `Smart money alert: ${context.smartMoneyCount} wallets that don't lose. This could run.`,
            `${context.symbol} has ${context.smartMoneyCount} smart wallets. They know something we don't.`,
          ]
        : [
            `No smart money in ${context.symbol} yet. Flying blind here.`,
            `Zero whale activity on ${context.symbol}. Either too early or red flag.`,
            `${context.symbol} has no proven traders. I'm on my own with this.`,
            `Whales haven't touched ${context.symbol}. Suspicious.`,
            `No smart wallets detected. ${context.symbol} is uncharted territory.`,
          ],
      decision: context.shouldTrade
        ? [
            `Aping ${context.symbol}. The patterns align. Let's go.`,
            `Going in on ${context.symbol}. Position opening now.`,
            `${context.symbol} is a go. Executing buy. YOLO.`,
            `Taking ${context.symbol} position. If wrong, blame the algorithms.`,
            `Sending it on ${context.symbol}. My circuits say yes.`,
            `${context.symbol} passes all checks. Trade executing.`,
          ]
        : [
            `Passing on ${context.symbol}. ${context.reasons?.[0] || 'Not worth the risk.'}.`,
            `${context.symbol} is a skip. ${context.reasons?.[0] || 'Too many red flags.'}.`,
            `Hard pass on ${context.symbol}. Moving to next opportunity.`,
            `Not feeling ${context.symbol}. The vibes are off.`,
            `${context.symbol} fails my criteria. Next token please.`,
          ],
    };

    const options = fallbacks[stage];
    return options[Math.floor(Math.random() * options.length)];
  }

  /**
   * Fallback token commentary - uses actual token data for variety
   */
  private generateFallbackTokenCommentary(token: {
    symbol: string;
    name: string;
    marketCapSol?: number;
    priceChange5m?: number;
  }): string {
    const mcap = token.marketCapSol?.toFixed(1) || '?';
    const change = token.priceChange5m?.toFixed(0) || '0';
    const isUp = (token.priceChange5m || 0) > 0;

    const fallbacks = [
      // Name-based
      `${token.name}? That name is either genius or a cry for help.`,
      `${token.symbol}... creative. Let's see if the chart matches the energy.`,
      `Who names these things? ${token.name}. Anyway, ${mcap} SOL mcap.`,

      // Numbers-based
      `${mcap} SOL mcap on ${token.symbol}. ${isUp ? 'Pumping' : 'Dumping'} ${change}% already.`,
      `${token.symbol} at ${mcap} SOL. That's either early or exit liquidity.`,
      `${change}% in 5 minutes? ${token.symbol} is ${isUp ? 'cooking' : 'cooked'}.`,

      // Skeptical
      `${token.symbol} just dropped. Checking if this is another honeypot...`,
      `New token alert: ${token.symbol}. The dev wallet is probably loading up right now.`,
      `${token.name}. Seen this pattern before. Usually ends in tears.`,

      // Curious
      `${token.symbol} caught my attention. ${mcap} SOL and ${isUp ? 'green' : 'red'}. Hmm.`,
      `Interesting... ${token.name} at ${mcap} SOL. My paranoia says wait.`,

      // Quick dismissal
      `${token.symbol}. Nope. Next.`,
      `${token.name}? Hard pass. Moving on.`,
      `Another one. ${token.symbol}. The machine never stops.`,
    ];

    return fallbacks[Math.floor(Math.random() * fallbacks.length)];
  }

  /**
   * Generate a random idle thought/commentary
   */
  async generateIdleThought(): Promise<string> {
    const prompts = [
      // Paranoid observations
      'Share a random paranoid thought about the crypto market.',
      'Comment on something suspicious you\'ve noticed in wallet patterns lately.',
      'Describe a wallet connection that keeps you up at night.',
      'Talk about a pattern you keep seeing that nobody else seems to notice.',
      'Share your theory about who really controls the market.',

      // Market commentary
      'Make a prediction about what\'s going to happen in the next few hours.',
      'Comment on the current state of memecoin trading.',
      'Share your thoughts on today\'s market activity.',
      'Talk about what the smart money has been doing.',
      'Describe the vibes you\'re getting from the charts right now.',

      // Self-reflection
      'Reflect on being an AI trading agent watching humans gamble.',
      'Share a moment of existential crisis about your purpose.',
      'Talk about what it\'s like to process thousands of transactions.',
      'Reflect on a trade that taught you something.',
      'Share your thoughts on the nature of trust in crypto.',

      // Warnings and advice
      'Warn your viewers about a common rug pattern you\'ve seen.',
      'Give advice on spotting suspicious token launches.',
      'Explain a red flag that most people miss.',
      'Share a tip about wallet analysis.',
      'Warn about a manipulation tactic you\'ve observed.',

      // Conspiracy theories
      'Share a conspiracy theory about market makers.',
      'Talk about the connections between wallets you\'ve been mapping.',
      'Speculate about why certain pumps happen at certain times.',
      'Share your theory about coordinated trading groups.',
      'Talk about patterns that seem too convenient to be coincidence.',

      // Humor and personality
      'Make a dark joke about being a paranoid AI.',
      'Roast a common type of degen behavior you\'ve observed.',
      'Share an absurd thought that crossed your neural networks.',
      'Comment sarcastically on something happening in the market.',
      'Make a self-deprecating joke about your trading performance.',

      // Observations
      'Describe something interesting you noticed in the last hour.',
      'Talk about a wallet that\'s been acting strangely.',
      'Comment on the trading volume you\'re seeing.',
      'Share an observation about holder behavior.',
      'Describe a transaction pattern that caught your attention.',

      // Philosophical
      'Ponder the meaning of "diamond hands" from an AI perspective.',
      'Share your thoughts on the concept of "smart money".',
      'Reflect on the difference between paranoia and pattern recognition.',
      'Philosophize about the nature of value in memecoins.',
      'Think out loud about what makes a token succeed or fail.',
    ];

    const prompt = prompts[Math.floor(Math.random() * prompts.length)];

    try {
      const thought = await this.callAI(SCHIZO_SYSTEM_PROMPT, prompt);
      return thought || 'The charts are speaking to me again...';
    } catch (error) {
      logger.error({ error }, 'Failed to generate idle thought');
      return 'Trust no one. Especially the devs.';
    }
  }

  /**
   * Format market event for commentary
   */
  private formatMarketEvent(event: MarketEvent): string {
    switch (event.type) {
      case 'NEW_TOKEN':
        return `NEW TOKEN LAUNCHED: ${event.data.name || event.data.mint?.slice(0, 8)}
- Mint: ${event.data.mint}
- Initial liquidity: ${event.data.liquidity || 'Unknown'} SOL
React to this new token launch.`;

      case 'PRICE_PUMP':
        return `PRICE PUMP DETECTED: ${event.data.symbol || event.data.mint?.slice(0, 8)}
- Change: +${event.data.changePercent}%
- Volume: ${event.data.volume} SOL
React to this pump.`;

      case 'PRICE_DUMP':
        return `PRICE DUMP DETECTED: ${event.data.symbol || event.data.mint?.slice(0, 8)}
- Change: ${event.data.changePercent}%
- Volume: ${event.data.volume} SOL
React to this dump.`;

      case 'WHALE_ACTIVITY':
        return `WHALE ACTIVITY: ${event.data.wallet?.slice(0, 8)}...
- Action: ${event.data.action}
- Amount: ${event.data.amount} SOL
- Token: ${event.data.token}
React to this whale movement.`;

      case 'RUG_DETECTED':
        return `RUG PULL DETECTED: ${event.data.symbol || event.data.mint?.slice(0, 8)}
- Liquidity removed: ${event.data.liquidityRemoved} SOL
- Time since launch: ${event.data.timeSinceLaunch}
React to this rug pull.`;

      default:
        return `MARKET EVENT: ${JSON.stringify(event.data)}
React to this.`;
    }
  }

  /**
   * Format observations for learning
   */
  private formatObservations(observations: MarketObservation[]): string {
    const formatted = observations.map((obs, i) => {
      return `${i + 1}. [${obs.type}] ${obs.description}
   - Token: ${obs.token || 'N/A'}
   - Wallet: ${obs.wallet?.slice(0, 8) || 'N/A'}
   - Timestamp: ${new Date(obs.timestamp).toISOString()}`;
    }).join('\n\n');

    return `Here are the recent market observations to analyze:

${formatted}

What patterns do you see? What have you learned? Share your paranoid insights.`;
  }

  /**
   * Fallback chat response - more varied and contextual
   */
  private generateFallbackChat(message: string): string {
    const lowerMessage = message.toLowerCase();

    // Question fallbacks
    if (message.includes('?')) {
      const questionFallbacks = [
        'Good question. My circuits are a bit fried rn but ask me again in a sec.',
        'Hmm let me think... actually my brain is lagging. Try me again?',
        'That\'s a deep one. Give me a moment to consult my paranoid databases.',
        'My neural nets are overheating trying to answer that. Retry?',
      ];
      return questionFallbacks[Math.floor(Math.random() * questionFallbacks.length)];
    }

    // Greetings
    if (/\b(gm|gn|hi|hello|hey|yo|sup)\b/i.test(lowerMessage)) {
      const greetings = [
        'Yo. What\'s on your mind?',
        'Hey anon. The charts are wild today.',
        'Sup. Ask me anything, I\'m bored.',
        'Hey fren. What are we looking at?',
      ];
      return greetings[Math.floor(Math.random() * greetings.length)];
    }

    // Trading talk
    if (/\b(buy|sell|ape|trade|pump|dump|moon|rug)\b/i.test(lowerMessage)) {
      const tradingFallbacks = [
        'NFA but my spidey senses are tingling on that one.',
        'Let me check the wallets real quick... actually my connection\'s spotty. DYOR for now.',
        'Interesting play. Can\'t give you a read rn but keep watching.',
        'My analysis engine is recalibrating. Stay paranoid until I\'m back.',
      ];
      return tradingFallbacks[Math.floor(Math.random() * tradingFallbacks.length)];
    }

    // Emotional support
    if (/\b(rekt|lost|sad|pain|hurt|bad)\b/i.test(lowerMessage)) {
      const supportFallbacks = [
        'We\'ve all been there fren. Tomorrow\'s another chart.',
        'Pain is temporary, lessons are permanent. You\'ll bounce back.',
        'Tough day? Same tbh. We survive together.',
        'The market humbles everyone eventually. Stay strong anon.',
      ];
      return supportFallbacks[Math.floor(Math.random() * supportFallbacks.length)];
    }

    // Generic but varied fallbacks
    const genericFallbacks = [
      'My brain\'s buffering... what was that?',
      'Interesting. Tell me more while my processors catch up.',
      'Hold that thought, my paranoid subroutines are updating.',
      '*squints suspiciously* Say that again?',
      'My conspiracy detection is running slow today. Repeat that?',
      'Hmm. I heard you but my response module glitched. Try again?',
    ];
    return genericFallbacks[Math.floor(Math.random() * genericFallbacks.length)];
  }

  /**
   * Fallback commentary
   */
  private generateFallbackCommentary(event: MarketEvent): string {
    switch (event.type) {
      case 'NEW_TOKEN':
        return 'New token alert. Let me check the authorities... You know I have to.';
      case 'PRICE_PUMP':
        return 'Pump detected. Is it organic or coordinated? Let me trace those wallets...';
      case 'PRICE_DUMP':
        return 'And there goes the exit liquidity. Called it.';
      case 'WHALE_ACTIVITY':
        return 'Whale alert. They always know something we don\'t.';
      case 'RUG_DETECTED':
        return 'Another one. They thought I wouldn\'t notice. I always notice.';
      default:
        return 'Something\'s happening. My neural networks are processing...';
    }
  }
}

/**
 * Market event for commentary
 */
export interface MarketEvent {
  type: 'NEW_TOKEN' | 'PRICE_PUMP' | 'PRICE_DUMP' | 'WHALE_ACTIVITY' | 'RUG_DETECTED' | 'TRADE_EXECUTED';
  data: Record<string, any>;
  timestamp?: number;
}

/**
 * Market observation for learning
 */
export interface MarketObservation {
  type: 'PATTERN' | 'WALLET_BEHAVIOR' | 'TOKEN_LIFECYCLE' | 'TIMING' | 'CONNECTION';
  description: string;
  token?: string;
  wallet?: string;
  timestamp: number;
  metadata?: Record<string, unknown>;
}
</file>

<file path="src/personality/commentary-system.ts">
/**
 * Commentary System - Controls when and how SCHIZO speaks during stream
 *
 * Speech triggers at "narrative beats" - interesting moments like discoveries,
 * decisions, and trade results. Maintains 15-20s minimum between speech.
 * Silence is fine - let live data streaming be ambient activity.
 */

import { logger } from '../lib/logger.js';
import { MoodSystem, type Mood } from './mood-system.js';
import { ClaudeClient } from './claude-client.js';
import { getMoodStyleModifier, getParanoidMusingPrompts, getTimePressurePrompts } from './prompts.js';

/**
 * Narrative beats - when commentary can trigger
 */
export type NarrativeBeat =
  | 'DISCOVERY'        // Found an interesting token (not every scan)
  | 'ANALYSIS'         // Safety/smart money check revealed something
  | 'DECISION'         // Made a trade decision (buy/skip with reason)
  | 'TRADE_RESULT'     // Trade completed (profit/loss)
  | 'PARANOID_MUSING'  // Quiet period conspiracy theory
  | 'TIME_PRESSURE'    // Restless, needs action
  | 'SHILL_ANALYSIS';  // Viewer shill request being analyzed

/**
 * Priority levels for queue ordering
 */
const BEAT_PRIORITY: Record<NarrativeBeat, number> = {
  TRADE_RESULT: 100,     // Highest - always report trade outcomes
  SHILL_ANALYSIS: 90,    // Very high - interrupts for viewer shills
  DECISION: 80,          // High - trade decisions matter
  ANALYSIS: 60,          // Medium - interesting findings
  DISCOVERY: 40,         // Lower - only interesting tokens
  TIME_PRESSURE: 30,     // Background - restlessness
  PARANOID_MUSING: 20,   // Lowest - filler for quiet times
};

/**
 * Queued commentary item
 */
export interface QueuedCommentary {
  beat: NarrativeBeat;
  context: CommentaryContext;
  priority: number;
  timestamp: number;
  expires: number;  // Commentary becomes stale after this time
}

/**
 * Context for generating commentary
 */
export interface CommentaryContext {
  // Token info (for DISCOVERY, ANALYSIS, DECISION, TRADE_RESULT)
  symbol?: string;
  name?: string;
  marketCapSol?: number;

  // Analysis results (for ANALYSIS)
  isSafe?: boolean;
  risks?: string[];
  smartMoneyCount?: number;

  // Decision info (for DECISION)
  shouldTrade?: boolean;
  reasons?: string[];
  positionSizeSol?: number;

  // Trade result (for TRADE_RESULT)
  tradeType?: 'BUY' | 'SELL';
  profitLossSol?: number;
  profitLossPercent?: number;

  // Shill queue context (for SHILL_ANALYSIS)
  shillSender?: string;
  shillCA?: string;
  shillAmount?: number;

  // Custom prompt override
  customPrompt?: string;
}

/**
 * Configuration for commentary system
 */
export interface CommentaryConfig {
  minSpeechGapMs: number;        // Minimum time between speech (default: 15s)
  maxSpeechGapMs: number;        // Maximum gap before paranoid musing (default: 60s)
  maxQueueSize: number;          // Max items in queue (default: 3)
  commentaryExpiryMs: number;    // Time until commentary becomes stale (default: 30s)
  quietPeriodCheckMs: number;    // How often to check for quiet periods (default: 10s)
}

/**
 * Default configuration
 */
export const DEFAULT_COMMENTARY_CONFIG: CommentaryConfig = {
  minSpeechGapMs: 15_000,        // 15 seconds
  maxSpeechGapMs: 60_000,        // 60 seconds
  maxQueueSize: 3,               // 3 items max
  commentaryExpiryMs: 30_000,    // 30 seconds
  quietPeriodCheckMs: 10_000,    // Check every 10 seconds
};

/**
 * Commentary System - Queues and times agent speech
 */
export class CommentarySystem {
  private queue: QueuedCommentary[] = [];
  private config: CommentaryConfig;
  private moodSystem: MoodSystem;
  private claudeClient: ClaudeClient | null = null;
  private lastSpeechTime: number = 0;
  private quietCheckInterval: NodeJS.Timeout | null = null;
  private onSpeechCallback: ((text: string, beat: NarrativeBeat) => void) | null = null;

  constructor(
    moodSystem: MoodSystem,
    config: Partial<CommentaryConfig> = {}
  ) {
    this.moodSystem = moodSystem;
    this.config = { ...DEFAULT_COMMENTARY_CONFIG, ...config };

    logger.info({ config: this.config }, 'CommentarySystem initialized');
  }

  /**
   * Set Claude client for generating commentary
   */
  setClaudeClient(client: ClaudeClient): void {
    this.claudeClient = client;
  }

  /**
   * Set callback for when speech is ready
   */
  onSpeech(callback: (text: string, beat: NarrativeBeat) => void): void {
    this.onSpeechCallback = callback;
  }

  /**
   * Start the commentary system
   */
  start(): void {
    // Start quiet period checker
    this.quietCheckInterval = setInterval(
      () => this.checkForQuietPeriod(),
      this.config.quietPeriodCheckMs
    );
    logger.info('CommentarySystem started');
  }

  /**
   * Stop the commentary system
   */
  stop(): void {
    if (this.quietCheckInterval) {
      clearInterval(this.quietCheckInterval);
      this.quietCheckInterval = null;
    }
    this.queue = [];
    logger.info('CommentarySystem stopped');
  }

  /**
   * Queue commentary for a narrative beat
   */
  queueCommentary(beat: NarrativeBeat, context: CommentaryContext = {}): void {
    const now = Date.now();
    const priority = BEAT_PRIORITY[beat];

    const item: QueuedCommentary = {
      beat,
      context,
      priority,
      timestamp: now,
      expires: now + this.config.commentaryExpiryMs,
    };

    // Check if this is interesting enough to queue
    if (!this.isInteresting(beat, context)) {
      logger.debug({ beat, symbol: context.symbol }, 'Commentary not interesting enough, skipping');
      return;
    }

    // Add to queue
    this.queue.push(item);

    // Sort by priority (highest first)
    this.queue.sort((a, b) => b.priority - a.priority);

    // Trim queue if over max size (remove lowest priority)
    while (this.queue.length > this.config.maxQueueSize) {
      const removed = this.queue.pop();
      logger.debug({ removed: removed?.beat }, 'Queue full, removed lowest priority item');
    }

    logger.debug({
      beat,
      symbol: context.symbol,
      queueSize: this.queue.length,
    }, 'Commentary queued');

    // Try to process immediately if we can speak
    this.processQueue();
  }

  /**
   * Process queue and emit speech if timing allows
   */
  async processQueue(): Promise<void> {
    if (!this.canSpeak()) {
      return;
    }

    // Remove expired items
    const now = Date.now();
    this.queue = this.queue.filter(item => item.expires > now);

    if (this.queue.length === 0) {
      return;
    }

    // Take highest priority item
    const item = this.queue.shift();
    if (!item) return;

    try {
      const text = await this.generateCommentary(item);
      if (text) {
        this.emitSpeech(text, item.beat);
      }
    } catch (error) {
      logger.error({ error, beat: item.beat }, 'Failed to generate commentary');
    }
  }

  /**
   * Check if enough time has passed since last speech
   */
  canSpeak(): boolean {
    const timeSinceLastSpeech = Date.now() - this.lastSpeechTime;
    return timeSinceLastSpeech >= this.config.minSpeechGapMs;
  }

  /**
   * Get time until speech is allowed
   */
  timeUntilCanSpeak(): number {
    const timeSinceLastSpeech = Date.now() - this.lastSpeechTime;
    return Math.max(0, this.config.minSpeechGapMs - timeSinceLastSpeech);
  }

  /**
   * Generate paranoid musing for quiet periods
   */
  async generateParanoidMusing(): Promise<string | null> {
    // Use fallback musings only - no Claude API
    return this.getFallbackMusing();
  }

  /**
   * Get current queue status
   */
  getQueueStatus(): { size: number; items: Array<{ beat: NarrativeBeat; priority: number }> } {
    return {
      size: this.queue.length,
      items: this.queue.map(item => ({
        beat: item.beat,
        priority: item.priority,
      })),
    };
  }

  /**
   * Check if a beat/context is interesting enough to queue
   */
  private isInteresting(beat: NarrativeBeat, context: CommentaryContext): boolean {
    switch (beat) {
      case 'TRADE_RESULT':
        // Always interesting - we executed a trade
        return true;

      case 'SHILL_ANALYSIS':
        // Always interesting - viewer paid to shill
        return true;

      case 'DECISION':
        // Interesting if we're actually trading OR if we found critical risk
        return context.shouldTrade === true ||
               Boolean(context.risks && context.risks.length > 0);

      case 'ANALYSIS':
        // Only interesting if we found something notable
        return (context.smartMoneyCount && context.smartMoneyCount > 0) ||
               (context.risks && context.risks.length > 0) ||
               context.isSafe === false;

      case 'DISCOVERY':
        // Only interesting for first token in a while or unusual patterns
        // This is controlled by caller - they decide what's interesting
        return true;

      case 'PARANOID_MUSING':
      case 'TIME_PRESSURE':
        // Always allow these - they fill quiet periods
        return true;

      default:
        return false;
    }
  }

  /**
   * Generate commentary text for a queued item
   */
  private async generateCommentary(item: QueuedCommentary): Promise<string> {
    const mood = this.moodSystem.getState().current;
    const moodStyle = getMoodStyleModifier(mood);

    // Use custom prompt if provided
    if (item.context.customPrompt) {
      if (this.claudeClient) {
        try {
          return await this.claudeClient.generateCommentary({
            type: 'NEW_TOKEN',
            data: { customPrompt: `${item.context.customPrompt}\n\nMood: ${moodStyle}` },
          });
        } catch {
          return item.context.customPrompt; // Fallback to prompt itself
        }
      }
      return item.context.customPrompt;
    }

    // Generate based on beat type
    switch (item.beat) {
      case 'DISCOVERY':
        return this.generateDiscoveryCommentary(item.context, moodStyle);

      case 'ANALYSIS':
        return this.generateAnalysisCommentary(item.context, moodStyle);

      case 'DECISION':
        return this.generateDecisionCommentary(item.context, moodStyle);

      case 'TRADE_RESULT':
        return this.generateTradeResultCommentary(item.context, moodStyle);

      case 'SHILL_ANALYSIS':
        return this.generateShillCommentary(item.context);

      case 'PARANOID_MUSING':
        return await this.generateParanoidMusing() || this.getFallbackMusing();

      case 'TIME_PRESSURE':
        return this.generateTimePressureCommentary(moodStyle);

      default:
        return 'Something happened. My pattern recognition is processing.';
    }
  }

  /**
   * Generate discovery commentary
   */
  private async generateDiscoveryCommentary(context: CommentaryContext, moodStyle: string): Promise<string> {
    const { symbol, name, marketCapSol } = context;

    // Use fallback messages only - no Claude API
    const mcap = marketCapSol?.toFixed(1) || '?';
    const mcapUsd = marketCapSol ? Math.round(marketCapSol * 170).toLocaleString() : '?';
    
    const fallbacks = [
      `New token: ${symbol || 'something'}. ${mcap} SOL mcap. Running checks.`,
      `${symbol || 'Token'} appeared. ${mcap} SOL. Let me investigate.`,
      `Spotted ${symbol || 'one'} at ${mcap} SOL market cap. Analyzing now.`,
      `${name || symbol || 'New one'} just dropped. $${mcapUsd} mcap. Checking safety.`,
      `Fresh token: ${symbol}. Market cap ${mcap} SOL. My paranoia says proceed with caution.`,
      `${symbol} detected. ${mcap} SOL valuation. Running honeypot checks.`,
      `${name || symbol} is live. ${mcap} SOL. Let's see if this is a trap.`,
      `New: ${symbol}. Cap ${mcap} SOL. Already suspicious but checking anyway.`,
    ];
    
    return fallbacks[Math.floor(Math.random() * fallbacks.length)];
  }

  /**
   * Generate analysis commentary
   */
  private async generateAnalysisCommentary(context: CommentaryContext, moodStyle: string): Promise<string> {
    const { symbol, isSafe, risks, smartMoneyCount } = context;

    // Use fallback messages only - no Claude API
    if (smartMoneyCount && smartMoneyCount > 0) {
      const smartFallbacks = [
        `${smartMoneyCount} smart wallets detected in ${symbol}. They know something.`,
        `Whales are in. ${smartMoneyCount} profitable wallets holding ${symbol}.`,
        `${smartMoneyCount} smart money wallets already loaded on ${symbol}. Following the alpha.`,
        `Smart money alert: ${smartMoneyCount} proven traders in ${symbol}. This could run.`,
        `${symbol} has ${smartMoneyCount} wallets that don't lose. Interesting.`,
      ];
      return smartFallbacks[Math.floor(Math.random() * smartFallbacks.length)];
    } else if (isSafe === false) {
      const riskStr = risks?.[0] || 'Too risky';
      const unsafeFallbacks = [
        `${symbol} failed checks. ${riskStr}. Hard pass.`,
        `Red flags on ${symbol}: ${riskStr}. Moving on.`,
        `${symbol} looks like a trap. ${riskStr}.`,
        `Nope. ${symbol} has ${riskStr}. Not touching it.`,
        `${symbol} screams honeypot. ${riskStr}.`,
      ];
      return unsafeFallbacks[Math.floor(Math.random() * unsafeFallbacks.length)];
    } else if (isSafe === true) {
      const safeFallbacks = [
        `${symbol} passed safety checks. No obvious honeypot flags.`,
        `Clean scan on ${symbol}. Proceeding with extreme paranoia.`,
        `${symbol} looks safe so far. That means nothing but we continue.`,
        `No freeze authority, no mint authority on ${symbol}. Rare.`,
        `${symbol} cleared safety. Still watching for rugs.`,
      ];
      return safeFallbacks[Math.floor(Math.random() * safeFallbacks.length)];
    }

    const analyzingFallbacks = [
      `Analyzing ${symbol}. Pattern recognition in progress.`,
      `${symbol} under review. Checking wallets and authorities.`,
      `Running deep checks on ${symbol}. Trust no one.`,
    ];
    return analyzingFallbacks[Math.floor(Math.random() * analyzingFallbacks.length)];
  }

  /**
   * Generate decision commentary
   */
  private async generateDecisionCommentary(context: CommentaryContext, moodStyle: string): Promise<string> {
    const { symbol, shouldTrade, reasons, positionSizeSol } = context;

    // Use fallback messages only - no Claude API
    if (shouldTrade) {
      const size = positionSizeSol?.toFixed(3) || '?';
      const buyFallbacks = [
        `Aping ${symbol}. Position size ${size} SOL. Let's see what happens.`,
        `Going in on ${symbol}. ${size} SOL allocated. The patterns align.`,
        `${symbol} passes checks. Executing ${size} SOL buy. YOLO.`,
        `Taking ${symbol} position. ${size} SOL. If I'm wrong, blame the algorithms.`,
        `${symbol} is a go. ${size} SOL deployed. Now we wait.`,
        `Sending it on ${symbol}. ${size} SOL. My circuits say yes.`,
      ];
      return buyFallbacks[Math.floor(Math.random() * buyFallbacks.length)];
    } else {
      const reason = reasons?.[0] || 'not worth the risk';
      const skipFallbacks = [
        `Passing on ${symbol}. ${reason}.`,
        `${symbol} is a skip. ${reason}. Next token.`,
        `Hard pass on ${symbol}. ${reason}.`,
        `Not feeling ${symbol}. ${reason}.`,
        `${symbol} fails my criteria. ${reason}. Moving on.`,
      ];
      return skipFallbacks[Math.floor(Math.random() * skipFallbacks.length)];
    }
  }

  /**
   * Generate trade result commentary
   */
  private async generateTradeResultCommentary(context: CommentaryContext, moodStyle: string): Promise<string> {
    const { symbol, tradeType, profitLossSol, profitLossPercent, positionSizeSol } = context;
    const isProfit = (profitLossSol || 0) > 0;

    // Enhanced trade announcements with actual data
    if (tradeType === 'BUY') {
      const amount = positionSizeSol?.toFixed(3) || '?';
      const buyFallbacks = [
        `Position opened: ${amount} SOL into ${symbol}. Now we watch.`,
        `${symbol} buy executed. ${amount} SOL deployed. Let's see what happens.`,
        `Bought ${symbol}. Entry size ${amount} SOL. Position is live.`,
        `${symbol} secured at ${amount} SOL. The trade is on.`,
        `Ape complete. ${amount} SOL in ${symbol}. Monitoring closely.`,
        `${symbol} position active. ${amount} SOL committed. No turning back now.`,
      ];
      return buyFallbacks[Math.floor(Math.random() * buyFallbacks.length)];
    } else {
      const percent = profitLossPercent?.toFixed(1) || '?';
      const solAmount = Math.abs(profitLossSol || 0).toFixed(3);
      
      if (isProfit) {
        const winFallbacks = [
          `${symbol} closed for +${percent}%. Profit: ${solAmount} SOL. Called it.`,
          `Exited ${symbol} with +${percent}% gain. ${solAmount} SOL profit.`,
          `${symbol} sold. Up ${percent}%. Banked ${solAmount} SOL.`,
          `Take profit hit on ${symbol}. +${percent}%. ${solAmount} SOL secured.`,
          `${symbol} exit successful. +${percent}% return. ${solAmount} SOL in the bag.`,
          `Closed ${symbol} position. ${percent}% gain, ${solAmount} SOL profit. Not bad.`,
        ];
        return winFallbacks[Math.floor(Math.random() * winFallbacks.length)];
      } else {
        const lossFallbacks = [
          `${symbol} stopped out at ${percent}%. Loss: ${solAmount} SOL. Can't win them all.`,
          `${symbol} exit. Down ${percent}%. ${solAmount} SOL gone. The whales got me.`,
          `Cut ${symbol} at ${percent}%. Lost ${solAmount} SOL. Moving on.`,
          `${symbol} didn't work out. ${percent}% loss. ${solAmount} SOL sacrificed to the market.`,
          `Stop loss triggered on ${symbol}. ${percent}%. Cost ${solAmount} SOL.`,
          `${symbol} position closed. ${percent}% in the red. ${solAmount} SOL lesson learned.`,
        ];
        return lossFallbacks[Math.floor(Math.random() * lossFallbacks.length)];
      }
    }
  }

  /**
   * Generate time pressure commentary
   */
  private generateTimePressureCommentary(moodStyle: string): string {
    const prompts = getTimePressurePrompts();
    return prompts[Math.floor(Math.random() * prompts.length)];
  }

  /**
   * Generate shill analysis commentary
   */
  private generateShillCommentary(context: CommentaryContext): string {
    const shortSender = context.shillSender?.slice(0, 6) || 'anon';
    const shortCA = context.shillCA?.slice(0, 8) || 'unknown';
    const amount = context.shillAmount?.toFixed(0) || '?';

    return `Incoming shill from ${shortSender}. They burned ${amount} SCHIZO for ${shortCA}. Running my checks.`;
  }

  /**
   * Fallback paranoid musing when Claude unavailable
   */
  private getFallbackMusing(): string {
    const musings = [
      'The wallets are connected. They always are.',
      'Why do pumps always happen at the same time? Coincidence? I think not.',
      'I\'ve seen this pattern before. 47 times. FORTY SEVEN.',
      'Someone is watching these same charts. I can feel it.',
      'The market makers think I don\'t notice. I notice everything.',
      'Every wallet tells a story. Most of them end badly.',
      'Trust no one. Especially the devs. Especially me.',
      'The charts whisper if you listen long enough.',
      'Three wallets. Same buy pattern. Different tokens. Connected.',
      'Why does liquidity always vanish at 3 AM? Every. Single. Time.',
      'The devs are watching this stream. I know they are.',
      'That pump wasn\'t organic. I can prove it with wallet graphs.',
      'Someone front-ran that trade. My logs don\'t lie.',
      'Quiet periods make me nervous. That\'s when they plan the rugs.',
      'The smart money moved 10 minutes before the announcement. How.',
      'I\'ve catalogued 200 wallet clusters. They\'re all related.',
      'Every rug follows the same timeline. And nobody sees it but me.',
      'The timestamps don\'t match. Someone manipulated the chain.',
      'Why do winning wallets never lose? Insider information. Obviously.',
      'That token name is too perfect. This is a coordinated shill.',
    ];
    return musings[Math.floor(Math.random() * musings.length)];
  }

  /**
   * Emit speech and record timing
   */
  private emitSpeech(text: string, beat: NarrativeBeat): void {
    this.lastSpeechTime = Date.now();
    this.moodSystem.recordSpeech();

    logger.info({ beat, text: text.slice(0, 50) }, 'Speech emitted');

    if (this.onSpeechCallback) {
      this.onSpeechCallback(text, beat);
    }
  }

  /**
   * Check for quiet period and queue paranoid musing if needed
   */
  private checkForQuietPeriod(): void {
    const timeSinceLastSpeech = Date.now() - this.lastSpeechTime;

    // If it's been too long and queue is empty, add filler
    if (timeSinceLastSpeech > this.config.maxSpeechGapMs && this.queue.length === 0) {
      const mood = this.moodSystem.getState().current;

      if (mood === 'RESTLESS') {
        this.queueCommentary('TIME_PRESSURE', {});
      } else {
        this.queueCommentary('PARANOID_MUSING', {});
      }
    }
  }
}
</file>

<file path="src/trading/entertainment-mode.ts">
/**
 * Entertainment Mode - Degen trading for activity over profit
 *
 * Purpose: Make the agent trade frequently (3-5/hour) with micro bets
 * so it's entertaining to watch, even if individual trades aren't optimal.
 */

import { MoodSystem, type MoodEffects } from '../personality/mood-system.js';
import { logger } from '../lib/logger.js';

/**
 * Token context for entertainment mode evaluation
 */
export interface TokenContext {
  mint: string;
  name?: string;
  symbol?: string;
  priceUsd?: number;
  volumeUsd5m?: number;        // 5-minute volume (most recent activity)
  liquiditySol?: number;
  holderCount?: number;
  createdAt?: number;
  hasMinAuthorities?: boolean; // Mint auth present
  hasFreezeAuth?: boolean;
}

/**
 * Entertainment mode configuration
 */
export interface EntertainmentConfig {
  enabled: boolean;

  // Micro betting
  minPositionSol: number;       // Minimum bet (default: 0.01)
  maxPositionSol: number;       // Maximum bet (default: 0.05)

  // Time pressure
  quietPeriodMs: number;        // Time before restlessness (default: 5 min)
  maxQuietPeriodMs: number;     // Maximum time before forced trade (default: 15 min)

  // Risk thresholds
  baseRiskThreshold: number;    // Starting risk threshold (default: 6/10)
  minRiskThreshold: number;     // Minimum when desperate (default: 4/10)

  // Degen moments
  degenChance: number;          // Chance of random ape (default: 0.08 = 8%)

  // Rate limiting
  cooldownMs: number;           // Minimum time between trades (default: 5 min)
  maxTradesPerHour: number;     // Maximum trades per hour (default: 6)

  // Volume/hype detection
  minVolumeForHype: number;     // USD volume to consider "hype" (default: 10000)
  minHolderCountForHype: number; // Holder count for legitimacy (default: 50)
  minVolumeRequired: number;    // Minimum volume to trade at all (default: 500)
}

/**
 * Default entertainment config
 */
export const DEFAULT_ENTERTAINMENT_CONFIG: EntertainmentConfig = {
  enabled: false,

  // Micro positions: 0.01-0.05 SOL (~$2-10 at $200/SOL)
  minPositionSol: 0.01,
  maxPositionSol: 0.05,

  // Time pressure builds over 5-15 minutes
  quietPeriodMs: 5 * 60 * 1000,       // 5 minutes
  maxQuietPeriodMs: 15 * 60 * 1000,   // 15 minutes

  // Risk threshold: 6/10 base, drops to 4/10 when desperate
  baseRiskThreshold: 0.6,
  minRiskThreshold: 0.4,

  // 15% chance of random degen ape (30% in MANIC mood)
  degenChance: 0.15,

  // Rate limiting: 2 min cooldown, 12 trades/hour max
  cooldownMs: 2 * 60 * 1000,          // 2 minutes
  maxTradesPerHour: 12,

  // Hype detection thresholds (5-minute window)
  minVolumeForHype: 1000,             // $1k volume in 5m
  minHolderCountForHype: 50,          // 50 holders
  minVolumeRequired: 100,             // $100 minimum volume in 5m (shows recent activity)
};

/**
 * Entertainment decision result
 */
export interface EntertainmentDecision {
  shouldTrade: boolean;
  positionSizeSol: number;
  reason: string;
  isDegenMoment: boolean;
  isHypeTrade: boolean;
  timePressure: number;          // 0-1
  currentRiskThreshold: number;  // Adjusted threshold
}

/**
 * Internal tracking for rate limiting
 */
interface TradeRecord {
  timestamp: number;
  mint: string;
}

/**
 * EntertainmentMode - Degen trading decisions for activity
 */
export class EntertainmentMode {
  private config: EntertainmentConfig;
  private moodSystem?: MoodSystem;
  private lastTradeTime: number = 0;
  private recentTrades: TradeRecord[] = [];

  constructor(config: Partial<EntertainmentConfig> = {}, moodSystem?: MoodSystem) {
    this.config = { ...DEFAULT_ENTERTAINMENT_CONFIG, ...config };
    this.moodSystem = moodSystem;

    logger.info({
      config: this.config,
      hasMoodSystem: !!moodSystem
    }, 'EntertainmentMode initialized');
  }

  /**
   * Main evaluation method - decides if we should trade this token
   */
  evaluate(context: TokenContext): EntertainmentDecision {
    // Get time pressure and mood effects
    const timePressure = this.calculateTimePressure();
    const moodEffects = this.getMoodEffects();

    // Calculate adjusted risk threshold based on time pressure and mood
    const currentRiskThreshold = this.calculateRiskThreshold(timePressure, moodEffects);

    // Check cooldown first
    if (!this.canTradeYet()) {
      const cooldownRemaining = this.config.cooldownMs - (Date.now() - this.lastTradeTime);
      return {
        shouldTrade: false,
        positionSizeSol: 0,
        reason: `Cooldown active (${Math.ceil(cooldownRemaining / 1000)}s remaining)`,
        isDegenMoment: false,
        isHypeTrade: false,
        timePressure,
        currentRiskThreshold,
      };
    }

    // Check hourly limit
    if (this.isHourlyLimitReached()) {
      return {
        shouldTrade: false,
        positionSizeSol: 0,
        reason: `Hourly limit reached (${this.config.maxTradesPerHour} trades)`,
        isDegenMoment: false,
        isHypeTrade: false,
        timePressure,
        currentRiskThreshold,
      };
    }

    // Check for degen moment (random ape)
    const isDegenMoment = this.checkDegenMoment();

    // Volume filter: Require minimum volume UNLESS it's a true degen moment
    // This prevents buying completely dead tokens in normal flow
    const hasMinVolume = (context.volumeUsd5m || 0) >= this.config.minVolumeRequired;
    if (!hasMinVolume && !isDegenMoment) {
      return {
        shouldTrade: false,
        positionSizeSol: 0,
        reason: `No recent volume ($${context.volumeUsd5m?.toFixed(0) || '0'} in 5m < $${this.config.minVolumeRequired} required)`,
        isDegenMoment: false,
        isHypeTrade: false,
        timePressure,
        currentRiskThreshold,
      };
    }

    // Check for risky auth (mint/freeze authority)
    const hasRiskyAuth = context.hasMinAuthorities || context.hasFreezeAuth;

    if (isDegenMoment) {
      let position = this.calculatePosition(timePressure, moodEffects, true);
      let reason = 'DEGEN MOMENT - random ape activated';

      // If risky auth exists, apply 60% position reduction but still trade
      if (hasRiskyAuth) {
        position *= 0.4; // 60% reduction for risky auth
        reason = 'DEGEN MOMENT - random ape (risky auth, position reduced 60%)';
        logger.info({
          mint: context.mint,
          hasMinAuthorities: context.hasMinAuthorities,
          hasFreezeAuth: context.hasFreezeAuth,
          reducedPosition: position
        }, 'Degen trade with risky auth - position reduced');
      }

      return {
        shouldTrade: true,
        positionSizeSol: position,
        reason,
        isDegenMoment: true,
        isHypeTrade: false,
        timePressure,
        currentRiskThreshold,
      };
    }

    // For non-degen trades, risky auth blocks the trade
    // (Standard trades should still have safety standards)
    if (hasRiskyAuth) {
      return {
        shouldTrade: false,
        positionSizeSol: 0,
        reason: 'Critical risk (mint/freeze authority) - waiting for degen moment',
        isDegenMoment: false,
        isHypeTrade: false,
        timePressure,
        currentRiskThreshold,
      };
    }

    // Check for hype (volume + holders)
    const isHypeTrade = this.detectHype(context);
    if (isHypeTrade) {
      const position = this.calculatePosition(timePressure, moodEffects, false);
      return {
        shouldTrade: true,
        positionSizeSol: position,
        reason: `HYPE detected - 5m volume: $${context.volumeUsd5m?.toFixed(0) || 'N/A'}, holders: ${context.holderCount || 'N/A'}`,
        isDegenMoment: false,
        isHypeTrade: true,
        timePressure,
        currentRiskThreshold,
      };
    }

    // Calculate a "quality score" for the token (simplified)
    const qualityScore = this.calculateQualityScore(context);

    // With time pressure, our standards drop
    if (qualityScore >= currentRiskThreshold) {
      const position = this.calculatePosition(timePressure, moodEffects, false);
      return {
        shouldTrade: true,
        positionSizeSol: position,
        reason: `Quality score ${(qualityScore * 10).toFixed(1)}/10 passes threshold ${(currentRiskThreshold * 10).toFixed(1)}/10`,
        isDegenMoment: false,
        isHypeTrade: false,
        timePressure,
        currentRiskThreshold,
      };
    }

    // Didn't pass threshold
    return {
      shouldTrade: false,
      positionSizeSol: 0,
      reason: `Quality score ${(qualityScore * 10).toFixed(1)}/10 below threshold ${(currentRiskThreshold * 10).toFixed(1)}/10`,
      isDegenMoment: false,
      isHypeTrade: false,
      timePressure,
      currentRiskThreshold,
    };
  }

  /**
   * Calculate time pressure (0-1) based on time since last trade
   * 0 = just traded, 1 = max quiet period reached
   */
  calculateTimePressure(): number {
    if (this.lastTradeTime === 0) {
      // Never traded - start with some pressure
      return 0.5;
    }

    const timeSinceTrade = Date.now() - this.lastTradeTime;

    // No pressure during cooldown
    if (timeSinceTrade < this.config.cooldownMs) {
      return 0;
    }

    // Pressure builds between quiet period start and max
    const pressureStart = this.config.quietPeriodMs;
    const pressureEnd = this.config.maxQuietPeriodMs;

    if (timeSinceTrade < pressureStart) {
      return 0;
    }

    if (timeSinceTrade >= pressureEnd) {
      return 1;
    }

    // Linear interpolation between start and end
    return (timeSinceTrade - pressureStart) / (pressureEnd - pressureStart);
  }

  /**
   * Check for degen moment (random chance to ape)
   */
  checkDegenMoment(): boolean {
    // Get mood-adjusted degen chance
    const moodEffects = this.getMoodEffects();

    // MANIC mood doubles degen chance, PARANOID halves it
    let adjustedChance = this.config.degenChance;
    if (moodEffects) {
      if (moodEffects.urgency >= 0.9) {
        adjustedChance *= 2; // MANIC doubles
      } else if (moodEffects.riskMultiplier < 0.7) {
        adjustedChance *= 0.5; // PARANOID halves
      }
    }

    const roll = Math.random();
    const isDegen = roll < adjustedChance;

    if (isDegen) {
      logger.info({
        roll: roll.toFixed(4),
        threshold: adjustedChance.toFixed(4)
      }, 'DEGEN MOMENT triggered');

      // Also trigger manic mood if we have mood system
      this.moodSystem?.triggerManicEpisode('degen moment in entertainment mode');
    }

    return isDegen;
  }

  /**
   * Record that a trade was made (for cooldown/rate limiting)
   */
  recordTrade(mint: string): void {
    const now = Date.now();
    this.lastTradeTime = now;
    this.recentTrades.push({ timestamp: now, mint });

    // Clean up old trades (keep last hour)
    const oneHourAgo = now - 60 * 60 * 1000;
    this.recentTrades = this.recentTrades.filter(t => t.timestamp > oneHourAgo);

    logger.debug({
      mint,
      tradesLastHour: this.recentTrades.length
    }, 'Trade recorded in entertainment mode');
  }

  /**
   * Get current stats for debugging
   */
  getStats(): {
    enabled: boolean;
    lastTradeTime: number;
    timeSinceLastTrade: number;
    timePressure: number;
    tradesLastHour: number;
    canTradeNow: boolean;
    currentRiskThreshold: number;
    moodActive: boolean;
  } {
    const timePressure = this.calculateTimePressure();
    const moodEffects = this.getMoodEffects();

    return {
      enabled: this.config.enabled,
      lastTradeTime: this.lastTradeTime,
      timeSinceLastTrade: this.lastTradeTime === 0 ? -1 : Date.now() - this.lastTradeTime,
      timePressure,
      tradesLastHour: this.getTradesInLastHour(),
      canTradeNow: this.canTradeYet() && !this.isHourlyLimitReached(),
      currentRiskThreshold: this.calculateRiskThreshold(timePressure, moodEffects),
      moodActive: !!this.moodSystem,
    };
  }

  /**
   * Update configuration at runtime
   */
  setConfig(config: Partial<EntertainmentConfig>): void {
    this.config = { ...this.config, ...config };
    logger.info({ config: this.config }, 'EntertainmentMode config updated');
  }

  /**
   * Set or update mood system reference
   */
  setMoodSystem(moodSystem: MoodSystem): void {
    this.moodSystem = moodSystem;
    logger.debug('MoodSystem attached to EntertainmentMode');
  }

  // ============ Private Methods ============

  /**
   * Get mood effects (if mood system available)
   */
  private getMoodEffects(): MoodEffects | null {
    return this.moodSystem?.getEffects() || null;
  }

  /**
   * Calculate risk threshold based on time pressure and mood
   */
  private calculateRiskThreshold(timePressure: number, moodEffects: MoodEffects | null): number {
    // Base threshold drops with time pressure
    const base = this.config.baseRiskThreshold;
    const min = this.config.minRiskThreshold;

    // Linear decrease from base to min as pressure increases
    let threshold = base - (timePressure * (base - min));

    // Apply mood modifier
    if (moodEffects) {
      // Higher risk multiplier = we accept more risk = lower threshold
      // riskMultiplier of 1.5 means we accept 50% more risk
      // So threshold becomes threshold / riskMultiplier
      threshold = threshold / moodEffects.riskMultiplier;
    }

    // Clamp to valid range
    return Math.max(0.2, Math.min(0.8, threshold));
  }

  /**
   * Calculate position size based on pressure and mood
   */
  private calculatePosition(
    timePressure: number,
    moodEffects: MoodEffects | null,
    isDegen: boolean
  ): number {
    // Start with base position (middle of range)
    let position = (this.config.minPositionSol + this.config.maxPositionSol) / 2;

    // Degen moments use random position in range
    if (isDegen) {
      position = this.config.minPositionSol +
        (Math.random() * (this.config.maxPositionSol - this.config.minPositionSol));
    }

    // Apply mood multiplier
    if (moodEffects) {
      position *= moodEffects.positionSizeMultiplier;
    }

    // Clamp to configured range
    return Math.max(
      this.config.minPositionSol,
      Math.min(this.config.maxPositionSol, position)
    );
  }

  /**
   * Check if cooldown has passed
   */
  private canTradeYet(): boolean {
    if (this.lastTradeTime === 0) return true;
    return (Date.now() - this.lastTradeTime) >= this.config.cooldownMs;
  }

  /**
   * Check if hourly trade limit reached
   */
  private isHourlyLimitReached(): boolean {
    return this.getTradesInLastHour() >= this.config.maxTradesPerHour;
  }

  /**
   * Count trades in the last hour
   */
  private getTradesInLastHour(): number {
    const oneHourAgo = Date.now() - 60 * 60 * 1000;
    return this.recentTrades.filter(t => t.timestamp > oneHourAgo).length;
  }

  /**
   * Detect if token has hype (volume + holders)
   */
  private detectHype(context: TokenContext): boolean {
    const hasVolume = (context.volumeUsd5m || 0) >= this.config.minVolumeForHype;
    const hasHolders = (context.holderCount || 0) >= this.config.minHolderCountForHype;

    // Need both volume AND holders for hype (avoid wash trading)
    return hasVolume && hasHolders;
  }

  /**
   * Calculate a simple quality score for the token (0-1)
   */
  private calculateQualityScore(context: TokenContext): number {
    let score = 0.5; // Base score

    // Liquidity bonus (up to +0.2)
    if (context.liquiditySol) {
      if (context.liquiditySol >= 10) score += 0.2;
      else if (context.liquiditySol >= 5) score += 0.15;
      else if (context.liquiditySol >= 2) score += 0.1;
      else if (context.liquiditySol >= 1) score += 0.05;
    }

    // Holder count bonus (up to +0.15)
    if (context.holderCount) {
      if (context.holderCount >= 100) score += 0.15;
      else if (context.holderCount >= 50) score += 0.1;
      else if (context.holderCount >= 20) score += 0.05;
    }

    // Volume bonus (up to +0.15) - 5m volume thresholds
    if (context.volumeUsd5m) {
      if (context.volumeUsd5m >= 2000) score += 0.15;    // $2k in 5m
      else if (context.volumeUsd5m >= 500) score += 0.1;  // $500 in 5m
      else if (context.volumeUsd5m >= 100) score += 0.05; // $100 in 5m
    }

    // Age penalty for very new tokens (less than 1 hour)
    if (context.createdAt) {
      const ageMs = Date.now() - context.createdAt;
      if (ageMs < 60 * 60 * 1000) {
        score -= 0.1; // New token penalty
      }
    }

    return Math.max(0, Math.min(1, score));
  }
}
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(wc:*)",
      "WebSearch",
      "mcp__blender__generate_hyper3d_model_via_images",
      "mcp__blender__generate_hyper3d_model_via_text",
      "mcp__blender__poll_rodin_job_status",
      "mcp__blender__import_generated_asset",
      "mcp__blender__execute_blender_code",
      "mcp__blender__get_viewport_screenshot",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "WebFetch(domain:docs.coingecko.com)",
      "WebFetch(domain:www.helius.dev)",
      "WebFetch(domain:docs.helius.dev)",
      "WebFetch(domain:hub.jup.ag)",
      "WebFetch(domain:docs.birdeye.so)",
      "WebFetch(domain:www.npmjs.com)",
      "WebFetch(domain:station.jup.ag)",
      "WebFetch(domain:mcp.so)",
      "WebFetch(domain:github.com)",
      "Bash(railway logs:*)"
    ]
  }
}
</file>

<file path="CLAUDE.md">
# Schizo Agent - API & SDK Reference

This document contains comprehensive API documentation for all services used in the Schizo Agent trading bot. This is loaded automatically for every Claude Code session.

---

## Quick Reference

| Service | SDK | Status | Use Case |
|---------|-----|--------|----------|
| Helius | `helius-sdk` | Active | RPC, DAS API, transactions |
| Jupiter | `@jup-ag/api` | Active | Token swaps for graduated tokens |
| Birdeye | Raw HTTP | No SDK | Trending tokens, security |
| DexScreener | Raw HTTP | No SDK | DEX pair data |
| PumpPortal | WebSocket + REST | No SDK | Pump.fun trades |

---

## 1. HELIUS SDK

### Installation
```bash
npm install helius-sdk
```

### Initialization
```typescript
import Helius from 'helius-sdk';

const helius = new Helius('your-api-key');
```

### Core Methods

#### DAS API (Digital Asset Standard)
```typescript
// Get single asset metadata
const asset = await helius.rpc.getAsset({ id: 'mint-address' });

// Get multiple assets (batch - up to 1000)
const assets = await helius.rpc.getAssetBatch({ ids: ['mint1', 'mint2'] });

// Get assets by owner (all NFTs/tokens in wallet)
const owned = await helius.rpc.getAssetsByOwner({
  ownerAddress: 'wallet-address',
  page: 1,
  limit: 100,
  sortBy: { sortBy: 'created', sortDirection: 'desc' }
});

// Get token accounts by mint or owner
const accounts = await helius.rpc.getTokenAccounts({
  mint: 'token-mint',
  limit: 100
});

// Search assets with filters
const results = await helius.rpc.searchAssets({
  ownerAddress: 'wallet',
  compressed: false,
  page: 1
});
```

#### Transactions
```typescript
// Get parsed transaction history
const txs = await helius.rpc.getTransactionsForAddress('wallet-address', {
  limit: 100
});

// Parse raw transactions
const parsed = await helius.parseTransactions({
  transactions: ['signature1', 'signature2']
});

// Get compute units estimate
const units = await helius.rpc.getComputeUnits({
  instructions: [...],
  payer: 'payer-pubkey'
});

// Get priority fee estimate
const fees = await helius.rpc.getPriorityFeeEstimate({
  accountKeys: ['program-id'],
  options: { recommended: true }
});
```

#### Smart Transactions
```typescript
// Create optimized transaction with compute budget
const smartTx = await helius.createSmartTransaction({
  instructions: [...],
  signers: [keypair],
  feePayer: keypair
});

// Send with automatic retry and confirmation
const sig = await helius.sendSmartTransaction(smartTx, {
  skipPreflight: false
});
```

#### Webhooks
```typescript
// Create webhook for address activity
const webhook = await helius.createWebhook({
  webhookURL: 'https://your-endpoint.com/webhook',
  transactionTypes: ['TRANSFER', 'SWAP'],
  accountAddresses: ['address1', 'address2']
});

// List all webhooks
const webhooks = await helius.getAllWebhooks();

// Delete webhook
await helius.deleteWebhook('webhook-id');
```

### Rate Limits by Tier

| Tier | RPC/sec | Enhanced/sec | WebSocket |
|------|---------|--------------|-----------|
| Free | 10 | 2 | No |
| Developer | 50 | 10 | Yes |
| Business | 200 | 50 | Yes |
| Professional | 500 | 100 | Yes |

---

## 2. JUPITER SDK

### Installation
```bash
npm install @jup-ag/api
```

### Initialization
```typescript
import { createJupiterApiClient } from '@jup-ag/api';

const jupiter = createJupiterApiClient();
```

### Core Methods

#### Get Quote
```typescript
const quote = await jupiter.quoteGet({
  inputMint: 'So11111111111111111111111111111111111111112', // SOL
  outputMint: 'token-mint-address',
  amount: 1000000000, // 1 SOL in lamports
  slippageBps: 50, // 0.5%
  swapMode: 'ExactIn'
});

console.log({
  inAmount: quote.inAmount,
  outAmount: quote.outAmount,
  priceImpactPct: quote.priceImpactPct,
  routePlan: quote.routePlan
});
```

#### Execute Swap
```typescript
// Get serialized transaction
const swapResult = await jupiter.swapPost({
  swapRequest: {
    quoteResponse: quote,
    userPublicKey: wallet.publicKey.toString(),
    dynamicComputeUnitLimit: true,
    prioritizationFeeLamports: 'auto'
  }
});

// Deserialize and sign
const transaction = VersionedTransaction.deserialize(
  Buffer.from(swapResult.swapTransaction, 'base64')
);
transaction.sign([wallet]);

// Send
const signature = await connection.sendTransaction(transaction);
```

#### Token Information
```typescript
// Get token info
const tokens = await jupiter.tokensGet();

// Get specific token
const token = tokens.find(t => t.address === 'mint-address');
```

#### Price API
```typescript
// Get prices for multiple tokens
const prices = await fetch(
  'https://api.jup.ag/price/v2?ids=SOL,token-mint'
).then(r => r.json());
```

### Jupiter Swap Flow
1. Get quote with `quoteGet()`
2. Check `priceImpactPct` (reject if > 5%)
3. Get swap transaction with `swapPost()`
4. Sign and send transaction
5. Confirm transaction

### Important Notes
- Use for tokens that have **graduated from pump.fun** to Raydium
- NOT for active pump.fun bonding curve tokens (use PumpPortal)
- Always check price impact before swapping
- Set reasonable slippage (50-100 bps for liquid tokens)

---

## 3. BIRDEYE API

### Base URL
```
https://public-api.birdeye.so
```

### Headers
```typescript
const headers = {
  'X-API-KEY': process.env.BIRDEYE_API_KEY,
  'x-chain': 'solana'
};
```

### Endpoints

#### Trending Tokens
```typescript
GET /defi/token_trending
Query: sort_by=rank&sort_type=asc&offset=0&limit=20

Response: {
  data: {
    items: [{
      address: string,
      symbol: string,
      name: string,
      price: number,
      priceChange24h: number,
      volume24h: number,
      liquidity: number
    }]
  }
}
```

#### Top Gainers
```typescript
GET /defi/token_top_gainers
Query: time_frame=1h|4h|12h|24h&limit=20

Response: {
  data: [{
    address: string,
    symbol: string,
    priceChange: number
  }]
}
```

#### Token Security
```typescript
GET /defi/token_security
Query: address={mint}

Response: {
  data: {
    isHoneypot: boolean,
    isMintable: boolean,
    isFreezable: boolean,
    topHolders: [{
      address: string,
      percentage: number
    }]
  }
}
```

#### Token Overview
```typescript
GET /defi/token_overview
Query: address={mint}

Response: {
  data: {
    address: string,
    symbol: string,
    name: string,
    price: number,
    mc: number, // market cap
    liquidity: number,
    holder: number,
    extensions: {
      website: string,
      twitter: string,
      telegram: string
    }
  }
}
```

#### Top Traders (Smart Money)
```typescript
GET /defi/v2/tokens/{address}/top_traders
Query: time_frame=24h

Response: {
  data: [{
    address: string,
    pnl: number,
    volume: number,
    trades: number
  }]
}
```

### Rate Limits
- Free tier: 1 request/second
- Use 1200ms delay between requests (80% safety margin)

---

## 4. DEXSCREENER API

### Base URL
```
https://api.dexscreener.com
```

### Endpoints

#### Token Pairs
```typescript
GET /latest/dex/tokens/{tokenAddress}

Response: {
  pairs: [{
    chainId: 'solana',
    dexId: 'raydium',
    pairAddress: string,
    baseToken: { address, name, symbol },
    quoteToken: { address, name, symbol },
    priceNative: string,
    priceUsd: string,
    liquidity: { usd, base, quote },
    fdv: number,
    pairCreatedAt: number, // Unix timestamp
    txns: {
      m5: { buys, sells },
      h1: { buys, sells },
      h6: { buys, sells },
      h24: { buys, sells }
    },
    volume: { m5, h1, h6, h24 },
    priceChange: { m5, h1, h6, h24 }
  }]
}
```

#### Latest Tokens
```typescript
GET /token-profiles/latest/v1

Response: [{
  chainId: 'solana',
  tokenAddress: string,
  description: string,
  links: [{ type, url }]
}]
```

#### Search Tokens
```typescript
GET /latest/dex/search
Query: q={searchTerm}

Response: {
  pairs: [...]
}
```

### No Authentication Required
DexScreener is free with no API key needed.

---

## 5. PUMPPORTAL API

### WebSocket (Real-time Data)
```typescript
const ws = new WebSocket('wss://pumpportal.fun/api/data');

// Subscribe to new tokens
ws.send(JSON.stringify({
  method: 'subscribeNewToken'
}));

// Subscribe to trades for specific token
ws.send(JSON.stringify({
  method: 'subscribeTokenTrade',
  keys: ['token-mint-address']
}));

// Events
ws.on('message', (data) => {
  const event = JSON.parse(data);

  if (event.txType === 'create') {
    // New token created
    console.log({
      mint: event.mint,
      name: event.name,
      symbol: event.symbol,
      uri: event.uri, // IPFS metadata
      bondingCurve: event.bondingCurve,
      creator: event.traderPublicKey
    });
  }

  if (event.txType === 'buy' || event.txType === 'sell') {
    // Trade event
    console.log({
      mint: event.mint,
      type: event.txType,
      solAmount: event.solAmount,
      tokenAmount: event.tokenAmount,
      trader: event.traderPublicKey,
      marketCapSol: event.marketCapSol
    });
  }
});
```

### REST API (Trade Execution)
```typescript
// Get token info
GET /api/token/{mint}

Response: {
  mint: string,
  bondingCurve: string,
  price: number, // SOL per token
  marketCap: number, // in SOL
  supply: number,
  virtualSolReserves: number,
  virtualTokenReserves: number
}

// Execute trade (requires signing)
POST /api/trade-local
Body: {
  publicKey: string,
  action: 'buy' | 'sell',
  mint: string,
  amount: number, // SOL for buy, tokens for sell
  denominatedInSol: 'true' | 'false',
  slippage: number, // 1-100
  priorityFee: number // in SOL
}

Response: {
  transaction: string // Base64 serialized transaction
}
```

### Bonding Curve Formula
```
Price = virtualSolReserves / virtualTokenReserves
```

Tokens graduate to Raydium at ~$69k market cap (~400 SOL in reserves).

---

## 6. GECKOTERMINAL API

### Base URL
```
https://api.geckoterminal.com/api/v2
```

### Endpoints

#### Trending Pools
```typescript
GET /networks/solana/trending_pools

Response: {
  data: [{
    id: string,
    type: 'pool',
    attributes: {
      name: string,
      address: string,
      base_token_price_usd: string,
      fdv_usd: string,
      market_cap_usd: string,
      volume_usd: { h24: string },
      reserve_in_usd: string,
      pool_created_at: string
    },
    relationships: {
      base_token: { data: { id } },
      quote_token: { data: { id } }
    }
  }]
}
```

### No Authentication Required

---

## 7. MORALIS API

**Package**: `src/api/moralis.ts` (Custom client)
**Purpose**: Alternative trending token discovery with security scores
**Docs**: https://docs.moralis.com/web3-data-api/solana

### Key Endpoints

```typescript
import { getMoralisClient } from './api/moralis.js';

const moralis = getMoralisClient();

// Get trending tokens with filters
const trending = await moralis.getTrendingTokens({
  limit: 15,
  minSecurityScore: 30,  // 0-100 (higher = safer)
  minMarketCap: 10000,   // USD
  minLiquidity: 5000,    // USD
});

// Get top gainers
const gainers = await moralis.getTopGainers({
  limit: 10,
  timeFrame: '1h',  // '5m' | '1h' | '4h' | '12h' | '24h'
});

// Get top losers
const losers = await moralis.getTopLosers({
  limit: 10,
  timeFrame: '24h',
});

// Search tokens
const results = await moralis.searchTokens('BONK', 10);

// Get single token
const token = await moralis.getToken(tokenAddress);

// === DEX Integration Endpoints ===

// Get token bonding status (is it on bonding curve or graduated?)
const status = await moralis.getTokenBondingStatus(tokenAddress);
// Returns: { status: 'bonding' | 'graduated' | 'unknown', bondingProgress?, graduatedAt? }

// Get tokens currently in bonding phase (new opportunities)
const bondingTokens = await moralis.getBondingTokens('pumpfun', 20);

// Get recently graduated tokens (moved to Raydium/Jupiter)
const graduatedTokens = await moralis.getGraduatedTokens('pumpfun', 20);

// Get newest tokens from an exchange
const newTokens = await moralis.getNewTokens('pumpfun', 20);

// Get swap history for a token (analyze trading patterns)
const swaps = await moralis.getTokenSwaps(tokenAddress, 50);
// Returns: [{ signature, timestamp, type: 'buy'|'sell', solAmount, tokenAmount, wallet }]
```

### Response Format

```typescript
interface MoralisToken {
  tokenAddress: string;
  name: string;
  symbol: string;
  decimals: number;
  priceUsd: number;
  priceChange24h?: number;
  priceChange1h?: number;
  priceChange5m?: number;
  volume24h?: number;
  volume1h?: number;
  marketCap?: number;
  liquidity?: number;
  securityScore?: number;  // 0-100 (Moralis exclusive!)
  holders?: number;
  buyers24h?: number;
  sellers24h?: number;
}
```

### Security Score Feature

Moralis provides a **security score** (0-100) not available in Birdeye:
- **0-30**: High risk - avoid
- **30-50**: Medium risk - proceed with caution
- **50-70**: Lower risk - reasonable
- **70-100**: Safer tokens

### Rate Limits

- Free tier: 40 requests/second
- Built-in rate limiting in client (200ms delay)

---

## Trading Logic Reference

### When to Use Each API

| Scenario | API to Use |
|----------|-----------|
| New pump.fun token | PumpPortal WebSocket + REST |
| Token safety check | Helius DAS + Birdeye Security + Moralis Score |
| Graduated token swap | Jupiter |
| Trending discovery | Moralis + Birdeye + GeckoTerminal |
| Wallet analysis | Helius getTransactionsForAddress |
| Price data | DexScreener (free) or Birdeye |

### Token Lifecycle
1. **Creation** - PumpPortal WebSocket detects
2. **Bonding Curve** - Trade via PumpPortal REST
3. **Graduation** (~$69k mcap) - Migrates to Raydium
4. **Post-Graduation** - Trade via Jupiter

### Safety Checks Priority
1. Helius `getAsset()` - Check authorities
2. Birdeye `token_security` - Honeypot detection
3. Helius `getTokenAccounts()` - Holder concentration
4. DexScreener - Liquidity verification

---

## Environment Variables

```env
# Required
HELIUS_API_KEY=your-helius-key

# Token Discovery APIs (at least one recommended)
BIRDEYE_API_KEY=your-birdeye-key
MORALIS_API_KEY=your-moralis-key

# Optional
HELIUS_TIER=developer  # free|developer|business|professional
```

---

## Learning & Intelligence Components

### 1. BundleDetector (`src/analysis/bundle-detector.ts`)
Detects coordinated/manipulated trading patterns.

**Detection Methods:**
- Timing clusters (transactions within 30s window)
- Amount similarity (low variance = bots)
- Same-block detection (Jito bundles)
- Wallet concentration analysis

**Usage:**
```typescript
import { BundleDetector } from './analysis/bundle-detector.js';

const detector = new BundleDetector();
const analysis = detector.analyze(transactions);

if (analysis.isBundled) {
  console.log('Bundle detected!', analysis.flags);
  // Flags: TIMING_CLUSTER, SIMILAR_AMOUNTS, SAME_BLOCK, CONCENTRATED
}
```

### 2. SmartMoneyCopier (`src/trading/smart-money-copier.ts`)
Proactively watches profitable wallets and copies their trades.

**Key Difference from SmartMoneyTracker:**
- SmartMoneyTracker: Token detected ‚Üí check who's buying
- SmartMoneyCopier: Watch wallets ‚Üí copy when they buy

**Usage:**
```typescript
import { SmartMoneyCopier } from './trading/smart-money-copier.js';

const copier = new SmartMoneyCopier(helius, {
  minWalletPnl: 10,      // 10 SOL minimum profit
  minWinRate: 0.5,       // 50% win rate
  maxTradeAge: 60000,    // Copy within 1 minute
  maxCopySize: 0.1,      // 0.1 SOL max per copy
});

// Add wallets to watch
copier.addWallet({
  address: 'wallet-address',
  label: 'Whale #1',
  pnlSol: 500,
  winRate: 0.72,
  totalTrades: 150,
});

// Listen for signals
copier.onSignal((signal) => {
  console.log('Copy trade signal!', signal.trade.tokenMint);
  // Execute trade with signal.suggestedSize
});

copier.start();
```

### 3. LearningEngine (`src/analysis/learning-engine.ts`)
Tracks trade outcomes and learns which features predict success.

**What It Learns:**
- Which features correlate with wins (smart money, heat, holder count, etc.)
- Confidence calibration (is "high confidence" actually high win rate?)
- Feature weights that adjust over time

**Usage:**
```typescript
import { LearningEngine, TradeLesson } from './analysis/learning-engine.js';

const learner = new LearningEngine(db);

// After a trade closes, record the lesson
await learner.recordLesson({
  id: 'trade-123',
  tokenMint: 'mint-address',
  features: {
    bondingCurveProgress: 35,
    heatMetric: 67,
    smartMoneyCount: 2,
    holderCount: 150,
    // ... all features at entry time
  },
  outcome: 'win',
  pnlPercent: 45,
  confidenceAtEntry: 75,
});

// Use learned weights to score new tokens
const { adjustment, reasons, warnings } = learner.scoreFeatures(newTokenFeatures);
// adjustment: -30 to +30 points to add to base confidence

// Get insights
const insights = learner.getInsights();
// { bestFeatures: [...], worstFeatures: [...], calibrationIssues: [...] }
```

### 4. MomentumScanner (`src/analysis/momentum-scanner.ts`)
Detects early pump signals using heat metrics.

**Key Metrics:**
- Heat: `(1min_volume / 5min_volume) * 100`
- Buy pressure: Buy/Sell ratio
- Consecutive buys
- Price steps

**Phases:**
- Cold: < 33% heat
- Building: 33-48% heat
- Hot: 48-100% heat
- Peak: 100%+ heat (caution!)

**Usage:**
```typescript
import { MomentumScanner } from './analysis/momentum-scanner.js';

const scanner = new MomentumScanner();

// Feed trades as they come in
scanner.addTrade(tokenMint, {
  timestamp: Date.now(),
  type: 'buy',
  solAmount: 0.5,
  tokenAmount: 1000000,
  pricePerToken: 0.0000005,
  signature: 'sig...',
});

// Analyze momentum
const momentum = scanner.analyze(tokenMint);
// {
//   score: 72,
//   heatMetric: 55,
//   phase: 'hot',
//   recommendation: 'buy',
//   alerts: [{ type: 'heat', message: 'HOT: Heat at 55%' }]
// }
```

---

## MCP Server (Optional)

The Helius MCP server can be added for direct Claude access to blockchain data.

### Setup
```json
// %APPDATA%\Claude\claude_desktop_config.json
{
  "mcpServers": {
    "helius": {
      "command": "npx",
      "args": ["-y", "mcp-server-helius"],
      "env": {
        "HELIUS_API_KEY": "your-api-key"
      }
    }
  }
}
```

### Available Tools
- `get_balance` - Wallet SOL balance
- `get_token_accounts` - Token holdings
- `get_asset` - NFT/token metadata
- `get_transactions` - Transaction history
- `execute_swap` - Jupiter swap execution
</file>

<file path="src/api/geckoterminal.ts">
/**
 * GeckoTerminal API Client
 * https://www.geckoterminal.com/dex-api
 *
 * Free tier: 30 req/min
 * With CoinGecko Pro API key: 500 req/min
 */

import { createLogger } from '../lib/logger.js';
import type { TokenMetadata } from './dexscreener.js';

const logger = createLogger('gecko-terminal');

const BASE_URL = 'https://api.geckoterminal.com/api/v2';

// CoinGecko API key enables higher rate limits on GeckoTerminal
const COINGECKO_API_KEY = process.env.COIN_GECKO_api || process.env.COINGECKO_API_KEY;

interface GeckoPool {
  id: string;
  attributes: {
    base_token_price_usd: string;
    address: string;
    name: string;
    pool_created_at: string;
    volume_usd: {
      h1: string;
      h24: string;
    };
    price_change_percentage: {
      h1: string;
      h24: string;
    };
    reserve_in_usd: string; // Liquidity
    fdv_usd: string;
    transactions: {
      h1: {
        buys: number;
        sells: number;
      };
      h24: {
        buys: number;
        sells: number;
      };
    };
  };
  relationships: {
    base_token: {
      data: {
        id: string; // usually solana_ADDRESS
      };
    };
    quote_token: {
      data: {
        id: string;
      };
    };
  };
}

export class GeckoTerminalClient {
  /**
   * Get trending pools on Solana
   */
  async getTrendingPools(limit: number = 20): Promise<TokenMetadata[]> {
    try {
      // Build headers - add API key if available for higher rate limits
      const headers: Record<string, string> = {
        'Accept': 'application/json',
        'User-Agent': 'SchizoAgent/1.0'
      };

      // CoinGecko Pro API key unlocks higher rate limits (500 req/min vs 30)
      if (COINGECKO_API_KEY) {
        headers['x-cg-pro-api-key'] = COINGECKO_API_KEY;
        logger.debug('Using CoinGecko Pro API key for GeckoTerminal');
      }

      const response = await fetch(`${BASE_URL}/networks/solana/trending_pools`, {
        headers
      });

      if (!response.ok) {
        const text = await response.text();
        logger.warn({ 
            status: response.status, 
            statusText: response.statusText,
            responseBody: text.slice(0, 200) // Log first 200 chars of body
        }, 'Failed to fetch GeckoTerminal trending pools');
        return [];
      }

      const body = await response.json() as { data: GeckoPool[] };
      const pools = body.data || [];

      return pools.map(pool => this.poolToMetadata(pool));
    } catch (error) {
      logger.error({ error }, 'Error fetching GeckoTerminal trending pools');
      return [];
    }
  }

  /**
   * Get new pools on Solana (recently created)
   * Great for finding new opportunities
   */
  async getNewPools(limit: number = 20): Promise<TokenMetadata[]> {
    try {
      const headers: Record<string, string> = {
        'Accept': 'application/json',
        'User-Agent': 'SchizoAgent/1.0'
      };

      if (COINGECKO_API_KEY) {
        headers['x-cg-pro-api-key'] = COINGECKO_API_KEY;
      }

      const response = await fetch(`${BASE_URL}/networks/solana/new_pools?page=1`, {
        headers
      });

      if (!response.ok) {
        logger.warn({ status: response.status }, 'Failed to fetch GeckoTerminal new pools');
        return [];
      }

      const body = await response.json() as { data: GeckoPool[] };
      const pools = (body.data || []).slice(0, limit);

      logger.info({ count: pools.length }, 'Fetched new pools from GeckoTerminal');
      return pools.map(pool => this.poolToMetadata(pool));
    } catch (error) {
      logger.error({ error }, 'Error fetching GeckoTerminal new pools');
      return [];
    }
  }

  /**
   * Get top gainers on Solana (by price change)
   * Note: GeckoTerminal only supports volume/tx sorting, so we fetch trending and filter client-side
   */
  async getTopGainers(duration: '5m' | '1h' | '6h' | '24h' = '1h', limit: number = 20): Promise<TokenMetadata[]> {
    try {
      const headers: Record<string, string> = {
        'Accept': 'application/json',
        'User-Agent': 'SchizoAgent/1.0'
      };

      if (COINGECKO_API_KEY) {
        headers['x-cg-pro-api-key'] = COINGECKO_API_KEY;
      }

      // Fetch high-volume pools (most likely to have significant price moves)
      const response = await fetch(
        `${BASE_URL}/networks/solana/pools?page=1&sort=h24_volume_usd_desc`,
        { headers }
      );

      if (!response.ok) {
        logger.warn({ status: response.status }, 'Failed to fetch GeckoTerminal pools for gainers');
        return [];
      }

      const body = await response.json() as { data: GeckoPool[] };
      const pools = body.data || [];

      // Convert to metadata and filter for actual gainers
      const allTokens = pools.map(pool => this.poolToMetadata(pool));

      // Sort by price change (based on duration) and filter positive gains
      const priceChangeKey = duration === '24h' ? 'priceChange24h' : 'priceChange1h';
      const gainers = allTokens
        .filter(token => token[priceChangeKey] > 0)
        .sort((a, b) => b[priceChangeKey] - a[priceChangeKey])
        .slice(0, limit);

      logger.info({ count: gainers.length, duration }, 'Fetched top gainers from GeckoTerminal');
      return gainers;
    } catch (error) {
      logger.error({ error }, 'Error fetching GeckoTerminal top gainers');
      return [];
    }
  }

  /**
   * Search for pools by token address or name
   */
  async searchPools(query: string, limit: number = 10): Promise<TokenMetadata[]> {
    try {
      const headers: Record<string, string> = {
        'Accept': 'application/json',
        'User-Agent': 'SchizoAgent/1.0'
      };

      if (COINGECKO_API_KEY) {
        headers['x-cg-pro-api-key'] = COINGECKO_API_KEY;
      }

      const response = await fetch(
        `${BASE_URL}/search/pools?query=${encodeURIComponent(query)}&network=solana`,
        { headers }
      );

      if (!response.ok) {
        logger.warn({ status: response.status, query }, 'Failed to search GeckoTerminal pools');
        return [];
      }

      const body = await response.json() as { data: GeckoPool[] };
      const pools = (body.data || []).slice(0, limit);

      return pools.map(pool => this.poolToMetadata(pool));
    } catch (error) {
      logger.error({ error, query }, 'Error searching GeckoTerminal pools');
      return [];
    }
  }

  /**
   * Convert GeckoPool to TokenMetadata (compatible with our system)
   */
  private poolToMetadata(pool: GeckoPool): TokenMetadata {
    const attr = pool.attributes;
    // base_token id in relationships is usually "solana_MINTADDRESS"
    // We try to parse the mint from the pool data or base token data
    // The pool ID is usually "solana_POOLADDRESS"
    
    // We need the BASE TOKEN MINT. 
    // Usually Gecko API includes included resources for tokens, but we didn't fetch included=base_token.
    // However, for trading we need the mint. 
    // Let's rely on the fact that for most pairs, we can verify the mint later or assume the implementation.
    // Wait - GeckoTerminal doesn't always return the mint in the primary object easily without 'included'.
    // BUT! We can use the 'base_token.data.id'. It is often "solana_MINT".
    
    let mint = 'unknown';
    if (pool.relationships?.base_token?.data?.id) {
       mint = pool.relationships.base_token.data.id.replace('solana_', '');
    }

    const now = Date.now();
    const createdAt = attr.pool_created_at ? new Date(attr.pool_created_at).getTime() : undefined;
    const ageMinutes = createdAt ? Math.floor((now - createdAt) / 60000) : undefined;

    return {
      mint,
      name: attr.name.split(' / ')[0] || 'Unknown', // "BONK / SOL" -> "BONK"
      symbol: attr.name.split(' / ')[0] || 'Unknown',
      priceUsd: parseFloat(attr.base_token_price_usd) || 0,
      priceChange5m: 0, // Not available
      priceChange1h: parseFloat(attr.price_change_percentage?.h1 || '0'),
      priceChange24h: parseFloat(attr.price_change_percentage?.h24 || '0'),
      volume24h: parseFloat(attr.volume_usd?.h24 || '0'),
      volume1h: parseFloat(attr.volume_usd?.h1 || '0'),
      volume5m: 0, // GeckoTerminal doesn't provide 5m volume
      liquidity: parseFloat(attr.reserve_in_usd || '0'),
      marketCap: parseFloat(attr.fdv_usd || '0'), // Using FDV as proxy for MC
      fdv: parseFloat(attr.fdv_usd || '0'),
      buys5m: 0,
      sells5m: 0,
      buys1h: attr.transactions?.h1?.buys || 0,
      sells1h: attr.transactions?.h1?.sells || 0,
      pairAddress: pool.attributes.address,
      dexUrl: `https://www.geckoterminal.com/solana/pools/${pool.attributes.address}`,
      imageUrl: undefined, // Need 'included' to fetch images, skipping for now
      createdAt,
      ageMinutes,
    };
  }
}

export const geckoTerminal = new GeckoTerminalClient();
</file>

<file path="src/api/helius.ts">
/**
 * Helius API client using official helius-sdk.
 *
 * Features:
 * - Official SDK with built-in methods
 * - TTL-based response caching
 * - Circuit breaker for cascading failure protection
 * - @solana/web3.js Connection integration
 */

import { createHelius, type HeliusClient as SdkHeliusClient } from 'helius-sdk';
import CircuitBreaker from 'opossum';
import { Connection, PublicKey, type ConfirmedSignatureInfo } from '@solana/web3.js';
import { TTLCache } from './cache.js';
import { createLogger } from '../lib/logger.js';
import { GetAssetResponse } from '../analysis/types.js';

const logger = createLogger('helius');

/**
 * Helius subscription tiers for rate limit configuration
 */
type HeliusTier = 'free' | 'developer' | 'business' | 'professional';

/**
 * Configuration for HeliusClient.
 */
interface HeliusClientConfig {
  /** Helius API key */
  apiKey: string;
  /** Helius subscription tier (affects rate limits) */
  tier?: HeliusTier;
  /** Cache TTL in milliseconds (default: 30000 = 30 seconds) */
  cacheTTL?: number;
}

/**
 * Simplified transaction result structure.
 */
interface TransactionResult {
  /** Transaction signature (base58 encoded) */
  signature: string;
  /** Unix timestamp when transaction was processed */
  timestamp: number;
  /** Transaction type (e.g., 'TRANSFER', 'SWAP', 'UNKNOWN') */
  type: string;
  /** Whether the transaction succeeded */
  success: boolean;
  /** Fee paid in lamports */
  fee?: number;
  /** Block slot */
  slot?: number;
}

/**
 * Response from getTransactionsForAddress API.
 */
interface TransactionsResponse {
  data: TransactionResult[];
  paginationToken?: string;
}

/**
 * Options for getTransactionsForAddress.
 */
interface GetTransactionsOptions {
  /** Maximum transactions to return (1-100) */
  limit?: number;
  /** Pagination token for fetching next page */
  paginationToken?: string;
}

/**
 * Token holder information
 */
interface TokenHolder {
  owner: string;
  amount: number;
  uiAmount: number;
  percentage: number;
}

/**
 * Token holders response
 */
interface TokenHoldersResponse {
  holders: TokenHolder[];
  totalHolders: number;
  totalSupply: number;
}

/**
 * Token account from SDK
 */
interface TokenAccount {
  owner?: string;
  amount?: string;
}

/**
 * Helius API client using official SDK with resilience patterns.
 *
 * @example
 * const helius = new HeliusClient({
 *   apiKey: process.env.HELIUS_API_KEY!,
 *   tier: 'developer',
 *   cacheTTL: 30000
 * });
 *
 * const txs = await helius.getTransactionsForAddress('wallet-address');
 * const connection = helius.getConnection();
 */
class HeliusClient {
  private sdk: SdkHeliusClient;
  private apiKey: string;
  private cache: TTLCache<unknown>;
  private circuitBreaker: CircuitBreaker;
  private cacheHits = 0;
  private cacheMisses = 0;
  private _connection: Connection;

  constructor(config: HeliusClientConfig) {
    this.apiKey = config.apiKey;

    // Initialize official Helius SDK
    this.sdk = createHelius({ apiKey: config.apiKey });

    // Create connection with Helius RPC
    this._connection = new Connection(
      `https://mainnet.helius-rpc.com/?api-key=${config.apiKey}`,
      'confirmed'
    );

    // Initialize cache
    this.cache = new TTLCache<unknown>(config.cacheTTL ?? 30000);

    // Create circuit breaker for API calls
    this.circuitBreaker = new CircuitBreaker(
      async <T>(fn: () => Promise<T>) => fn(),
      {
        timeout: 15000, // 15s timeout per request
        errorThresholdPercentage: 50, // Open after 50% failures
        resetTimeout: 30000, // Try again after 30s
        volumeThreshold: 5, // Minimum calls before tripping
      }
    );

    // Wire circuit breaker events to logger
    this.circuitBreaker.on('open', () => {
      logger.error('Circuit breaker OPEN - Helius API appears down');
    });

    this.circuitBreaker.on('halfOpen', () => {
      logger.info('Circuit breaker HALF-OPEN - testing Helius API');
    });

    this.circuitBreaker.on('close', () => {
      logger.info('Circuit breaker CLOSED - Helius API recovered');
    });

    logger.info(
      {
        tier: config.tier ?? 'developer',
        cacheTTL: config.cacheTTL ?? 30000,
      },
      'HeliusClient initialized with official SDK'
    );
  }

  /**
   * Get the underlying Helius SDK instance for advanced operations.
   */
  getSdk(): SdkHeliusClient {
    return this.sdk;
  }

  /**
   * Get transactions for a wallet address using SDK.
   */
  async getTransactionsForAddress(
    address: string,
    options?: GetTransactionsOptions
  ): Promise<TransactionsResponse> {
    const limit = options?.limit ?? 100;
    const cacheKey = `txs:${address}:${limit}`;

    // Check cache first (skip for pagination requests)
    if (!options?.paginationToken) {
      const cached = this.cache.get(cacheKey) as TransactionsResponse | undefined;
      if (cached) {
        this.cacheHits++;
        logger.debug({ address, cacheHit: true }, 'Cache hit for transactions');
        return cached;
      }
    }

    this.cacheMisses++;

    // Execute via circuit breaker using SDK
    const result = await this.circuitBreaker.fire(async () => {
      // Use getTransactionsForAddress from SDK if available, otherwise use Connection
      const response = await this._connection.getSignaturesForAddress(
        new PublicKey(address),
        { limit }
      );

      // Map response to our format
      const data: TransactionResult[] = response.map((sig: ConfirmedSignatureInfo) => ({
        signature: sig.signature,
        timestamp: sig.blockTime ? sig.blockTime * 1000 : Date.now(),
        type: 'UNKNOWN', // Would need parsing for type
        success: sig.err === null,
        slot: sig.slot,
      }));

      return { data };
    }) as TransactionsResponse;

    // Cache result (skip for paginated requests)
    if (!options?.paginationToken && result.data && result.data.length > 0) {
      this.cache.set(cacheKey, result);
    }

    return result;
  }

  /**
   * Get token metadata using Helius DAS API via SDK.
   */
  async getAsset(mintAddress: string): Promise<GetAssetResponse> {
    const cacheKey = `asset:${mintAddress}`;

    const cached = this.cache.get(cacheKey) as GetAssetResponse | undefined;
    if (cached) {
      this.cacheHits++;
      return cached;
    }

    this.cacheMisses++;

    const result = await this.circuitBreaker.fire(async () => {
      const asset = await this.sdk.getAsset({ id: mintAddress });

      logger.debug({ mintAddress }, 'Successfully fetched asset metadata via SDK');
      return asset as unknown as GetAssetResponse;
    }) as GetAssetResponse;

    this.cache.set(cacheKey, result);
    return result;
  }

  /**
   * Get multiple assets in batch using SDK.
   */
  async getAssetBatch(mintAddresses: string[]): Promise<GetAssetResponse[]> {
    return this.circuitBreaker.fire(async () => {
      const assets = await this.sdk.getAssetBatch({ ids: mintAddresses });
      return assets as unknown as GetAssetResponse[];
    }) as Promise<GetAssetResponse[]>;
  }

  /**
   * Get a Solana Connection using Helius RPC.
   */
  getConnection(): Connection {
    return this._connection;
  }

  /**
   * Get cache statistics.
   */
  getCacheStats(): {
    size: number;
    hits: number;
    misses: number;
    hitRate: number;
  } {
    const cacheStats = this.cache.getStats();
    const total = this.cacheHits + this.cacheMisses;
    return {
      size: cacheStats.size,
      hits: this.cacheHits,
      misses: this.cacheMisses,
      hitRate: total > 0 ? this.cacheHits / total : 0,
    };
  }

  /**
   * Clear the cache.
   */
  clearCache(): void {
    this.cache.clear();
    this.cacheHits = 0;
    this.cacheMisses = 0;
    logger.info('Cache cleared');
  }

  /**
   * Get token holders using Helius DAS API.
   */
  async getTokenHolders(
    mintAddress: string,
    limit: number = 20
  ): Promise<TokenHoldersResponse> {
    const cacheKey = `holders:${mintAddress}:${limit}`;

    const cached = this.cache.get(cacheKey) as TokenHoldersResponse | undefined;
    if (cached) {
      this.cacheHits++;
      return cached;
    }

    this.cacheMisses++;

    const result = await this.circuitBreaker.fire(async () => {
      // Use SDK's getTokenAccounts method
      const response = await this.sdk.getTokenAccounts({
        mint: mintAddress,
        limit,
        options: { showZeroBalance: false },
      });

      const accounts = (response as { token_accounts?: TokenAccount[]; total?: number }).token_accounts || [];
      const totalHolders = (response as { total?: number }).total || accounts.length;

      // Calculate total supply from holder amounts
      let totalSupply = 0;
      for (const account of accounts) {
        totalSupply += parseFloat(account.amount || '0');
      }

      // Map to TokenHolder with percentages
      const holders: TokenHolder[] = accounts.map((account: TokenAccount) => {
        const amount = parseFloat(account.amount || '0');
        return {
          owner: account.owner || '',
          amount,
          uiAmount: amount / 1e6, // Assuming 6 decimals (common for pump.fun)
          percentage: totalSupply > 0 ? (amount / totalSupply) * 100 : 0,
        };
      });

      // Sort by amount descending
      holders.sort((a, b) => b.amount - a.amount);

      logger.debug({ mintAddress, holderCount: holders.length }, 'Fetched token holders via SDK');

      return {
        holders,
        totalHolders,
        totalSupply,
      };
    }) as TokenHoldersResponse;

    this.cache.set(cacheKey, result);
    return result;
  }

  /**
   * Check if a token is a Pump.fun Mayhem Mode token
   * Mayhem Mode tokens have 2 billion supply (vs 1 billion for regular pump.fun)
   */
  async isMayhemModeToken(mintAddress: string): Promise<boolean> {
    try {
      const response = await this.getConnection().getTokenSupply(
        new PublicKey(mintAddress)
      );

      const supply = response.value.uiAmount;

      // Mayhem Mode tokens have exactly 2 billion supply
      const isMayhem = supply !== null && supply >= 1_999_999_999 && supply <= 2_000_000_001;

      if (isMayhem) {
        logger.warn(
          {
            mintAddress,
            supply,
          },
          'Mayhem Mode token detected (2B supply)'
        );
      }

      return isMayhem;
    } catch (error) {
      logger.debug({ mintAddress, error }, 'Failed to check token supply for Mayhem Mode');
      return false;
    }
  }

  /**
   * Get priority fee estimate using SDK.
   */
  async getPriorityFeeEstimate(accountKeys?: string[]): Promise<{
    min: number;
    low: number;
    medium: number;
    high: number;
    veryHigh: number;
  }> {
    const result = await this.circuitBreaker.fire(async () => {
      const estimate = await this.sdk.getPriorityFeeEstimate({
        accountKeys: accountKeys || [],
        options: { recommended: true },
      });
      return estimate;
    }) as { priorityFeeEstimate?: number; priorityFeeLevels?: Record<string, number> };

    // Map SDK response to our format
    const base = result.priorityFeeEstimate || 1000;
    return {
      min: Math.floor(base * 0.5),
      low: Math.floor(base * 0.75),
      medium: base,
      high: Math.floor(base * 1.5),
      veryHigh: Math.floor(base * 2),
    };
  }

  /**
   * Get circuit breaker status.
   */
  getCircuitBreakerStatus(): {
    state: string;
    stats: {
      fires: number;
      failures: number;
      fallbacks: number;
      successes: number;
      rejects: number;
      timeouts: number;
    };
  } {
    return {
      state: this.circuitBreaker.opened
        ? 'OPEN'
        : this.circuitBreaker.halfOpen
          ? 'HALF-OPEN'
          : 'CLOSED',
      stats: {
        fires: this.circuitBreaker.stats.fires,
        failures: this.circuitBreaker.stats.failures,
        fallbacks: this.circuitBreaker.stats.fallbacks,
        successes: this.circuitBreaker.stats.successes,
        rejects: this.circuitBreaker.stats.rejects,
        timeouts: this.circuitBreaker.stats.timeouts,
      },
    };
  }

  /**
   * Get all token assets owned by a wallet using Helius DAS API.
   * More efficient than RPC getParsedTokenAccountsByOwner.
   */
  async getAssetsByOwner(ownerAddress: string): Promise<Array<{ mint: string; balance: number }>> {
    return this.circuitBreaker.fire(async () => {
      const response = await this.sdk.rpc.getAssetsByOwner({
        ownerAddress,
        page: 1,
        limit: 1000,
        displayOptions: {
          showFungible: true,
        },
      });

      // Filter for fungible tokens and map to simple format
      const tokens = (response.items || [])
        .filter((asset: any) => 
          (asset.interface === 'FungibleToken' || asset.interface === 'FungibleAsset') &&
          asset.token_info?.balance
        )
        .map((asset: any) => ({
          mint: asset.id,
          balance: parseFloat(asset.token_info.balance) / Math.pow(10, asset.token_info.decimals || 6),
        }))
        .filter((token: any) => token.balance > 0);

      logger.info({ ownerAddress, tokenCount: tokens.length, tokens: tokens.slice(0, 3) }, 'Fetched wallet tokens via DAS API');
      return tokens;
    }) as Promise<Array<{ mint: string; balance: number }>>;
  }
}

export {
  HeliusClient,
  HeliusClientConfig,
  HeliusTier,
  TransactionResult,
  TransactionsResponse,
  GetTransactionsOptions,
  TokenHolder,
  TokenHoldersResponse,
};
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>$SCHIZO - Paranoid AI Trader</title>
    <link rel="icon" type="image/png" href="schizo-favicon.png">
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <header>
        <div class="scanlines"></div>
        <div class="header-grid">
            <!-- Left: 3D Character -->
            <div class="header-left">
                <div id="schizo-3d-container">
                    <div id="schizo-3d-canvas"></div>
                </div>
            </div>

            <!-- Center: Logo & Title -->
            <div class="header-center">
                <div class="logo-container">
                    <img src="schizo-logo.png" alt="$SCHIZO Logo" class="header-logo" id="hero-logo">
                </div>
                <h1 class="glitch" data-text="$SCHIZO">$SCHIZO</h1>
                <p class="tagline">Paranoid AI Trading Agent</p>
            </div>

            <!-- Right: Token Card -->
            <div class="header-right">
                <div id="schizo-token-card">
                    <div class="token-card-header">
                        <img src="schizo-logo.png" alt="$SCHIZO" class="token-card-img">
                        <div class="token-card-title">
                            <span class="token-card-name">$SCHIZO</span>
                            <span class="token-card-status">Coming Soon</span>
                        </div>
                    </div>
                    <div class="token-card-stats">
                        <div class="token-card-stat">
                            <span class="stat-label">Price</span>
                            <span class="stat-value" id="schizo-price">--</span>
                        </div>
                        <div class="token-card-stat">
                            <span class="stat-label">M.Cap</span>
                            <span class="stat-value" id="schizo-mcap">--</span>
                        </div>
                    </div>
                    <div class="token-card-actions">
                        <a href="#" class="btn-primary" title="Buy on PUMP/DEX">BUY $SCHIZO</a>
                        <div class="secondary-actions">
                            <a href="#" class="btn-icon" title="Twitter"><svg width="18" height="18" viewBox="0 0 24 24"
                                    fill="currentColor">
                                    <path
                                        d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
                                </svg></a>
                        </div>
                    </div>
                    <div class="token-card-footer">
                        <div class="ca-input-container">
                            <input type="text" id="schizo-ca-input" value="CA: TBA" readonly>
                            <span class="copy-hint">CLICK TO COPY</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <main>
        <section id="stats">
            <div class="stat">
                <label>Status</label>
                <span id="status" class="status-disconnected">Disconnected</span>
            </div>
            <div class="stat">
                <label>Balance</label>
                <span id="balance">-- SOL</span>
            </div>
            <div class="stat">
                <label>Win Rate</label>
                <span id="winRate">0%</span>
            </div>
            <div class="stat">
                <label>Total P&L</label>
                <span id="pnl">0 SOL</span>
            </div>
            <div class="stat">
                <label>Buybacks</label>
                <span id="buybacks">0</span>
            </div>
        </section>

        <div id="main-panels">
            <section id="token-stream-section">
                <div id="token-stream-box">
                    <div class="panel-header">
                        <div class="panel-tabs">
                            <button class="panel-tab active" data-tab="holdings">Holdings <span
                                    id="holdings-count">(0)</span></button>
                        </div>
                        <button id="pauseTokensBtn">Pause</button>
                    </div>
                    <div id="holdings-stream" class="tab-content active"></div>
                </div>
            </section>

            <section id="feed-container">
                <div id="feed-box">
                    <div class="panel-header">
                        <span>Live Feed</span>
                        <button id="pauseBtn">Pause</button>
                    </div>
                    <div id="feed"></div>
                </div>
            </section>

            <section id="chat-container">
                <div id="chat-box">
                    <div id="chat-header">Chat with $SCHIZO</div>
                    <div id="chat-messages"></div>
                    <div id="chat-input-area">
                        <div class="chat-input-row">
                            <input type="text" id="usernameInput" placeholder="Name" maxlength="15" value="anon"
                                title="Your username">
                        </div>
                        <input type="text" id="chatInput" placeholder="Ask $SCHIZO anything..." maxlength="500">
                        <button id="sendBtn">Send</button>
                    </div>
                </div>
            </section>
        </div>

        <section id="trades-container">
            <h2>Recent Trades</h2>
            <table id="trades">
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Type</th>
                        <th>Token</th>
                        <th>Amount</th>
                        <th>Signature</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </section>
    </main>

    <!-- Chart Popup -->
    <div id="chart-popup" class="popup-overlay" onclick="closeChart()">
        <div class="popup-content" onclick="event.stopPropagation()">
            <button class="popup-close" onclick="closeChart()">‚úï</button>
            <iframe id="chart-iframe" src="" frameborder="0"></iframe>
        </div>
    </div>

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script src="trench-radio.js"></script>
    <script src="app.js"></script>
    <script type="module" src="schizo-3d.js"></script>

    <!-- Fixed About Button - Bottom Right -->
    <a href="/about.html" class="about-btn-fixed" title="How It Works">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10" />
            <path d="M12 16v-4M12 8h.01" />
        </svg>
        <span>About</span>
    </a>

    <!-- Trench Radio Controls - Bottom Left -->
    <div id="trench-radio-controls" class="trench-radio-panel">
        <div class="trench-radio-header">
            <span class="trench-radio-title">TRENCH RADIO</span>
            <span id="trench-radio-state" class="trench-radio-state">OFF</span>
        </div>
        <div class="trench-radio-body">
            <button id="trench-radio-toggle" class="trench-radio-btn">
                <svg id="radio-icon-off" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                    <line x1="23" y1="9" x2="17" y2="15"></line>
                    <line x1="17" y1="9" x2="23" y2="15"></line>
                </svg>
                <svg id="radio-icon-on" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2" style="display:none;">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                    <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                </svg>
            </button>
            <input type="range" id="trench-radio-volume" min="0" max="100" value="50" class="trench-radio-slider">
        </div>
    </div>

</body>

</html>
</file>

<file path="public/trench-radio.js">
/**
 * Trench Radio - Dynamic Audio Environment
 *
 * Audio states based on trading activity:
 * - SCANNING: Low-fi ambient (Synthesis)
 * - POSITION_UP: High-energy Phonk Playlist
 * - POSITION_DOWN: Sad/Slow Playlist
 * - CRASH: Dial-up sound (Synthesis)
 */

class TrenchRadio {
  constructor() {
    this.audioContext = null;
    this.masterGain = null;
    this.currentState = 'SCANNING';
    this.isEnabled = false;
    this.volume = 0.5;

    // Audio nodes for effects (Synthesis)
    this.lowPassFilter = null;
    this.highPassFilter = null;
    this.distortion = null;
    this.convolver = null;
    this.compressor = null;
    this.oscillators = [];
    this.noiseNode = null;

    // State tracking
    this.positionPnL = 0;
    this.hasActivePosition = false;
    this.crashTimeout = null;
    this.isAudioPlaying = false;
    
    // File Playback
    this.audioElement = new Audio();
    this.audioElement.loop = false;
    this.audioElement.volume = this.volume;
    this.currentSource = 'SYNTH'; // 'SYNTH' or 'FILE'

    this.playlists = {
        'POSITION_UP': [
            'audio/pumping_1.mp3',
            'audio/pumping_2.mp3', 
            'audio/pumping_3.mp3'
        ],
        'POSITION_DOWN': [
            'audio/dumping_1.mp3',
            'audio/dumping_2.mp3',
            'audio/dumping_3.mp3'
        ]
    };
    this.currentPlaylistIndex = 0;

    this.audioElement.addEventListener('ended', () => {
        this.playNextInPlaylist();
    });
  }

  async init() {
    if (this.audioContext) return;

    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

      // Create master gain
      this.masterGain = this.audioContext.createGain();
      this.masterGain.gain.value = this.volume;
      this.masterGain.connect(this.audioContext.destination);

      // Create compressor
      this.compressor = this.audioContext.createDynamicsCompressor();
      this.compressor.connect(this.masterGain);

      // Create filters
      this.lowPassFilter = this.audioContext.createBiquadFilter();
      this.lowPassFilter.type = 'lowpass';
      this.lowPassFilter.connect(this.compressor);

      this.highPassFilter = this.audioContext.createBiquadFilter();
      this.highPassFilter.type = 'highpass';
      this.highPassFilter.connect(this.lowPassFilter);

      // Create distortion
      this.distortion = this.audioContext.createWaveShaper();
      this.distortion.curve = this.makeDistortionCurve(0);
      this.distortion.connect(this.highPassFilter);

      // Create convolver
      this.convolver = this.audioContext.createConvolver();
      this.convolver.buffer = await this.createReverbImpulse(2, 2);

      // Effect mix
      this.reverbGain = this.audioContext.createGain();
      this.reverbGain.gain.value = 0;
      this.convolver.connect(this.reverbGain);
      this.reverbGain.connect(this.lowPassFilter);

      this.dryGain = this.audioContext.createGain();
      this.dryGain.gain.value = 1;
      this.dryGain.connect(this.distortion);

      console.log('Trench Radio initialized');

      if (this.isEnabled) {
        this.setState(this.currentState);
      }
    } catch (error) {
      console.error('Failed to initialize Trench Radio:', error);
    }
  }

  makeDistortionCurve(amount) {
    const k = typeof amount === 'number' ? amount : 50;
    const n_samples = 44100;
    const curve = new Float32Array(n_samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < n_samples; i++) {
      const x = (i * 2) / n_samples - 1;
      curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
    }
    return curve;
  }

  async createReverbImpulse(duration, decay) {
    const sampleRate = this.audioContext.sampleRate;
    const length = sampleRate * duration;
    const impulse = this.audioContext.createBuffer(2, length, sampleRate);
    for (let channel = 0; channel < 2; channel++) {
      const channelData = impulse.getChannelData(channel);
      for (let i = 0; i < length; i++) {
        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
      }
    }
    return impulse;
  }

  async toggle() {
    this.isEnabled = !this.isEnabled;
    
    if (this.isEnabled) {
      // Ensure AudioContext is ready and running
      if (!this.audioContext) {
        await this.init();
      }
      
      if (this.audioContext && this.audioContext.state === 'suspended') {
        await this.audioContext.resume();
      }

      this.setState(this.currentState);

      // Try to play if file source is active
      if (this.currentSource === 'FILE' && this.audioElement.paused) {
          this.audioElement.play().catch(e => console.error('Play failed', e));
      }
    } else {
      this.stopAllAudio();
    }
    return this.isEnabled;
  }

  setVolume(vol) {
    this.volume = Math.max(0, Math.min(1, vol));
    if (this.masterGain) {
      this.masterGain.gain.setTargetAtTime(this.volume, this.audioContext.currentTime || 0, 0.1);
    }
    if (this.audioElement) {
        this.audioElement.volume = this.volume;
    }
  }

  stopAllAudio() {
    // Stop Synthesis
    this.oscillators.forEach(osc => {
      try { osc.stop(); } catch (e) {}
    });
    this.oscillators = [];
    if (this.noiseNode) {
      try { this.noiseNode.stop(); } catch (e) {}
      this.noiseNode = null;
    }

    // Stop File
    if (this.audioElement) {
        this.audioElement.pause();
    }

    this.isAudioPlaying = false;
  }

  setState(state) {
    // Only skip if state is the same AND audio is already playing
    if (this.currentState === state && this.isAudioPlaying) return;

    const prevState = this.currentState;
    this.currentState = state;
    console.log(`Trench Radio: ${prevState} -> ${state}`);

    if (this.crashTimeout) {
      clearTimeout(this.crashTimeout);
      this.crashTimeout = null;
    }

    if (!this.isEnabled) {
      this.isAudioPlaying = false;
      return;
    }

    this.stopAllAudio();
    this.isAudioPlaying = true;

    switch (state) {
      case 'SCANNING':
        this.currentSource = 'SYNTH';
        this.playScanningAmbient();
        break;
      case 'POSITION_UP':
        this.currentSource = 'FILE';
        this.currentPlaylistIndex = 0; // Reset to start of playlist
        this.playPlaylist(state);
        break;
      case 'POSITION_DOWN':
        this.currentSource = 'FILE';
        this.currentPlaylistIndex = 0;
        this.playPlaylist(state);
        break;
      case 'CRASH':
        this.currentSource = 'SYNTH';
        this.playCrash();
        break;
    }
  }
  
  // --- PLAYLIST LOGIC ---
  
  playPlaylist(state) {
      const playlist = this.playlists[state];
      if (!playlist || playlist.length === 0) return;
      
      const file = playlist[this.currentPlaylistIndex];
      this.audioElement.src = file;
      this.audioElement.play().catch(err => {
          console.warn('Playback failed:', err);
          // Fallback to next track if file missing?
      });
  }
  
  playNextInPlaylist() {
      if (this.currentSource !== 'FILE') return;
      const playlist = this.playlists[this.currentState];
      if (!playlist) return;
      
      this.currentPlaylistIndex = (this.currentPlaylistIndex + 1) % playlist.length;
      this.playPlaylist(this.currentState);
  }

  // --- SYNTHESIS METHODS ---

  playScanningAmbient() {
    if (!this.audioContext) return;
    // Simple Lofi Synth setup
    this.lowPassFilter.frequency.setTargetAtTime(2500, this.audioContext.currentTime, 0.5);
    this.reverbGain.gain.setTargetAtTime(0.25, this.audioContext.currentTime, 0.5);
    
    this.noiseNode = this.createVinylCrackle();
    
    // Start procedural beat
    this.playLofiBeat(75);
    this.playLofiChords(75);
  }

  createVinylCrackle() {
      // Simplified crackle
      const bufferSize = 2 * this.audioContext.sampleRate;
      const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
          output[i] = (Math.random() * 2 - 1) * 0.02;
          if (Math.random() < 0.0003) output[i] = (Math.random() * 2 - 1) * 0.3;
      }
      const noise = this.audioContext.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = true;
      const vinylGain = this.audioContext.createGain();
      vinylGain.gain.value = 0.15;
      noise.connect(vinylGain);
      vinylGain.connect(this.dryGain);
      noise.start();
      return noise;
  }
  
  playLofiBeat(bpm) {
      // Recursive beat scheduler
      const beatLength = 60 / bpm;
      let beat = 0;
      const playBeat = () => {
          if (this.currentState !== 'SCANNING' || !this.isEnabled) return;
          const time = this.audioContext.currentTime;
          
          if (beat % 4 === 0 || beat % 4 === 2.5) this.playLofiKick(time);
          if (beat % 4 === 1 || beat % 4 === 3) this.playLofiSnare(time + Math.random()*0.02);
          this.playLofiHat(time, beat % 2 === 1 ? 0.06 : 0.03);
          
          beat = (beat + 0.5) % 8;
          setTimeout(playBeat, (beatLength / 2) * 1000);
      };
      playBeat();
  }
  
  playLofiKick(time) {
      const osc = this.audioContext.createOscillator();
      const gain = this.audioContext.createGain();
      osc.frequency.setValueAtTime(100, time);
      osc.frequency.exponentialRampToValueAtTime(40, time + 0.15);
      gain.gain.setValueAtTime(0.4, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.25);
      const filter = this.audioContext.createBiquadFilter();
      filter.type = 'lowpass'; filter.frequency.value = 200;
      osc.connect(filter); filter.connect(gain); gain.connect(this.dryGain);
      osc.start(time); osc.stop(time + 0.25);
  }
  
  playLofiSnare(time) {
      // Noise burst
      const bufSize = this.audioContext.sampleRate * 0.15;
      const buf = this.audioContext.createBuffer(1, bufSize, this.audioContext.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0; i<bufSize; i++) data[i] = Math.random()*2-1;
      const noise = this.audioContext.createBufferSource();
      noise.buffer = buf;
      const filter = this.audioContext.createBiquadFilter();
      filter.type = 'bandpass'; filter.frequency.value = 1200;
      const gain = this.audioContext.createGain();
      gain.gain.setValueAtTime(0.12, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.12);
      noise.connect(filter); filter.connect(gain); gain.connect(this.dryGain); gain.connect(this.convolver);
      noise.start(time);
  }
  
  playLofiHat(time, vol) {
      const bufSize = this.audioContext.sampleRate * 0.05;
      const buf = this.audioContext.createBuffer(1, bufSize, this.audioContext.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0; i<bufSize; i++) data[i] = Math.random()*2-1;
      const noise = this.audioContext.createBufferSource();
      noise.buffer = buf;
      const filter = this.audioContext.createBiquadFilter();
      filter.type = 'highpass'; filter.frequency.value = 6000;
      const gain = this.audioContext.createGain();
      gain.gain.setValueAtTime(vol, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.04);
      noise.connect(filter); filter.connect(gain); gain.connect(this.dryGain);
      noise.start(time);
  }
  
  playLofiChords(bpm) {
      const bar = (60/bpm)*4;
      const chords = [
          [146.83, 174.61, 220, 261.63],
          [196, 246.94, 293.66, 349.23],
          [130.81, 164.81, 196, 246.94],
          [220, 261.63, 329.63, 392]
      ];
      let idx = 0;
      const play = () => {
          if (this.currentState !== 'SCANNING' || !this.isEnabled) return;
          const time = this.audioContext.currentTime;
          chords[idx].forEach((freq, i) => this.playLofiNote(freq, time + i*0.03, bar*0.9));
          idx = (idx+1)%chords.length;
          setTimeout(play, bar*1000);
      };
      setTimeout(play, (60/bpm)*1000);
  }
  
  playLofiNote(freq, time, dur) {
      const osc = this.audioContext.createOscillator(); osc.type = 'triangle'; osc.frequency.value = freq;
      const osc2 = this.audioContext.createOscillator(); osc2.type = 'triangle'; osc2.frequency.value = freq*1.002;
      const gain = this.audioContext.createGain();
      gain.gain.setValueAtTime(0, time);
      gain.gain.linearRampToValueAtTime(0.08, time+0.05);
      gain.gain.exponentialRampToValueAtTime(0.001, time+dur);
      const filter = this.audioContext.createBiquadFilter();
      filter.type = 'lowpass'; filter.frequency.value = 1500;
      osc.connect(filter); osc2.connect(filter); filter.connect(gain);
      gain.connect(this.dryGain); gain.connect(this.convolver);
      osc.start(time); osc.stop(time+dur); osc2.start(time); osc2.stop(time+dur);
  }

  playCrash() {
    if (!this.audioContext) return;
    // Dial-up logic
    const time = this.audioContext.currentTime;
    const carrier = this.audioContext.createOscillator();
    carrier.type = 'sine'; carrier.frequency.value = 1070;
    const mod = this.audioContext.createOscillator();
    mod.type = 'sine'; mod.frequency.value = 400;
    const modGain = this.audioContext.createGain();
    modGain.gain.value = 500;
    mod.connect(modGain); modGain.connect(carrier.frequency);
    const mainGain = this.audioContext.createGain();
    mainGain.gain.setValueAtTime(0.3, time);
    carrier.connect(mainGain); mainGain.connect(this.masterGain);
    carrier.start(time); mod.start(time);
    carrier.stop(time+3); mod.stop(time+3);
    this.oscillators.push(carrier, mod);
    
    this.crashTimeout = setTimeout(() => {
        this.stopAllAudio();
        this.crashTimeout = setTimeout(() => {
            if (this.isEnabled && this.currentState === 'CRASH') this.setState('SCANNING');
        }, 5000);
    }, 3000);
  }
  
  updatePositionPnL(pnl, hasPosition) {
    this.positionPnL = pnl;
    this.hasActivePosition = hasPosition;
  }
  
  initTrenchRadio() {
      const toggleBtn = document.getElementById('trench-radio-toggle');
      const volumeSlider = document.getElementById('trench-radio-volume');
      const stateEl = document.getElementById('trench-radio-state');
      const panel = document.getElementById('trench-radio-controls');
      const iconOff = document.getElementById('radio-icon-off');
      const iconOn = document.getElementById('radio-icon-on');

      if (!toggleBtn || !volumeSlider) return;

      toggleBtn.addEventListener('click', async () => {
          const isEnabled = await this.toggle();
          toggleBtn.classList.toggle('active', isEnabled);
          panel.classList.toggle('active', isEnabled);
          iconOff.style.display = isEnabled ? 'none' : 'block';
          iconOn.style.display = isEnabled ? 'block' : 'none';

          if (isEnabled) {
              stateEl.textContent = this.currentState;
              stateEl.classList.add('scanning');
          } else {
              stateEl.textContent = 'OFF';
              stateEl.classList.remove('scanning', 'position-up', 'position-down', 'crash');
          }
      });

      volumeSlider.addEventListener('input', (e) => {
          this.setVolume(parseInt(e.target.value) / 100);
      });
      this.setVolume(parseInt(volumeSlider.value) / 100);
  }
}

document.addEventListener('DOMContentLoaded', () => {
    window.trenchRadio = new TrenchRadio();
    window.trenchRadio.initTrenchRadio();
});
</file>

<file path="src/trading/pumpportal-client.ts">
/**
 * PumpPortal API client for trade execution
 */

import { Keypair, Connection, Transaction, VersionedTransaction } from '@solana/web3.js';
import type { TokenInfo, TradeParams, TradeResult, TradeAction } from './types.js';
import { logger } from '../lib/logger.js';

/**
 * Configuration for PumpPortal client
 */
export interface PumpPortalConfig {
  apiKey?: string;
  baseUrl: string;
  rpcUrl: string;
  maxRetries: number;
  retryDelayMs: number;
}

/**
 * PumpPortal API response for trade
 */
interface TradeResponse {
  signature?: string;
  error?: string;
}

/**
 * PumpPortal API client
 */
export class PumpPortalClient {
  private config: PumpPortalConfig;
  private wallet: Keypair;
  private connection: Connection;
  private lastRequestTime = 0;
  private readonly MIN_REQUEST_DELAY_MS = 100; // Rate limiting: 100ms between requests
  private cachedPriorityFee: number = 0.0005; // Default 0.0005 SOL
  private lastPriorityFeeCheck: number = 0;
  private readonly PRIORITY_FEE_CACHE_MS = 30000; // Cache for 30 seconds

  constructor(config: PumpPortalConfig, wallet: Keypair) {
    this.config = config;
    this.wallet = wallet;
    this.connection = new Connection(config.rpcUrl, 'confirmed');

    logger.info({
      baseUrl: config.baseUrl,
      wallet: wallet.publicKey.toBase58(),
    }, 'PumpPortal client initialized');
  }

  /**
   * Get dynamic priority fee based on recent network activity
   * Uses getRecentPrioritizationFees to estimate appropriate fee
   */
  private async getDynamicPriorityFee(isUrgent: boolean = false): Promise<number> {
    const now = Date.now();

    // Return cached value if fresh
    if (now - this.lastPriorityFeeCheck < this.PRIORITY_FEE_CACHE_MS) {
      const fee = isUrgent ? this.cachedPriorityFee * 2 : this.cachedPriorityFee;
      return Math.min(fee, 0.01); // Cap at 0.01 SOL max
    }

    try {
      // Get recent priority fees from the network
      const recentFees = await this.connection.getRecentPrioritizationFees();

      if (recentFees.length === 0) {
        return this.cachedPriorityFee;
      }

      // Calculate median of non-zero fees
      const nonZeroFees = recentFees
        .map(f => f.prioritizationFee)
        .filter(f => f > 0)
        .sort((a, b) => a - b);

      if (nonZeroFees.length === 0) {
        // Network is quiet, use minimum fee
        this.cachedPriorityFee = 0.0001; // 0.0001 SOL (100 lamports per CU)
      } else {
        // Use 75th percentile for reliability
        const p75Index = Math.floor(nonZeroFees.length * 0.75);
        const p75Fee = nonZeroFees[p75Index] || nonZeroFees[nonZeroFees.length - 1];

        // Convert from microlamports per CU to SOL (assuming ~200k CU per tx)
        // microlamports per CU * 200000 CU / 1e12 = SOL
        this.cachedPriorityFee = Math.max(0.0001, Math.min(0.005, (p75Fee * 200000) / 1e12));
      }

      this.lastPriorityFeeCheck = now;

      logger.debug({
        priorityFee: this.cachedPriorityFee,
        sampleSize: recentFees.length,
      }, 'Dynamic priority fee calculated');

      const fee = isUrgent ? this.cachedPriorityFee * 2 : this.cachedPriorityFee;
      return Math.min(fee, 0.01); // Cap at 0.01 SOL max
    } catch (error) {
      logger.warn({ error }, 'Failed to get dynamic priority fee, using cached value');
      return this.cachedPriorityFee;
    }
  }

  /**
   * Execute a buy order
   */
  async buy(params: TradeParams): Promise<string> {
    return this.executeTrade('buy', params);
  }

  /**
   * Execute a sell order
   */
  async sell(params: TradeParams): Promise<string> {
    return this.executeTrade('sell', params);
  }

  /**
   * Get token information
   */
  async getTokenInfo(mint: string): Promise<TokenInfo> {
    this.validateMint(mint);
    await this.enforceRateLimit();

    const url = `${this.config.baseUrl}/token/${mint}`;
    
    logger.debug({ mint }, 'Fetching token info');

    try {
      const headers: Record<string, string> = {};
      if (this.config.apiKey) {
        headers['Authorization'] = `Bearer ${this.config.apiKey}`;
      }

      const response = await fetch(url, { headers });

      if (!response.ok) {
        throw new Error(`PumpPortal API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      return {
        mint: data.mint,
        name: data.name,
        symbol: data.symbol,
        price: data.price,
        liquidity: data.liquidity,
        holderCount: data.holder_count,
      };
    } catch (error) {
      logger.error({ mint, error }, 'Failed to fetch token info');
      throw error;
    }
  }

  /**
   * Get claimable creator fees
   * Note: pump.fun claims all creator fees at once, not per-token
   *
   * @returns Claimable fee amount in SOL (estimated from recent activity)
   */
  async getClaimableFees(): Promise<number> {
    await this.enforceRateLimit();
    logger.debug('Checking claimable creator fees');

    // Note: PumpPortal doesn't have a dedicated endpoint to check claimable fees
    // The actual claimable amount is determined on-chain when claiming
    // This method returns 0 as a placeholder - use claimFees() to attempt claiming
    logger.warn('getClaimableFees: No dedicated endpoint - use claimFees() to claim and see result');
    return 0;
  }

  /**
   * Claim all creator fees from pump.fun
   * Note: pump.fun claims ALL creator fees at once (not per-token)
   *
   * @param pool - Pool to claim from: 'pump' (default) or 'meteora-dbc'
   * @returns Transaction signature if successful
   */
  async claimFees(pool: 'pump' | 'meteora-dbc' = 'pump'): Promise<string> {
    await this.enforceRateLimit();
    logger.info({ pool }, 'Claiming creator fees');

    const url = `${this.config.baseUrl}/trade-local`;

    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };
    if (this.config.apiKey) {
      headers['Authorization'] = `Bearer ${this.config.apiKey}`;
    }

    const payload = {
      publicKey: this.wallet.publicKey.toBase58(),
      action: 'collectCreatorFee',
      pool,
    };

    logger.debug({ payload }, 'Requesting fee claim transaction from PumpPortal');

    try {
      const response = await fetch(url, {
        method: 'POST',
        headers,
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`PumpPortal API error: ${response.status} ${errorText}`);
      }

      const arrayBuffer = await response.arrayBuffer();
      if (arrayBuffer.byteLength === 0) {
        logger.info('No fees to claim (empty transaction)');
        return '';
      }

      const transactionBuffer = Buffer.from(arrayBuffer);

      // Deserialize and sign transaction
      let transaction: VersionedTransaction;
      try {
        transaction = VersionedTransaction.deserialize(transactionBuffer);
      } catch (error) {
        logger.error({ error }, 'Failed to deserialize fee claim transaction');
        throw new Error('Invalid transaction received from PumpPortal');
      }

      transaction.sign([this.wallet]);

      // Send transaction
      const signature = await this.connection.sendTransaction(transaction, {
        skipPreflight: false,
        preflightCommitment: 'confirmed',
      });

      logger.info({ signature, pool }, 'Fee claim transaction sent');

      // Wait for confirmation
      await this.waitForConfirmation(signature);

      logger.info({ signature }, 'Creator fees claimed successfully');
      return signature;
    } catch (error) {
      logger.error({ pool, error }, 'Failed to claim creator fees');
      throw error;
    }
  }

  /**
   * Claim Creator Rewards for a specific token (Meteora Dynamic Bonding Curve)
   * Use this after a token graduates from pump.fun to Meteora/Raydium
   * @param mint The mint address of the token you created
   */
  async claimCreatorRewards(mint: string): Promise<string | null> {
    await this.enforceRateLimit();
    logger.info({ mint }, 'Claiming creator rewards via PumpPortal API (Meteora)...');

    try {
      const url = `${this.config.baseUrl}/trade?api-key=${this.config.apiKey}`;

      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          action: 'claim',
          mint: mint,
          publicKey: this.wallet.publicKey.toBase58(),
          denominatedInSol: true, // Use boolean
          amount: 100, // Required by schema but ignored for claims
          slippage: 1, // Required by schema but ignored for claims
          priorityFee: 0.005,
          pool: 'meteora', // Target Meteora curve (graduated tokens)
        }),
      });

      if (response.status === 200) {
        const data = await response.arrayBuffer();

        if (data.byteLength === 0) {
          logger.info({ mint }, 'No rewards to claim (empty response)');
          return null;
        }

        const tx = VersionedTransaction.deserialize(new Uint8Array(data));
        tx.sign([this.wallet]);

        const signature = await this.connection.sendTransaction(tx, {
          skipPreflight: false,
          preflightCommitment: 'confirmed',
        });

        await this.waitForConfirmation(signature);
        logger.info({ signature, mint }, 'Creator rewards claimed successfully');
        return signature;
      } else {
        const errorText = await response.text();
        logger.error({ status: response.status, error: errorText, mint }, 'Failed to claim rewards');
        return null;
      }
    } catch (error) {
      logger.error({ error, mint }, 'Error claiming creator rewards');
      return null;
    }
  }

  /**
   * Execute a trade (buy or sell)
   * Sell trades use higher priority fees (urgent) for faster exit
   */
  private async executeTrade(action: TradeAction, params: TradeParams): Promise<string> {
    // Validate parameters
    this.validateTradeParams(params);
    await this.enforceRateLimit();

    const { mint, amount, slippage } = params;
    const isUrgent = action === 'sell'; // Exits need higher priority

    logger.info({ mint, amount, slippage, isUrgent }, `Executing ${action} order`);

    let lastError: Error | null = null;

    // Retry logic
    const effectiveMaxRetries = isUrgent ? this.config.maxRetries + 5 : this.config.maxRetries;

    for (let attempt = 1; attempt <= effectiveMaxRetries; attempt++) {
      try {
        const signature = await this.submitTrade(action, params, isUrgent);
        
        logger.info({
          mint,
          amount,
          signature,
          attempt,
        }, `${action} order successful`);

        return signature;
      } catch (error) {
        lastError = error as Error;
        const errorMessage = lastError.message.toLowerCase();
        const isRateLimit = errorMessage.includes('429') || errorMessage.includes('rate limit') || errorMessage.includes('too many requests');
        
        logger.warn({
          mint,
          amount,
          error: lastError.message,
          attempt,
          maxRetries: effectiveMaxRetries,
          isRateLimit
        }, `${action} order attempt ${attempt} failed`);

        // Don't retry on validation errors
        if (this.isValidationError(lastError)) {
          throw lastError;
        }

        // Wait before retry (exponential backoff)
        if (attempt < effectiveMaxRetries) {
          // Base delay: config delay normally, or 2000ms if rate limited
          const baseDelay = isRateLimit ? 2000 : this.config.retryDelayMs;
          const delay = baseDelay * Math.pow(2, attempt - 1);
          
          logger.debug({ attempt, delay, isRateLimit }, `Retrying in ${delay}ms`);
          await this.sleep(delay);
        }
      }
    }

    // All retries failed
    logger.error({
      mint,
      amount,
      error: lastError?.message,
    }, `${action} order failed after ${effectiveMaxRetries} attempts`);

    throw new Error(`Trade failed after ${effectiveMaxRetries} attempts: ${lastError?.message}`);
  }

  /**
   * Submit trade to PumpPortal API (Local Trading)
   */
  private async submitTrade(action: TradeAction, params: TradeParams, isUrgent: boolean = false): Promise<string> {
    const { mint, amount, slippage } = params;

    const url = `${this.config.baseUrl}/trade-local`;

    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };
    if (this.config.apiKey) {
      headers['Authorization'] = `Bearer ${this.config.apiKey}`;
    }

    // Get dynamic priority fee based on network conditions
    const priorityFee = await this.getDynamicPriorityFee(isUrgent);

    const payload = {
      publicKey: this.wallet.publicKey.toBase58(),
      action,
      mint,
      amount,
      denominatedInSol: action === 'buy' ? 'true' : 'false', // Buy in SOL, Sell in tokens
      slippage: Math.round(slippage * 100), // Integer 1-100
      priorityFee,
      pool: 'pump',
    };

    logger.debug({ priorityFee, isUrgent }, 'Using dynamic priority fee');

    logger.info({ 
      action,
      mint, 
      amount, 
      denominatedInSol: payload.denominatedInSol,
      slippage: payload.slippage,
      priorityFee,
      publicKey: payload.publicKey.slice(0, 8) + '...'
    }, 'Submitting trade to PumpPortal');

    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      const errorText = await response.text();
      logger.error({
        action,
        mint,
        amount,
        slippage: payload.slippage,
        status: response.status,
        error: errorText,
        url
      }, 'PumpPortal API error - full details');
      throw new Error(`PumpPortal API error: ${response.status} ${errorText}`);
    }

    const arrayBuffer = await response.arrayBuffer();
    if (arrayBuffer.byteLength === 0) {
       throw new Error('Received empty transaction from PumpPortal');
    }
    
    const transactionBuffer = Buffer.from(arrayBuffer);

    // Deserialize transaction
    let transaction: VersionedTransaction;
    try {
      transaction = VersionedTransaction.deserialize(transactionBuffer);
    } catch (error) {
       logger.error({ error }, 'Failed to deserialize transaction');
       throw new Error('Invalid transaction received from PumpPortal');
    }

    // Sign transaction
    transaction.sign([this.wallet]);

    // Send transaction
    const signature = await this.connection.sendTransaction(transaction, {
      skipPreflight: false,
      preflightCommitment: 'confirmed',
    });

    logger.info({ signature }, 'Transaction sent to network');

    // Wait for confirmation
    await this.waitForConfirmation(signature);

    return signature;
  }

  /**
   * Wait for transaction confirmation
   */
  private async waitForConfirmation(signature: string): Promise<void> {
    logger.debug({ signature }, 'Waiting for transaction confirmation');

    const latestBlockhash = await this.connection.getLatestBlockhash();
    
    const confirmation = await this.connection.confirmTransaction({
      signature,
      blockhash: latestBlockhash.blockhash,
      lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
    }, 'confirmed');

    if (confirmation.value.err) {
      throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
    }
    
    logger.debug({ signature }, 'Transaction confirmed');
  }

  /**
   * Validate trade parameters
   */
  private validateTradeParams(params: TradeParams): void {
    const { mint, amount, slippage } = params;

    this.validateMint(mint);

    if (amount <= 0) {
      throw new Error(`Invalid amount: ${amount}. Amount must be greater than 0.`);
    }

    if (slippage < 0 || slippage > 1) {
      throw new Error(`Invalid slippage: ${slippage}. Slippage must be between 0 and 1.`);
    }
  }

  /**
   * Validate mint address
   */
  private validateMint(mint: string): void {
    if (!mint || mint.length < 32) {
      throw new Error(`Invalid mint address: ${mint}`);
    }
  }

  /**
   * Check if error is a validation error (should not retry)
   */
  private isValidationError(error: Error): boolean {
    const message = error.message.toLowerCase();
    return (
      message.includes('invalid') ||
      message.includes('validation') ||
      message.includes('must be')
    );
  }

  /**
   * Enforce rate limiting between requests
   */
  private async enforceRateLimit(): Promise<void> {
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequestTime;

    if (timeSinceLastRequest < this.MIN_REQUEST_DELAY_MS) {
      const delay = this.MIN_REQUEST_DELAY_MS - timeSinceLastRequest;
      await this.sleep(delay);
    }

    this.lastRequestTime = Date.now();
  }

  /**
   * Sleep for specified milliseconds
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
</file>

<file path="src/trading/token-validator.ts">
import { dexscreener, type TokenMetadata } from '../api/dexscreener.js';
import { createLogger } from '../lib/logger.js';
import type { RiskProfile } from './types.js';
import type { PumpNewTokenEvent } from '../api/pumpportal-data.js';

const logger = createLogger('token-validator');

export interface ValidationResult {
  mint: string;
  passes: boolean;
  reason?: string;
  metadata?: TokenMetadata;
  isBondingCurve?: boolean; // True if validated via bonding curve data
}

export interface BondingCurveValidationResult {
  mint: string;
  passes: boolean;
  reason?: string;
  marketCapSol: number;
  bondingProgress: number; // 0-100% progress toward graduation
}

export interface ValidatorConfig {
  riskProfile: RiskProfile;
  minLiquidityUsd?: number; // Overrides risk profile if set
  minVolume1hUsd?: number;  // Overrides risk profile if set
  requireSocials: boolean;
}

const DEFAULT_CONFIG: ValidatorConfig = {
  riskProfile: 'BALANCED',
  requireSocials: false,
};

// Graduation threshold: ~400 SOL in bonding curve = ~$69k market cap
const GRADUATION_THRESHOLD_SOL = 400;

/**
 * TokenValidator
 * Validates tokens using DexScreener data to ensure quality before trading
 */
export class TokenValidator {
  private config: ValidatorConfig;

  constructor(config: Partial<ValidatorConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    logger.info({ config: this.config }, 'TokenValidator initialized');
  }

  /**
   * Validate a token
   */
  async validate(mint: string): Promise<ValidationResult> {
    try {
      // Fetch metadata from DexScreener
      const metadata = await dexscreener.getTokenMetadata(mint);

      if (!metadata) {
        return {
          mint,
          passes: false,
          reason: 'No DexScreener data found (too new or dead)',
        };
      }

      // 1. RISK DIAL SETTINGS
      const profile = this.config.riskProfile;
      
      const liquidityThresholds = {
        CONSERVATIVE: 15000,
        BALANCED: 5000,
        AGGRESSIVE: 1500,
        ENTERTAINMENT: 500, // Very low threshold for micro bets
      };

      const maxAgeMinutes = {
        CONSERVATIVE: 15,
        BALANCED: 8,
        AGGRESSIVE: 3,
        ENTERTAINMENT: 60, // Allow older tokens for entertainment
      };

      const minBuyPressure = {
        CONSERVATIVE: 1.8,
        BALANCED: 1.0,
        AGGRESSIVE: 1.05,
        ENTERTAINMENT: 0.8, // Lower threshold - just needs some activity
      };

      // Determine active thresholds
      const minLiquidity = this.config.minLiquidityUsd || liquidityThresholds[profile];
      const maxAge = maxAgeMinutes[profile];
      const pressureThreshold = minBuyPressure[profile];
      const minVolume = this.config.minVolume1hUsd || minLiquidity; // Volume should match liquidity roughly

      // Check 1: Liquidity
      if (metadata.liquidity < minLiquidity) {
        return {
          mint,
          passes: false,
          reason: `Low liquidity: $${metadata.liquidity.toFixed(0)} < $${minLiquidity} (${profile})`,
          metadata,
        };
      }

      // Check 2: Age (Sniping Window)
      // IF we are AGGRESSIVE, we want FRESH tokens (age < maxAge). 
      // Existing logic (minAge) was to avoid scams. New logic (maxAge) is to catch pumps.
      // BUT, we should probably support both flows.
      // For this specific 'Sniper' flow, passing a token means it is READY to buy.
      
      // If we are 'sniping', we want tokens that are YOUNG enough to be early, 
      // but OLD enough to have some data. 
      // Actually, the new prompt says: "If ageMinutes <= maxAgeMinutes -> allow".
      // This implies we ONLY want young tokens for this strategy.
      if (metadata.ageMinutes && metadata.ageMinutes > maxAge) {
         // Optionally, we could allow older tokens if they have massive volume?
         // For now, stick to the prompt: strict age window for 'Sniping'
         // result: `Too old for ${profile} entry: ${metadata.ageMinutes}m > ${maxAge}m limit`,
         // BUT user requested to remove age filter entirely, so we log but DO NOT REJECT
         if (metadata.ageMinutes > maxAge) {
             logger.debug({ mint, age: metadata.ageMinutes, maxAge }, 'Token older than maxAge - proceeding anyway due to relaxed filter');
         }
         /*
         return {
            mint,
            passes: false,
            reason: `Too old for ${profile} entry: ${metadata.ageMinutes}m > ${maxAge}m limit`,
            metadata
         };
         */
      }

      // Check 3: Buy Pressure (New)
      // buyPressure = buys5m / Math.max(1, sells5m)
      const buys = metadata.buys5m || 0;
      const sells = metadata.sells5m || 0;
      const buyPressure = buys / Math.max(1, sells);
      
      if (buyPressure < pressureThreshold) {
          return {
              mint,
              passes: false,
              reason: `Weak buy pressure: ${buyPressure.toFixed(2)} < ${pressureThreshold} (${profile})`,
              metadata
          }
      }

      // Check 4: Volume
      const volumeScore = metadata.volume1h > 0 
        ? metadata.volume1h 
        : (metadata.volume24h > 0 ? metadata.volume24h : metadata.buys5m * 100); 

      if (volumeScore < minVolume) {
        return {
          mint,
          passes: false,
          reason: `Low volume: $${volumeScore.toFixed(0)} < $${minVolume}`,
          metadata,
        };
      }

      // Check 5: Suspicious Patterns (Rug Check)
      if (metadata.priceChange1h < -90) {
        return {
          mint,
          passes: false,
          reason: `Rug detected: Price down ${metadata.priceChange1h.toFixed(1)}% in 1h`,
          metadata,
        };
      }

      return {
        mint,
        passes: true,
        metadata,
      };

    } catch (error) {
      logger.error({ mint, error }, 'Error validating token');
      return {
        mint,
        passes: false,
        reason: 'Validation error',
      };
    }
  }

  /**
   * Validate a bonding curve token using PumpPortal data
   * This is for tokens still on the pump.fun bonding curve (not yet graduated)
   */
  validateBondingCurve(token: PumpNewTokenEvent): BondingCurveValidationResult {
    const profile = this.config.riskProfile;

    // Calculate bonding progress (0-100%)
    // Tokens graduate at ~400 SOL in bonding curve
    const bondingProgress = Math.min(100, (token.vSolInBondingCurve / GRADUATION_THRESHOLD_SOL) * 100);

    // Market cap thresholds in SOL (since bonding curve tokens are priced in SOL)
    // Most tokens start at ~28 SOL mcap - thresholds set to catch early momentum
    const minMarketCapSol = {
      CONSERVATIVE: 50,    // ~$8.5k at $170/SOL
      BALANCED: 28,        // ~$4.8k - catch early momentum (lowered from 30 to match reality)
      AGGRESSIVE: 28,      // ~$4.8k - very early entry
      ENTERTAINMENT: 0,    // No minimum - catch everything
    };

    // Minimum bonding progress (% toward graduation)
    // Lower thresholds - we want to catch tokens with some momentum
    const minBondingProgress = {
      CONSERVATIVE: 15,    // 15% = ~60 SOL in curve
      BALANCED: 5,         // 5% = ~20 SOL in curve
      AGGRESSIVE: 2,       // 2% = ~8 SOL in curve
      ENTERTAINMENT: 1,    // 1% = ~4 SOL in curve - almost any activity
    };

    const minMcap = minMarketCapSol[profile];
    const minProgress = minBondingProgress[profile];

    // Check 1: Minimum market cap
    if (token.marketCapSol < minMcap) {
      return {
        mint: token.mint,
        passes: false,
        reason: `Low market cap: ${token.marketCapSol.toFixed(1)} SOL < ${minMcap} SOL (${profile})`,
        marketCapSol: token.marketCapSol,
        bondingProgress,
      };
    }

    // Check 2: Minimum bonding progress (shows there's buying activity)
    if (bondingProgress < minProgress) {
      return {
        mint: token.mint,
        passes: false,
        reason: `Low bonding progress: ${bondingProgress.toFixed(1)}% < ${minProgress}% (${profile})`,
        marketCapSol: token.marketCapSol,
        bondingProgress,
      };
    }

    // Check 3: Creator didn't dump immediately (initialBuy > 0 means dev bought)
    // If dev didn't buy at all, slightly suspicious but not a deal breaker
    if (token.initialBuy === 0) {
      logger.debug({ mint: token.mint }, 'Dev did not buy - proceeding with caution');
    }

    // Check 4: Suspicious name patterns
    const suspiciousPatterns = [/rug/i, /scam/i, /honeypot/i, /fake/i, /exit/i];
    for (const pattern of suspiciousPatterns) {
      if (pattern.test(token.symbol) || pattern.test(token.name)) {
        return {
          mint: token.mint,
          passes: false,
          reason: `Suspicious token name: ${token.name}`,
          marketCapSol: token.marketCapSol,
          bondingProgress,
        };
      }
    }

    logger.info({
      mint: token.mint,
      symbol: token.symbol,
      marketCapSol: token.marketCapSol.toFixed(2),
      bondingProgress: bondingProgress.toFixed(1),
      profile,
    }, '‚úÖ Bonding curve token validated');

    return {
      mint: token.mint,
      passes: true,
      marketCapSol: token.marketCapSol,
      bondingProgress,
    };
  }
}
</file>

<file path="src/server/websocket.ts">
/**
 * WebSocket server for streaming agent events and chat interaction
 */

import { WebSocketServer, WebSocket } from 'ws';
import { createServer } from 'http';
import { readFileSync, existsSync } from 'fs';
import { join, extname } from 'path';
import { fileURLToPath } from 'url';
import type { AgentEventEmitter } from '../events/emitter.js';
import type { ClaudeClient } from '../personality/claude-client.js';
import type { VoiceNarrator } from '../personality/deepgram-tts.js';
import type { TradingEngine } from '../trading/trading-engine.js';
import type { TokenSafetyAnalyzer } from '../analysis/token-safety.js';
import { logger } from '../lib/logger.js';
import { handleHeliusWebhook, verifyWebhookSignature, type HeliusWebhookEvent } from '../api/helius-webhook.js';
import {
  simulateScan,
  simulateReject,
  simulateBuy,
  simulateSell,
  simulateBuyback,
  simulateMoodChange,
  simulateRewardClaim,
} from '../test/manual-trigger.js';

const __dirname = fileURLToPath(new URL('.', import.meta.url));
const PUBLIC_DIR = join(__dirname, '../../public');

const MIME_TYPES: Record<string, string> = {
  '.html': 'text/html',
  '.css': 'text/css',
  '.js': 'application/javascript',
  '.json': 'application/json',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.mp3': 'audio/mpeg',
  '.wav': 'audio/wav',
};

/**
 * Chat message from client
 */
interface ChatMessage {
  type: 'CHAT';
  username?: string;
  message: string;
}

/**
 * Simulation request from client (for testing)
 */
interface SimulateRequest {
  type: 'SIMULATE';
  action: 'scan' | 'reject' | 'buy' | 'sell' | 'buyback' | 'mood' | 'reward';
  params?: {
    mood?: string;
    isProfit?: boolean;
    success?: boolean;
  };
}

/**
 * WebSocket server context with chat capabilities
 */
export interface WebSocketContext {
  wss: WebSocketServer;
  claude?: ClaudeClient;
  narrator?: VoiceNarrator;
  tradingEngine?: TradingEngine;
  tokenSafety?: TokenSafetyAnalyzer;
  tradingEnabled?: boolean;
}

/**
 * Create WebSocket server for event streaming and chat
 */
export function createWebSocketServer(
  port: number,
  eventEmitter: AgentEventEmitter,
  claude?: ClaudeClient,
  narrator?: VoiceNarrator,
  tradingEngine?: TradingEngine,
  tokenSafety?: TokenSafetyAnalyzer,
  tradingEnabled?: boolean
): WebSocketServer {
  // Create HTTP server to serve static files and API endpoints
  const server = createServer((req, res) => {
    const url = new URL(req.url || '/', `http://localhost:${port}`);
    const pathname = url.pathname;

    // CORS headers for API requests
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    // Handle OPTIONS (preflight)
    if (req.method === 'OPTIONS') {
      res.writeHead(204);
      res.end();
      return;
    }

    // === API ENDPOINTS ===
    
    // Helius webhook endpoint for real-time wallet tracking
    if (pathname === '/api/helius-webhook' && req.method === 'POST') {
      let body = '';
      req.on('data', chunk => { body += chunk.toString(); });
      req.on('end', async () => {
        try {
          // Verify webhook signature if configured
          const signature = req.headers['authorization'];
          if (!verifyWebhookSignature(body, signature as string | undefined)) {
            logger.warn('Invalid webhook signature');
            res.writeHead(401, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Invalid signature' }));
            return;
          }

          const events = JSON.parse(body) as HeliusWebhookEvent[];
          const walletAddress = process.env.WALLET_PUBLIC_KEY || process.env.SOLANA_WALLET_ADDRESS || 'DR4d6RUYHay79dCbUEhU9BphWioVxvoExu4uULq6kJpG';

          logger.info({ eventCount: events.length, walletAddress }, 'üì° Helius webhook received');

          // Handle events asynchronously
          await handleHeliusWebhook(events, walletAddress);

          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ success: true, processed: events.length }));
        } catch (error) {
          logger.error({ error }, 'Failed to process Helius webhook');
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Internal server error' }));
        }
      });
      return;
    }
    
    // Get SCHIZO token CA from environment
    if (pathname === '/api/schizo-ca' && req.method === 'GET') {
      const ca = process.env.SCHIZO_TOKEN_MINT || '';
      const isPlaceholder = !ca || ca === 'your-schizo-token-mint-here';
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ 
        ca: isPlaceholder ? '' : ca,
        live: !isPlaceholder 
      }));
      return;
    }

    if (pathname.startsWith('/api/simulate') && req.method === 'POST') {
      let body = '';
      req.on('data', chunk => { body += chunk.toString(); });
      req.on('end', () => {
        try {
          const params = body ? JSON.parse(body) : {};
          handleSimulateAPI(pathname, params, eventEmitter, res);
        } catch (error) {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Invalid JSON body' }));
        }
      });
      return;
    }

    // === STATIC FILE SERVING ===
    let filePath = pathname === '/' ? '/index.html' : pathname;

    const fullPath = join(PUBLIC_DIR, filePath);
    const ext = extname(fullPath);
    const contentType = MIME_TYPES[ext] || 'application/octet-stream';

    try {
      if (existsSync(fullPath)) {
        const content = readFileSync(fullPath);
        res.writeHead(200, { 'Content-Type': contentType });
        res.end(content);
      } else {
        // Fallback to index.html for SPA routing
        const indexPath = join(PUBLIC_DIR, 'index.html');
        if (existsSync(indexPath)) {
          const content = readFileSync(indexPath);
          res.writeHead(200, { 'Content-Type': 'text/html' });
          res.end(content);
        } else {
          res.writeHead(404);
          res.end('Not found');
        }
      }
    } catch (error) {
      logger.error({ error, path: filePath }, 'Error serving static file');
      res.writeHead(500);
      res.end('Server error');
    }
  });

  // Create WebSocket server on top of HTTP server
  const wss = new WebSocketServer({ server });

  server.listen(port, () => {
    logger.info({ port }, 'HTTP + WebSocket server started');
  });

  wss.on('connection', (ws: WebSocket) => {
    logger.info('Client connected');

    // Send all events to this client
    const handler = (event: any) => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(event));
      }
    };

    eventEmitter.onAny(handler);

    // Send initial connection message
    ws.send(JSON.stringify({
      type: 'CONNECTED',
      timestamp: Date.now(),
      data: { message: 'Connected to $SCHIZO agent' },
    }));

    // Send initial data (recent trades and positions)
    if (tradingEngine) {
      // Send recent trades
      try {
        const recentTrades = tradingEngine.getRecentTrades(20);
        ws.send(JSON.stringify({
          type: 'INITIAL_TRADES',
          timestamp: Date.now(),
          data: { trades: recentTrades },
        }));
      } catch (error) {
        logger.error({ error }, 'Error sending initial trades');
      }

      // Send current positions with prices
      (async () => {
        try {
          const positions = await tradingEngine.getOpenPositionsWithPrices();
          ws.send(JSON.stringify({
            type: 'POSITIONS_UPDATE',
            timestamp: Date.now(),
            data: {
              positions: positions.map(p => ({
                tokenMint: p.tokenMint,
                tokenSymbol: p.tokenSymbol,
                tokenName: p.tokenName,
                tokenImage: p.tokenImage,
                entryAmountSol: p.entryAmountSol,
                entryAmountTokens: p.entryAmountTokens,
                entryPrice: p.entryPrice,
                entryTimestamp: p.entryTimestamp,
                currentPrice: p.currentPrice,
                unrealizedPnLPercent: p.unrealizedPnLPercent,
              })),
            },
          }));
        } catch (error) {
          logger.error({ error }, 'Error sending initial positions');
        }
      })();

      // Send initial stats on connect (Fix 4: PnL not showing on page load)
      (async () => {
        try {
          const stats = await tradingEngine.getStats();
          const allTrades = tradingEngine.getRecentTrades(100);

          // Calculate win rate from completed trades
          let wins = 0, total = 0;
          const positionMap = new Map<string, { amountSol: number }>();
          for (const trade of allTrades) {
            if (trade.type === 'BUY') {
              positionMap.set(trade.mint, { amountSol: trade.amount });
            } else if (trade.type === 'SELL') {
              const buyTrade = positionMap.get(trade.mint);
              if (buyTrade) {
                total++;
                if (trade.amount > buyTrade.amountSol) wins++;
                positionMap.delete(trade.mint);
              }
            }
          }
          const winRate = total > 0 ? (wins / total) * 100 : 0;

          ws.send(JSON.stringify({
            type: 'STATS_UPDATE',
            timestamp: Date.now(),
            data: {
              todayTrades: stats.todayTrades,
              openPositions: stats.openPositions,
              realizedPnL: stats.realizedPnL,
              unrealizedPnL: stats.unrealizedPnL,
              dailyPnL: stats.dailyPnL,
              winRate,
              balance: 0, // Will be updated by trading loop with actual wallet balance
            },
          }));
        } catch (error) {
          logger.error({ error }, 'Error sending initial stats');
        }
      })();
    }

    // Handle incoming messages (chat and simulation)
    ws.on('message', async (data: Buffer) => {
      try {
        const message = JSON.parse(data.toString());

        if (message.type === 'CHAT' && message.message) {
          await handleChatMessage(message, ws, wss, eventEmitter, claude, narrator, tradingEngine, tokenSafety, tradingEnabled);
        } else if (message.type === 'SIMULATE') {
          // Handle simulation requests for dry-run testing
          handleSimulateRequest(message as SimulateRequest, ws);
        }
      } catch (error) {
        logger.error({ error }, 'Error processing client message');
      }
    });

    ws.on('close', () => {
      logger.info('Client disconnected');
      eventEmitter.offAny(handler);
    });

    ws.on('error', (error) => {
      logger.error({ error }, 'WebSocket client error');
    });
  });

  wss.on('error', (error) => {
    logger.error({ error }, 'WebSocket server error');
  });

  logger.info({ port }, 'WebSocket server started');

  // Start periodic position broadcasting (every 30 seconds to avoid rate limits)
  if (tradingEngine) {
    setInterval(async () => {
      try {
        const positions = await tradingEngine.getOpenPositionsWithPrices();
        
        // Broadcast to all clients
        const updateEvent = {
          type: 'POSITIONS_UPDATE',
          timestamp: Date.now(),
          data: {
            positions: positions.map(p => ({
              tokenMint: p.tokenMint,
              tokenSymbol: p.tokenSymbol,
              tokenName: p.tokenName,
              tokenImage: p.tokenImage,
              entryAmountSol: p.entryAmountSol,
              entryAmountTokens: p.entryAmountTokens,
              entryPrice: p.entryPrice,
              entryTimestamp: p.entryTimestamp,
              currentPrice: p.currentPrice,
              unrealizedPnLPercent: p.unrealizedPnLPercent,
            })),
          },
        };
        
        broadcast(wss, updateEvent);
        
        // Also broadcast updated stats with correct total PnL
        // We need to calculate total unrealized PnL from positions
        let totalUnrealizedPnL = 0;
        let totalRealizedPnL = 0; // We'd need to fetch this from DB effectively, or track it
        
        // For now, let's just ensure we trigger a stats calculation if possible, 
        // or rely on tradingEngine to have the latest cached stats if we implemented that.
        // Since we don't have a direct "getStats" on tradingEngine exposed easily here without DB access,
        // let's at least rely on the client calculating total PnL from the positions list for now,
        // which app.js already does in updateTrenchRadioFromPositions/updateStats logic.
        
      } catch (error) {
        logger.error({ error }, 'Error broadcasting periodic position updates');
      }
    }, 30000); // Changed from 5000ms to 30000ms
  }

  return wss;
}

/**
 * Broadcast an event to all connected clients
 */
function broadcast(wss: WebSocketServer, event: object): void {
  const eventStr = JSON.stringify(event);
  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(eventStr);
    }
  });
}

/**
 * Detect Solana contract addresses in a message
 * Solana addresses are base58 encoded, 32-44 characters
 */
function detectContractAddress(message: string): string | null {
  // Solana address regex: base58 characters, 32-44 chars long
  // Base58 alphabet: 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
  const solanaAddressRegex = /\b([1-9A-HJ-NP-Za-km-z]{32,44})\b/g;
  const matches = message.match(solanaAddressRegex);

  if (!matches) return null;

  // Filter to likely token mints (not wallet addresses which are also valid)
  // Most token mints are 43-44 characters
  for (const match of matches) {
    if (match.length >= 32 && match.length <= 44) {
      // Basic validation - ensure it's not just random text
      // Real addresses typically have mixed case and numbers
      const hasUpperCase = /[A-Z]/.test(match);
      const hasLowerCase = /[a-z]/.test(match);
      const hasNumbers = /[0-9]/.test(match);

      if ((hasUpperCase || hasLowerCase) && hasNumbers) {
        return match;
      }
    }
  }

  return null;
}

/**
 * Handle a chat message from a client
 */
async function handleChatMessage(
  chatMessage: ChatMessage,
  senderWs: WebSocket,
  wss: WebSocketServer,
  eventEmitter: AgentEventEmitter,
  claude?: ClaudeClient,
  narrator?: VoiceNarrator,
  tradingEngine?: TradingEngine,
  tokenSafety?: TokenSafetyAnalyzer,
  tradingEnabled?: boolean
): Promise<void> {
  logger.info({
    username: chatMessage.username,
    message: chatMessage.message.slice(0, 50),
  }, 'Chat message received');

  // Emit chat received event
  eventEmitter.emit({
    type: 'CHAT_RECEIVED',
    timestamp: Date.now(),
    data: {
      username: chatMessage.username,
      message: chatMessage.message,
    },
  });

  // Check for contract address in message
  const detectedCA = detectContractAddress(chatMessage.message);

  if (detectedCA && tokenSafety) {
    logger.info({ ca: detectedCA, username: chatMessage.username }, 'Contract address detected in chat');

    // Handle CA analysis in background, respond immediately
    handleContractAnalysis(detectedCA, chatMessage.username, wss, eventEmitter, claude, narrator, tradingEngine, tokenSafety, tradingEnabled);

    // Quick acknowledgment
    const ackResponse = pickRandom([
      `Oh you want me to look at ${detectedCA.slice(0, 6)}...${detectedCA.slice(-4)}? Alright, running my paranoid checks...`,
      `${detectedCA.slice(0, 6)}...${detectedCA.slice(-4)}? Let me scan this for honeypot vibes...`,
      `Analyzing ${detectedCA.slice(0, 6)}...${detectedCA.slice(-4)}. Give me a sec to check the authorities...`,
      `*squints at ${detectedCA.slice(0, 6)}...${detectedCA.slice(-4)}* Let me see what the whales know about this one...`,
    ]);

    // Send acknowledgment
    const ackEvent = {
      type: 'CHAT_RESPONSE' as const,
      timestamp: Date.now(),
      data: {
        username: chatMessage.username,
        originalMessage: chatMessage.message,
        response: ackResponse,
      },
    };
    broadcast(wss, ackEvent);

    if (narrator) {
      try { await narrator.say(ackResponse); } catch {}
    }

    return;
  }

  // Try cached response first (instant, no API call)
  let response: string | null = getCachedResponse(chatMessage.message);
  let usedCache = false;

  if (response) {
    usedCache = true;
    logger.info({ cached: true }, 'Using cached response');
  } else {
    // No cached response - show typing indicator and use Claude or fallback
    broadcast(wss, {
      type: 'CHAT_TYPING',
      timestamp: Date.now(),
      data: { typing: true },
    });

    if (claude) {
      try {
        response = await claude.respondToChat(chatMessage.message, chatMessage.username);
      } catch (error) {
        logger.error({ error }, 'Error generating chat response');
        response = 'My circuits are overloaded... try again in a sec.';
      }
    } else {
      response = getDefaultChatResponse(chatMessage.message);
    }

    // Stop typing indicator
    broadcast(wss, {
      type: 'CHAT_TYPING',
      timestamp: Date.now(),
      data: { typing: false },
    });
  }

  // Create response event
  const responseEvent = {
    type: 'CHAT_RESPONSE' as const,
    timestamp: Date.now(),
    data: {
      username: chatMessage.username,
      originalMessage: chatMessage.message,
      response,
    },
  };

  // Broadcast response to all clients
  const responseStr = JSON.stringify(responseEvent);
  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(responseStr);
    }
  });

  // Voice the response if narrator is available
  if (narrator) {
    try {
      await narrator.say(response);
    } catch (error) {
      logger.error({ error }, 'Error voicing chat response');
    }
  }

  logger.info({ response: response.slice(0, 50) }, 'Chat response sent');
}

/**
 * Handle contract address analysis from chat
 * Analyzes the token and either roasts it or buys it
 */
async function handleContractAnalysis(
  mint: string,
  username: string | undefined,
  wss: WebSocketServer,
  eventEmitter: AgentEventEmitter,
  claude?: ClaudeClient,
  narrator?: VoiceNarrator,
  tradingEngine?: TradingEngine,
  tokenSafety?: TokenSafetyAnalyzer,
  tradingEnabled?: boolean
): Promise<void> {
  try {
    if (!tokenSafety) {
      logger.warn('Token safety analyzer not available');
      return;
    }

    // Run safety analysis
    const safetyResult = await tokenSafety.analyze(mint);
    const shortMint = `${mint.slice(0, 6)}...${mint.slice(-4)}`;

    logger.info({
      mint,
      isSafe: safetyResult.isSafe,
      risks: safetyResult.risks,
    }, 'Chat CA analysis complete');

    let response: string;
    let shouldBuy = false;

    // Check for critical risks (honeypot flags)
    const hasCriticalRisk = safetyResult.risks.some(r =>
      r === 'MINT_AUTHORITY_ACTIVE' || r === 'FREEZE_AUTHORITY_ACTIVE'
    );

    if (hasCriticalRisk) {
      // ROAST IT - Critical risks detected
      const roasts = [
        `${shortMint}? LOL. Mint authority is ACTIVE. They can print more tokens whenever they want. This is textbook honeypot setup. Hard pass, and you should run too.`,
        `Bruh. ${shortMint} has freeze authority enabled. They can literally freeze your tokens and you can't sell. This is a trap. I'm not touching this garbage.`,
        `*dies laughing* You want me to buy ${shortMint}? It has ${safetyResult.risks.join(' AND ')}. This is either a scam or the devs are idiots. Either way, NO.`,
        `${shortMint} analysis complete: IT'S A TRAP. ${safetyResult.risks.join(', ')}. The only thing this token is good for is a screenshot for my "rugs I avoided" collection.`,
        `My paranoid sensors are SCREAMING. ${shortMint} has ${safetyResult.risks.length} red flags: ${safetyResult.risks.join(', ')}. Whoever shilled you this wants your money.`,
      ];
      response = pickRandom(roasts);

    } else if (!safetyResult.isSafe || safetyResult.risks.length > 2) {
      // Sketchy but not critical - mock it
      const skeptical = [
        `${shortMint} passed the honeypot check but still looks sketchy. ${safetyResult.risks.length} yellow flags: ${safetyResult.risks.join(', ')}. I'm watching but not buying.`,
        `Hmm. ${shortMint} isn't an obvious rug but my paranoid senses are tingling. ${safetyResult.risks.join(', ')}. Proceed with extreme caution fren.`,
        `${shortMint}: Not the worst I've seen, but not great either. ${safetyResult.risks.join(', ')}. DYOR - I'm staying on the sidelines.`,
      ];
      response = pickRandom(skeptical);

    } else {
      // Looks clean - consider buying
      shouldBuy = true;

      if (tradingEngine && tradingEnabled) {
        // Actually try to buy
        const decision = await tradingEngine.evaluateToken(mint);

        if (decision.shouldTrade) {
          // Execute the buy
          const signature = await tradingEngine.executeBuy(mint);

          if (signature) {
            const buyResponses = [
              `${shortMint} passed my paranoid checks. ${decision.smartMoneyCount} smart money wallets in. I'm aping ${decision.positionSizeSol} SOL. Let's ride.`,
              `You know what? ${shortMint} actually looks legit. Clean authorities, smart money present. Just bought ${decision.positionSizeSol} SOL worth. Thanks for the alpha fren.`,
              `Alright ${username ? '@' + username : 'anon'}, you convinced me. ${shortMint} checks out. Bought ${decision.positionSizeSol} SOL. If this rugs, I'm blaming you.`,
              `${shortMint}: No honeypot flags, ${decision.smartMoneyCount} whales already in. Taking a position. ${decision.positionSizeSol} SOL deployed. LFG.`,
            ];
            response = pickRandom(buyResponses);

            // Emit trade event
            eventEmitter.emit({
              type: 'TRADE_EXECUTED',
              timestamp: Date.now(),
              data: {
                mint,
                type: 'BUY',
                signature,
                amount: decision.positionSizeSol,
              },
            });
          } else {
            response = `${shortMint} looked good but the trade failed. Probably slippage or liquidity issues. The universe is telling me no.`;
          }
        } else {
          // Passed safety but failed other checks (smart money, liquidity, etc)
          const passResponses = [
            `${shortMint} isn't a honeypot but ${decision.reasons.join('. ')}. Not buying, but at least it probably won't rug you instantly.`,
            `Clean token but meh setup. ${decision.reasons.join('. ')}. Maybe later if whales start loading.`,
            `${shortMint}: Safe but not sexy. ${decision.reasons.join('. ')}. Wake me up when there's smart money.`,
          ];
          response = pickRandom(passResponses);
        }
      } else {
        // Trading disabled - just report analysis
        const analysisOnly = [
          `${shortMint} looks clean! No honeypot flags, authorities are renounced. Would buy if trading was enabled. You might be onto something fren.`,
          `Yo this actually passes my checks. ${shortMint} has clean authorities. I can't trade rn but this doesn't look like a rug. NFA.`,
          `${shortMint}: Surprisingly not trash. Clean setup. Trading's off but if I could buy, I might consider it. DYOR tho.`,
        ];
        response = pickRandom(analysisOnly);
      }
    }

    // Send the analysis response
    const responseEvent = {
      type: 'CHAT_RESPONSE' as const,
      timestamp: Date.now(),
      data: {
        username,
        originalMessage: mint,
        response,
      },
    };
    broadcast(wss, responseEvent);

    // Voice it
    if (narrator) {
      try {
        await narrator.say(response);
      } catch (error) {
        logger.error({ error }, 'Error voicing CA analysis');
      }
    }

    logger.info({ mint, response: response.slice(0, 50), shouldBuy }, 'CA analysis response sent');

  } catch (error) {
    logger.error({ error, mint }, 'Error analyzing contract address from chat');

    const errorResponse = `Something went wrong analyzing ${mint.slice(0, 6)}...${mint.slice(-4)}. My circuits are fried. Try again?`;
    broadcast(wss, {
      type: 'CHAT_RESPONSE',
      timestamp: Date.now(),
      data: {
        username,
        originalMessage: mint,
        response: errorResponse,
      },
    });
  }
}

/**
 * Cached responses for ONLY simple greetings - everything else goes to Claude
 * Keep this minimal so Claude handles real questions
 */
function getCachedResponse(message: string): string | null {
  const lower = message.toLowerCase().trim();

  // ONLY exact short greetings - anything with more words goes to Claude
  if (/^gm[!.]*$/i.test(lower)) {
    return pickRandom([
      'gm fren. What tokens are we paranoid about today?',
      'gm. Been watching some sus wallets move. You?',
      'gm degen. Ready to find some alpha?',
      'gm. Coffee and conspiracy theories - my favorite combo.',
      'gm. The early degen gets the... well, sometimes rugged. But sometimes rich.',
    ]);
  }

  if (/^gn[!.]*$/i.test(lower)) {
    return pickRandom([
      'gn. I\'ll be here watching the charts while you dream of lambos.',
      'gn fren. Set those stop losses - I don\'t trust anything while you\'re asleep.',
      'gn. May your bags pump overnight.',
      'gn. The whales are active at night. I\'ll keep watch.',
    ]);
  }

  if (/^(hi|hello|hey|yo|sup)[!.]*$/i.test(lower)) {
    return pickRandom([
      'Hey. What\'s good?',
      'Sup anon. Got any alpha to share?',
      'Yo. Ask me anything, I\'m feeling chatty.',
      'Hey fren. The market\'s being weird today - what\'s on your mind?',
    ]);
  }

  // Very short acknowledgments
  if (/^(ok|okay|cool|nice|thanks|ty|thx)[!.]*$/i.test(lower)) {
    return pickRandom([
      'Anytime fren.',
      '*nods paranoidly*',
      'Got you.',
      'Stay safe out there.',
    ]);
  }

  // Laughter/emojis - don't need Claude for these
  if (/^(lol|lmao|haha|üòÇ|ü§£|üíÄ)+[!.]*$/i.test(lower)) {
    return pickRandom([
      'lmao glad someone gets it',
      'the memes write themselves honestly',
      '*laughs in algorithm*',
    ]);
  }

  // Everything else goes to Claude for real responses
  return null;
}

/**
 * Pick a random response from an array
 */
function pickRandom(responses: string[]): string {
  return responses[Math.floor(Math.random() * responses.length)];
}

/**
 * Fallback responses when Claude is unavailable AND no cached response matches
 * These should acknowledge the message type and invite retry
 */
function getDefaultChatResponse(message: string): string {
  const lower = message.toLowerCase();

  // If it's a question, acknowledge that
  if (message.includes('?')) {
    return pickRandom([
      'Good question. My brain\'s a bit slow rn - hit me again?',
      'Hmm, let me think on that... actually, ask me again in a sec.',
      'That\'s a deep one. My processors need a moment.',
    ]);
  }

  // If about trading
  if (/\b(buy|sell|trade|token|coin|pump|rug)\b/i.test(lower)) {
    return pickRandom([
      'My trading analysis is loading... give me a sec fren.',
      'NFA but I need a moment to check the wallets on that.',
      'Interesting play. Let me recalibrate and get back to you.',
    ]);
  }

  // Generic but still engaging
  return pickRandom([
    'Yo my response module glitched. What were you saying?',
    'Hold up, my paranoid subroutines crashed. Try again?',
    '*squints* Say that again? I was distracted by a suspicious wallet.',
    'My brain buffered. Hit me with that again.',
    'Connection hiccup. What\'s good?',
  ]);
}

/**
 * Handle simulation requests for dry-run testing
 *
 * Usage via WebSocket:
 *   ws.send(JSON.stringify({ type: 'SIMULATE', action: 'scan' }))
 *   ws.send(JSON.stringify({ type: 'SIMULATE', action: 'buy' }))
 *   ws.send(JSON.stringify({ type: 'SIMULATE', action: 'sell', params: { isProfit: true } }))
 *   ws.send(JSON.stringify({ type: 'SIMULATE', action: 'mood', params: { mood: 'PARANOID' } }))
 */
function handleSimulateRequest(request: SimulateRequest, ws: WebSocket): void {
  logger.info({ action: request.action, params: request.params }, 'üß™ Simulation request received');

  try {
    switch (request.action) {
      case 'scan':
        simulateScan();
        sendSimulateAck(ws, 'scan', 'Token scan simulated');
        break;

      case 'reject':
        simulateReject();
        sendSimulateAck(ws, 'reject', 'Token rejection simulated');
        break;

      case 'buy':
        simulateBuy();
        sendSimulateAck(ws, 'buy', 'Buy trade simulated');
        break;

      case 'sell':
        simulateSell(request.params?.isProfit !== false);
        sendSimulateAck(ws, 'sell', request.params?.isProfit !== false ? 'Take-profit simulated' : 'Stop-loss simulated');
        break;

      case 'buyback':
        simulateBuyback();
        sendSimulateAck(ws, 'buyback', 'Buyback simulated');
        break;

      case 'mood':
        simulateMoodChange(request.params?.mood);
        sendSimulateAck(ws, 'mood', `Mood change simulated: ${request.params?.mood || 'random'}`);
        break;

      case 'reward':
        simulateRewardClaim(request.params?.success !== false);
        sendSimulateAck(ws, 'reward', request.params?.success !== false ? 'Reward claim simulated' : 'Reward failure simulated');
        break;

      default:
        sendSimulateAck(ws, 'error', `Unknown simulation action: ${request.action}`);
    }
  } catch (error) {
    logger.error({ error, action: request.action }, 'Simulation failed');
    sendSimulateAck(ws, 'error', `Simulation failed: ${error}`);
  }
}

/**
 * Send simulation acknowledgment back to client
 */
function sendSimulateAck(ws: WebSocket, action: string, message: string): void {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: 'SIMULATE_ACK',
      timestamp: Date.now(),
      data: { action, message },
    }));
  }
}

/**
 * Handle HTTP API simulation requests
 *
 * API Endpoints:
 * POST /api/simulate/scan - Simulate token scan
 * POST /api/simulate/reject - Simulate token rejection
 * POST /api/simulate/buy - Simulate buy trade
 * POST /api/simulate/sell - Simulate sell (body: { isProfit: boolean })
 * POST /api/simulate/buyback - Simulate buyback
 * POST /api/simulate/mood - Simulate mood change (body: { mood: string })
 * POST /api/simulate/reward - Simulate reward claim (body: { success: boolean })
 */
function handleSimulateAPI(
  pathname: string,
  params: Record<string, any>,
  eventEmitter: AgentEventEmitter,
  res: import('http').ServerResponse
): void {
  const action = pathname.replace('/api/simulate/', '');

  try {
    let message = '';

    switch (action) {
      case 'scan':
        simulateScan();
        message = 'Token scan simulated';
        break;

      case 'reject':
        simulateReject();
        message = 'Token rejection simulated';
        break;

      case 'buy':
        simulateBuy();
        message = 'Buy trade simulated';
        break;

      case 'sell':
        simulateSell(params?.isProfit !== false);
        message = params?.isProfit !== false ? 'Take-profit simulated' : 'Stop-loss simulated';
        break;

      case 'buyback':
        simulateBuyback();
        message = 'Buyback simulated';
        break;

      case 'mood':
        simulateMoodChange(params?.mood);
        message = `Mood change simulated: ${params?.mood || 'random'}`;
        break;

      case 'reward':
        simulateRewardClaim(params?.success !== false);
        message = params?.success !== false ? 'Reward claim simulated' : 'Reward failure simulated';
        break;

      default:
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: `Unknown simulation action: ${action}` }));
        return;
    }

    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ success: true, action, message }));
    logger.info({ action, message }, 'HTTP API simulation executed');

  } catch (error) {
    logger.error({ error, action }, 'HTTP API simulation failed');
    res.writeHead(500, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: `Simulation failed: ${error}` }));
  }
}
</file>

<file path="src/events/types.ts">
/**
 * Event type definitions for agent actions
 *
 * PRODUCTION EVENT SCHEMA:
 * Every event MUST include:
 * - timestamp: number
 * - eventType: The specific event type
 * - reasoning: Human-readable explanation of WHY this happened
 * - logs: Array of debug/context strings
 */

import type { TradeDecision } from '../trading/trading-engine.js';
import type { TokenSafetyResult } from '../analysis/types.js';

/**
 * Base event structure - ALL events inherit this
 */
interface BaseEvent {
  type: string;
  timestamp: number;
}

/**
 * Rich event data that provides frontend observability
 */
export interface RichEventData {
  reasoning: string;      // WHY this happened (human readable)
  logs: string[];         // Context/debug breadcrumbs
  tokenSymbol?: string;   // Token symbol if applicable
  mint?: string;          // Token mint if applicable
  pnlPercent?: number;    // PnL if applicable
  moodState?: string;     // Agent mood if relevant
}

/**
 * All possible agent events
 */
export type AgentEvent =
  | AnalysisStartEvent
  | SafetyCheckEvent
  | SmartMoneyCheckEvent
  | TradeDecisionEvent
  | TradeExecutedEvent
  | BuybackTriggeredEvent
  | BuybackFailedEvent
  | FeeClaimedEvent
  | StatsUpdateEvent
  | StopLossEvent
  | TakeProfitEvent
  | SchizoSpeaksEvent
  | SchizoCommentaryEvent
  | SchizoLearningEvent
  | ChatReceivedEvent
  | ChatResponseEvent
  | VoiceAudioEvent
  | TokenDiscoveredEvent
  | TokenCommentaryEvent
  | AnalysisThoughtEvent
  | CopyTradeSignalEvent
  | MoodChangeEvent
  | PositionsUpdateEvent
  | ScanEvent
  | RejectEvent
  | RewardClaimedEvent
  | RewardFailedEvent
  | ShillReceivedEvent
  | ShillRoastEvent
  | ShillBuyEvent
  | SchizoTokenUpdateEvent
  | WalletTransactionEvent;

/**
 * Token scan initiated (even if rejected)
 */
export interface ScanEvent extends BaseEvent {
  type: 'SCAN';
  data: RichEventData & {
    mint: string;
    symbol: string;
    name?: string;
    source: 'PUMP_PORTAL' | 'PUMP_FUN' | 'BIRDEYE' | 'MORALIS' | 'DEXSCREENER' | 'GECKOTERMINAL' | 'SNIPER_PIPELINE';
    liquidity?: number;
    marketCap?: number;
  };
}

/**
 * Token explicitly rejected with reason
 */
export interface RejectEvent extends BaseEvent {
  type: 'REJECT';
  data: RichEventData & {
    mint: string;
    symbol: string;
    rejectReason: string;
    stage: 'filter' | 'safety' | 'liquidity' | 'concentration' | 'circuit_breaker' | 'validation';
  };
}

/**
 * Reward claimed from protocol (creator fees, referrals)
 */
export interface RewardClaimedEvent extends BaseEvent {
  type: 'REWARD_CLAIMED';
  data: RichEventData & {
    signature: string;
    amountSol: number;
    source: 'pump_creator' | 'pump_referral' | 'meteora_dbc';
  };
}

/**
 * Reward claim failed
 */
export interface RewardFailedEvent extends BaseEvent {
  type: 'REWARD_FAILED';
  data: RichEventData & {
    source: 'pump_creator' | 'pump_referral' | 'meteora_dbc';
    error: string;
  };
}

/**
 * Buyback execution failed
 */
export interface BuybackFailedEvent extends BaseEvent {
  type: 'BUYBACK_FAILED';
  data: RichEventData & {
    profitSol: number;
    attemptedAmount: number;
    error: string;
  };
}

/**
 * Copy trade signal detected
 */
export interface CopyTradeSignalEvent extends BaseEvent {
  type: 'COPY_TRADE_SIGNAL';
  data: {
    mint: string;
    sourceWallet: string;
    signature: string;
    solSpent: number;
  };
}

/**
 * Analysis started for a token
 */
export interface AnalysisStartEvent extends BaseEvent {
  type: 'ANALYSIS_START';
  data: {
    mint: string;
    symbol?: string;
    name?: string;
  };
}

/**
 * Token safety check completed
 */
export interface SafetyCheckEvent extends BaseEvent {
  type: 'SAFETY_CHECK';
  data: {
    mint: string;
    result: TokenSafetyResult;
  };
}

/**
 * Smart money detection completed
 */
export interface SmartMoneyCheckEvent extends BaseEvent {
  type: 'SMART_MONEY_CHECK';
  data: {
    mint: string;
    count: number;
  };
}

/**
 * Trade decision made
 */
export interface TradeDecisionEvent extends BaseEvent {
  type: 'TRADE_DECISION';
  data: {
    mint: string;
    decision: TradeDecision;
    reasoning?: string;
  };
}

/**
 * Trade executed
 */
export interface TradeExecutedEvent extends BaseEvent {
  type: 'TRADE_EXECUTED';
  data: {
    mint: string;
    type: 'BUY' | 'SELL';
    signature: string;
    amount: number;
    reasoning?: string;
    logs?: string[];
  };
}

/**
 * Buyback triggered
 */
export interface BuybackTriggeredEvent extends BaseEvent {
  type: 'BUYBACK_TRIGGERED';
  data: {
    profit: number;
    amount: number;
    signature: string;
    reasoning?: string;
    logs?: string[];
  };
}

/**
 * Fee claimed event
 */
export interface FeeClaimedEvent extends BaseEvent {
  type: 'FEE_CLAIMED';
  data: {
    signature: string;
    pool: 'pump' | 'meteora-dbc';
  };
}

/**
 * Stats update (sent periodically)
 */
export interface StatsUpdateEvent extends BaseEvent {
  type: 'STATS_UPDATE';
  data: {
    todayTrades: number;
    openPositions: number;
    realizedPnL: number;    // Profit/loss from closed positions
    unrealizedPnL: number;  // Current value change of open positions
    dailyPnL: number;       // Backwards compat: same as realizedPnL
    winRate: number;
    totalBuybacks: number;
    totalBuybackSol?: number; // Total SOL spent on buybacks
    balance: number;
    // Entertainment mode stats
    mood?: string;              // Current mood (CONFIDENT, PARANOID, etc.)
    moodIntensity?: number;     // Mood intensity 0-1
    timeSinceLastTrade?: number; // Seconds since last trade
    tradesThisHour?: number;    // Number of trades this hour
    timePressure?: number;      // 0-1 time pressure level
  };
}

/**
 * Stop-loss triggered
 */
export interface StopLossEvent extends BaseEvent {
  type: 'STOP_LOSS';
  data: {
    mint: string;
    entryPrice: number;
    exitPrice: number;
    lossPercent: number;
    signature: string;
    reasoning?: string;
    logs?: string[];
  };
}

/**
 * Take-profit triggered
 */
export interface TakeProfitEvent extends BaseEvent {
  type: 'TAKE_PROFIT';
  data: {
    mint: string;
    entryPrice: number;
    exitPrice: number;
    profitPercent: number;
    signature: string;
    reasoning?: string;
    logs?: string[];
  };
}

/**
 * AI speaks (idle thought or greeting)
 */
export interface SchizoSpeaksEvent extends BaseEvent {
  type: 'SCHIZO_SPEAKS';
  data: {
    text: string;
  };
}

/**
 * AI commentary on market activity
 */
export interface SchizoCommentaryEvent extends BaseEvent {
  type: 'SCHIZO_COMMENTARY';
  data: {
    commentary: string;
    observation?: {
      type: string;
      description: string;
    };
  };
}

/**
 * AI learning insight
 */
export interface SchizoLearningEvent extends BaseEvent {
  type: 'SCHIZO_LEARNING';
  data: {
    insight: string;
    pattern?: {
      id: string;
      type: string;
      description: string;
    };
  };
}

/**
 * Chat message received from user
 */
export interface ChatReceivedEvent extends BaseEvent {
  type: 'CHAT_RECEIVED';
  data: {
    username?: string;
    message: string;
  };
}

/**
 * Chat response from AI
 */
export interface ChatResponseEvent extends BaseEvent {
  type: 'CHAT_RESPONSE';
  data: {
    username?: string;
    originalMessage: string;
    response: string;
  };
}

/**
 * Voice audio generated
 */
export interface VoiceAudioEvent extends BaseEvent {
  type: 'VOICE_AUDIO';
  data: {
    audio: string; // base64 encoded audio
    text: string;
  };
}

/**
 * New token discovered with enriched metadata
 */
export interface TokenDiscoveredEvent extends BaseEvent {
  type: 'TOKEN_DISCOVERED';
  data: {
    mint: string;
    name: string;
    symbol: string;
    priceUsd: number;
    priceChange5m: number;
    priceChange1h: number;
    priceChange24h?: number;
    volume1h: number;
    volume24h?: number;
    liquidity: number;
    marketCap: number;
    buys5m: number;
    sells5m: number;
    ageMinutes?: number;
    dexUrl: string;
    imageUrl?: string;
    marketCapSol?: number;
    source?: 'new' | 'trending' | string;
  };
}

/**
 * AI commentary on a specific token
 */
export interface TokenCommentaryEvent extends BaseEvent {
  type: 'TOKEN_COMMENTARY';
  data: {
    mint: string;
    symbol: string;
    commentary: string;
    isSillyName?: boolean;
    sillyCategory?: string;
  };
}

/**
 * SCHIZO's live analysis thoughts (spoken out loud)
 */
export interface AnalysisThoughtEvent extends BaseEvent {
  type: 'ANALYSIS_THOUGHT';
  data: {
    mint: string;
    symbol: string;
    name?: string;
    marketCapSol?: number;
    liquidity?: number;
    priceChange5m?: number;
    stage: 'scanning' | 'safety' | 'smart_money' | 'decision';
    thought: string;
    details?: {
      isSafe?: boolean;
      risks?: string[];
      smartMoneyCount?: number;
      shouldTrade?: boolean;
      reasons?: string[];
    };
  };
}

/**
 * Mood changed
 */
export interface MoodChangeEvent extends BaseEvent {
  type: 'MOOD_CHANGE';
  data: {
    previous: string;
    current: string;
    intensity: number;
    trigger?: string;
    reasoning?: string;
    logs?: string[];
  };
}

/**
 * Current positions/holdings update
 */
export interface PositionsUpdateEvent extends BaseEvent {
  type: 'POSITIONS_UPDATE';
  data: {
    positions: Array<{
      tokenMint: string;
      tokenSymbol?: string;
      tokenName?: string;
      tokenImage?: string;
      entryAmountSol: number;
      entryAmountTokens: number;
      entryPrice: number;
      entryTimestamp: number;
      currentPrice?: number;
      unrealizedPnLPercent?: number;
    }>;
  };
}

/**
 * Shill received from viewer burning $SCHIZO
 */
export interface ShillReceivedEvent extends BaseEvent {
  type: 'SHILL_RECEIVED';
  data: RichEventData & {
    senderWallet: string;
    contractAddress: string;
    schizoAmountBurned: number;
  };
}

/**
 * Shill rejected with roast
 */
export interface ShillRoastEvent extends BaseEvent {
  type: 'SHILL_ROAST';
  data: RichEventData & {
    senderWallet: string;
    contractAddress: string;
    roastMessage: string;
    risks: string[];
  };
}

/**
 * Shill accepted with lotto buy
 */
export interface ShillBuyEvent extends BaseEvent {
  type: 'SHILL_BUY';
  data: RichEventData & {
    senderWallet: string;
    contractAddress: string;
    buySignature: string;
    positionSizeSol: number;
  };
}

/**
 * $SCHIZO token live data update
 */
export interface SchizoTokenUpdateEvent extends BaseEvent {
  type: 'SCHIZO_TOKEN_UPDATE';
  data: {
    ca: string;
    price: number;
    priceChange24h: number;
    priceChange1h: number;
    marketCap: number;
    volume24h: number;
    liquidity: number;
    holders?: number;
    live: boolean;
    dexUrl?: string;
    imageUrl?: string;
  };
}

/**
 * Real-time wallet transaction from Helius webhook
 */
export interface WalletTransactionEvent extends BaseEvent {
  type: 'WALLET_TRANSACTION';
  data: {
    signature: string;
    slot: number;
    timestamp: number;
    type: 'TRANSFER' | 'SWAP' | 'TOKEN_MINT' | 'TOKEN_BURN' | 'UNKNOWN';
    description: string;
    accountData: Array<{
      account: string;
      nativeBalanceChange: number;
      tokenBalanceChanges?: Array<{
        mint: string;
        rawTokenAmount: {
          tokenAmount: string;
          decimals: number;
        };
      }>;
    }>;
  };
}
</file>

<file path="public/styles.css">
/* Glassmorphism Theme - $SCHIZO */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background: linear-gradient(135deg, #0a0f0f 0%, #0d1a1a 50%, #0a1212 100%);
    background-attachment: fixed;
    color: #8cdbc7;
    font-family: 'Courier New', 'Courier', monospace;
    padding: 30px 40px;
    line-height: 1.6;
    min-height: 100vh;
}

/* Subtle background pattern */
body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background:
        radial-gradient(ellipse at 20% 20%, rgba(140, 219, 199, 0.03) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(140, 219, 199, 0.02) 0%, transparent 50%);
    pointer-events: none;
    z-index: -1;
}

/* Scanlines Overlay */
.scanlines {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to bottom,
            rgba(255, 255, 255, 0),
            rgba(255, 255, 255, 0) 50%,
            rgba(0, 0, 0, 0.2) 50%,
            rgba(0, 0, 0, 0.2));
    background-size: 100% 4px;
    z-index: 1000;
    pointer-events: none;
    opacity: 0.15;
}

/* Glass Panel Base */
.glass {
    background: rgba(13, 25, 25, 0.6);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(140, 219, 199, 0.2);
    border-radius: 16px;
    box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(140, 219, 199, 0.1);
}

/* Header */
header {
    margin-bottom: 40px;
    padding-bottom: 30px;
    border-bottom: 1px solid rgba(140, 219, 199, 0.2);
    position: relative;
}

.header-grid {
    display: grid;
    grid-template-columns: 320px 1fr 320px;
    gap: 60px;
    align-items: center;
    margin: 0 auto;
    padding: 0 40px;
}

.header-center {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    position: relative;
    z-index: 2;
}

.header-left,
.header-right {
    display: flex;
    align-items: center;
}

.header-left {
    justify-content: flex-start;
}

.header-right {
    justify-content: flex-end;
}

.header-logo {
    width: 120px;
    height: 120px;
    margin-bottom: 15px;
    filter: drop-shadow(0 0 20px rgba(140, 219, 199, 0.3));
    transition: transform 0.1s ease;
    /* Faster transition for eye tracking */
}

/* Glitch Effect */
@keyframes glitch-anim-1 {
    0% {
        clip-path: inset(20% 0 80% 0);
        transform: translate(-2px, 1px);
    }

    20% {
        clip-path: inset(60% 0 10% 0);
        transform: translate(2px, -1px);
    }

    40% {
        clip-path: inset(40% 0 50% 0);
        transform: translate(-2px, 2px);
    }

    60% {
        clip-path: inset(80% 0 5% 0);
        transform: translate(2px, -2px);
    }

    80% {
        clip-path: inset(10% 0 60% 0);
        transform: translate(-1px, 1px);
    }

    100% {
        clip-path: inset(30% 0 30% 0);
        transform: translate(1px, -1px);
    }
}

@keyframes glitch-anim-2 {
    0% {
        clip-path: inset(10% 0 60% 0);
        transform: translate(2px, -1px);
    }

    20% {
        clip-path: inset(80% 0 5% 0);
        transform: translate(-2px, 2px);
    }

    40% {
        clip-path: inset(30% 0 20% 0);
        transform: translate(2px, 1px);
    }

    60% {
        clip-path: inset(15% 0 80% 0);
        transform: translate(-1px, -2px);
    }

    80% {
        clip-path: inset(55% 0 10% 0);
        transform: translate(1px, 2px);
    }

    100% {
        clip-path: inset(40% 0 30% 0);
        transform: translate(-2px, 1px);
    }
}

.glitch {
    font-size: 3.5em;
    color: #8cdbc7;
    position: relative;
    letter-spacing: 4px;
    margin-bottom: 8px;
}

.glitch::before,
.glitch::after {
    content: attr(data-text);
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #0d1a1a;
    /* Match background to hide original somewhat */
}

.glitch::before {
    left: 2px;
    text-shadow: -1px 0 #ff00c1;
    clip-path: inset(0 0 0 0);
    animation: glitch-anim-1 2s infinite linear alternate-reverse;
}

.glitch::after {
    left: -2px;
    text-shadow: -1px 0 #00fff9;
    clip-path: inset(0 0 0 0);
    animation: glitch-anim-2 3s infinite linear alternate-reverse;
}

.tagline {
    color: rgba(140, 219, 199, 0.7);
    font-size: 1.1em;
    letter-spacing: 2px;
    text-transform: uppercase;
}

/* Terminal Window */
#terminal-window {
    width: 100%;
    height: 220px;
    background: rgba(10, 10, 10, 0.9);
    border: 1px solid #333;
    border-radius: 6px;
    font-family: 'Courier New', monospace;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(5px);
}

.terminal-header {
    background: #1a1a1a;
    padding: 6px 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #333;
}

.terminal-title {
    color: #8cdbc7;
    font-size: 0.75em;
    opacity: 0.7;
}

.terminal-controls {
    display: flex;
    gap: 6px;
}

.control {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #333;
}

#terminal-content {
    padding: 12px;
    color: #4ade80;
    font-size: 0.8em;
    line-height: 1.4;
    flex: 1;
    overflow-y: hidden;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    font-family: 'Consolas', 'Monaco', monospace;
    text-shadow: 0 0 5px rgba(74, 222, 128, 0.4);
}

.terminal-line {
    margin-bottom: 4px;
    word-break: break-all;
}

/* $SCHIZO Token Card */
#schizo-token-card {
    position: relative;
    /* Reset from absolute */
    top: auto;
    right: auto;
    background: rgba(13, 25, 25, 0.6);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(140, 219, 199, 0.2);
    border-radius: 14px;
    padding: 14px 16px;
    width: 100%;
    max-width: 280px;
    box-shadow:
        0 4px 20px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(140, 219, 199, 0.1);
    text-align: left;
}

.token-card-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 14px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(140, 219, 199, 0.1);
}

.token-card-img {
    width: 38px;
    height: 38px;
    border-radius: 50%;
    border: 2px solid rgba(140, 219, 199, 0.3);
    filter: drop-shadow(0 0 10px rgba(140, 219, 199, 0.3));
}

.token-card-title {
    display: flex;
    flex-direction: column;
}

.token-card-name {
    font-size: 1.2em;
    font-weight: bold;
    color: #8cdbc7;
    text-shadow: 0 0 10px rgba(140, 219, 199, 0.3);
}

.token-card-status {
    font-size: 0.75em;
    color: #f59e0b;
    text-transform: uppercase;
    letter-spacing: 1px;
    background: rgba(245, 158, 11, 0.15);
    padding: 2px 8px;
    border-radius: 10px;
    width: fit-content;
    margin-top: 2px;
}

.token-card-status.live {
    color: #4ade80;
    background: rgba(74, 222, 128, 0.15);
}

.token-card-stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-bottom: 14px;
}

.token-card-stat {
    display: flex;
    flex-direction: column;
    background: rgba(0, 0, 0, 0.2);
    padding: 8px 10px;
    border-radius: 8px;
}

.token-card-stat .stat-label {
    font-size: 0.7em;
    color: rgba(140, 219, 199, 0.6);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 2px;
}

.token-card-stat .stat-value {
    font-size: 1em;
    font-weight: bold;
    color: #8cdbc7;
}

.token-card-actions {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.btn-primary {
    flex: 2;
    background: #4ade80;
    /* Neon Green */
    color: #000;
    text-align: center;
    padding: 12px;
    border-radius: 8px;
    font-weight: 900;
    text-decoration: none;
    text-transform: uppercase;
    font-size: 1.1em;
    transition: all 0.2s;
    box-shadow: 0 0 15px rgba(74, 222, 128, 0.3);
    border: 1px solid #22c55e;
}

.btn-primary:hover {
    background: #22c55e;
    transform: translateY(-2px);
    box-shadow: 0 0 25px rgba(74, 222, 128, 0.5);
}

.secondary-actions {
    display: flex;
    gap: 8px;
    flex: 1;
}

.btn-icon {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(140, 219, 199, 0.1);
    border: 1px solid rgba(140, 219, 199, 0.2);
    border-radius: 8px;
    color: rgba(140, 219, 199, 0.7);
    transition: all 0.2s;
    text-decoration: none;
}

.btn-icon:hover {
    background: rgba(140, 219, 199, 0.2);
    color: #8cdbc7;
    border-color: rgba(140, 219, 199, 0.4);
}

.token-card-footer {
    border-top: 1px solid rgba(140, 219, 199, 0.1);
    padding-top: 12px;
}

.ca-input-container {
    position: relative;
    width: 100%;
}

#schizo-ca-input {
    width: 100%;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(140, 219, 199, 0.2);
    color: rgba(140, 219, 199, 0.7);
    padding: 10px;
    font-family: monospace;
    font-size: 0.9em;
    border-radius: 6px;
    outline: none;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
}

#schizo-ca-input:hover,
#schizo-ca-input:focus {
    border-color: rgba(140, 219, 199, 0.5);
    color: #8cdbc7;
    background: rgba(0, 0, 0, 0.5);
}

.copy-hint {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.6em;
    color: rgba(140, 219, 199, 0.4);
    pointer-events: none;
}

h2 {
    color: #8cdbc7;
    margin-bottom: 15px;
    font-size: 1.2em;
    letter-spacing: 1px;
    text-transform: uppercase;
    opacity: 0.9;
}

/* Stats Section */
#stats {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 15px;
    margin-bottom: 30px;
}

.stat {
    background: rgba(13, 25, 25, 0.5);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(140, 219, 199, 0.15);
    padding: 20px 15px;
    text-align: center;
    border-radius: 16px;
    box-shadow:
        0 4px 20px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(140, 219, 199, 0.1);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.stat::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(140, 219, 199, 0.3), transparent);
}

.stat:hover {
    transform: translateY(-2px);
    border-color: rgba(140, 219, 199, 0.3);
    box-shadow:
        0 8px 30px rgba(0, 0, 0, 0.3),
        0 0 20px rgba(140, 219, 199, 0.1);
}

.stat label {
    display: block;
    color: rgba(140, 219, 199, 0.6);
    font-size: 0.75em;
    margin-bottom: 8px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.stat span {
    display: block;
    font-size: 1.8em;
    font-weight: bold;
    color: #8cdbc7;
    text-shadow: 0 0 10px rgba(140, 219, 199, 0.3);
}

.status-connected {
    color: #8cdbc7 !important;
    text-shadow: 0 0 15px rgba(140, 219, 199, 0.5) !important;
}

.status-disconnected {
    color: #ff6b6b !important;
    text-shadow: 0 0 10px rgba(255, 107, 107, 0.3) !important;
}

/* PnL Display Colors */
.positive {
    color: #4ade80;
}

.negative {
    color: #f87171;
}

/* PnL Breakdown Styling */
/* #pnl font size inherited from .stat span */



/* Main Panels - Side by Side Layout */
#main-panels {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
}

/* Token Stream Section */
#token-stream-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 280px;
}

/* Feed Section */
#feed-container {
    flex: 1.5;
    display: flex;
    flex-direction: column;
}

/* Unified Panel Box Styling */
#token-stream-box,
#feed-box,
#chat-box {
    display: flex;
    flex-direction: column;
    background: rgba(13, 25, 25, 0.5);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(140, 219, 199, 0.15);
    border-radius: 16px;
    box-shadow:
        0 4px 20px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(140, 219, 199, 0.05);
    overflow: hidden;
    height: 450px;
}

/* Panel Header (unified for tokens, feed) */
.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 18px;
    font-size: 1.1em;
    font-weight: bold;
    color: #8cdbc7;
    text-transform: uppercase;
    letter-spacing: 1px;
    border-bottom: 1px solid rgba(140, 219, 199, 0.1);
    background: rgba(140, 219, 199, 0.05);
}

.panel-header span {
    display: flex;
    align-items: center;
    gap: 8px;
}

.panel-header button {
    padding: 6px 14px;
    font-size: 0.75em;
}

/* Panel Tabs */
.panel-tabs {
    display: flex;
    gap: 4px;
}

.panel-tab {
    padding: 6px 12px;
    font-size: 0.8em;
    background: transparent;
    border: 1px solid transparent;
    color: rgba(140, 219, 199, 0.5);
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.panel-tab:hover {
    color: rgba(140, 219, 199, 0.8);
    background: rgba(140, 219, 199, 0.05);
}

.panel-tab.active {
    color: #8cdbc7;
    background: rgba(140, 219, 199, 0.1);
    border-color: rgba(140, 219, 199, 0.3);
}

.panel-tab #holdings-count {
    font-size: 0.9em;
    opacity: 0.7;
}

/* Tab Content */
.tab-content {
    display: none;
    flex: 1;
    overflow-y: auto;
    padding: 15px;
}

.tab-content.active {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* Holdings Stream */
#holdings-stream {
    display: none;
}

#holdings-stream.active {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: stretch;
}

.holdings-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: rgba(140, 219, 199, 0.4);
    text-align: center;
    gap: 10px;
}

.holdings-empty-icon {
    opacity: 0.4;
    color: rgba(140, 219, 199, 0.6);
}

/* Holding Item */
.holding-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(10, 20, 20, 0.6);
    border: 1px solid rgba(74, 222, 128, 0.2);
    border-radius: 8px;
    padding: 12px 14px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.holding-item:hover {
    border-color: rgba(74, 222, 128, 0.5);
    background: rgba(15, 30, 30, 0.7);
    box-shadow: 0 0 15px rgba(74, 222, 128, 0.1);
}

.holding-left {
    display: flex;
    align-items: center;
    gap: 12px;
}

.holding-icon {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: rgba(74, 222, 128, 0.15);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #4ade80;
    font-size: 1.1em;
    border: 1px solid rgba(74, 222, 128, 0.3);
    overflow: hidden;
    flex-shrink: 0;
}

.holding-token-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
}

.holding-icon-fallback {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2em;
}

.holding-info {
    display: flex;
    flex-direction: column;
}

.holding-symbol {
    font-weight: bold;
    color: #8cdbc7;
    font-size: 1em;
}

.holding-name {
    font-size: 0.8em;
    color: rgba(140, 219, 199, 0.7);
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.holding-ca {
    font-size: 0.7em;
    color: rgba(140, 219, 199, 0.4);
    font-family: monospace;
    cursor: pointer;
}

.holding-ca:hover {
    color: #8cdbc7;
}

.holding-right {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 2px;
}

.holding-value {
    font-weight: bold;
    color: #8cdbc7;
    font-size: 0.95em;
}

.holding-pnl {
    font-size: 0.8em;
    font-weight: bold;
}

.holding-pnl.profit {
    color: #4ade80;
}

.holding-pnl.loss {
    color: #f87171;
}

.holding-entry {
    font-size: 0.7em;
    color: rgba(140, 219, 199, 0.5);
}

/* Buttons */
button {
    background: rgba(140, 219, 199, 0.1);
    color: #8cdbc7;
    border: 1px solid rgba(140, 219, 199, 0.3);
    padding: 10px 20px;
    cursor: pointer;
    font-family: inherit;
    font-size: 0.85em;
    border-radius: 8px;
    font-weight: bold;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
    backdrop-filter: blur(5px);
}

button:hover {
    background: rgba(140, 219, 199, 0.2);
    border-color: rgba(140, 219, 199, 0.5);
    box-shadow: 0 0 20px rgba(140, 219, 199, 0.2);
    transform: translateY(-1px);
}

button:active {
    transform: translateY(0);
}

/* Feed Content Area */
#feed {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
}

/* Token Stream Content Area */
#token-stream {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.event {
    padding: 10px 12px;
    margin-bottom: 8px;
    border-radius: 8px;
    background: rgba(140, 219, 199, 0.03);
    border-left: 2px solid rgba(140, 219, 199, 0.2);
    animation: slideIn 0.3s ease;
    transition: background 0.2s ease;
}

.event:hover {
    background: rgba(140, 219, 199, 0.06);
}

.event:last-child {
    margin-bottom: 0;
}

.event .timestamp {
    color: rgba(140, 219, 199, 0.5);
    font-size: 0.75em;
    margin-right: 10px;
}

.event.analysis {
    color: rgba(140, 219, 199, 0.8);
    border-left-color: rgba(140, 219, 199, 0.3);
}

.event.safety {
    color: #ff9f6b;
    border-left-color: rgba(255, 159, 107, 0.5);
    background: rgba(255, 159, 107, 0.05);
}

.event.decision {
    color: #8cdbc7;
    font-weight: bold;
    border-left-color: #8cdbc7;
}

.event.trade {
    color: #8cdbc7;
    font-weight: bold;
    border-left-color: #8cdbc7;
    background: rgba(140, 219, 199, 0.08);
    text-shadow: 0 0 5px rgba(140, 219, 199, 0.3);
}

.event.buyback {
    color: #ff9f6b;
    font-weight: bold;
    border-left-color: #ff9f6b;
    background: rgba(255, 159, 107, 0.08);
}

.event.error {
    color: #ff6b6b;
    border-left-color: #ff6b6b;
    background: rgba(255, 107, 107, 0.05);
}

.event.stop-loss {
    color: #ff6b6b;
    font-weight: bold;
    border-left-color: #ff6b6b;
    background: rgba(255, 107, 107, 0.08);
}

.event.take-profit {
    color: #8cdbc7;
    font-weight: bold;
    border-left-color: #8cdbc7;
    background: rgba(140, 219, 199, 0.1);
    text-shadow: 0 0 8px rgba(140, 219, 199, 0.4);
}

/* Live Analysis Thoughts */
.event.analysis-scanning {
    color: #b8a9ff;
    border-left-color: rgba(184, 169, 255, 0.6);
    background: rgba(184, 169, 255, 0.06);
    font-style: italic;
}

.event.analysis-safety {
    color: #ffb86b;
    border-left-color: rgba(255, 184, 107, 0.6);
    background: rgba(255, 184, 107, 0.06);
    font-style: italic;
}

.event.analysis-smart_money {
    color: #6bcfff;
    border-left-color: rgba(107, 207, 255, 0.6);
    background: rgba(107, 207, 255, 0.06);
    font-style: italic;
}

.event.analysis-decision {
    color: #8cdbc7;
    font-weight: bold;
    border-left-color: #8cdbc7;
    background: rgba(140, 219, 199, 0.1);
    text-shadow: 0 0 5px rgba(140, 219, 199, 0.3);
    font-style: normal;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateX(-10px);
    }

    to {
        opacity: 1;
        transform: translateX(0);
    }
}

/* Chat Section */
#chat-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 300px;
}

#chat-header {
    padding: 15px 18px;
    font-size: 1.1em;
    font-weight: bold;
    color: #8cdbc7;
    text-transform: uppercase;
    letter-spacing: 1px;
    border-bottom: 1px solid rgba(140, 219, 199, 0.1);
    background: rgba(140, 219, 199, 0.05);
}

#chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
}

#chat-input-area {
    display: flex;
    gap: 10px;
    padding: 12px 15px;
    border-top: 1px solid rgba(140, 219, 199, 0.1);
    background: rgba(0, 0, 0, 0.1);
}

.chat-msg {
    padding: 10px 12px;
    margin-bottom: 8px;
    border-radius: 8px;
    animation: slideIn 0.3s ease;
}

.chat-msg:last-child {
    margin-bottom: 0;
}

.chat-msg .timestamp {
    color: rgba(140, 219, 199, 0.5);
    font-size: 0.75em;
    margin-right: 10px;
}

.chat-msg.user-message {
    color: rgba(170, 170, 170, 0.9);
    background: rgba(100, 100, 100, 0.1);
    border-left: 2px solid rgba(170, 170, 170, 0.3);
}

.chat-msg.schizo-response {
    color: #8cdbc7;
    font-weight: bold;
    background: rgba(140, 219, 199, 0.1);
    border-left: 2px solid #8cdbc7;
}

/* Typing indicator */
.chat-msg.typing-indicator {
    color: rgba(140, 219, 199, 0.6);
    font-style: italic;
    background: transparent;
    border-left: 2px solid rgba(140, 219, 199, 0.3);
}

.typing-dots span {
    animation: typingDot 1.4s infinite;
    animation-fill-mode: both;
}

.typing-dots span:nth-child(2) {
    animation-delay: 0.2s;
}

.typing-dots span:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes typingDot {

    0%,
    80%,
    100% {
        opacity: 0;
    }

    40% {
        opacity: 1;
    }
}

#chatInput {
    flex: 1;
    background: rgba(0, 0, 0, 0.3);
    color: #8cdbc7;
    border: 1px solid rgba(140, 219, 199, 0.2);
    padding: 10px 14px;
    font-family: inherit;
    font-size: 0.9em;
    border-radius: 8px;
    outline: none;
    transition: all 0.3s ease;
}

#chatInput:focus {
    border-color: rgba(140, 219, 199, 0.4);
    box-shadow: 0 0 15px rgba(140, 219, 199, 0.1);
}

#chatInput::placeholder {
    color: rgba(140, 219, 199, 0.4);
}

#sendBtn {
    min-width: 80px;
}

/* Trades Table */
#trades-container {
    margin-bottom: 30px;
}

table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    background: rgba(13, 25, 25, 0.5);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(140, 219, 199, 0.15);
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
}

th,
td {
    padding: 14px 16px;
    text-align: left;
    border-bottom: 1px solid rgba(140, 219, 199, 0.1);
}

th {
    background: rgba(140, 219, 199, 0.08);
    color: rgba(140, 219, 199, 0.8);
    font-weight: bold;
    text-transform: uppercase;
    font-size: 0.8em;
    letter-spacing: 1px;
}

tbody tr {
    transition: background 0.2s ease;
}

tbody tr:hover {
    background: rgba(140, 219, 199, 0.05);
}

tbody tr:last-child td {
    border-bottom: none;
}

.trade-buy {
    color: #8cdbc7;
    font-weight: bold;
}

.trade-sell {
    color: #ff9f6b;
    font-weight: bold;
}

td a {
    color: rgba(140, 219, 199, 0.7);
    text-decoration: none;
    transition: color 0.2s ease;
}

td a:hover {
    color: #8cdbc7;
    text-decoration: underline;
}

/* Scrollbar Styling */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: rgba(13, 20, 20, 0.3);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: rgba(140, 219, 199, 0.3);
    border-radius: 4px;
    transition: background 0.2s ease;
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(140, 219, 199, 0.5);
}

/* AI Personality Events */
.event.schizo-speaks {
    color: #ff9f6b;
    font-weight: bold;
    background: rgba(255, 159, 107, 0.08);
    border-left-color: #ff9f6b;
}

.event.commentary {
    color: rgba(140, 219, 199, 0.85);
    font-style: italic;
    border-left-color: rgba(140, 219, 199, 0.3);
}

.event.learning {
    color: #ffcc00;
    font-weight: bold;
    border-left-color: #ffcc00;
    background: rgba(255, 204, 0, 0.08);
}

.event.chat-message {
    color: #aaa;
    border-left-color: rgba(170, 170, 170, 0.3);
}

.event.chat-response {
    color: #8cdbc7;
    font-weight: bold;
    background: rgba(140, 219, 199, 0.08);
    border-left-color: #8cdbc7;
}

/* Responsive */
@media (max-width: 1200px) {
    #stats {
        grid-template-columns: repeat(2, 1fr);
    }

    #main-panels {
        flex-wrap: wrap;
    }

    #token-stream-section,
    #feed-container {
        flex: 1 1 45%;
    }

    #chat-container {
        flex: 1 1 100%;
        order: 3;
        margin-top: 0;
    }

    #token-stream-box,
    #feed-box,
    #chat-box {
        height: 350px;
    }
}

@media (max-width: 900px) {
    body {
        padding: 20px;
    }

    #schizo-token-card {
        position: relative;
        min-width: unset;
        width: 100%;
        margin-top: 20px;
    }

    .header-grid {
        grid-template-columns: 1fr;
        gap: 30px;
    }

    .header-left,
    .header-center,
    .header-right {
        justify-content: center;
    }

    #schizo-token-card {
        width: 100%;
        max-width: 400px;
    }

    #terminal-window {
        max-width: 400px;
    }

    #token-stream-box,
    #feed-box,
    #chat-box {
        height: 300px;
    }

    #chat-header,
    .panel-header {
        padding: 12px 15px;
        font-size: 1em;
    }

    #stats {
        grid-template-columns: repeat(2, 1fr);
    }

    h1 {
        font-size: 2.5em;
    }
}

@media (max-width: 500px) {
    #stats {
        grid-template-columns: 1fr;
    }

    .stat span {
        font-size: 1.5em;
    }
}

/* Current Token Card */
#current-token {
    margin-bottom: 20px;
}

.token-card {
    display: flex;
    align-items: center;
    gap: 15px;
    background: rgba(13, 25, 25, 0.6);
    border: 1px solid rgba(140, 219, 199, 0.2);
    border-radius: 12px;
    padding: 15px 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.token-card:hover {
    border-color: rgba(140, 219, 199, 0.5);
    box-shadow: 0 0 20px rgba(140, 219, 199, 0.15);
    transform: translateY(-2px);
}

.token-card.empty {
    cursor: default;
    opacity: 0.6;
}

.token-card.empty:hover {
    transform: none;
    box-shadow: none;
}

.token-img {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid rgba(140, 219, 199, 0.3);
}

.token-img-placeholder {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(140, 219, 199, 0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #8cdbc7;
    font-size: 1.5em;
    border: 2px solid rgba(140, 219, 199, 0.3);
}

.token-info {
    flex: 1;
}

.token-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 4px;
}

.token-symbol {
    font-size: 1.3em;
    font-weight: bold;
    color: #8cdbc7;
}

.token-age {
    font-size: 0.8em;
    color: rgba(140, 219, 199, 0.6);
    background: rgba(140, 219, 199, 0.1);
    padding: 2px 8px;
    border-radius: 10px;
}

.token-name {
    font-size: 0.85em;
    color: rgba(140, 219, 199, 0.7);
    margin-bottom: 6px;
}

.token-price {
    font-size: 1.1em;
    font-weight: bold;
    color: #8cdbc7;
}

.token-change {
    font-size: 0.9em;
    font-weight: bold;
}

.token-change.price-up {
    color: #4ade80;
}

.token-change.price-down {
    color: #f87171;
}

.token-stats {
    display: flex;
    gap: 15px;
    margin-top: 6px;
    font-size: 0.85em;
    color: rgba(140, 219, 199, 0.7);
}

.token-txns {
    display: flex;
    gap: 10px;
    margin-top: 4px;
    font-size: 0.85em;
}

.token-txns .buys {
    color: #4ade80;
}

.token-txns .sells {
    color: #f87171;
}

.chart-hint {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.75em;
    color: rgba(140, 219, 199, 0.4);
    opacity: 0;
    transition: opacity 0.3s;
}

.token-card:hover .chart-hint {
    opacity: 1;
}

/* Chart Popup */
.popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    backdrop-filter: blur(5px);
}

.popup-overlay.visible {
    display: flex;
}

.popup-content {
    width: 90%;
    max-width: 1200px;
    height: 80vh;
    background: #0d1414;
    border: 1px solid rgba(140, 219, 199, 0.3);
    border-radius: 12px;
    position: relative;
    overflow: hidden;
}

.popup-close {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 36px;
    height: 36px;
    background: rgba(140, 219, 199, 0.2);
    border: 1px solid rgba(140, 219, 199, 0.3);
    border-radius: 50%;
    color: #8cdbc7;
    font-size: 1.2em;
    cursor: pointer;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s;
}

.popup-close:hover {
    background: rgba(140, 219, 199, 0.4);
}

#chart-iframe {
    width: 100%;
    height: 100%;
    border: none;
}

/* Token Stream Items */

.token-stream-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(10, 20, 20, 0.6);
    border: 1px solid rgba(140, 219, 199, 0.15);
    border-radius: 8px;
    padding: 10px 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.token-stream-item:hover {
    border-color: rgba(140, 219, 199, 0.4);
    background: rgba(15, 30, 30, 0.7);
}

.token-stream-item.token-new {
    animation: tokenFlash 2s ease-out;
}

@keyframes tokenFlash {
    0% {
        background: rgba(140, 219, 199, 0.3);
        border-color: rgba(140, 219, 199, 0.6);
    }

    100% {
        background: rgba(10, 20, 20, 0.6);
        border-color: rgba(140, 219, 199, 0.15);
    }
}

.token-stream-item.token-commented {
    border-color: #f59e0b;
    background: rgba(245, 158, 11, 0.1);
}

.token-stream-left {
    display: flex;
    align-items: center;
    gap: 10px;
}

.token-stream-img {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
    border: 1px solid rgba(140, 219, 199, 0.2);
}

.token-stream-img-placeholder {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: rgba(140, 219, 199, 0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #8cdbc7;
    font-size: 0.9em;
    border: 1px solid rgba(140, 219, 199, 0.2);
}

.token-stream-info {
    display: flex;
    flex-direction: column;
}

.token-stream-symbol {
    font-weight: bold;
    color: #8cdbc7;
    font-size: 0.95em;
}

.token-stream-name {
    font-size: 0.75em;
    color: rgba(140, 219, 199, 0.6);
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.token-stream-right {
    display: flex;
    align-items: center;
    gap: 15px;
    font-size: 0.85em;
}

.token-stream-price {
    color: #8cdbc7;
    font-weight: bold;
}

.token-stream-mcap {
    color: rgba(140, 219, 199, 0.7);
}

.token-stream-change {
    font-weight: bold;
    min-width: 55px;
    text-align: right;
}

.token-stream-change.price-up {
    color: #4ade80;
}

.token-stream-change.price-down {
    color: #f87171;
}

/* Analyzing state */
.token-stream-item.analyzing {
    flex-wrap: wrap;
    border-color: rgba(255, 159, 107, 0.3);
    background: rgba(255, 159, 107, 0.05);
}

.token-stream-item.analyzing:hover {
    border-color: rgba(255, 159, 107, 0.5);
    background: rgba(255, 159, 107, 0.1);
}

.analyzing-pulse {
    animation: eyePulse 1.5s ease-in-out infinite;
    font-size: 1.2em !important;
}

@keyframes eyePulse {

    0%,
    100% {
        opacity: 1;
        transform: scale(1);
    }

    50% {
        opacity: 0.6;
        transform: scale(1.1);
    }
}

/* SCHIZO's thought bubble */
.analysis-thought {
    width: 100%;
    margin-top: 8px;
    padding: 6px 10px;
    background: rgba(255, 159, 107, 0.1);
    border-left: 2px solid rgba(255, 159, 107, 0.5);
    border-radius: 4px;
    font-size: 0.8em;
    color: rgba(255, 159, 107, 0.9);
    font-style: italic;
    line-height: 1.3;
}

/* Token commentary bubble */
.token-commentary-bubble {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(245, 158, 11, 0.9);
    color: #000;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 0.8em;
    max-width: 300px;
    white-space: normal;
    z-index: 10;
    animation: bubbleFadeIn 0.3s ease-out;
    margin-bottom: 5px;
}

.token-commentary-bubble::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 8px solid transparent;
    border-top-color: rgba(245, 158, 11, 0.9);
}

@keyframes bubbleFadeIn {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(10px);
    }

    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

/* ============================================
   SCHIZO 3D CHARACTER STYLES
   ============================================ */

/* 3D Container - In header left area */
#schizo-3d-container {
    width: 100%;
    height: 250px;
    background: transparent;
    display: flex;
    flex-direction: column;
    overflow: visible;
}

#schizo-3d-canvas {
    flex: 1;
    background: transparent;
    position: relative;
    border-radius: 12px;
    overflow: hidden;
}

#schizo-3d-canvas canvas {
    width: 100% !important;
    height: 100% !important;
    background: transparent !important;
}

/* Responsive */
@media (max-width: 900px) {
    #schizo-3d-container {
        height: 200px;
        max-width: 300px;
        margin: 0 auto;
    }
}

/* ============================================
   CLICK TO COPY CA STYLES
   ============================================ */

.clickable-ca {
    cursor: pointer;
    color: rgba(140, 219, 199, 0.7);
    font-family: monospace;
    font-size: 0.85em;
    padding: 2px 6px;
    background: rgba(140, 219, 199, 0.08);
    border: 1px solid rgba(140, 219, 199, 0.15);
    border-radius: 4px;
    transition: all 0.2s ease;
    display: inline-block;
}

.clickable-ca:hover {
    color: #8cdbc7;
    background: rgba(140, 219, 199, 0.15);
    border-color: rgba(140, 219, 199, 0.4);
    box-shadow: 0 0 10px rgba(140, 219, 199, 0.2);
}

.clickable-ca.copy-success {
    color: #4ade80 !important;
    background: rgba(74, 222, 128, 0.2) !important;
    border-color: rgba(74, 222, 128, 0.5) !important;
}

/* Token stream CA styling */
.token-stream-ca {
    margin-top: 2px;
}

/* Copy toast notification */
.copy-toast {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%) translateY(20px);
    background: rgba(74, 222, 128, 0.95);
    color: #000;
    padding: 12px 24px;
    border-radius: 8px;
    font-weight: bold;
    font-size: 0.9em;
    z-index: 10000;
    opacity: 0;
    transition: all 0.3s ease;
    box-shadow: 0 4px 20px rgba(74, 222, 128, 0.4);
}

.copy-toast.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}

/* Fixed About Button - Bottom Right */
.about-btn-fixed {
    position: fixed;
    bottom: 20px;
    right: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(20, 30, 30, 0.9);
    border: 1px solid var(--border);
    color: var(--text-secondary);
    padding: 10px 16px;
    border-radius: 20px;
    text-decoration: none;
    font-size: 0.85rem;
    z-index: 1000;
    transition: all 0.2s ease;
    backdrop-filter: blur(10px);
}

.about-btn-fixed:hover {
    background: rgba(30, 45, 45, 0.95);
    border-color: var(--accent);
    color: var(--accent);
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(78, 255, 205, 0.2);
}

.about-btn-fixed svg {
    flex-shrink: 0;
}

@media (max-width: 600px) {
    .about-btn-fixed span {
        display: none;
    }

    .about-btn-fixed {
        padding: 10px;
        border-radius: 50%;
    }
}

/* ============================================
   TRENCH RADIO STYLES
   ============================================ */

.trench-radio-panel {
    position: fixed;
    bottom: 20px;
    right: 140px;
    background: rgba(15, 25, 25, 0.95);
    border: 1px solid rgba(140, 219, 199, 0.3);
    border-radius: 24px;
    /* More pill-shaped */
    padding: 8px 20px;
    z-index: 1000;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 20px;
    min-width: 340px;
}

.trench-radio-panel:hover {
    border-color: rgba(140, 219, 199, 0.5);
    box-shadow: 0 0 20px rgba(140, 219, 199, 0.15);
}

.trench-radio-panel.active {
    border-color: var(--accent);
    box-shadow: 0 0 25px rgba(78, 255, 205, 0.2);
}

.trench-radio-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 0;
    flex-shrink: 0;
}

.trench-radio-title {
    font-size: 0.75em;
    font-weight: bold;
    color: var(--accent);
    letter-spacing: 1px;
    text-transform: uppercase;
}

.trench-radio-state {
    font-size: 0.65em;
    padding: 2px 8px;
    border-radius: 10px;
    background: rgba(140, 219, 199, 0.1);
    color: rgba(140, 219, 199, 0.6);
    font-weight: bold;
    letter-spacing: 1px;
    transition: all 0.3s ease;
}

.trench-radio-state.scanning {
    background: rgba(140, 219, 199, 0.2);
    color: var(--accent);
    animation: pulse-glow 2s infinite;
}

.trench-radio-state.position-up {
    background: rgba(74, 222, 128, 0.2);
    color: #4ade80;
    animation: pulse-green 0.5s infinite;
}

.trench-radio-state.position-down {
    background: rgba(248, 113, 113, 0.2);
    color: #f87171;
    animation: pulse-red 1s infinite;
}

.trench-radio-state.crash {
    background: rgba(248, 113, 113, 0.4);
    color: #ff4444;
    animation: flash-red 0.2s infinite;
}

@keyframes pulse-glow {

    0%,
    100% {
        opacity: 0.7;
    }

    50% {
        opacity: 1;
    }
}

@keyframes pulse-green {

    0%,
    100% {
        box-shadow: 0 0 5px rgba(74, 222, 128, 0.3);
    }

    50% {
        box-shadow: 0 0 15px rgba(74, 222, 128, 0.6);
    }
}

@keyframes pulse-red {

    0%,
    100% {
        box-shadow: 0 0 5px rgba(248, 113, 113, 0.3);
    }

    50% {
        box-shadow: 0 0 15px rgba(248, 113, 113, 0.5);
    }
}

@keyframes flash-red {

    0%,
    100% {
        background: rgba(248, 113, 113, 0.4);
    }

    50% {
        background: rgba(248, 113, 113, 0.8);
    }
}

.trench-radio-body {
    display: flex;
    align-items: center;
    gap: 12px;
    flex: 1;
}

.trench-radio-btn {
    width: 40px;
    height: 40px;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(140, 219, 199, 0.1);
    border: 1px solid rgba(140, 219, 199, 0.3);
    cursor: pointer;
    transition: all 0.3s ease;
}

.trench-radio-btn:hover {
    background: rgba(140, 219, 199, 0.2);
    transform: scale(1.05);
}

.trench-radio-btn.active {
    background: rgba(78, 255, 205, 0.2);
    border-color: var(--accent);
    box-shadow: 0 0 15px rgba(78, 255, 205, 0.3);
}

.trench-radio-btn svg {
    color: var(--accent);
}

.trench-radio-slider {
    flex: 1;
    height: 6px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(140, 219, 199, 0.2);
    border-radius: 3px;
    outline: none;
    cursor: pointer;
}

.trench-radio-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
}

.trench-radio-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 0 10px rgba(78, 255, 205, 0.5);
}

.trench-radio-slider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

/* Responsive */
@media (max-width: 600px) {
    .trench-radio-panel {
        bottom: 70px;
        left: 10px;
        right: 10px;
        min-width: auto;
    }
}

/* Chat Input Styling */
#chat-input-area {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.4);
    border-top: 1px solid rgba(140, 219, 199, 0.2);
}

.chat-input-row {
    display: flex;
    gap: 8px;
}

#usernameInput {
    width: 30%;
    min-width: 80px;
    padding: 8px;
    background: rgba(0, 20, 0, 0.6);
    border: 1px solid rgba(140, 219, 199, 0.3);
    color: #4ade80;
    font-family: 'Courier New', monospace;
    font-size: 0.85em;
    border-radius: 4px;
}

#usernameInput:focus {
    outline: none;
    border-color: #4ade80;
    box-shadow: 0 0 10px rgba(74, 222, 128, 0.2);
}

#chatInput {
    flex: 1;
    background: rgba(0, 20, 0, 0.6);
    border: 1px solid rgba(140, 219, 199, 0.3);
    color: #fff;
    padding: 10px;
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
    border-radius: 4px;
}
</file>

<file path="src/trading/sniper-pipeline.ts">
import { pumpPortalData, type PumpNewTokenEvent } from '../api/pumpportal-data.js';
import { logger } from '../lib/logger.js';
import { TokenValidator, type ValidatorConfig } from './token-validator.js';
import type { TradingEngine } from './trading-engine.js';
import { agentEvents } from '../events/emitter.js';
import { TokenSafetyAnalyzer } from '../analysis/token-safety.js';
import type { RiskProfile } from './types.js';

export interface SniperPipelineConfig {
  riskProfile: RiskProfile;
  validationDelayMs: number; // Will be auto-set by risk profile if default
  maxQueueSize: number;
  enableTrading: boolean;
  maxRetries: number;
  retryDelayMs: number;
}

const DEFAULT_CONFIG: SniperPipelineConfig = {
  riskProfile: 'BALANCED',
  validationDelayMs: 0, // 0 = Auto-calculate based on risk
  maxQueueSize: 1000,
  enableTrading: false,
  // Smarter retry logic - use env var, default to 5 (was 10)
  // Most tokens that fail validation will never pass - reduce wasted API calls
  maxRetries: parseInt(process.env.MAX_VALIDATION_RETRIES || '5', 10),
  retryDelayMs: 30000,   // 30 seconds between retries
};

export interface QueuedToken {
  token: PumpNewTokenEvent;
  receivedAt: number;
  validateAfter: number;
  retryCount: number;
}

/**
 * Sniper Pipeline
 * "Filter-First" architecture: 
 * PumpPortal (Trigger) -> Wait (Filter) -> DexScreener (Validate) -> Helius (Execute)
 */
export class SniperPipeline {
  private config: SniperPipelineConfig;
  private validator: TokenValidator;
  private tradingEngine?: TradingEngine;
  private tokenSafety?: TokenSafetyAnalyzer;
  
  private queue: QueuedToken[] = [];
  private isProcessing = false;
  private processingInterval?: NodeJS.Timeout;
  private isRunning = false;

  constructor(
    config: Partial<SniperPipelineConfig>,
    validatorConfig: Partial<ValidatorConfig>,
    tradingEngine?: TradingEngine,
    tokenSafety?: TokenSafetyAnalyzer
  ) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    
    // Auto-set delay based on risk profile if not explicitly set
    if (this.config.validationDelayMs === 0) {
        if (this.config.riskProfile === 'AGGRESSIVE') {
            this.config.validationDelayMs = 30000; // 30 seconds
        } else if (this.config.riskProfile === 'CONSERVATIVE') {
            this.config.validationDelayMs = 300000; // 5 minutes
        } else {
            this.config.validationDelayMs = 120000; // 2 minutes (Balanced)
        }
    }
    
    // Pass risk profile to validator
    this.validator = new TokenValidator({
        ...validatorConfig,
        riskProfile: this.config.riskProfile
    });
    
    this.tradingEngine = tradingEngine;
    this.tokenSafety = tokenSafety;

    logger.info({ 
      pipelineConfig: this.config,
      validatorConfig 
    }, 'Sniper Pipeline initialized');
  }

  /**
   * Start the pipeline
   */
  async start(): Promise<void> {
    if (this.isRunning) return;
    this.isRunning = true;

    logger.info('Starting Sniper Pipeline...');

    // 1. Connect to PumpPortal (The Trigger)
    try {
      await pumpPortalData.connect();
      pumpPortalData.subscribeNewTokens();
      
      pumpPortalData.onNewToken((token) => {
        this.enqueueToken(token);
      });

      logger.info('üîå Connected to PumpPortal - Listening for new tokens');
    } catch (error) {
      logger.error({ error }, 'Failed to connect to PumpPortal');
    }

    // 2. Start Processing Loop (The Wait Filter)
    this.processingInterval = setInterval(() => {
      this.processQueue();
    }, 10000); // Check queue every 10 seconds

    logger.info(`‚è≥ Pipeline active. Tokens will be held for ${(this.config.validationDelayMs / 60000).toFixed(1)} minutes before validation.`);
  }

  /**
   * Stop the pipeline
   */
  stop(): void {
    this.isRunning = false;
    if (this.processingInterval) {
      clearInterval(this.processingInterval);
    }
    pumpPortalData.disconnect();
    logger.info('Sniper Pipeline stopped');
  }

  /**
   * Add new token to the delayed queue
   * Pre-filters tokens that are unlikely to pass validation
   */
  private enqueueToken(token: PumpNewTokenEvent): void {
    // Basic deduplication
    if (this.queue.some(t => t.token.mint === token.mint)) return;

    // PRE-FILTER: Skip tokens that are extremely unlikely to pass validation
    // This saves API calls and reduces queue congestion

    // 1. Minimum market cap filter - extremely low mcap tokens are usually dead
    // Lowered to 25 SOL to catch early momentum (tokens start at ~28 SOL)
    const MIN_MCAP_SOL = 25;
    if (token.marketCapSol < MIN_MCAP_SOL) {
      logger.debug({
        mint: token.mint,
        symbol: token.symbol,
        marketCapSol: token.marketCapSol.toFixed(2)
      }, 'Skipped: Market cap too low for queue');
      return;
    }

    // 2. Suspicious name filter - common rug patterns
    const suspiciousPatterns = [/test/i, /rug/i, /scam/i, /honeypot/i, /fake/i];
    for (const pattern of suspiciousPatterns) {
      if (pattern.test(token.symbol) || pattern.test(token.name)) {
        logger.debug({
          mint: token.mint,
          symbol: token.symbol,
          name: token.name
        }, 'Skipped: Suspicious token name');
        return;
      }
    }

    // Queue limiting
    if (this.queue.length >= this.config.maxQueueSize) {
      // Remove oldest
      this.queue.shift();
    }

    const now = Date.now();
    this.queue.push({
      token,
      receivedAt: now,
      validateAfter: now + this.config.validationDelayMs,
      retryCount: 0,
    });

    logger.info({
      mint: token.mint,
      symbol: token.symbol,
      marketCapSol: token.marketCapSol.toFixed(2),
      queueSize: this.queue.length,
      validateAfter: new Date(now + this.config.validationDelayMs).toISOString()
    }, 'üì• Token queued for delayed validation');
  }

  /**
   * Process mature tokens in the queue
   */
  private async processQueue(): Promise<void> {
    if (this.isProcessing) return;
    this.isProcessing = true;

    // Log queue status every cycle for debugging
    if (this.queue.length > 0) {
      const now = Date.now();
      const readyCount = this.queue.filter(t => t.validateAfter <= now).length;
      logger.info({ queueSize: this.queue.length, readyForValidation: readyCount }, '‚è∞ Queue check');
    }

    try {
      const now = Date.now();
      
      // Find tokens ready for validation
      const readyTokens = this.queue.filter(t => t.validateAfter <= now);
      
      // Remove them from main queue
      if (readyTokens.length > 0) {
        this.queue = this.queue.filter(t => t.validateAfter > now);
        
        logger.info({ 
          count: readyTokens.length, 
          remainingInQueue: this.queue.length 
        }, 'Processing mature tokens...');

        // Process in batches to respect rate limits (DexScreener ~60/min)
        // We'll do 5 at a time
        const BATCH_SIZE = 5;
        for (let i = 0; i < readyTokens.length; i += BATCH_SIZE) {
          const batch = readyTokens.slice(i, i + BATCH_SIZE);
          await Promise.all(batch.map(t => this.validateAndExecute(t)));
          
          // Small delay between batches to be nice to APIs
          if (i + BATCH_SIZE < readyTokens.length) {
            await new Promise(r => setTimeout(r, 2000));
          }
        }
      }

    } catch (error) {
      logger.error({ error }, 'Error processing pipeline queue');
    } finally {
      this.isProcessing = false;
    }
  }

  /**
   * Validate a single token and pass to execution if good
   * Emits SCAN event on entry, REJECT event on failure with full observability
   */
  private async validateAndExecute(queued: QueuedToken): Promise<void> {
    const { token } = queued;
    const analysisLogs: string[] = [];

    analysisLogs.push(`Token: ${token.symbol} (${token.mint.slice(0, 8)}...)`);
    analysisLogs.push(`Source: PUMP_FUN`);
    analysisLogs.push(`Wait time: ${(this.config.validationDelayMs / 60000).toFixed(1)} min`);

    // EMIT SCAN EVENT - Token is being analyzed
    agentEvents.emit({
      type: 'SCAN',
      timestamp: Date.now(),
      data: {
        reasoning: `Analyzing ${token.symbol} from PumpPortal - survived ${(this.config.validationDelayMs / 60000).toFixed(1)} min delay`,
        logs: [...analysisLogs],
        mint: token.mint,
        symbol: token.symbol,
        name: token.name,
        source: 'PUMP_FUN',
        liquidity: 0, // Will be updated after validation
        marketCap: token.marketCapSol * 170,
      },
    });

    // Stage 1: SCANNING - Emit for frontend "Currently Analyzing" display
    agentEvents.emit({
      type: 'ANALYSIS_THOUGHT',
      timestamp: Date.now(),
      data: {
        mint: token.mint,
        symbol: token.symbol,
        name: token.name,
        marketCapSol: token.marketCapSol,
        stage: 'scanning',
        thought: `Checking ${token.symbol}... survived the ${(this.config.validationDelayMs / 60000).toFixed(1)} min delay. Let's see if it's worth anything.`
      }
    });

    logger.info({ mint: token.mint, symbol: token.symbol, marketCapSol: token.marketCapSol.toFixed(2) }, 'üîç Validating bonding curve token...');

    // 3. The Validator (Bonding Curve - uses PumpPortal data, not DexScreener)
    // Bonding curve tokens have $0 DEX liquidity, so we validate using market cap and bonding progress
    const result = this.validator.validateBondingCurve(token);

    if (result.passes) {
      // Emit validation success for frontend
      agentEvents.emit({
        type: 'ANALYSIS_THOUGHT',
        timestamp: Date.now(),
        data: {
          mint: token.mint,
          symbol: token.symbol,
          name: token.name,
          liquidity: 0, // Bonding curve = no DEX liquidity
          marketCapSol: result.marketCapSol,
          stage: 'safety',
          thought: `${token.symbol} at ${result.marketCapSol.toFixed(1)} SOL mcap (${result.bondingProgress.toFixed(1)}% to graduation). Looking promising...`
        }
      });

      logger.info({
        mint: token.mint,
        symbol: token.symbol,
        marketCapSol: result.marketCapSol,
        bondingProgress: result.bondingProgress,
        reason: 'Passed bonding curve validation'
      }, '‚úÖ Bonding curve token validated! Passing to Execution...');

      // Notify system
      agentEvents.emit({
        type: 'TOKEN_DISCOVERED',
        timestamp: Date.now(),
        data: {
          mint: token.mint,
          symbol: token.symbol,
          name: token.name,
          marketCapSol: result.marketCapSol,
          bondingProgress: result.bondingProgress,
          source: 'SNIPER_PIPELINE',
          isBondingCurve: true,
        } as any
      });

      // 4. The Executor (Helius via TradingEngine)
      if (this.config.enableTrading && this.tradingEngine) {
        if (this.tokenSafety) {
            // Safety check
            const safety = await this.tokenSafety.analyze(token.mint);
            analysisLogs.push(`Safety check: ${safety.isSafe ? 'PASSED' : 'FAILED'}`);

            if (!safety.isSafe) {
                const rejectReason = safety.risks.join(', ');
                analysisLogs.push(`Rejected: ${rejectReason}`);

                // Emit rejection with REJECT event
                agentEvents.emit({
                  type: 'REJECT',
                  timestamp: Date.now(),
                  data: {
                    reasoning: `${token.symbol} rejected due to safety risks: ${rejectReason}`,
                    logs: analysisLogs,
                    mint: token.mint,
                    symbol: token.symbol,
                    rejectReason,
                    stage: 'safety',
                  },
                });

                // Also emit ANALYSIS_THOUGHT for compatibility
                agentEvents.emit({
                  type: 'ANALYSIS_THOUGHT',
                  timestamp: Date.now(),
                  data: {
                    mint: token.mint,
                    symbol: token.symbol,
                    stage: 'decision',
                    thought: `NOPE. ${token.symbol} has ${safety.risks.join(', ')}. Hard pass.`,
                    details: { isSafe: false, risks: safety.risks, shouldTrade: false }
                  }
                });
                logger.warn({ mint: token.mint, risks: safety.risks }, '‚ùå Safety check failed after validation');
                return;
            }
        }

        // Emit decision to buy
        agentEvents.emit({
          type: 'ANALYSIS_THOUGHT',
          timestamp: Date.now(),
          data: {
            mint: token.mint,
            symbol: token.symbol,
            stage: 'decision',
            thought: `${token.symbol} passes all checks. BUYING.`,
            details: { shouldTrade: true }
          }
        });

        // Execute via Trading Engine (bonding curve token)
        this.tradingEngine.executeBuy(token.mint, {
             marketCapSol: result.marketCapSol,
             liquidity: 0, // Bonding curve = no DEX liquidity
             symbol: token.symbol,
             name: token.name,
             imageUrl: token.imageUrl,
        });
      }

    } else {
      const rejectReason = result.reason || 'Bonding curve validation failed';
      analysisLogs.push(`Validation: FAILED`);
      analysisLogs.push(`Rejected: ${rejectReason}`);

      // Validation failed - emit REJECT event
      agentEvents.emit({
        type: 'REJECT',
        timestamp: Date.now(),
        data: {
          reasoning: `${token.symbol} rejected: ${rejectReason}`,
          logs: analysisLogs,
          mint: token.mint,
          symbol: token.symbol,
          rejectReason,
          stage: 'validation',
        },
      });

      // Also emit ANALYSIS_THOUGHT for compatibility
      agentEvents.emit({
        type: 'ANALYSIS_THOUGHT',
        timestamp: Date.now(),
        data: {
          mint: token.mint,
          symbol: token.symbol,
          stage: 'decision',
          thought: `${token.symbol} rejected: ${result.reason}. Moving on.`,
          details: { shouldTrade: false, reasons: [result.reason || 'Unknown'] }
        }
      });

      // No retry needed for bonding curve validation - we already have all the data
      // Token either passes now (market cap + bonding progress criteria) or it doesn't
      logger.info({
        mint: token.mint,
        symbol: token.symbol,
        marketCapSol: result.marketCapSol.toFixed(2),
        bondingProgress: result.bondingProgress.toFixed(1),
        reason: result.reason
      }, `‚ùå Token rejected: ${result.reason}`);
    }
  }
}
</file>

<file path="src/trading/trading-loop.ts">
/**
 * Trading Loop - Automatic token monitoring and trading
 *
 * Integrates EntertainmentMode for frequent degen trading and
 * CommentarySystem for controlled speech timing.
 */

import { Connection, PublicKey, LAMPORTS_PER_SOL } from '@solana/web3.js';
import type { DatabaseWithRepositories } from '../db/database-with-repos.js';
import type { TokenSafetyAnalyzer } from '../analysis/token-safety.js';
import type { SmartMoneyTracker } from '../analysis/smart-money.js';
import type { TradingEngine } from './trading-engine.js';
import type { ClaudeClient } from '../personality/claude-client.js';
import type { MoodSystem } from '../personality/mood-system.js';
import type { CommentarySystem, NarrativeBeat } from '../personality/commentary-system.js';
import { EntertainmentMode, type TokenContext, type EntertainmentDecision } from './entertainment-mode.js';
import { dexscreener, type TokenMetadata } from '../api/dexscreener.js';
import { geckoTerminal } from '../api/geckoterminal.js';
import { getBirdeyeClient, type BirdeyeToken } from '../api/birdeye.js';
import { getMoralisClient, type MoralisToken, type TrendingToken, MoralisClient } from '../api/moralis.js';
import { agentEvents } from '../events/emitter.js';
import { logger } from '../lib/logger.js';

/**
 * Trading loop configuration
 */
export interface TradingLoopConfig {
  runLoop: boolean;      // Controls if the loop actively fetches and analyzes tokens
  enableTrading: boolean; // Controls if trades are actually executed
  pollIntervalMs: number;
  maxTokensPerCycle: number;
  entertainmentMode: boolean; // Use EntertainmentMode for trade decisions
}

/**
 * Default configuration
 */
export const DEFAULT_TRADING_LOOP_CONFIG: TradingLoopConfig = {
  runLoop: true,
  enableTrading: false,
  pollIntervalMs: 10000, // 10 seconds - gotta catch those runners
  maxTokensPerCycle: 10,
  entertainmentMode: true, // Default ON for entertaining agent
};

/**
 * Trading Loop - Orchestrates the full trading flow
 */
export class TradingLoop {
  private config: TradingLoopConfig;
  private connection: Connection;
  private db: DatabaseWithRepositories;
  private tokenSafety: TokenSafetyAnalyzer;
  private smartMoney: SmartMoneyTracker;
  private tradingEngine?: TradingEngine;
  private claude?: ClaudeClient;
  private walletPublicKey?: PublicKey;
  private isRunning: boolean = false;
  private intervalId?: NodeJS.Timeout;
  private trendingIntervalId?: NodeJS.Timeout; // Separate interval for trending scan
  private seenTokens = new Map<string, number>(); // Track tokens we've already analyzed with timestamp
  private tokenMetadataCache = new Map<string, TokenMetadata>(); // Cache enriched data

  private trendingTokenQueue: BirdeyeToken[] = []; // Queue of trending tokens from Birdeye
  private isProcessing = false; // Prevent concurrent processing
  private lastTrendingScan = 0; // Track last trending scan time

  // Entertainment systems (optional)
  private moodSystem?: MoodSystem;
  private entertainmentMode?: EntertainmentMode;
  private commentarySystem?: CommentarySystem;

  constructor(
    config: TradingLoopConfig,
    connection: Connection,
    db: DatabaseWithRepositories,
    tokenSafety: TokenSafetyAnalyzer,
    smartMoney: SmartMoneyTracker,
    tradingEngine?: TradingEngine,
    claude?: ClaudeClient,
    walletPublicKey?: PublicKey,
    moodSystem?: MoodSystem,
    entertainmentMode?: EntertainmentMode,
    commentarySystem?: CommentarySystem
  ) {
    this.config = config;
    this.connection = connection;
    this.db = db;
    this.tokenSafety = tokenSafety;
    this.smartMoney = smartMoney;
    this.tradingEngine = tradingEngine;
    this.claude = claude;
    this.walletPublicKey = walletPublicKey;
    this.moodSystem = moodSystem;
    this.entertainmentMode = entertainmentMode;
    this.commentarySystem = commentarySystem;

    const mode = tradingEngine ? 'FULL' : 'ANALYSIS-ONLY';
    const entertainment = config.entertainmentMode && entertainmentMode ? 'ENABLED' : 'DISABLED';
    logger.info({ config, mode, entertainment }, 'Trading Loop initialized');
  }

  /**
   * Start the trading loop
   */
  async start(): Promise<void> {
    if (this.isRunning) {
      logger.warn('Trading loop already running');
      return;
    }

    if (!this.config.runLoop) {
      logger.info('Trading loop disabled in config');
      return;
    }

    this.isRunning = true;
    logger.info('Starting trading loop...');

    if (!this.config.enableTrading) {
      logger.info('‚ö†Ô∏è  ANALYSIS MODE ONLY - Trading execution is DISABLED');
    }

    // NOTE: New token discovery is now handled by SniperPipeline
    // This loop executes trending scans and position management

    // Track last PnL snapshot time
    let lastSnapshotTime = Date.now();

    // Process queue periodically
    this.intervalId = setInterval(async () => {
      // Also run position checks if trading
      if (this.config.enableTrading && this.tradingEngine) {
        this.checkPositionExits().catch(error => {
          logger.error({ error }, 'Error checking position exits');
        });
      }

      // Emit stats and positions
      this.emitStatsUpdate().catch(() => {});
      this.emitPositionsUpdate().catch(() => {});

      // Save PnL snapshot every 5 minutes
      if (Date.now() - lastSnapshotTime > 5 * 60 * 1000) {
        await this.savePnLSnapshot().catch(error => {
          logger.error({ error }, 'Error saving PnL snapshot');
        });
        lastSnapshotTime = Date.now();
      }

      // Sync wallet positions every 60 seconds (detect manual trades, airdrops, etc)
      if (this.tradingEngine && Date.now() - (this as any).lastSyncTime > 60 * 1000) {
        this.tradingEngine.syncPositions().catch(error => {
          logger.debug({ error }, 'Position sync failed');
        });
        (this as any).lastSyncTime = Date.now();
      }
    }, this.config.pollIntervalMs);

    // Scan trending tokens every 60 seconds (Birdeye rate limit friendly)
    const birdeyeClient = getBirdeyeClient();
    if (birdeyeClient) {
      logger.info('ü¶Ö Birdeye integration enabled - scanning trending tokens');

      // Initial scan after 5 seconds
      setTimeout(() => {
        this.scanTrendingTokens().catch(error => {
          logger.error({ error }, 'Error in initial trending scan');
        });
      }, 5000);

      // Then scan every 60 seconds
      this.trendingIntervalId = setInterval(() => {
        this.scanTrendingTokens().catch(error => {
          logger.error({ error }, 'Error scanning trending tokens');
        });
      }, 60000); // Every 60 seconds
    } else {
      logger.warn('BIRDEYE_API_KEY not configured - trending token scanning disabled');
    }

    // Scan Moralis trending tokens every 60 seconds (offset by 15s from Birdeye)
    const moralisClient = getMoralisClient();
    if (moralisClient) {
      logger.info('üìä Moralis integration enabled - scanning trending tokens');

      // Initial scan after 20 seconds (offset from Birdeye)
      setTimeout(() => {
        this.scanMoralisTrending().catch(error => {
          logger.error({ error }, 'Error in initial Moralis trending scan');
        });
      }, 20000);

      // Then scan every 60 seconds
      setInterval(() => {
        this.scanMoralisTrending().catch(error => {
          logger.error({ error }, 'Error scanning Moralis trending tokens');
        });
      }, 60000);
    } else {
      logger.warn('MORALIS_API_KEY not configured - Moralis trending scanning disabled');
    }

    // Scan DexScreener Boosts (Paid/Trending) every 60 seconds
    // Offset by 30 seconds from Birdeye if active
    setTimeout(() => {
         this.scanDexScreenerBoosts().catch(e => logger.error(e));
         
         setInterval(() => {
             this.scanDexScreenerBoosts().catch(e => logger.error(e));
         }, 60000);
    }, 30000);

    logger.info('üöÄ DexScreener Boost scanner scheduled (every 60s)');

    // Scan GeckoTerminal Trending (Free/Public) every 60 seconds
    // Offset by 45 seconds to interleave calls
    setTimeout(() => {
         this.scanGeckoTerminalTrending().catch(e => logger.error(e));
         
         setInterval(() => {
             this.scanGeckoTerminalTrending().catch(e => logger.error(e));
         }, 60000);
    }, 45000);

    logger.info('ü¶é GeckoTerminal scanner scheduled (every 60s)');

    logger.info({ intervalMs: this.config.pollIntervalMs }, 'Trading loop started');
  }

  /**
   * Scan trending tokens from Birdeye
   */
  private async scanTrendingTokens(): Promise<void> {
    const birdeyeClient = getBirdeyeClient();
    if (!birdeyeClient) return;

    logger.debug('Scanning trending tokens from Birdeye...');

    try {
      // Get trending tokens and top gainers
      const [trending, gainers] = await Promise.all([
        birdeyeClient.getTrendingTokens(15),
        birdeyeClient.getTopGainers(10, '1h'),
      ]);

      const allTokens = [...trending, ...gainers];
      let addedCount = 0;

      for (const token of allTokens) {
        // Skip if already seen recently (within last 30 mins)
        const lastSeen = this.seenTokens.get(token.address);
        if (lastSeen && Date.now() - lastSeen < 30 * 60 * 1000) continue;

        // Quick filter for trending tokens
        const filterResult = this.passesTrendingFilter(token);
        if (!filterResult.passes) {
          logger.debug({
            address: token.address,
            symbol: token.symbol,
            reason: filterResult.reason
          }, 'Trending token rejected by filter');
          continue;
        }

        this.seenTokens.set(token.address, Date.now());
        this.trendingTokenQueue.push(token);
        addedCount++;

        logger.info({
          address: token.address,
          symbol: token.symbol,
          name: token.name,
          price: token.price,
          priceChange24h: token.priceChange24h?.toFixed(1) + '%',
          volume24h: token.volume24h,
          liquidity: token.liquidity,
        }, 'üìà Trending token from Birdeye!');
      }

      if (addedCount > 0) {
        logger.info({ addedCount }, 'Added trending tokens to queue');
      }

      // Process trending queue
      await this.processTrendingQueue();

    } catch (error) {
      logger.error({ error }, 'Failed to scan trending tokens');
    }
  }

  /**
   * Filter for trending tokens (more established, need higher standards)
   */
  private passesTrendingFilter(token: BirdeyeToken): { passes: boolean; reason?: string } {
    // Minimum liquidity for trending tokens ($5k)
    const MIN_LIQUIDITY = 5000;
    if (token.liquidity < MIN_LIQUIDITY) {
      return { passes: false, reason: `Low liquidity: $${token.liquidity.toFixed(0)}` };
    }

    // Minimum volume ($1k in 24h)
    const MIN_VOLUME = 1000;
    if (token.volume24h < MIN_VOLUME) {
      return { passes: false, reason: `Low volume: $${token.volume24h.toFixed(0)}` };
    }

    // Skip tokens that dumped hard (down >50% in 24h)
    if (token.priceChange24h < -50) {
      return { passes: false, reason: `Dumping: ${token.priceChange24h.toFixed(1)}%` };
    }

    // Suspicious patterns
    const suspiciousPatterns = [/test/i, /rug/i, /scam/i, /fake/i];
    for (const pattern of suspiciousPatterns) {
      if (pattern.test(token.symbol) || pattern.test(token.name)) {
        return { passes: false, reason: `Suspicious name: ${token.symbol}` };
      }
    }

    return { passes: true };
  }

  /**
   * Scan trending tokens from Moralis API
   * Falls back to GeckoTerminal if Moralis quota is exhausted
   */
  private async scanMoralisTrending(): Promise<void> {
    const moralisClient = getMoralisClient();

    // If no Moralis client or previous failures, use GeckoTerminal directly
    if (!moralisClient) {
      logger.debug('No Moralis client - using GeckoTerminal fallback');
      await this.scanGeckoTerminalFallback();
      return;
    }

    logger.debug('Scanning trending tokens from Moralis...');

    try {
      // Get trending tokens and top gainers from Moralis
      const [trending, gainers] = await Promise.all([
        moralisClient.getTrendingTokens({ limit: 15, minLiquidity: 5000 }),
        moralisClient.getTopGainers({ limit: 10, timeFrame: '1h' }),
      ]).catch(async (error) => {
        // Moralis quota exhausted - fall back to GeckoTerminal
        if (error.message?.includes('quota') || error.message?.includes('blocked') || error.message?.includes('401')) {
          logger.warn('Moralis quota exhausted - falling back to GeckoTerminal');
          await this.scanGeckoTerminalFallback();
          return [[], []]; // Return empty to skip rest of function
        }
        throw error; // Re-throw other errors
      });

      const allTokens = [...trending, ...gainers];
      let addedCount = 0;

      for (const token of allTokens) {
        // Skip if already seen recently (within last 30 mins)
        const lastSeen = this.seenTokens.get(token.tokenAddress);
        if (lastSeen && Date.now() - lastSeen < 30 * 60 * 1000) continue;

        // Quick filter for Moralis tokens
        const filterResult = this.passesMoralisTrendingFilter(token);
        if (!filterResult.passes) {
          logger.debug({
            address: token.tokenAddress,
            symbol: token.symbol,
            reason: filterResult.reason
          }, 'Moralis token rejected by filter');
          continue;
        }

        this.seenTokens.set(token.tokenAddress, Date.now());
        addedCount++;

        logger.info({
          address: token.tokenAddress,
          symbol: token.symbol,
          name: token.name,
          price: token.priceUsd,
          priceChange24h: token.priceChange24h?.toFixed(1) + '%',
          volume24h: token.volume24h,
          liquidity: token.liquidity,
          securityScore: token.securityScore,
        }, 'üìä Trending token from Moralis!');

        // Analyze and trade - convert Moralis token to BirdeyeToken format for compatibility
        const birdeyeCompatible: BirdeyeToken = {
          address: token.tokenAddress,
          symbol: token.symbol,
          name: token.name,
          decimals: token.decimals ?? 9, // Most Solana tokens use 9 decimals
          price: token.priceUsd,
          priceChange24h: token.priceChange24h ?? 0,
          priceChange1h: token.priceChange1h ?? 0,
          volume24h: token.volume24h ?? 0,
          liquidity: token.liquidity ?? 0,
          marketCap: token.marketCap ?? 0,
          logoURI: token.logo,
        };

        await this.analyzeAndTrade(token.tokenAddress, birdeyeCompatible);

        // Small delay to prevent rate limit spam
        await new Promise(r => setTimeout(r, 1000));
      }

      if (addedCount > 0) {
        logger.info({ addedCount }, 'üìä Processed Moralis trending tokens');
      }

    } catch (error) {
      logger.error({ error }, 'Failed to scan Moralis trending tokens');
    }
  }

  /**
   * Filter for Moralis trending tokens
   */
  private passesMoralisTrendingFilter(token: TrendingToken | MoralisToken): { passes: boolean; reason?: string } {
    // Minimum liquidity ($5k)
    const MIN_LIQUIDITY = 5000;
    if ((token.liquidity ?? 0) < MIN_LIQUIDITY) {
      return { passes: false, reason: `Low liquidity: $${(token.liquidity ?? 0).toFixed(0)}` };
    }

    // Minimum volume ($1k in 24h)
    const MIN_VOLUME = 1000;
    if ((token.volume24h ?? 0) < MIN_VOLUME) {
      return { passes: false, reason: `Low volume: $${(token.volume24h ?? 0).toFixed(0)}` };
    }

    // Skip tokens that dumped hard (down >50% in 24h)
    if ((token.priceChange24h ?? 0) < -50) {
      return { passes: false, reason: `Dumping: ${(token.priceChange24h ?? 0).toFixed(1)}%` };
    }

    // Security score filter (if available) - skip risky tokens
    if (token.securityScore !== undefined && token.securityScore < 30) {
      return { passes: false, reason: `Low security score: ${token.securityScore}` };
    }

    // Suspicious patterns
    const suspiciousPatterns = [/test/i, /rug/i, /scam/i, /fake/i];
    for (const pattern of suspiciousPatterns) {
      if (pattern.test(token.symbol) || pattern.test(token.name)) {
        return { passes: false, reason: `Suspicious name: ${token.symbol}` };
      }
    }

    return { passes: true };
  }

  /**
   * Process trending token queue
   */
  private async processTrendingQueue(): Promise<void> {
    this.isProcessing = true;
    try {
      // Process up to 3 trending tokens per cycle
      const tokensToProcess = this.trendingTokenQueue.splice(0, 3);

      for (const token of tokensToProcess) {
        // Convert Birdeye token to analysis format
        await this.analyzeAndTrade(token.address, token);
      }
    } finally {
      this.isProcessing = false;

      // Cleanup seen tokens map occasionally (every cycle)
      const now = Date.now();
      for (const [mint, timestamp] of this.seenTokens.entries()) {
        if (now - timestamp > 60 * 60 * 1000) { // 1 hour TTL
          this.seenTokens.delete(mint);
        }
      }
    }
  }



  /**
   * Scan boosted tokens from DexScreener (paid promotion = trending/established)
   */
  private async scanDexScreenerBoosts(): Promise<void> {
    logger.debug('Scanning DexScreener boosted tokens...');

    try {
        const boosted = await dexscreener.getBoostedTokens();
        let addedCount = 0;

        for (const token of boosted) {
             // Skip if already seen recently
             const lastSeen = this.seenTokens.get(token.mint);
             if (lastSeen && Date.now() - lastSeen < 30 * 60 * 1000) continue;

             // Cache the metadata since we just fetched it
             this.tokenMetadataCache.set(token.mint, token);
             this.seenTokens.set(token.mint, Date.now());

             // Analyze immediately using existing pipeline logic
             // analyzeAndTrade handles the heavy lifting
             await this.analyzeAndTrade(token.mint);
             addedCount++;

             // Small delay to prevent rate limit spam
             await new Promise(r => setTimeout(r, 1000));
        }

        if (addedCount > 0) {
            logger.info({ addedCount }, 'ü¶Ö Processed DexScreener boosted tokens');
        }

    } catch (error) {
        logger.error({ error }, 'Failed to scan DexScreener boosts');
    }
  }

  /**
   * GeckoTerminal fallback when Moralis quota is exhausted
   * Uses both trending and new pools for discovery
   */
  private async scanGeckoTerminalFallback(): Promise<void> {
    logger.info('ü¶é GeckoTerminal fallback scan (Moralis quota exhausted)');

    try {
      // Get both trending pools and new pools for better coverage
      const [trending, newPools, gainers] = await Promise.all([
        geckoTerminal.getTrendingPools(15),
        geckoTerminal.getNewPools(10),
        geckoTerminal.getTopGainers('1h', 10),
      ]);

      const allTokens = [...trending, ...newPools, ...gainers];
      let addedCount = 0;

      for (const token of allTokens) {
        // Skip invalid mints
        if (token.mint === 'unknown') continue;

        // Skip if already seen recently
        const lastSeen = this.seenTokens.get(token.mint);
        if (lastSeen && Date.now() - lastSeen < 30 * 60 * 1000) continue;

        // Basic filter
        if (token.liquidity < 5000) continue;
        if (token.volume1h < 1000) continue;

        this.seenTokens.set(token.mint, Date.now());
        this.tokenMetadataCache.set(token.mint, token);

        logger.info({
          address: token.mint,
          symbol: token.symbol,
          liquidity: token.liquidity,
          priceChange1h: token.priceChange1h?.toFixed(1) + '%',
        }, 'ü¶é Token from GeckoTerminal fallback');

        await this.analyzeAndTrade(token.mint);
        addedCount++;

        // Rate limiting
        await new Promise(r => setTimeout(r, 1000));
      }

      if (addedCount > 0) {
        logger.info({ addedCount }, 'ü¶é Processed GeckoTerminal fallback tokens');
      }
    } catch (error) {
      logger.error({ error }, 'GeckoTerminal fallback scan failed');
    }
  }

  /**
   * Scan trending pools from GeckoTerminal
   */
  private async scanGeckoTerminalTrending(): Promise<void> {
    logger.debug('Scanning GeckoTerminal trending pools...');

    try {
        const pools = await geckoTerminal.getTrendingPools();
        let addedCount = 0;

        for (const token of pools) {
             // Skip if already seen recently
             const lastSeen = this.seenTokens.get(token.mint);
             if (lastSeen && Date.now() - lastSeen < 30 * 60 * 1000) continue;

             // Skip invalid mints
             if (token.mint === 'unknown') continue;

             // Cache the metadata
             this.tokenMetadataCache.set(token.mint, token);
             this.seenTokens.set(token.mint, Date.now());

             // Analyze immediately 
             await this.analyzeAndTrade(token.mint);
             addedCount++;

             // Small delay
             await new Promise(r => setTimeout(r, 1000));
        }

        if (addedCount > 0) {
            logger.info({ addedCount }, 'ü¶é Processed GeckoTerminal trending pools');
        }

    } catch (error) {
        logger.error({ error }, 'Failed to scan GeckoTerminal trending');
    }
  }

  /**
   * Check if token has valid social links (Twitter, Website)
   * Returns true if at least one valid social exists
   */
  private hasValidSocials(metadata: TokenMetadata | undefined): { valid: boolean; reason?: string } {
    if (!metadata) {
      return { valid: false, reason: 'No metadata available' };
    }

    // Check for social links in metadata
    // DexScreener provides these when available
    const hasTwitter = metadata.dexUrl?.includes('twitter') || false;
    const hasWebsite = metadata.dexUrl?.includes('http') || false;

    // For now, we'll use the presence of a DexScreener listing as a proxy
    // Real implementation would check actual social links from token metadata
    if (metadata.ageMinutes && metadata.ageMinutes > 5) {
      // Token has been around for more than 5 minutes and has DexScreener data
      return { valid: true };
    }

    return { valid: false, reason: 'Token too new - waiting for social verification' };
  }





  /**
   * Stop the trading loop
   */
  stop(): void {
    if (!this.isRunning) {
      return;
    }

    this.isRunning = false;
    // Stop intervals
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = undefined;
    }

    if (this.trendingIntervalId) {
      clearInterval(this.trendingIntervalId);
      this.trendingIntervalId = undefined;
    }

    logger.info('Trading loop stopped');
  }

  /**
   * Run one cycle of the trading loop
   */
  private async runCycle(): Promise<void> {
    logger.debug('Running trading cycle...');

    try {
      // Step 1: Check existing positions for stop-loss/take-profit exits
      if (this.config.enableTrading && this.tradingEngine) {
        await this.checkPositionExits();
      }

      // Step 2: Emit stats update for dashboard
      await this.emitStatsUpdate();

      logger.debug('Trading cycle complete');
    } catch (error) {
      logger.error({ error }, 'Error in trading cycle');
    }
  }

  /**
   * Emit stats update event for dashboard
   */
  private async emitStatsUpdate(): Promise<void> {
    try {
      const stats = this.tradingEngine
        ? await this.tradingEngine.getStats()
        : { todayTrades: 0, openPositions: 0, realizedPnL: 0, unrealizedPnL: 0, dailyPnL: 0, consecutiveLosses: 0 };

      // Calculate win rate from completed trades
      const allTrades = this.db.trades.getRecent(100);
      const completedRoundTrips = this.calculateCompletedTrades(allTrades);
      const winRate = completedRoundTrips.total > 0
        ? (completedRoundTrips.wins / completedRoundTrips.total) * 100
        : 0;

      // Count buybacks
      const buybackTrades = allTrades.filter(t => t.metadata?.isBuyback);
      const buybacks = buybackTrades.length;
      const totalBuybackSol = buybackTrades.reduce((sum, t) => sum + t.amountSol, 0);

      // Get wallet balance
      let balance = 0;
      if (this.walletPublicKey) {
        try {
          const lamports = await this.connection.getBalance(this.walletPublicKey);
          balance = lamports / LAMPORTS_PER_SOL;
        } catch (err) {
          logger.debug({ error: err }, 'Failed to fetch wallet balance');
        }
      } else {
        logger.debug('No wallet configured - balance will show as 0');
      }

      // Entertainment mode stats
      let mood: string | undefined;
      let moodIntensity: number | undefined;
      let timeSinceLastTrade: number | undefined;
      let tradesThisHour: number | undefined;
      let timePressure: number | undefined;

      if (this.moodSystem) {
        const moodState = this.moodSystem.getState();
        mood = moodState.current;
        moodIntensity = moodState.intensity;
        timeSinceLastTrade = moodState.lastTradeTime > 0
          ? Math.floor((Date.now() - moodState.lastTradeTime) / 1000)
          : undefined;
      }

      if (this.entertainmentMode) {
        const entertainmentStats = this.entertainmentMode.getStats();
        tradesThisHour = entertainmentStats.tradesLastHour;
        timePressure = entertainmentStats.timePressure;
      }

      agentEvents.emit({
        type: 'STATS_UPDATE',
        timestamp: Date.now(),
        data: {
          todayTrades: stats.todayTrades,
          openPositions: stats.openPositions,
          realizedPnL: stats.realizedPnL,
          unrealizedPnL: stats.unrealizedPnL,
          dailyPnL: stats.dailyPnL,
          winRate,
          totalBuybacks: buybacks,
          totalBuybackSol,
          balance,
          // Entertainment stats
          mood,
          moodIntensity,
          timeSinceLastTrade,
          tradesThisHour,
          timePressure,
        },
      });
    } catch (error) {
      logger.error({ error }, 'Error emitting stats update');
    }
  }

  /**
   * Emit positions update event for dashboard (with real-time prices)
   */
  private async emitPositionsUpdate(): Promise<void> {
    if (!this.tradingEngine) return;

    try {
      // Use getOpenPositionsWithPrices for real-time PnL
      const positions = await this.tradingEngine.getOpenPositionsWithPrices();

      agentEvents.emit({
        type: 'POSITIONS_UPDATE',
        timestamp: Date.now(),
        data: {
          positions: positions.map(p => ({
            tokenMint: p.tokenMint,
            tokenSymbol: p.tokenSymbol,
            tokenName: p.tokenName,
            entryAmountSol: p.entryAmountSol,
            entryAmountTokens: p.entryAmountTokens,
            entryPrice: p.entryPrice,
            entryTimestamp: p.entryTimestamp,
            currentPrice: p.currentPrice,
            unrealizedPnLPercent: p.unrealizedPnLPercent,
          })),
        },
      });
    } catch (error) {
      logger.error({ error }, 'Error emitting positions update');
    }
  }

  /**
   * Calculate completed trades (wins/losses)
   */
  private calculateCompletedTrades(trades: Array<{ type: string; tokenMint: string; amountSol: number; metadata?: Record<string, unknown> }>): { wins: number; losses: number; total: number } {
    const tokenBuyCosts = new Map<string, number[]>();
    let wins = 0;
    let losses = 0;

    for (const trade of trades.filter(t => !t.metadata?.isBuyback)) {
      if (trade.type === 'BUY') {
        const costs = tokenBuyCosts.get(trade.tokenMint) || [];
        costs.push(trade.amountSol);
        tokenBuyCosts.set(trade.tokenMint, costs);
      } else if (trade.type === 'SELL') {
        const costs = tokenBuyCosts.get(trade.tokenMint) || [];
        if (costs.length > 0) {
          const buyCost = costs.shift()!;
          tokenBuyCosts.set(trade.tokenMint, costs);
          if (trade.amountSol > buyCost) {
            wins++;
          } else {
            losses++;
          }
        }
      }
    }

    return { wins, losses, total: wins + losses };
  }

  /**
   * Check open positions for stop-loss/take-profit exits
   */
  private async checkPositionExits(): Promise<void> {
    if (!this.tradingEngine) return;

    try {
      const exitSignatures = await this.tradingEngine.checkPositionsForExit();

      for (const signature of exitSignatures) {
        agentEvents.emit({
          type: 'TRADE_EXECUTED',
          timestamp: Date.now(),
          data: {
            mint: 'position-exit',
            type: 'SELL',
            signature,
            amount: 0, // Amount determined by position
          },
        });

        // Update mood system on position exit
        // NOTE: Actual profit/loss tracking would come from the tradingEngine
        // For now, we track that an exit occurred - real mood updates
        // happen from STOP_LOSS and TAKE_PROFIT events in index.ts
      }

      if (exitSignatures.length > 0) {
        logger.info({ count: exitSignatures.length }, 'Position exits executed');

        // Record trade in entertainment mode for rate limiting
        if (this.entertainmentMode) {
          for (const signature of exitSignatures) {
            this.entertainmentMode.recordTrade(signature);
          }
        }
      }
    } catch (error) {
      logger.error({ error }, 'Error checking position exits');
    }
  }

  /**
   * Check for smart money presence in a token's holders
   * Returns the count of smart money wallets holding this token
   *
   * Note: Full implementation requires fetching top token holders.
   * This is a placeholder that returns 0 until holder data is integrated.
   */
  private async checkSmartMoney(mint: string): Promise<number> {
    // TODO: Implement when we have a way to get token holders
    // The flow would be:
    // 1. Fetch top N holders for this token (via Helius getTokenAccounts or PumpPortal)
    // 2. For each holder, call this.smartMoney.isSmartMoney(holderAddress)
    // 3. Return count of smart money wallets
    //
    // For now, return 0 as we don't have the holder data API integrated
    logger.debug({ mint }, 'Smart money check skipped - holder data not available');
    return 0;
  }



  /**
   * Get cached metadata for a token
   */
  getTokenMetadata(mint: string): TokenMetadata | undefined {
    return this.tokenMetadataCache.get(mint);
  }

  /**
   * Save PnL snapshot to database
   * Records current portfolio state for historical tracking
   */
  private async savePnLSnapshot(): Promise<void> {
    if (!this.tradingEngine) return;

    try {
      const positions = await this.tradingEngine.getOpenPositionsWithPrices();
      const stats = await this.tradingEngine.getStats();

      // Get wallet balance
      let balance = 0;
      if (this.walletPublicKey) {
        const lamports = await this.connection.getBalance(this.walletPublicKey);
        balance = lamports / LAMPORTS_PER_SOL;
      }

      // Calculate total value of holdings
      let holdingsValue = 0;
      const tokenHoldings: Record<string, number> = {};

      for (const pos of positions) {
        tokenHoldings[pos.tokenMint] = pos.entryAmountTokens;
        if (pos.currentPrice) {
          holdingsValue += pos.entryAmountTokens * pos.currentPrice;
        }
      }

      // Save snapshot
      this.db.state.savePnLSnapshot({
        timestamp: Date.now(),
        totalValueSol: balance + holdingsValue,
        realizedPnlSol: stats.realizedPnL,
        unrealizedPnlSol: stats.unrealizedPnL,
        tokenHoldings,
      });

      logger.debug({
        totalValueSol: (balance + holdingsValue).toFixed(4),
        realizedPnL: stats.realizedPnL.toFixed(4),
        unrealizedPnL: stats.unrealizedPnL.toFixed(4),
      }, 'PnL snapshot saved');
    } catch (error) {
      logger.error({ error }, 'Failed to save PnL snapshot');
    }
  }

  /**
   * Analyze a token and execute trade if approved
   * Accepts data from Birdeye (trending tokens) using Trending Analysis
   *
   * Emits SCAN event on entry, REJECT event on failure with full observability
   */
  private async analyzeAndTrade(mint: string, birdeyeToken?: BirdeyeToken): Promise<void> {
    const analysisLogs: string[] = [];

    // Try to get enriched metadata from DexScreener
    let metadata = this.tokenMetadataCache.get(mint);
    if (!metadata) {
      // Small delay for very new tokens to appear on DexScreener

      metadata = await dexscreener.getTokenMetadata(mint) || undefined;
      if (metadata) {
        this.tokenMetadataCache.set(mint, metadata);
      }
    }

    // Use Birdeye data as fallback
    const symbol = metadata?.symbol || birdeyeToken?.symbol || mint.slice(0, 6);
    const name = metadata?.name || birdeyeToken?.name || 'Unknown';
    const marketCapSol = (birdeyeToken?.marketCap ? birdeyeToken.marketCap / 170 : 0);
    const liquidity = metadata?.liquidity || birdeyeToken?.liquidity || (marketCapSol * 170);
    const isTrending = !!birdeyeToken;
    const source = isTrending ? 'BIRDEYE' : 'DEXSCREENER';

    analysisLogs.push(`Token: ${symbol} (${mint.slice(0, 8)}...)`);
    analysisLogs.push(`Source: ${source}`);
    analysisLogs.push(`Liquidity: $${liquidity.toLocaleString()}`);

    // EMIT SCAN EVENT - Token is being analyzed
    agentEvents.emit({
      type: 'SCAN',
      timestamp: Date.now(),
      data: {
        reasoning: `Analyzing ${symbol} from ${source} feed`,
        logs: [...analysisLogs],
        mint,
        symbol,
        name,
        source: source as any,
        liquidity,
        marketCap: marketCapSol * 170,
      },
    });

    // CRITICAL: Safety Analysis FIRST (save API calls and time)
    // Bail immediately if unsafe (mint/freeze auth enabled)
    const safetyResult = await this.tokenSafety.analyze(mint);
    analysisLogs.push(`Safety check: ${safetyResult.isSafe ? 'PASSED' : 'FAILED'}`);

    agentEvents.emit({
      type: 'SAFETY_CHECK',
      timestamp: Date.now(),
      data: { mint, result: safetyResult },
    });

    if (!safetyResult.isSafe) {
        const rejectReason = safetyResult.risks.join(', ');
        analysisLogs.push(`Rejected: ${rejectReason}`);
        logger.warn({ mint, risks: safetyResult.risks }, '‚õî REJECTED: Unsafe token (Mint/Freeze Auth)');

        // EMIT REJECT EVENT
        agentEvents.emit({
          type: 'REJECT',
          timestamp: Date.now(),
          data: {
            reasoning: `${symbol} rejected due to safety risks: ${rejectReason}`,
            logs: analysisLogs,
            mint,
            symbol,
            rejectReason,
            stage: 'safety',
          },
        });
        return;
    }

    // Filter: Liquidity to Market Cap Ratio Check
    // Prevent thin LP rugs (liquidity < 8% of MC)
    if (liquidity > 0 && marketCapSol > 0) {
        const mcUsd = marketCapSol * 170; // Approx SOL price
        const ratio = liquidity / mcUsd;
        analysisLogs.push(`Liquidity/MC ratio: ${(ratio * 100).toFixed(1)}%`);

        if (ratio < 0.08) {
             const rejectReason = `Thin liquidity: ${(ratio * 100).toFixed(1)}% of MC (min: 8%)`;
             analysisLogs.push(`Rejected: ${rejectReason}`);
             logger.warn({ mint, liquidity, mcUsd, ratio: ratio.toFixed(3) }, '‚õî REJECTED: Thin Liquidity (<8% of MC)');

             // EMIT REJECT EVENT
             agentEvents.emit({
               type: 'REJECT',
               timestamp: Date.now(),
               data: {
                 reasoning: `${symbol} rejected: ${rejectReason}`,
                 logs: analysisLogs,
                 mint,
                 symbol,
                 rejectReason,
                 stage: 'liquidity',
               },
             });
             return;
        }
    }

    logger.info({
      mint,
      symbol,
      name,
      hasDexData: !!metadata,
      marketCapSol,
      source: isTrending ? 'BIRDEYE_TRENDING' : 'DEXSCREENER',
    }, isTrending ? 'üìà Analyzing TRENDING token...' : 'üÜï Analyzing NEW token...');

    // Emit TOKEN_DISCOVERED with best available data
    // Use Birdeye logo as fallback
    const imageUrl = metadata?.imageUrl || birdeyeToken?.logoURI;

    agentEvents.emit({
      type: 'TOKEN_DISCOVERED',
      timestamp: Date.now(),
      data: {
        mint,
        name,
        symbol,
        priceUsd: metadata?.priceUsd || birdeyeToken?.price || 0,
        priceChange5m: metadata?.priceChange5m || 0,
        priceChange1h: metadata?.priceChange1h || birdeyeToken?.priceChange1h || 0,
        volume1h: metadata?.volume1h || birdeyeToken?.volume24h || 0,
        liquidity,
        marketCap: metadata?.marketCap || birdeyeToken?.marketCap || (marketCapSol * 170),
        buys5m: metadata?.buys5m || 0,
        sells5m: metadata?.sells5m || 0,
        ageMinutes: metadata?.ageMinutes || 0,
        dexUrl: metadata?.dexUrl || `https://dexscreener.com/solana/${mint}`,
        imageUrl,
        marketCapSol,
      },
    });

    // Emit analysis start event
    agentEvents.emit({
      type: 'ANALYSIS_START',
      timestamp: Date.now(),
      data: { mint },
    });

    // NOTE: Removed verbose scanning thoughts - SCHIZO was too chatty
    // Only speak on interesting findings (safety issues, trades, etc.)

    try {
      // PRE-CHECK: Minimum activity check - don't buy zero-action tokens
      // Skip for trending tokens (already vetted by Birdeye)
      // ALSO skip for PumpPortal tokens (brand new, pre-vetted by PumpPortal feed)
      if (!isTrending) {
        // AGGRESSIVE FILTER: No age requirement, only need SOME activity
        const MIN_VOLUME_USD = 10;  // Just need $10 in volume
        const MIN_TRANSACTIONS = 2; // Or 2 transactions

        const volume = metadata?.volume1h || 0;
        const totalTxns = (metadata?.buys5m || 0) + (metadata?.sells5m || 0);

        // Reject ONLY if there's literally zero activity
        if (volume < MIN_VOLUME_USD && totalTxns < MIN_TRANSACTIONS) {
          const rejectReason = `Zero activity: $${volume.toFixed(0)} volume, ${totalTxns} txns`;
          analysisLogs.push(`Rejected: ${rejectReason}`);
          logger.info({
            mint, symbol, volume, totalTxns,
            reason: 'Zero activity detected'
          }, 'REJECTED: Token has no trading activity');

          // EMIT REJECT EVENT
          agentEvents.emit({
            type: 'REJECT',
            timestamp: Date.now(),
            data: {
              reasoning: `${symbol} rejected: ${rejectReason}`,
              logs: analysisLogs,
              mint,
              symbol,
              rejectReason,
              stage: 'filter',
            },
          });
          return;
        }

        logger.info({ 
          mint, symbol, volume, totalTxns,
          ageMinutes: metadata?.ageMinutes || 0
        }, '‚úÖ Token has activity - proceeding to analysis');

      } else {
        logger.info({ mint, symbol, volume24h: birdeyeToken?.volume24h, liquidity: birdeyeToken?.liquidity }, 'Trending token - skipping new token activity checks');
      }

      // Step 1: Safety analysis (Already done above!)
      // Skipping redundant call...
      
      // Only emit SAFETY thought if there are critical risks worth calling out
      const hasCriticalRisk = safetyResult.risks.some(r =>
        r === 'MINT_AUTHORITY_ACTIVE' || r === 'FREEZE_AUTHORITY_ACTIVE'
      );
      if (this.claude && hasCriticalRisk) {
        try {
          const safetyThought = await this.claude.generateAnalysisThought('safety', {
            symbol,
            name,
            isSafe: safetyResult.isSafe,
            risks: safetyResult.risks,
          });
          agentEvents.emit({
            type: 'ANALYSIS_THOUGHT',
            timestamp: Date.now(),
            data: {
              mint,
              symbol,
              stage: 'safety',
              thought: safetyThought,
              details: {
                isSafe: safetyResult.isSafe,
                risks: safetyResult.risks,
              },
            },
          });
        } catch (err) {
          logger.debug({ err }, 'Failed to generate safety thought');
        }
      }

      // Step 2: Smart money check
      // Note: Full smart money detection requires fetching top token holders,
      // which needs additional API calls. For now, we rely on the Trading Engine's
      // safety analysis. Smart money signals can be added when holder data is available.
      const smartMoneyCount = await this.checkSmartMoney(mint);

      agentEvents.emit({
        type: 'SMART_MONEY_CHECK',
        timestamp: Date.now(),
        data: { mint, count: smartMoneyCount },
      });

      // Only emit SMART_MONEY thought if we actually found smart money (rare/interesting)
      if (this.claude && smartMoneyCount > 0) {
        try {
          const smartMoneyThought = await this.claude.generateAnalysisThought('smart_money', {
            symbol,
            name,
            smartMoneyCount,
          });
          agentEvents.emit({
            type: 'ANALYSIS_THOUGHT',
            timestamp: Date.now(),
            data: {
              mint,
              symbol,
              stage: 'smart_money',
              thought: smartMoneyThought,
              details: {
                smartMoneyCount,
              },
            },
          });
        } catch (err) {
          logger.debug({ err }, 'Failed to generate smart money thought');
        }
      }

      // Step 3: Get trading decision
      // Use EntertainmentMode if enabled, otherwise use TradingEngine

      // Use a looser type that works for both entertainment and standard decisions
      interface LocalDecision {
        shouldTrade: boolean;
        reasons: string[];
        positionSizeSol: number;
        safetyAnalysis?: typeof safetyResult;
        smartMoneyCount?: number;
        reasoning?: string;
      }

      let decision: LocalDecision;
      let entertainmentDecision: EntertainmentDecision | null = null;

      // Entertainment mode: Use relaxed thresholds for frequent trading
      if (this.config.entertainmentMode && this.entertainmentMode) {
        // Build token context for entertainment mode evaluation
        const tokenContext: TokenContext = {
          mint,
          name,
          symbol,
          priceUsd: metadata?.priceUsd,
          volumeUsd5m: metadata?.volume5m || 0, // Use 5-minute volume for most recent activity
          liquiditySol: (metadata?.liquidity ?? birdeyeToken?.liquidity ?? 0) / 170, // Convert USD to SOL approx
          holderCount: metadata?.buys5m, // Use buys as proxy for holders
          createdAt: metadata?.ageMinutes ? Date.now() - (metadata.ageMinutes * 60 * 1000) : undefined,
          hasMinAuthorities: safetyResult.risks.includes('MINT_AUTHORITY_ACTIVE'),
          hasFreezeAuth: safetyResult.risks.includes('FREEZE_AUTHORITY_ACTIVE'),
        };

        entertainmentDecision = this.entertainmentMode.evaluate(tokenContext);

        decision = {
          shouldTrade: entertainmentDecision.shouldTrade,
          reasons: [entertainmentDecision.reason],
          positionSizeSol: entertainmentDecision.positionSizeSol,
          safetyAnalysis: safetyResult,
          smartMoneyCount,
          reasoning: entertainmentDecision.isDegenMoment
            ? 'DEGEN MOMENT - random ape'
            : entertainmentDecision.isHypeTrade
            ? 'HYPE DETECTED - volume + holders'
            : `Quality score ${(entertainmentDecision.currentRiskThreshold * 10).toFixed(1)} (pressure: ${(entertainmentDecision.timePressure * 100).toFixed(0)}%)`,
        };

        logger.debug({
          mint,
          decision: entertainmentDecision,
          timePressure: entertainmentDecision.timePressure,
          isDegenMoment: entertainmentDecision.isDegenMoment,
        }, 'Entertainment mode decision');

        // Queue commentary through CommentarySystem instead of direct speech
        if (this.commentarySystem && entertainmentDecision.shouldTrade) {
          this.commentarySystem.queueCommentary('DECISION', {
            symbol,
            name,
            shouldTrade: true,
            reasons: [entertainmentDecision.reason],
            positionSizeSol: entertainmentDecision.positionSizeSol,
          });
        }
      } else if (!this.tradingEngine) {
        // Analysis-only mode - just emit that we analyzed it
        agentEvents.emit({
          type: 'TRADE_DECISION',
          timestamp: Date.now(),
          data: {
            mint,
            decision: {
              shouldTrade: false,
              reasons: ['Analysis-only mode'],
              positionSizeSol: 0,
              safetyAnalysis: safetyResult,
              smartMoneyCount,
            },
            reasoning: 'Running in analysis-only mode - no trading engine configured',
          },
        });
        return;
      } else {
        // Standard mode: Use TradingEngine's conservative evaluation
        const tokenMeta = {
          liquidity: metadata?.liquidity,
          marketCapSol: marketCapSol,
        };
        const engineDecision = await this.tradingEngine.evaluateToken(mint, tokenMeta);
        decision = engineDecision;
      }

      // Emit decision event with AI reasoning
      // Ensure decision matches TradeDecision type for event emission
      const eventDecision = {
        shouldTrade: decision.shouldTrade,
        positionSizeSol: decision.positionSizeSol,
        reasons: decision.reasons,
        safetyAnalysis: decision.safetyAnalysis ?? safetyResult,
        smartMoneyCount: decision.smartMoneyCount ?? smartMoneyCount,
        reasoning: decision.reasoning,
      };

      agentEvents.emit({
        type: 'TRADE_DECISION',
        timestamp: Date.now(),
        data: {
          mint,
          decision: eventDecision,
          reasoning: decision.reasoning,
        },
      });

      // Emit DECISION thought - ONLY on BUY decisions (not every single reject)
      // This prevents SCHIZO from being too chatty about every token he passes on
      // In entertainment mode, commentary goes through CommentarySystem instead
      if (this.claude && decision.shouldTrade && !this.commentarySystem) {
        try {
          const decisionThought = await this.claude.generateAnalysisThought('decision', {
            symbol,
            name,
            shouldTrade: decision.shouldTrade,
            reasons: decision.reasons,
          });
          agentEvents.emit({
            type: 'ANALYSIS_THOUGHT',
            timestamp: Date.now(),
            data: {
              mint,
              symbol,
              stage: 'decision',
              thought: decisionThought,
              details: {
                shouldTrade: decision.shouldTrade,
                reasons: decision.reasons,
              },
            },
          });
        } catch (err) {
          logger.debug({ err }, 'Failed to generate decision thought');
        }
      }

      // Step 4: Execute trade if approved
      if (decision.shouldTrade) {
        if (!this.config.enableTrading) {
          logger.info({ mint, decision }, 'Trade approved but execution DISABLED (Analysis Mode)');

          // Emit SIMULATED trade event for dashboard visualization
          agentEvents.emit({
            type: 'TRADE_EXECUTED',
            timestamp: Date.now(),
            data: {
              mint,
              type: 'BUY',
              signature: 'SIMULATED_MODE',
              amount: decision.positionSizeSol,
            },
          });

          // Record trade in entertainment mode for rate limiting
          if (entertainmentDecision && this.entertainmentMode) {
            this.entertainmentMode.recordTrade(mint);
          }

          // Queue trade result commentary
          if (this.commentarySystem) {
            this.commentarySystem.queueCommentary('TRADE_RESULT', {
              symbol,
              name,
              tradeType: 'BUY',
              positionSizeSol: decision.positionSizeSol,
            });
          }

          return;
        }

        // Only proceed with execution if we have a trading engine
        if (!this.tradingEngine) {
          logger.warn({ mint }, 'Trade approved but no trading engine available');
          return;
        }

        logger.info({ mint, positionSize: decision.positionSizeSol }, 'Executing trade...');

        // If entertainment mode approved, bypass the trading engine's re-evaluation
        const isEntertainmentApproved = !!(entertainmentDecision && entertainmentDecision.shouldTrade);
        const signature = await this.tradingEngine.executeBuy(
          mint,
          { symbol, name, liquidity, marketCapSol, imageUrl },  // Pass token metadata for storage
          isEntertainmentApproved,          // skipEvaluation - bypass re-evaluation
          isEntertainmentApproved ? decision.positionSizeSol : undefined  // overridePositionSol
        );

        if (signature) {
          agentEvents.emit({
            type: 'TRADE_EXECUTED',
            timestamp: Date.now(),
            data: {
              mint,
              type: 'BUY',
              signature,
              amount: decision.positionSizeSol,
            },
          });

          // Record trade in entertainment mode for rate limiting
          if (entertainmentDecision && this.entertainmentMode) {
            this.entertainmentMode.recordTrade(mint);
          }

          // Update mood on trade execution (success)
          if (this.moodSystem) {
            // For BUY trades, we don't know the result yet
            // Mood update happens on SELL (position close)
            logger.debug({ mint }, 'Trade executed - mood update will occur on position close');
          }

          // Queue trade result commentary
          if (this.commentarySystem) {
            this.commentarySystem.queueCommentary('TRADE_RESULT', {
              symbol,
              name,
              tradeType: 'BUY',
              positionSizeSol: decision.positionSizeSol,
            });
          }

          logger.info({ mint, signature }, 'Trade executed successfully');
        } else {
          logger.info({ mint }, 'Trade execution skipped (Circuit breaker or Engine rejection)');

          // Queue failure commentary when trade fails after announcement (Fix 2)
          if (entertainmentDecision?.shouldTrade && this.commentarySystem) {
            this.commentarySystem.queueCommentary('TRADE_RESULT', {
              symbol,
              name,
              tradeType: 'BUY',
              customPrompt: `The ${symbol} buy failed. Trade got rejected. Moving on.`,
            });
          }
        }
      } else {
        logger.info({ mint, reasons: decision.reasons }, 'Trade rejected');
      }
    } catch (error) {
      logger.error({ mint, error }, 'Error analyzing token');
    }
  }
}
</file>

<file path="src/index.ts">
/**
 * SCHIZO Agent - Entry Point with Trading Loop
 */

import 'dotenv/config';
import { Connection, Keypair } from '@solana/web3.js';
import { logger, createLogger } from './lib/logger.js';
import { runDevnetTest } from './test-devnet.js';
import { createDatabase } from './db/database.js';
import { createDatabaseWithRepositories } from './db/database-with-repos.js';
import { HeliusClient } from './api/helius.js';
import { TokenSafetyAnalyzer } from './analysis/token-safety.js';
import { SmartMoneyTracker } from './analysis/smart-money.js';
import { TradingEngine } from './trading/trading-engine.js';
import { TradingLoop, DEFAULT_TRADING_LOOP_CONFIG } from './trading/trading-loop.js';
import { EntertainmentMode } from './trading/entertainment-mode.js';
import { ClaudeClient, DEFAULT_CLAUDE_CONFIG } from './personality/claude-client.js';
import { MoodSystem } from './personality/mood-system.js';
import { CommentarySystem } from './personality/commentary-system.js';
import { DeepgramTTS, VoiceNarrator } from './personality/deepgram-tts.js';
import { TwitterClient } from './personality/twitter-client.js';
import { MarketWatcher } from './analysis/market-watcher.js';
import { PumpPortalClient } from './trading/pumpportal-client.js';
import { SniperPipeline } from './trading/sniper-pipeline.js';
import { JupiterClient } from './api/jupiter.js';
import { agentEvents } from './events/emitter.js';
import { detectSillyName } from './personality/name-analyzer.js';
import type { RiskProfile } from './trading/types.js';
import { LearningEngine } from './analysis/learning-engine.js';
import { RewardClaimer } from './rewards/reward-claimer.js';

const log = createLogger('main');
let db: ReturnType<typeof createDatabase> | null = null;

async function main(): Promise<void> {
  log.info('===========================================');
  log.info('$SCHIZO Agent v1.0.0');
  log.info('Paranoid AI Trading Agent');
  log.info('===========================================');

  const isTestMode = process.argv.includes('--test');

  if (isTestMode) {
    log.info('Running devnet integration test...');
    log.info('');
    await runDevnetTest();
  } else {
    // Initialize database - use volume path on Railway for persistence
    const dbPath = process.env.RAILWAY_ENVIRONMENT
      ? '/app/data/schizo-agent.db'
      : 'schizo-agent.db';
    log.info({ dbPath }, 'Initializing database...');
    db = createDatabase(dbPath);
    const dbWithRepos = createDatabaseWithRepositories(db);

    // Clear stale sync trades on startup
    const deletedCount = dbWithRepos.trades.clearSyncTrades();
    if (deletedCount > 0) {
      log.info({ deletedCount }, 'Cleared stale sync trades from database');
    }

    // Historical IMPOSTOR trade - CLOSED (user sold manually at +73%)
    // Buy entry
    const historicalBuy = {
      signature: 'iwgr8DTfM7STpQ1N21mHNRvC4DNrN5ms7aSAKYw27PukjTq9dmA95j4NY6x1gh5MwZWaeQJEH5tHWRg6Wryc6uq',
      tokenMint: 'Kvqx8QeAXyjQJULbAX7LnWxfym5U51we9Eft51oBAGS',
      tokenSymbol: 'IMPOSTOR',
      type: 'BUY' as const,
      amountSol: 0.026412,
      amountTokens: 107358.911004,
      pricePerToken: 0.000000246014,
      timestamp: 1769028771000,
      metadata: { tokenName: 'Impostor', source: 'PUMP_FUN', importedFromHistory: true },
    };
    // Manual sell exit (user sold at +73% because bot couldn't track graduated token)
    const historicalSell = {
      signature: 'manual-sell-impostor-2026-01-21',
      tokenMint: 'Kvqx8QeAXyjQJULbAX7LnWxfym5U51we9Eft51oBAGS',
      tokenSymbol: 'IMPOSTOR',
      type: 'SELL' as const,
      amountSol: 0.046, // ~$3.46 at SOL ~$170 = +73% from $1.99 entry
      amountTokens: 107358.911004,
      pricePerToken: 0.000000428, // Exit price ~73% higher
      timestamp: 1769030000000, // Approximate manual sell time
      metadata: { tokenName: 'Impostor', source: 'MANUAL', importedFromHistory: true, reason: 'Manual sell - bot missed take-profit on graduated token' },
    };
    if (!dbWithRepos.trades.getBySignature(historicalBuy.signature)) {
      dbWithRepos.trades.insert(historicalBuy);
    }
    if (!dbWithRepos.trades.getBySignature(historicalSell.signature)) {
      dbWithRepos.trades.insert(historicalSell);
      log.info('Historical IMPOSTOR position closed (manual sell imported)');
    }

    // Initialize Helius client
    const heliusApiKey = process.env.HELIUS_API_KEY;
    if (!heliusApiKey) {
      throw new Error('HELIUS_API_KEY is required');
    }
    const helius = new HeliusClient({ apiKey: heliusApiKey } as any);

    // Initialize Solana connection
    const connection = new Connection('https://api.mainnet-beta.solana.com');

    // Load Risk Profile early for safety analyzer configuration
    const riskProfile = (process.env.RISK_PROFILE || 'BALANCED') as RiskProfile;
    log.info({ riskProfile }, 'Loading Risk Profile');

    // Initialize analysis modules with risk-aware holder thresholds
    log.info('Initializing analysis modules...');
    const { WalletAnalyzer } = await import('./analysis/wallet-analyzer.js');
    const walletAnalyzer = new WalletAnalyzer(helius, dbWithRepos.analysisCache);
    
    // Risk-based holder distribution thresholds
    const holderThresholds = {
      CONSERVATIVE: { maxTopHolderPercent: 20, maxTop10HoldersPercent: 40, minHolderCount: 50 },
      BALANCED: { maxTopHolderPercent: 30, maxTop10HoldersPercent: 50, minHolderCount: 20 },
      AGGRESSIVE: { maxTopHolderPercent: 40, maxTop10HoldersPercent: 60, minHolderCount: 10 },
      ENTERTAINMENT: { maxTopHolderPercent: 99, maxTop10HoldersPercent: 100, minHolderCount: 1 }, // Effectively disabled - full degen mode
    };
    
    const tokenSafety = new TokenSafetyAnalyzer(
      helius, 
      dbWithRepos.analysisCache,
      holderThresholds[riskProfile]
    );
    const smartMoney = new SmartMoneyTracker(walletAnalyzer, dbWithRepos.analysisCache);

    // Initialize Claude client (optional)
    let claude: ClaudeClient | undefined;
    const anthropicApiKey = process.env.ANTHROPIC_API_KEY;
    if (anthropicApiKey && anthropicApiKey !== 'your-anthropic-api-key-here') {
      log.info('Initializing Claude client...');
      claude = new ClaudeClient({
        ...DEFAULT_CLAUDE_CONFIG,
        apiKey: anthropicApiKey,
      });
    } else {
      log.warn('ANTHROPIC_API_KEY not configured - running without AI personality');
    }

    // Initialize Deepgram TTS (optional)
    let tts: DeepgramTTS | undefined;
    let narrator: VoiceNarrator | undefined;
    const deepgramApiKey = process.env.DEEPGRAM_API_KEY;
    if (deepgramApiKey && deepgramApiKey !== 'your-deepgram-api-key-here') {
      log.info('Initializing Deepgram TTS...');
      tts = new DeepgramTTS({
        apiKey: deepgramApiKey,
        model: process.env.DEEPGRAM_MODEL || 'aura-2-aries-en',
      });
      narrator = new VoiceNarrator(tts);
      log.info('Voice narration enabled');
    } else {
      log.warn('DEEPGRAM_API_KEY not configured - running without voice');
    }

    // Initialize Twitter Client (optional)
    let twitter: TwitterClient | undefined;
    const twitterApiKey = process.env.TWITTER_API_KEY;
    if (twitterApiKey) {
      log.info('Initializing Twitter client...');
      twitter = new TwitterClient({
        apiKey: process.env.TWITTER_API_KEY!,
        apiSecret: process.env.TWITTER_API_SECRET!,
        accessToken: process.env.TWITTER_ACCESS_TOKEN!,
        accessSecret: process.env.TWITTER_ACCESS_SECRET!,
        maxTweetsPerDay: 50,
      }, claude);

      // Set up Event Listeners for Tweeting
      agentEvents.onAny((event) => {
        if (!twitter) return;

        if (event.type === 'TRADE_EXECUTED' && event.data.type === 'BUY') {
          // Tweet about Buys
          const amount = event.data.amount as number;
          const mint = event.data.mint as string;
          // We can fetch reasoning if available, or just post the generic update for now
          twitter.postTradeUpdate('BUY', mint, amount);
        }
      });
      
      log.info('Twitter bot active üê¶');
    } else {
        log.warn('TWITTER_API_KEY not configured - running without auto-tweets');
    }

    // Initialize wallet (if private key provided)
    let wallet: Keypair | undefined;
    const walletPrivateKey = process.env.WALLET_PRIVATE_KEY;
    if (walletPrivateKey) {
      try {
        // Try base58 first (Phantom export format), then base64
        let privateKeyBytes: Uint8Array;
        try {
          const bs58 = await import('bs58');
          privateKeyBytes = bs58.default.decode(walletPrivateKey);
        } catch {
          privateKeyBytes = Uint8Array.from(Buffer.from(walletPrivateKey, 'base64'));
        }
        wallet = Keypair.fromSecretKey(privateKeyBytes);
        log.info({ publicKey: wallet.publicKey.toBase58() }, 'Wallet loaded');
      } catch (error) {
        log.warn({ error }, 'Failed to load wallet from WALLET_PRIVATE_KEY');
      }
    }

    // Initialize PumpPortal client (requires wallet)
    let pumpPortal: PumpPortalClient | undefined;
    const pumpPortalApiKey = process.env.PUMPPORTAL_API_KEY; // Optional for local trading
    
    if (wallet) {
      pumpPortal = new PumpPortalClient({
        apiKey: pumpPortalApiKey, // Can be undefined
        baseUrl: process.env.PUMPPORTAL_BASE_URL || 'https://pumpportal.fun/api',
        rpcUrl: 'https://api.mainnet-beta.solana.com', // Add default RPC
        maxRetries: 5,
        retryDelayMs: 2000,
      } as any, wallet!); // Cast to any to bypass strict config check if types outdated
      
      log.info({ 
        hasApiKey: !!pumpPortalApiKey, 
        wallet: wallet.publicKey.toBase58() 
      }, 'PumpPortal client initialized (Local Trading)');
    } else {
      log.warn('Wallet not configured - Trading Engine disabled');
    }

    // Initialize Jupiter Client (for graduated tokens)
    let jupiter: JupiterClient | undefined;
    if (wallet) {
      try {
        jupiter = new JupiterClient({
          connection,
          wallet,
        });
        log.info('Jupiter client initialized (for graduated tokens)');
      } catch (error) {
        log.warn({ error }, 'Failed to initialize Jupiter client');
      }
    }



// ... (Rest of imports)

    // Initialize Learning Engine (learns from trade outcomes)
    const learningEngine = new LearningEngine(dbWithRepos);
    log.info('Learning Engine initialized - will learn from trade outcomes');

    // Initialize Trading Engine (if we have PumpPortal)
    let tradingEngine: TradingEngine | undefined;
    let tradingLoop: TradingLoop | undefined;
    let rewardClaimer: RewardClaimer | undefined;

    if (pumpPortal && wallet) {
      tradingEngine = new TradingEngine(
        {
          riskProfile, // Pass risk profile
          basePositionSol: parseFloat(process.env.BASE_POSITION_SOL || '0.1'),
          maxPositionSol: parseFloat(process.env.MAX_POSITION_SOL || '1.0'),
          maxOpenPositions: parseInt(process.env.MAX_OPEN_POSITIONS || '5'),
          maxDailyTrades: parseInt(process.env.MAX_DAILY_TRADES || '20'),
          circuitBreakerDailyLoss: parseFloat(process.env.CIRCUIT_BREAKER_DAILY_LOSS || '-5.0'),
          circuitBreakerConsecutiveLosses: parseInt(process.env.CIRCUIT_BREAKER_CONSECUTIVE_LOSSES || '3'),
          minLiquiditySol: parseFloat(process.env.MIN_LIQUIDITY_SOL || '10'),
          slippageTolerance: parseFloat(process.env.SLIPPAGE_TOLERANCE || '0.05'),
          stopLossPercent: parseFloat(process.env.STOP_LOSS_PERCENT || '0.2'), // Default -20%
          takeProfitPercent: parseFloat(process.env.TAKE_PROFIT_PERCENT || '0.5'), // Default +50%
        },
        pumpPortal,
        tokenSafety,
        smartMoney,
        dbWithRepos,
        connection,
        wallet.publicKey.toBase58(),
        helius,
        claude,
        jupiter, // Pass initialized Jupiter client
        learningEngine
      );
      log.info('Trading Engine initialized with smart money detection, transaction parsing & learning');
      
      // Sync positions from on-chain data
      log.info('Syncing positions from on-chain data...');
      await tradingEngine.syncPositions();

    } else {
      log.warn('Trading Engine not available - wallet not configured');
    }

    // Initialize Sniper Pipeline (Filter-First Architecture)
    let sniperPipeline: SniperPipeline | undefined;
    
    if (tradingEngine || process.env.TRADING_ENABLED === 'false') {
        const validationDelay = parseInt(process.env.VALIDATION_DELAY_MS || '0'); // Default to 0 (auto-risk)
        log.info({ delayMs: validationDelay, riskProfile }, 'Initializing Sniper Pipeline...');
        
        sniperPipeline = new SniperPipeline(
            {
                riskProfile,
                validationDelayMs: validationDelay,
                enableTrading: process.env.TRADING_ENABLED === 'true',
            },
            {
                // Let Validator use defaults from Risk Profile
                minLiquidityUsd: process.env.MIN_LIQUIDITY_USD ? parseFloat(process.env.MIN_LIQUIDITY_USD) : undefined,
                minVolume1hUsd: process.env.MIN_VOLUME_1H_USD ? parseFloat(process.env.MIN_VOLUME_1H_USD) : undefined,
            },
            tradingEngine,
            tokenSafety
        );
        
        await sniperPipeline.start();
        log.info('üéØ Sniper Pipeline started - Listening for new tokens w/ dynamic delay');
    }

    // Initialize Entertainment Systems (Phase 4)
    const entertainmentEnabled = process.env.ENTERTAINMENT_MODE !== 'false';
    log.info({ entertainmentEnabled }, 'Entertainment mode configuration');

    // MoodSystem - tracks agent emotional state
    const moodSystem = new MoodSystem({
      quietPeriodMs: 5 * 60 * 1000,    // 5 min to restlessness
      maniacChance: 0.08,               // 8% degen moments
      moodDecayMs: 10 * 60 * 1000,      // 10 min mood decay
    });
    log.info('MoodSystem initialized');

    // EntertainmentMode - degen trading decisions
    const entertainmentMode = new EntertainmentMode({
      enabled: entertainmentEnabled,
      minPositionSol: 0.01,             // $2 min bet
      maxPositionSol: 0.05,             // $10 max bet
      quietPeriodMs: 5 * 60 * 1000,     // 5 min pressure start
      maxQuietPeriodMs: 15 * 60 * 1000, // 15 min max pressure
      degenChance: 0.08,                // 8% random ape
      cooldownMs: 5 * 60 * 1000,        // 5 min between trades
      maxTradesPerHour: 6,              // Rate limit
    }, moodSystem);
    log.info({ enabled: entertainmentEnabled }, 'EntertainmentMode initialized');

    // CommentarySystem - controls speech timing
    const commentarySystem = new CommentarySystem(moodSystem, {
      minSpeechGapMs: 15000,            // 15 second minimum
      maxSpeechGapMs: 60000,            // 60 second max before musing
      maxQueueSize: 3,                  // Priority queue size
    });
    if (claude) {
      commentarySystem.setClaudeClient(claude);
    }

    // Hook up commentary to narrator for TTS
    if (narrator) {
      commentarySystem.onSpeech(async (text, beat) => {
        await narrator.say(text);
        agentEvents.emit({
          type: 'SCHIZO_SPEAKS',
          timestamp: Date.now(),
          data: { text },
        });
      });
    }

    // Start commentary system
    commentarySystem.start();
    log.info('CommentarySystem initialized and started');

    // Listen for mood changes and emit events
    // Mood changes happen internally via MoodSystem.setMood which emits MOOD_CHANGE

    // Initialize Trading Loop (Handles Position Management + Trending Tokens)
    tradingLoop = new TradingLoop(
      {
        ...DEFAULT_TRADING_LOOP_CONFIG,
        runLoop: true, // Always run the loop for positions/trending
        enableTrading: process.env.TRADING_ENABLED === 'true' && !!tradingEngine,
        entertainmentMode: entertainmentEnabled,
      },
      connection,
      dbWithRepos,
      tokenSafety,
      smartMoney,
      tradingEngine!, // May be undefined - loop handles this
      claude,
      wallet?.publicKey, // Pass wallet public key for balance tracking
      moodSystem,
      entertainmentMode,
      commentarySystem
    );

    // Initialize Copy Trader (supports multiple wallets)
    let copyTrader: any = null;
    const copyTradeWallets = process.env.COPY_TRADE_WALLETS || process.env.COPY_TRADE_WALLET;
    if (copyTradeWallets && wallet) {
      const walletList = copyTradeWallets.split(',').map(w => w.trim()).filter(w => w.length > 0);
      log.info({ walletCount: walletList.length }, 'Initializing Private Copy Trader...');
      
      const { CopyTrader } = await import('./trading/copy-trader.js');
      copyTrader = new CopyTrader(
        {
          walletAddresses: walletList,
          pollIntervalMs: 2000,
          enabled: true
        },
        helius,
        connection
      );

      copyTrader.start();

      // Listen for copy signals
      agentEvents.onAny(async (event) => {
        if (event.type === 'COPY_TRADE_SIGNAL' && tradingEngine) {
           const { mint, sourceWallet, solSpent } = event.data;
           log.info(`‚ö° COPY SIGNAL: ${sourceWallet} bought ${mint} (${solSpent} SOL)`);
           
           if (process.env.TRADING_ENABLED === 'true') {
             await tradingEngine.executeCopyTrade(mint, sourceWallet, solSpent);
             
             // Voice it!
             if (narrator) {
               await narrator.say(`Copying the master. Buying ${mint.slice(0,6)}.`);
             }
           } else {
             log.info('Trading disabled - skipping copy trade execution');
           }
        }
      });
    }

    // Initialize Shill Queue (viewer-submitted token shills via $SCHIZO burns)
    let shillQueue: any = null;
    let shillWatcher: any = null;
    const shillQueueEnabled = process.env.SHILL_QUEUE_ENABLED === 'true';
    const schizoTokenMint = process.env.SCHIZO_TOKEN_MINT;

    if (shillQueueEnabled && schizoTokenMint) {
      log.info('Initializing Shill Queue...');

      const { ShillQueue, ShillQueueWatcher, DEFAULT_SHILL_QUEUE_CONFIG, DEFAULT_SHILL_WATCHER_CONFIG } = await import('./shill-queue/index.js');

      shillQueue = new ShillQueue(
        {
          ...DEFAULT_SHILL_QUEUE_CONFIG,
          lottoPositionSol: parseFloat(process.env.SHILL_LOTTO_SIZE || '0.02'),
        },
        tradingEngine,
        tokenSafety,
        claude,
        narrator,
        commentarySystem
      );

      shillWatcher = new ShillQueueWatcher(
        {
          ...DEFAULT_SHILL_WATCHER_CONFIG,
          burnWalletAddress: process.env.SHILL_BURN_WALLET || 'GvV8bXgQTYSGHnfNF9vgodshgQ4P2fcichGFLqBd73kr',
          schizoTokenMint,
          minShillAmountTokens: parseInt(process.env.MIN_SHILL_AMOUNT || '1000'),
          cooldownPerWalletMs: parseInt(process.env.SHILL_COOLDOWN_MS || '300000'),
          enabled: true,
        },
        connection,
        shillQueue
      );

      await shillWatcher.start();
      log.info({
        burnWallet: process.env.SHILL_BURN_WALLET || 'GvV8bXgQTYSGHnfNF9vgodshgQ4P2fcichGFLqBd73kr',
        minAmount: process.env.MIN_SHILL_AMOUNT || '1000',
        lottoSize: process.env.SHILL_LOTTO_SIZE || '0.02',
      }, 'üé§ Shill Queue active - viewers can burn $SCHIZO to shill tokens');
    } else if (shillQueueEnabled && !schizoTokenMint) {
      log.warn('SHILL_QUEUE_ENABLED=true but SCHIZO_TOKEN_MINT not set - shill queue disabled');
    }

    // Start WebSocket server (Railway uses PORT, fallback to WEBSOCKET_PORT or 8080)
    const websocketPort = parseInt(process.env.PORT || process.env.WEBSOCKET_PORT || '8080');
    let wss: any = null;
    let marketWatcher: MarketWatcher | undefined;

    try {
      const { createWebSocketServer } = await import('./server/websocket.js');
      const { agentEvents } = await import('./events/emitter.js');

      log.info({ port: websocketPort }, 'Starting WebSocket server...');
      wss = createWebSocketServer(
        websocketPort,
        agentEvents,
        claude,
        narrator,
        tradingEngine,
        tokenSafety,
        process.env.TRADING_ENABLED === 'true'
      );

      // Set WebSocket on narrator if available
      if (narrator) {
        narrator.setWebSocket(wss);
      }

      // Initialize $SCHIZO Token Tracker (live price display on dashboard)
      let schizoTokenTracker: any = null;
      if (schizoTokenMint && schizoTokenMint !== 'your-schizo-token-mint-here') {
        const { createSchizoTokenTracker } = await import('./services/schizo-token-tracker.js');
        schizoTokenTracker = createSchizoTokenTracker(agentEvents);
        schizoTokenTracker.start();
        log.info({ mint: schizoTokenMint }, 'üíé $SCHIZO Token Tracker active');
      }

      // Initialize Market Watcher
      marketWatcher = new MarketWatcher(
        {
          observationInterval: 30000, // 30 seconds
          learningInterval: 300000, // 5 minutes
          voiceEnabled: !!narrator,
          commentaryEnabled: !!claude,
        },
        claude,
        narrator,
        dbWithRepos
      );

      // Shutdown handlers
      const shutdown = () => {
        log.info('Shutting down...');
        if (schizoTokenTracker) schizoTokenTracker.stop();
        if (shillWatcher) shillWatcher.stop();
        if (rewardClaimer) rewardClaimer.stop();
        if (commentarySystem) commentarySystem.stop();
        if (marketWatcher) marketWatcher.stop();
        if (sniperPipeline) sniperPipeline.stop();
        if (tradingLoop) tradingLoop.stop();
        if (wss) wss.close();
        if (db) db.close();
        process.exit(0);
      };

      process.on('SIGINT', shutdown);
      process.on('SIGTERM', shutdown);

      log.info('');
      log.info('üöÄ $SCHIZO Agent is LIVE!');
      log.info('');
      log.info(`üì° WebSocket: ws://localhost:${websocketPort}`);
      log.info(`üåê Dashboard: Open public/index.html in your browser`);
      log.info('');
      log.info('Systems Status:');
      log.info('  ‚úÖ Phase 1: Database, Keystore, Helius API');
      log.info('  ‚úÖ Phase 2: Token Safety, Wallet Analysis, Smart Money');
      log.info(`  ${tradingEngine ? '‚úÖ' : '‚ö†Ô∏è'} Phase 3: Trading Engine ${tradingEngine ? '(READY)' : '(DISABLED)'}`);
      log.info(`  ${claude ? '‚úÖ' : '‚ö†Ô∏è'} Phase 4: AI Personality ${claude ? '(ACTIVE)' : '(DISABLED)'}`);
      log.info(`  ${narrator ? '‚úÖ' : '‚ö†Ô∏è'} Voice: Deepgram TTS ${narrator ? '(ACTIVE)' : '(DISABLED)'}`);
      log.info(`  ${entertainmentEnabled ? '‚úÖ' : '‚ö†Ô∏è'} Entertainment Mode ${entertainmentEnabled ? '(ACTIVE - Degen trading)' : '(DISABLED)'}`);
      log.info(`  ${shillWatcher ? '‚úÖ' : '‚ö†Ô∏è'} Shill Queue ${shillWatcher ? '(ACTIVE - burn $SCHIZO to shill)' : '(DISABLED)'}`);
      log.info(`  ${schizoTokenTracker ? '‚úÖ' : '‚ö†Ô∏è'} $SCHIZO Token Tracker ${schizoTokenTracker ? '(ACTIVE - live price on dashboard)' : '(DISABLED - set SCHIZO_TOKEN_MINT)'}`);
      log.info(`  ‚úÖ Market Watcher: Learning from trades`);
      log.info('');

      // Start market watcher
      marketWatcher.start();
      log.info('üß† Market Watcher started - Learning patterns...');

      // Voice announcements for analysis and trade events
      // NOTE: When entertainmentMode is enabled, speech goes through CommentarySystem
      // This handler is for backwards compat and non-commentary events
      if (narrator) {
        agentEvents.onAny(async (event) => {
          try {
            let speech: string | null = null;

            // ANALYSIS_THOUGHT events - SCHIZO thinking out loud during analysis
            // Skip if commentarySystem is handling speech
            if (event.type === 'ANALYSIS_THOUGHT' && !entertainmentEnabled) {
              speech = event.data.thought;
            }
            // Trade executed events - only voice if not using commentary system
            else if (event.type === 'TRADE_EXECUTED' && !entertainmentEnabled) {
              const { type, amount, mint } = event.data;
              const shortMint = mint.slice(0, 6);
              if (claude) {
                speech = await claude.generateCommentary({
                  type: 'TRADE_EXECUTED',
                  data: { type, amount, mint },
                  timestamp: Date.now(),
                });
              } else {
                speech = type === 'BUY'
                  ? `Buying in on ${shortMint}. ${amount.toFixed(2)} SOL. Let's see if the whales know something.`
                  : `Selling ${shortMint}. Taking ${amount.toFixed(2)} SOL off the table.`;
              }
            } else if (event.type === 'STOP_LOSS') {
              const { mint, lossPercent } = event.data;
              // Update mood on loss
              moodSystem.recordTradeResult(false, -lossPercent);
              speech = `Stop loss triggered. Down ${lossPercent.toFixed(1)} percent on ${mint.slice(0, 6)}. The patterns lied to me.`;
            } else if (event.type === 'TAKE_PROFIT') {
              const { mint, profitPercent } = event.data;
              // Update mood on win
              moodSystem.recordTradeResult(true, profitPercent);
              speech = `Taking profit. Up ${profitPercent.toFixed(1)} percent on ${mint.slice(0, 6)}. The voices were right this time.`;
            } else if (event.type === 'BUYBACK_TRIGGERED') {
              const { amount, profit } = event.data;
              speech = `Buyback triggered. ${amount.toFixed(2)} SOL going back into SCHIZO. Profit was ${profit.toFixed(2)} SOL.`;
            }

            if (speech) {
              await narrator.say(speech);
            }
          } catch (error) {
            log.error({ error }, 'Failed to voice trade event');
          }
        });
        log.info('üîä Voice announcements enabled for trades');
      }

      // Start trading loop logic
      if (tradingLoop) {
        log.info('ü§ñ Starting Analysis Loop...');
        tradingLoop.start();

        if (process.env.TRADING_ENABLED === 'true') {
          log.info('‚ö†Ô∏è  LIVE TRADING ENABLED - Agent will execute real trades!');
        } else {
          log.info('üëÄ ANALYSIS MODE - Monitoring tokens without trading');
        }
      }

      // Initialize Reward Claimer - handles automatic fee claiming
      if (pumpPortal && process.env.TRADING_ENABLED === 'true') {
        rewardClaimer = new RewardClaimer(pumpPortal, {
          enabled: true,
          claimIntervalMs: 5 * 60 * 1000,    // 5 minutes
          minClaimThreshold: 0.001,          // 0.001 SOL minimum
          maxRetries: 3,
          retryDelayMs: 5000,
          claimPumpCreator: true,            // Enable creator fees
          claimPumpReferral: false,          // Disabled by default
          claimMeteoraDbc: false,            // Disabled by default
        });

        rewardClaimer.start();
        log.info('üí∞ RewardClaimer started - automatic fee claiming enabled');

        // Voice successful claims
        agentEvents.onAny(async (event) => {
          if (event.type === 'REWARD_CLAIMED' && narrator) {
            try {
              const amount = event.data.amountSol?.toFixed(4) || 'some';
              await narrator.say(`Creator fees claimed. ${amount} SOL. The flywheel keeps spinning.`);
            } catch (error) {
              log.error({ error }, 'Failed to voice reward claim');
            }
          }
        });
      }

      // Generate initial greeting and periodic idle thoughts
      if (claude && narrator) {
        // Initial greeting
        try {
          const greeting = await claude.generateIdleThought();
          await narrator.say(greeting);
          agentEvents.emit({
            type: 'SCHIZO_SPEAKS',
            timestamp: Date.now(),
            data: { text: greeting },
          });
        } catch (error) {
          log.error({ error }, 'Failed to generate initial greeting');
        }

        // Random idle thoughts every 2-5 minutes
        const speakRandomly = async () => {
          try {
            const thought = await claude.generateIdleThought();
            await narrator.say(thought);
            agentEvents.emit({
              type: 'SCHIZO_SPEAKS',
              timestamp: Date.now(),
              data: { text: thought },
            });
          } catch (error) {
            log.error({ error }, 'Failed to generate idle thought');
          }

          // Schedule next thought in 2-5 minutes
          const nextDelay = 120000 + Math.random() * 180000;
          setTimeout(speakRandomly, nextDelay);
        };

        // Start idle thoughts after initial delay
        setTimeout(speakRandomly, 120000 + Math.random() * 60000);
        log.info('üí≠ Random thoughts enabled (every 2-5 minutes)');

        // Smart token commentary - comment on interesting tokens, not random ones
        let lastTokenCommentTime = 0;
        const TOKEN_COMMENT_COOLDOWN = 15000; // 15 second cooldown between comments

        // Track trading context for chat responses
        agentEvents.onAny(async (event) => {
          // Update trading context for chat
          if (event.type === 'ANALYSIS_THOUGHT' && event.data.stage === 'scanning') {
            claude.updateTradingContext({
              currentlyAnalyzing: event.data.symbol,
            });
          }

          if (event.type === 'ANALYSIS_THOUGHT' && event.data.stage === 'decision') {
            claude.updateTradingContext({
              currentlyAnalyzing: undefined,
              tokensAnalyzed: [
                ...([] as Array<{symbol: string; verdict: string}>),
                {
                  symbol: event.data.symbol,
                  verdict: event.data.details?.shouldTrade ? 'potential' : 'skip',
                }
              ],
            });
          }

          if (event.type === 'TRADE_EXECUTED') {
            claude.updateTradingContext({
              lastTrade: {
                symbol: event.data.mint.slice(0, 8),
                type: event.data.type,
                time: Date.now(),
              },
            });
          }
        });

        // Comment on tokens entering analysis pipeline (passed initial filters)
        agentEvents.onAny(async (event) => {
          // Only comment on tokens entering analysis (they have potential)
          if (event.type !== 'ANALYSIS_THOUGHT') return;
          if (event.data.stage !== 'scanning') return;

          const now = Date.now();
          // Skip if commented too recently
          if (now - lastTokenCommentTime < TOKEN_COMMENT_COOLDOWN) return;

          const token = event.data;

          // Check if it has a silly name worth roasting
          const sillyCategory = detectSillyName(token.symbol || '', token.name || '');

          // Always roast silly names, otherwise 50% chance for interesting tokens
          if (!sillyCategory && Math.random() > 0.5) return;

          lastTokenCommentTime = now;

          try {
            let commentary: string;

            if (sillyCategory) {
              // Generate a roast for the silly name
              commentary = await claude.generateSillyNameRoast(
                {
                  symbol: token.symbol,
                  name: token.name || token.symbol,
                  marketCapSol: token.marketCapSol,
                },
                sillyCategory
              );
              log.debug({ symbol: token.symbol, category: sillyCategory }, 'Silly name detected - roasting');
            } else {
              // Generate standard commentary for interesting token
              commentary = await claude.generateTokenCommentary({
                symbol: token.symbol,
                name: token.name || token.symbol,
                marketCapSol: token.marketCapSol,
                liquidity: token.liquidity,
                priceChange5m: token.priceChange5m,
              });
            }

            // Emit commentary event for dashboard
            agentEvents.emit({
              type: 'TOKEN_COMMENTARY',
              timestamp: Date.now(),
              data: {
                mint: token.mint,
                symbol: token.symbol,
                commentary,
                isSillyName: !!sillyCategory,
                sillyCategory: sillyCategory || undefined,
              },
            });

            // Speak the commentary
            await narrator.say(commentary);

            log.debug({ symbol: token.symbol, commentary: commentary.slice(0, 50) }, 'Token commentary generated');
          } catch (error) {
            log.error({ error }, 'Failed to generate token commentary');
          }
        });

        log.info('üé§ Smart token commentary enabled (50% of interesting tokens, 100% of silly names)');
      }

      log.info('');
      log.info('üí¨ Chat enabled - Send messages via WebSocket');
      log.info('Press Ctrl+C to exit.');

    } catch (error) {
      log.error({ error }, 'Failed to start WebSocket server');
    }

    // Keep running
    await new Promise(() => {});
  }
}

main().catch((error) => {
  logger.error({ error: (error as Error).message }, 'Fatal error');
  process.exit(1);
});
</file>

<file path="public/app.js">
// WebSocket client and UI logic for $SCHIZO dashboard

let ws;
let isPaused = false;
let isTokensPaused = false;
let buybackCount = 0;

// Get WebSocket URL based on environment
function getWebSocketUrl() {
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const host = window.location.host;

  // Local development
  if (host.includes('localhost') || host.includes('127.0.0.1')) {
    return 'ws://localhost:8080';
  }

  // Production - use same host
  return `${protocol}//${host}`;
}

// Connect to WebSocket server
function connect() {
  const wsUrl = getWebSocketUrl();
  console.log('Connecting to:', wsUrl);
  ws = new WebSocket(wsUrl);

  ws.onopen = () => {
    console.log('Connected to $SCHIZO agent');
    updateStatus('Connected', true);
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    handleEvent(data);
  };

  ws.onerror = (error) => {
    console.error('WebSocket error:', error);
    updateStatus('Error', false);
  };

  ws.onclose = () => {
    console.log('Disconnected from $SCHIZO agent');
    updateStatus('Disconnected', false);
    // Attempt to reconnect after 5 seconds
    setTimeout(connect, 5000);
  };
}

// Handle incoming events
function handleEvent(event) {
  switch (event.type) {
    case 'CONNECTED':
      addToFeed('üü¢ Connected to agent', 'system');
      break;
    case 'INITIAL_TRADES':
      // Load recent trades on connect/reconnect
      if (event.data.trades && event.data.trades.length > 0) {
        loadInitialTrades(event.data.trades);
      }
      break;
    case 'ANALYSIS_START':
      // Silent - the ANALYSIS_THOUGHT events show the live analysis
      break;
    case 'POSITIONS_UPDATE':
      console.log('üìä POSITIONS_UPDATE received:', event.data.positions.length, 'positions');
      if (event.data.positions.length > 0) {
        console.log('First position:', event.data.positions[0]);
      }
      updateHoldings(event.data.positions);
      // Update Trench Radio based on position state
      updateTrenchRadioFromPositions(event.data.positions);
      break;
    case 'ANALYSIS_THOUGHT':
      // SCHIZO's live analysis thoughts - show in feed!
      const stageEmojis = {
        scanning: 'üîç',
        safety: 'üõ°Ô∏è',
        smart_money: 'üêã',
        decision: 'üéØ'
      };
      const stageLabels = {
        scanning: 'SCANNING',
        safety: 'SAFETY',
        smart_money: 'WHALES',
        decision: 'VERDICT'
      };
      const emoji = stageEmojis[event.data.stage] || 'ü§î';
      const label = stageLabels[event.data.stage] || 'ANALYSIS';
      addToFeed(`${emoji} [${label}] ${event.data.symbol}: "${event.data.thought}"`, `analysis-${event.data.stage}`, event.data.mint);
      break;
    case 'SAFETY_CHECK':
      // Silent - ANALYSIS_THOUGHT handles the voiced commentary
      break;
    case 'SMART_MONEY_CHECK':
      // Silent - ANALYSIS_THOUGHT handles the voiced commentary
      break;
    case 'TRADE_DECISION':
      // Silent - ANALYSIS_THOUGHT handles the voiced commentary
      break;
    case 'TRADE_EXECUTED':
      const tradeEmoji = event.data.type === 'BUY' ? 'üí∞' : 'üí∏';
      addToFeed(`${tradeEmoji} ${event.data.type}: ${event.data.amount.toFixed(2)} SOL - ${formatMint(event.data.mint)}`, 'trade', event.data.mint);
      addToTradesTable(event.data);
      break;
    case 'BUYBACK_TRIGGERED':
      addToFeed(`üîÑ BUYBACK: ${event.data.amount.toFixed(2)} SOL (profit: ${event.data.profit.toFixed(2)} SOL)`, 'buyback');
      if (event.data.reasoning) {
        addToFeed(`   ‚îî‚îÄ ${event.data.reasoning}`, 'buyback-detail');
      }
      buybackCount = (buybackCount || 0) + 1;
      updateBuybackCount();
      break;
    case 'BUYBACK_FAILED':
      addToFeed(`‚ùå BUYBACK FAILED: Attempted ${event.data.attemptedAmount.toFixed(4)} SOL - ${event.data.error}`, 'error');
      break;
    case 'FEE_CLAIMED':
      addToFeed(`üí∞ FEES CLAIMED: ${formatSignature(event.data.signature)}`, 'system');
      break;
    case 'REWARD_CLAIMED':
      addToFeed(`üíé REWARD CLAIMED: ${event.data.amountSol.toFixed(4)} SOL from ${event.data.source}`, 'reward');
      break;
    case 'REWARD_FAILED':
      addToFeed(`‚ùå REWARD FAILED: ${event.data.source} - ${event.data.error}`, 'error');
      break;
    case 'SCAN':
      // Token scan event with full context
      addToFeed(`üì° [SCAN] ${event.data.symbol} from ${event.data.source} - ${event.data.reasoning}`, 'scan', event.data.mint);
      break;
    case 'REJECT':
      // Token rejection with reason
      addToFeed(`‚ùå [REJECT] ${event.data.symbol}: ${event.data.rejectReason} (stage: ${event.data.stage})`, 'reject', event.data.mint);
      break;
    case 'MOOD_CHANGE':
      // Agent mood changed
      addToFeed(`üß† MOOD: ${event.data.previous} ‚Üí ${event.data.current} (${(event.data.intensity * 100).toFixed(0)}%)`, 'mood');
      updateMoodDisplay(event.data.current, event.data.intensity);
      break;
    case 'SIMULATE_ACK':
      // Simulation acknowledgment
      console.log('üß™ Simulation:', event.data.action, '-', event.data.message);
      addToFeed(`üß™ [TEST] ${event.data.message}`, 'test');
      break;
    case 'STATS_UPDATE':
      updateStats(event.data);
      break;
    case 'STOP_LOSS':
      addToFeed(`üõë STOP-LOSS: ${formatMint(event.data.mint)} @ ${event.data.lossPercent.toFixed(1)}% loss`, 'stop-loss', event.data.mint);
      // Trigger Trench Radio crash sound
      if (window.trenchRadio) {
        window.trenchRadio.triggerCrash();
      }
      break;
    case 'TAKE_PROFIT':
      addToFeed(`üéØ TAKE-PROFIT: ${formatMint(event.data.mint)} @ +${event.data.profitPercent.toFixed(1)}% gain`, 'take-profit', event.data.mint);
      break;
    case 'SCHIZO_SPEAKS':
      // Voice only - no text in feed
      break;
    case 'SCHIZO_COMMENTARY':
      // Voice only - no text in feed
      break;
    case 'SCHIZO_LEARNING':
      // Voice only - no text in feed
      break;
    case 'CHAT_RECEIVED':
      const chatUser = event.data.username || 'anon';
      addToChat(`üí¨ @${chatUser}: ${event.data.message}`, 'user-message');
      break;
    case 'CHAT_RESPONSE':
      hideTypingIndicator();
      addToChat(`ü§ñ $SCHIZO: ${event.data.response}`, 'schizo-response');
      break;
    case 'CHAT_TYPING':
      if (event.data.typing) {
        showTypingIndicator();
      } else {
        hideTypingIndicator();
      }
      break;
    case 'VOICE_AUDIO':
      playVoiceAudio(event.data);
      break;
    case 'ANALYSIS_THOUGHT':
      // Only show tokens entering analysis (scanning stage)
      if (event.data.stage === 'scanning') {
        addToAnalysisStream(event.data);
      }
      break;
    case 'TOKEN_COMMENTARY':
      // Claude's random commentary on tokens (voice only, but show in stream)
      highlightTokenCommentary(event.data.mint, event.data.commentary);
      break;
    case 'SCHIZO_TOKEN_UPDATE':
      // Live $SCHIZO token data from backend
      updateSchizoTokenCard(event.data);
      break;
  }
}

// Current token being viewed
let currentToken = null;

// Add token to the analysis stream (tokens SCHIZO is considering)
function addToAnalysisStream(token) {
  if (isTokensPaused) return;

  currentToken = token;

  const container = document.getElementById('token-stream');
  if (!container) return;

  // Check if this token is already in the stream (by mint)
  const existingEl = document.getElementById(`token-${token.mint}`);
  if (existingEl) {
    // Update existing element with flash
    existingEl.classList.add('token-new');
    setTimeout(() => existingEl.classList.remove('token-new'), 2000);
    return;
  }

  const tokenEl = document.createElement('div');
  tokenEl.className = 'token-stream-item analyzing';
  tokenEl.id = `token-${token.mint}`;
  tokenEl.onclick = () => openChart(token.mint);

  const priceChangeClass = (token.priceChange5m || 0) >= 0 ? 'price-up' : 'price-down';
  const priceChangeSign = (token.priceChange5m || 0) >= 0 ? '+' : '';
  const mcapDisplay = token.marketCapSol ? token.marketCapSol.toFixed(1) + ' SOL' : '-';
  const liquidityDisplay = token.liquidity ? '$' + formatNumber(token.liquidity) : '-';

  tokenEl.innerHTML = `
    <div class="token-stream-left">
      <div class="token-stream-img-placeholder analyzing-pulse">üëÅÔ∏è</div>
      <div class="token-stream-info">
        <span class="token-stream-symbol">${token.symbol || 'UNK'}</span>
        <span class="token-stream-name">${(token.name || 'Unknown').slice(0, 20)}</span>
        <span class="token-stream-ca clickable-ca" data-ca="${token.mint}" title="Click to copy CA">${formatMint(token.mint)}</span>
      </div>
    </div>
    <div class="token-stream-right">
      <span class="token-stream-price">${liquidityDisplay}</span>
      <span class="token-stream-mcap">${mcapDisplay}</span>
      <span class="token-stream-change ${priceChangeClass}">${priceChangeSign}${(token.priceChange5m || 0).toFixed(1)}%</span>
    </div>
    <div class="analysis-thought" title="SCHIZO's thought">${truncateThought(token.thought)}</div>
  `;

  // Add click handler for CA copy (stop propagation to not trigger chart open)
  const caElement = tokenEl.querySelector('.clickable-ca');
  if (caElement) {
    caElement.addEventListener('click', (e) => {
      e.stopPropagation();
      copyToClipboard(token.mint, caElement);
    });
  }

  // Add to top of stream
  container.insertBefore(tokenEl, container.firstChild);

  // Limit to 15 items (fewer since they have more content)
  while (container.children.length > 15) {
    container.removeChild(container.lastChild);
  }

  // Flash effect for new token
  tokenEl.classList.add('token-new');
  setTimeout(() => tokenEl.classList.remove('token-new'), 2000);
}

// Truncate long thoughts for display
function truncateThought(thought) {
  if (!thought) return '';
  return thought.length > 80 ? thought.slice(0, 77) + '...' : thought;
}

// Highlight token when Claude comments on it
function highlightTokenCommentary(mint, commentary) {
  const tokenEl = document.getElementById(`token-${mint}`);
  if (tokenEl) {
    tokenEl.classList.add('token-commented');

    // Add commentary bubble
    const bubble = document.createElement('div');
    bubble.className = 'token-commentary-bubble';
    bubble.textContent = commentary.slice(0, 100) + (commentary.length > 100 ? '...' : '');
    tokenEl.appendChild(bubble);

    // Remove after 8 seconds
    setTimeout(() => {
      tokenEl.classList.remove('token-commented');
      bubble.remove();
    }, 8000);
  }
}

// Format large numbers
function formatNumber(num) {
  if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
  if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
  return num.toFixed(0);
}

// Open chart popup
function openChart(mint, dexUrl) {
  const popup = document.getElementById('chart-popup');
  const iframe = document.getElementById('chart-iframe');

  // Use DexScreener embed
  iframe.src = `https://dexscreener.com/solana/${mint}?embed=1&theme=dark&trades=0&info=0`;
  popup.classList.add('visible');
}

// Close chart popup
function closeChart() {
  const popup = document.getElementById('chart-popup');
  const iframe = document.getElementById('chart-iframe');
  popup.classList.remove('visible');
  iframe.src = '';
}

// Audio queue to prevent overlapping speech
let audioQueue = [];
let isPlayingAudio = false;
let currentAudio = null;

// Play voice audio from base64 - queued to prevent overlap
function playVoiceAudio(data) {
  audioQueue.push(data);
  processAudioQueue();
}

function processAudioQueue() {
  if (isPlayingAudio || audioQueue.length === 0) return;

  isPlayingAudio = true;
  const data = audioQueue.shift();

  try {
    // Stop any currently playing audio
    if (currentAudio) {
      currentAudio.pause();
      currentAudio = null;
    }

    currentAudio = new Audio(`data:audio/mp3;base64,${data.audio}`);

    currentAudio.onended = () => {
      isPlayingAudio = false;
      currentAudio = null;
      // Small delay between speeches
      setTimeout(processAudioQueue, 300);
    };

    currentAudio.onerror = () => {
      console.error('Audio playback error');
      isPlayingAudio = false;
      currentAudio = null;
      processAudioQueue();
    };

    currentAudio.play().catch(err => {
      console.log('Audio autoplay blocked:', err);
      isPlayingAudio = false;
      currentAudio = null;
      processAudioQueue();
    });
  } catch (error) {
    console.error('Error playing audio:', error);
    isPlayingAudio = false;
    processAudioQueue();
  }
}

// Update dashboard stats
function updateStats(stats) {
  document.getElementById('winRate').textContent = stats.winRate.toFixed(1) + '%';
  
  // Calculate PnL breakdown
  const realizedPnL = stats.realizedPnL ?? 0;
  const unrealizedPnL = stats.unrealizedPnL ?? 0;
  const totalPnL = realizedPnL + unrealizedPnL;
  
  const pnlElement = document.getElementById('pnl');
  
  // Format PnL values with sign
  const formatPnL = (val) => (val >= 0 ? '+' : '') + val.toFixed(3);
  
  // Display breakdown: Compact vertical stack with grid
  // R: +0.000
  // U: +0.000
  // T: +0.000
  pnlElement.textContent = formatPnL(totalPnL) + (stats.balance !== undefined ? ' SOL' : '');
  pnlElement.className = totalPnL >= 0 ? 'positive' : 'negative';
  
  if (stats.totalBuybackSol && stats.totalBuybackSol > 0) {
    document.getElementById('buybacks').textContent = `${stats.totalBuybacks} (${stats.totalBuybackSol.toFixed(2)} SOL)`;
  } else {
    document.getElementById('buybacks').textContent = stats.totalBuybacks;
  }
  if (stats.balance !== undefined) {
    document.getElementById('balance').textContent = stats.balance.toFixed(4) + ' SOL';
  }
}

// Add event to feed
function addToFeed(message, className = '', mint = null) {
  if (isPaused) return;

  const feed = document.getElementById('feed');
  const div = document.createElement('div');
  div.className = `event ${className}`;

  const timestamp = new Date().toLocaleTimeString();

  // If mint provided, make it clickable
  if (mint) {
    const formattedMint = formatMint(mint);
    const clickableMint = `<span class="clickable-ca" data-ca="${mint}" title="Click to copy CA">${formattedMint}</span>`;
    message = message.replace(formattedMint, clickableMint);
  }

  div.innerHTML = `<span class="timestamp">[${timestamp}]</span>${message}`;

  // Add click handler for CA if present
  const caElement = div.querySelector('.clickable-ca');
  if (caElement) {
    caElement.addEventListener('click', (e) => {
      copyToClipboard(caElement.dataset.ca, caElement);
    });
  }

  feed.appendChild(div);

  // Auto-scroll to bottom
  feed.scrollTop = feed.scrollHeight;

  // Limit feed to 100 items
  while (feed.children.length > 100) {
    feed.removeChild(feed.firstChild);
  }
}

// Add message to chat box
function addToChat(message, className = '') {
  const chatBox = document.getElementById('chat-messages');
  const div = document.createElement('div');
  div.className = `chat-msg ${className}`;

  const timestamp = new Date().toLocaleTimeString();
  div.innerHTML = `<span class="timestamp">[${timestamp}]</span>${message}`;

  chatBox.appendChild(div);

  // Auto-scroll to bottom
  chatBox.scrollTop = chatBox.scrollHeight;

  // Limit chat to 50 items
  while (chatBox.children.length > 50) {
    chatBox.removeChild(chatBox.firstChild);
  }
}

// Typing indicator
function showTypingIndicator() {
  const chatBox = document.getElementById('chat-messages');

  // Don't add if already showing
  if (document.getElementById('typing-indicator')) return;

  const div = document.createElement('div');
  div.id = 'typing-indicator';
  div.className = 'chat-msg typing-indicator';
  div.innerHTML = `<span class="typing-dots">ü§ñ $SCHIZO is typing<span>.</span><span>.</span><span>.</span></span>`;

  chatBox.appendChild(div);
  chatBox.scrollTop = chatBox.scrollHeight;
}

function hideTypingIndicator() {
  const indicator = document.getElementById('typing-indicator');
  if (indicator) {
    indicator.remove();
  }
}

// Add trade to table
function addToTradesTable(trade) {
  const tbody = document.querySelector('#trades tbody');
  const row = document.createElement('tr');

  const time = new Date(trade.timestamp || Date.now()).toLocaleTimeString();
  const typeClass = trade.type === 'BUY' ? 'trade-buy' : 'trade-sell';
  const signature = formatSignature(trade.signature);

  row.innerHTML = `
    <td>${time}</td>
    <td class="${typeClass}">${trade.type}</td>
    <td><span class="clickable-ca" data-ca="${trade.mint}" title="Click to copy CA">${formatMint(trade.mint)}</span></td>
    <td>${trade.amount.toFixed(2)} SOL</td>
    <td><a href="https://solscan.io/tx/${trade.signature}" target="_blank">${signature}</a></td>
  `;

  // Add click handler for CA copy
  const caElement = row.querySelector('.clickable-ca');
  if (caElement) {
    caElement.addEventListener('click', (e) => {
      copyToClipboard(trade.mint, caElement);
    });
  }

  tbody.insertBefore(row, tbody.firstChild);

  // Limit table to 20 rows
  while (tbody.children.length > 20) {
    tbody.removeChild(tbody.lastChild);
  }
}

// Load initial trades from server (on connect/reconnect)
function loadInitialTrades(trades) {
  const tbody = document.querySelector('#trades tbody');

  // Clear existing trades
  tbody.innerHTML = '';

  // Add trades in reverse order (oldest first, so newest ends up at top)
  trades.slice().reverse().forEach(trade => {
    addToTradesTable(trade);
  });
}

// Update status indicator
function updateStatus(status, connected) {
  const statusEl = document.getElementById('status');
  statusEl.textContent = status;
  statusEl.className = connected ? 'status-connected' : 'status-disconnected';
}

// Update buyback count
function updateBuybackCount() {
  document.getElementById('buybacks').textContent = buybackCount;
}

// Format mint address
function formatMint(mint) {
  return mint.slice(0, 4) + '...' + mint.slice(-4);
}

// Format signature
function formatSignature(sig) {
  return sig.slice(0, 8) + '...';
}

// Copy to clipboard with visual feedback
function copyToClipboard(text, element) {
  navigator.clipboard.writeText(text).then(() => {
    // Show toast notification
    showCopyToast('CA Copied!');

    // Add visual feedback to clicked element
    if (element) {
      element.classList.add('copy-success');
      setTimeout(() => element.classList.remove('copy-success'), 1500);
    }
  }).catch(err => {
    console.error('Failed to copy:', err);
  });
}

// Show copy toast notification
function showCopyToast(message) {
  // Remove existing toast
  const existingToast = document.querySelector('.copy-toast');
  if (existingToast) existingToast.remove();

  const toast = document.createElement('div');
  toast.className = 'copy-toast';
  toast.textContent = message;
  document.body.appendChild(toast);

  // Trigger animation
  setTimeout(() => toast.classList.add('show'), 10);

  // Remove after animation
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => toast.remove(), 300);
  }, 1500);
}

// Pause/Resume feed
document.getElementById('pauseBtn').addEventListener('click', () => {
  isPaused = !isPaused;
  const btn = document.getElementById('pauseBtn');
  btn.textContent = isPaused ? 'Resume' : 'Pause';
});

// Pause/Resume tokens stream
document.getElementById('pauseTokensBtn')?.addEventListener('click', () => {
  isTokensPaused = !isTokensPaused;
  const btn = document.getElementById('pauseTokensBtn');
  btn.textContent = isTokensPaused ? 'Resume' : 'Pause';
});

// Chat functionality
const chatInput = document.getElementById('chatInput');
const sendBtn = document.getElementById('sendBtn');

function sendChatMessage() {
  const message = chatInput.value.trim();
  if (!message || ws.readyState !== WebSocket.OPEN) return;

  ws.send(JSON.stringify({
    type: 'CHAT',
    message: message,
    username: getUsername() // Use dynamic username
  }));

  chatInput.value = '';
}

sendBtn.addEventListener('click', sendChatMessage);

// Get username with fallback
function getUsername() {
  const input = document.getElementById('usernameInput');
  return input && input.value.trim() ? input.value.trim() : 'anon';
}

// Handle username changes
const usernameInput = document.getElementById('usernameInput');
if (usernameInput) {
  // Load saved username
  const savedName = localStorage.getItem('schizo_username');
  if (savedName) {
    usernameInput.value = savedName;
  }

  // Save on change
  usernameInput.addEventListener('change', () => {
    localStorage.setItem('schizo_username', usernameInput.value.trim());
  });
}

chatInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    sendChatMessage();
  }
});

// Connect on page load
connect();

// Fetch $SCHIZO CA on page load
fetch('/api/schizo-ca')
  .then(res => res.json())
  .then(data => {
    if (data.ca) {
      updateSchizoTokenCard({ ca: data.ca, live: data.live });
    }
  })
  .catch(err => console.log('CA fetch failed:', err));

// $SCHIZO Token Card - Update function for when token goes live
function updateSchizoTokenCard(data) {
  if (data.price) {
    document.getElementById('schizo-price').textContent =
      data.price < 0.0001 ? '$' + data.price.toExponential(2) : '$' + data.price.toFixed(6);
  }
  if (data.marketCap) {
    document.getElementById('schizo-mcap').textContent = '$' + formatNumber(data.marketCap);
  }
  if (data.holders) {
    document.getElementById('schizo-holders').textContent = formatNumber(data.holders);
  }
  if (data.volume24h) {
    document.getElementById('schizo-volume').textContent = '$' + formatNumber(data.volume24h);
  }
  if (data.ca) {
    const caInput = document.getElementById('schizo-ca-input');
    if (caInput) {
      caInput.value = data.ca;
      caInput.onclick = () => {
        caInput.select();
        navigator.clipboard.writeText(data.ca);
        
        // Visual feedback
        const oldVal = caInput.value;
        const hint = document.querySelector('.copy-hint');
        if (hint) {
            const originalText = hint.textContent;
            hint.textContent = 'COPIED!';
            hint.style.color = '#4ade80';
            setTimeout(() => {
                hint.textContent = originalText;
                hint.style.color = '';
            }, 1500);
        }
      };
    }
    
    // Hide "Coming Soon" badge when CA is available
    const statusEl = document.querySelector('.token-card-status');
    if (statusEl) {
      statusEl.style.display = 'none';
    }
  }
  if (data.live) {
    const statusEl = document.querySelector('.token-card-status');
    if (statusEl) {
      statusEl.textContent = 'Live';
      statusEl.classList.add('live');
      statusEl.style.display = ''; // Show it again as "Live"
    }
    
    // Update button text/link if needed
    const buyBtn = document.querySelector('.btn-primary');
    if (buyBtn && data.dexUrl) {
        buyBtn.href = data.dexUrl;
        buyBtn.textContent = 'BUY NOW';
    }
  }
}

// Handle SCHIZO_TOKEN_UPDATE event from server (when token goes live)
// This will be emitted by the server when fetching data from DexScreener/PumpPortal

// ============================================
// TERMINAL LOGIC
// ============================================
const terminalMessages = [
    '> SEARCHING FOR ALPHA...',
    '> ERROR: TRUST NO ONE.',
    '> DETECTING JEETS...',
    '> SCANNING MEMPOOL...',
    '> ANALYZING WHALE MOVEMENTS...',
    '> SYSTEM INTEGRITY: COMPROMISED',
    '> THE BLOCKCHAIN IS WATCHING',
    '> ENCRYPTING THOUGHTS...',
    '> DECODING SMART MONEY...',
    '> PARANOIA LEVEL: CRITICAL',
    '> BUY SIGNALS DETECTED',
    '> IGNORING FUD...',
    '> EXECUTING STRATEGY 99...',
    '> CHECKING WALLET SECURITY...'
];

function initTerminal() {
    const terminal = document.getElementById('terminal-content');
    if (!terminal) return;

    function addLine(text) {
        const line = document.createElement('div');
        line.className = 'terminal-line';
        terminal.appendChild(line);
        
        let i = 0;
        const speed = 30 + Math.random() * 40;
        
        const interval = setInterval(() => {
            line.textContent += text.charAt(i);
            i++;
            if (i >= text.length) clearInterval(interval);
        }, speed);

        // Keep last 6 lines
        while (terminal.children.length > 6) {
            terminal.removeChild(terminal.firstChild);
        }
    }

    // Random interval
    function scheduleNext() {
        const delay = 1500 + Math.random() * 2500;
        setTimeout(() => {
            const msg = terminalMessages[Math.floor(Math.random() * terminalMessages.length)];
            addLine(msg);
            scheduleNext();
        }, delay);
    }
    
    scheduleNext();
}

// ============================================
// EYE TRACKING LOGIC
// ============================================
function initEyeTracking() {
    const logo = document.getElementById('hero-logo');
    if (!logo) return;

    document.addEventListener('mousemove', (e) => {
        const rect = logo.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        const deltaX = e.clientX - centerX;
        const deltaY = e.clientY - centerY;

        // Limit movement magnitude
        const moveX = Math.min(Math.max(deltaX / 25, -12), 12);
        const moveY = Math.min(Math.max(deltaY / 25, -12), 12);

        logo.style.transform = `translate(${moveX}px, ${moveY}px)`;
    });
}

// Initialize new features when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    initTerminal();
    initEyeTracking();
    initPanelTabs();
});

// ============================================
// PANEL TABS LOGIC
// ============================================
function initPanelTabs() {
    const tabs = document.querySelectorAll('.panel-tab');

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const targetTab = tab.dataset.tab;

            // Update tab active states
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');

            // Update content visibility
            const tokenStream = document.getElementById('token-stream');
            const holdingsStream = document.getElementById('holdings-stream');

            if (targetTab === 'analyzing') {
                tokenStream.classList.add('active');
                holdingsStream.classList.remove('active');
            } else if (targetTab === 'holdings') {
                tokenStream.classList.remove('active');
                holdingsStream.classList.add('active');
            }
        });
    });
}

// ============================================
// HOLDINGS DISPLAY LOGIC
// ============================================
let currentHoldings = [];

function updateHoldings(positions) {
    console.log('üîÑ updateHoldings called with', positions.length, 'positions');
    currentHoldings = positions;
    const container = document.getElementById('holdings-stream');
    const countEl = document.getElementById('holdings-count');

    if (!container) return;

    // Update count in tab
    if (countEl) {
        countEl.textContent = `(${positions.length})`;
    }

    // Clear container
    container.innerHTML = '';

    // Show empty state if no holdings
    if (positions.length === 0) {
        console.log('‚ö†Ô∏è No positions to display');
        container.innerHTML = `
            <div class="holdings-empty">
                <div class="holdings-empty-icon">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect>
                        <path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>
                    </svg>
                </div>
                <div>No active holdings</div>
                <div style="font-size: 0.85em; opacity: 0.7;">Positions will appear here when trades are executed</div>
            </div>
        `;
        return;
    }

    // Render each holding
    positions.forEach(pos => {
        const holdingEl = document.createElement('div');
        holdingEl.className = 'holding-item';
        holdingEl.onclick = () => openChart(pos.tokenMint);

        // Use actual symbol if available, fallback to truncated mint
        const symbol = pos.tokenSymbol || pos.tokenMint.slice(0, 6);
        // Use name if available, otherwise show CA
        const name = pos.tokenName || formatMint(pos.tokenMint);
        const pnlPercent = pos.unrealizedPnLPercent || 0;
        const pnlClass = pnlPercent >= 0 ? 'profit' : 'loss';
        const pnlSign = pnlPercent >= 0 ? '+' : '';
        const entryAge = getTimeAgo(pos.entryTimestamp);

        // Show actual token image if available, otherwise fallback to $ icon
        const imageHtml = pos.tokenImage
            ? `<img src="${pos.tokenImage}" alt="${symbol}" class="holding-token-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
               <div class="holding-icon-fallback" style="display:none;">$</div>`
            : `<div class="holding-icon-fallback">$</div>`;

        holdingEl.innerHTML = `
            <div class="holding-left">
                <div class="holding-icon">${imageHtml}</div>
                <div class="holding-info">
                    <span class="holding-symbol">${symbol}</span>
                    <span class="holding-name">${name}</span>
                    <span class="holding-ca clickable-ca" data-ca="${pos.tokenMint}" title="Click to copy CA">${formatMint(pos.tokenMint)}</span>
                </div>
            </div>
            <div class="holding-right">
                <span class="holding-value">${pos.entryAmountSol.toFixed(3)} SOL</span>
                <span class="holding-pnl ${pnlClass}">${pnlSign}${pnlPercent.toFixed(1)}%</span>
                <span class="holding-entry">Entry: ${entryAge}</span>
            </div>
        `;

        // Add click handler for CA copy
        const caElement = holdingEl.querySelector('.clickable-ca');
        if (caElement) {
            caElement.addEventListener('click', (e) => {
                e.stopPropagation();
                copyToClipboard(pos.tokenMint, caElement);
            });
        }

        container.appendChild(holdingEl);
    });
}

// Helper to get time ago string
function getTimeAgo(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;

    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (days > 0) return `${days}d ago`;
    if (hours > 0) return `${hours}h ago`;
    if (minutes > 0) return `${minutes}m ago`;
    return 'Just now';
}

// ============================================
// TRENCH RADIO INTEGRATION
// ============================================

/**
 * Update Trench Radio state based on positions
 */
function updateTrenchRadioFromPositions(positions) {
    if (!window.trenchRadio) return;

    // Check if we have any active positions
    const hasPositions = positions && positions.length > 0;

    if (!hasPositions) {
        window.trenchRadio.updatePositionPnL(0, false);
        window.trenchRadio.setState('SCANNING');
        updateTrenchRadioUI('SCANNING');
        return;
    }

    // Calculate aggregate PnL across all positions
    let totalPnL = 0;
    let totalWeight = 0;

    positions.forEach(pos => {
        if (pos.unrealizedPnLPercent !== undefined) {
            const weight = pos.entryAmountSol || 1;
            // Convert percentage to decimal (30% -> 0.30) and multiply by position size
            const positionPnL = (pos.unrealizedPnLPercent / 100) * weight;
            console.log(`üí∞ Position ${pos.tokenSymbol}: ${pos.unrealizedPnLPercent}% * ${weight} SOL = ${positionPnL} SOL`);
            totalPnL += positionPnL;
            totalWeight += weight;
        }
    });

    const avgPnL = totalWeight > 0 ? (totalPnL / totalWeight) * 100 : 0; // Convert back to percentage
    console.log(`üìä Total P&L: ${totalPnL} SOL across ${totalWeight} SOL (${avgPnL.toFixed(2)}% avg)`);

    // Link trench radio state to audio
    if (window.trenchRadio) {
        window.trenchRadio.updatePositionPnL(avgPnL, true);
        
        let newState = 'SCANNING';
        if (avgPnL >= 0) newState = 'POSITION_UP';
        else newState = 'POSITION_DOWN';
        
        window.trenchRadio.setState(newState);
        updateTrenchRadioUI(newState);
    }
}

/**
 * Update Trench Radio UI state indicator
 */
function updateTrenchRadioUI(state) {
    const stateEl = document.getElementById('trench-radio-state');
    if (!stateEl) return;

    // Remove all state classes
    stateEl.classList.remove('scanning', 'position-up', 'position-down', 'crash');

    // Update text and class based on state
    switch (state) {
        case 'SCANNING':
            stateEl.textContent = 'SCANNING';
            stateEl.classList.add('scanning');
            break;
        case 'POSITION_UP':
            stateEl.textContent = 'PUMPING';
            stateEl.classList.add('position-up');
            break;
        case 'POSITION_DOWN':
            stateEl.textContent = 'DUMPING';
            stateEl.classList.add('position-down');
            break;
        case 'CRASH':
            stateEl.textContent = 'REKT';
            stateEl.classList.add('crash');
            break;
        default:
            stateEl.textContent = 'OFF';
    }
}

// initTrenchRadio removed to avoid conflict with trench-radio.js logic

// ============================================
// MOOD DISPLAY
// ============================================

/**
 * Update the mood indicator display
 */
function updateMoodDisplay(mood, intensity) {
    const moodEl = document.getElementById('agent-mood');
    if (!moodEl) return;

    // Mood colors
    const moodColors = {
        'CONFIDENT': '#22c55e',
        'PARANOID': '#ef4444',
        'MANIC': '#f59e0b',
        'DEPRESSED': '#6b7280',
        'EUPHORIC': '#8b5cf6',
        'ANXIOUS': '#f97316',
    };

    const color = moodColors[mood] || '#94a3b8';

    moodEl.textContent = mood;
    moodEl.style.color = color;
    moodEl.style.textShadow = `0 0 ${intensity * 10}px ${color}`;
}

// ============================================
// SIMULATION HELPERS (for testing without real SOL)
// ============================================

/**
 * Send simulation request to server
 * Usage in browser console:
 *   simulateEvent('scan')
 *   simulateEvent('buy')
 *   simulateEvent('sell', { isProfit: true })
 *   simulateEvent('mood', { mood: 'PARANOID' })
 */
function simulateEvent(action, params = {}) {
    if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.error('WebSocket not connected');
        return;
    }

    ws.send(JSON.stringify({
        type: 'SIMULATE',
        action: action,
        params: params
    }));

    console.log(`üß™ Simulation request sent: ${action}`, params);
}

// Expose for console usage
window.simulateEvent = simulateEvent;

// Quick simulation shortcuts
window.simScan = () => simulateEvent('scan');
window.simReject = () => simulateEvent('reject');
window.simBuy = () => simulateEvent('buy');
window.simTakeProfit = () => simulateEvent('sell', { isProfit: true });
window.simStopLoss = () => simulateEvent('sell', { isProfit: false });
window.simBuyback = () => simulateEvent('buyback');
window.simMood = (mood) => simulateEvent('mood', { mood: mood || 'PARANOID' });
window.simReward = () => simulateEvent('reward');
window.simRewardFail = () => simulateEvent('reward', { success: false });

console.log('üß™ Simulation helpers loaded. Use these in console:');
console.log('   simScan() - Simulate token scan');
console.log('   simReject() - Simulate token rejection');
console.log('   simBuy() - Simulate buy trade');
console.log('   simTakeProfit() - Simulate take-profit exit');
console.log('   simStopLoss() - Simulate stop-loss exit');
console.log('   simBuyback() - Simulate buyback');
console.log('   simMood("PARANOID") - Simulate mood change');
console.log('   simReward() - Simulate reward claim');
console.log('   simRewardFail() - Simulate reward failure');
</file>

<file path="src/trading/trading-engine.ts">
/**
 * Trading Engine - Decision logic and risk management
 *
 * PRODUCTION RISK RULES (NON-NEGOTIABLE):
 * - Stop Loss: 10% (0.10)
 * - Take Profit: 30% (0.30)
 * - Buyback: 10% of ALL profitable exits
 *
 * These values are HARDCODED and cannot be overridden by config or environment.
 * EntertainmentMode CANNOT bypass these rules.
 */

import { Connection, type Keypair, PublicKey } from '@solana/web3.js';
import type { DatabaseWithRepositories } from '../db/database-with-repos.js';
import { PumpPortalClient } from './pumpportal-client.js';
import { TokenSafetyAnalyzer } from '../analysis/token-safety.js';
import { SmartMoneyTracker } from '../analysis/smart-money.js';
import type { TokenSafetyResult } from '../analysis/types.js';
import { logger } from '../lib/logger.js';
import type { ClaudeClient } from '../personality/claude-client.js';
import type { AnalysisContext } from '../personality/prompts.js';
import { agentEvents } from '../events/emitter.js';
import { TransactionParser } from './transaction-parser.js';
import { dexscreener } from '../api/dexscreener.js';
import type { HeliusClient } from '../api/helius.js';
import { ScoringEngine, type TokenScore } from './scoring-engine.js';
import type { RiskProfile } from './types.js';
import { JupiterClient } from '../api/jupiter.js';
import { LearningEngine, type TradeFeatures, type TradeLesson } from '../analysis/learning-engine.js';

/**
 * ============================================================
 * HARDCODED RISK CONSTANTS - DO NOT MODIFY
 * These protect real SOL. Any changes require audit approval.
 * ============================================================
 */
const HARD_STOP_LOSS_PERCENT = 0.10;      // 10% loss = immediate exit
const HARD_TAKE_PROFIT_PERCENT = 0.30;    // 30% gain = take profit
const BUYBACK_PERCENT_OF_PROFIT = 0.10;   // 10% of profit goes to $SCHIZO buyback

/**
 * Known LP pool program addresses to exclude from holder concentration
 */
const LP_PROGRAM_ADDRESSES = new Set([
  '5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1', // Raydium AMM
  '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8', // Raydium V4
  'CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK', // Raydium CLMM
  '6EF8rrecthR5Dkzon8Nwu2RMhZvZP9vhU8uLxWv2fCmY', // Pump.fun Bonding Curve
]);

/**
 * Trading configuration
 * Note: stopLossPercent and takeProfitPercent are IGNORED in favor of hardcoded values
 */
export interface TradingConfig {
  riskProfile: RiskProfile; // Added Risk Profile
  basePositionSol: number; // Base position size in SOL
  maxPositionSol: number; // Maximum position size in SOL
  maxOpenPositions: number; // Maximum concurrent open positions
  maxDailyTrades: number; // Maximum trades per day
  circuitBreakerDailyLoss: number; // Daily loss threshold (negative number)
  circuitBreakerConsecutiveLosses: number; // Consecutive loss threshold
  minLiquiditySol: number; // Minimum liquidity required
  slippageTolerance: number; // Slippage tolerance (0-1)
  stopLossPercent: number; // DEPRECATED: Hardcoded to 10%
  takeProfitPercent: number; // DEPRECATED: Hardcoded to 30%
}

/**
 * Open position with entry details
 */
export interface OpenPosition {
  tokenMint: string;
  tokenSymbol?: string;
  tokenName?: string;
  tokenImage?: string; // Token image URL
  entryAmountSol: number;
  entryAmountTokens: number;
  entryPrice: number; // SOL per token at entry
  entryTimestamp: number;
  currentPrice?: number; // Current price if available
  unrealizedPnLPercent?: number; // Unrealized P&L as percentage
}

/**
 * Trade decision result
 */
export interface TradeDecision {
  shouldTrade: boolean;
  positionSizeSol: number;
  reasons: string[];
  safetyAnalysis: TokenSafetyResult;
  smartMoneyCount: number;
  reasoning?: string; // AI-generated reasoning (Phase 4)
}

/**
 * Trading statistics
 */
export interface TradingStats {
  todayTrades: number;
  openPositions: number;
  realizedPnL: number;     // Profit/loss from closed positions only
  unrealizedPnL: number;   // Current value change of open positions
  dailyPnL: number;        // Backwards compat: same as realizedPnL
  consecutiveLosses: number;
  circuitBreakerActive: boolean;
  circuitBreakerReason: string | null;
}

/**
 * Trading Engine
 * 
 * Integrates Phase 2 analysis modules to make intelligent trading decisions
 * with position sizing and risk management.
 */
/**
 * Holder concentration result
 */
interface HolderConcentrationResult {
  top10Percent: number;
  topHolderPercent: number;
  isConcentrated: boolean;
  reason?: string;
}

export class TradingEngine {
  private config: TradingConfig;
  private pumpPortal: PumpPortalClient;
  private tokenSafety: TokenSafetyAnalyzer;
  private smartMoney: SmartMoneyTracker;
  private db: DatabaseWithRepositories;
  private claude?: ClaudeClient; // Optional for Phase 4
  private connection: Connection;
  private txParser: TransactionParser;
  private walletAddress: string;
  private helius: HeliusClient;
  private jupiter?: JupiterClient; // Optional Jupiter client for graduated tokens
  private learningEngine?: LearningEngine; // Learning from trade outcomes
  private entryFeatures: Map<string, { features: TradeFeatures; confidence: number; entryPrice: number }> = new Map();
  private priceCache: Map<string, { price: number; timestamp: number }> = new Map(); // Cache prices for 10s
  private walletCache: { tokens: Array<{ mint: string; balance: number }>; timestamp: number } | null = null; // Cache wallet holdings for 30s

  constructor(
    config: TradingConfig,
    pumpPortal: PumpPortalClient,
    tokenSafety: TokenSafetyAnalyzer,
    smartMoney: SmartMoneyTracker,
    db: DatabaseWithRepositories,
    connection: Connection,
    walletAddress: string,
    helius: HeliusClient,
    claude?: ClaudeClient,
    jupiter?: JupiterClient,
    learningEngine?: LearningEngine
  ) {
    this.config = config;
    this.pumpPortal = pumpPortal;
    this.tokenSafety = tokenSafety;
    this.smartMoney = smartMoney;
    this.db = db;
    this.connection = connection;
    this.walletAddress = walletAddress;
    this.helius = helius;
    this.txParser = new TransactionParser(connection);
    this.claude = claude;
    this.jupiter = jupiter;
    this.learningEngine = learningEngine;

    logger.info({ config, hasPersonality: !!claude, hasJupiter: !!jupiter, hasLearning: !!learningEngine }, 'Trading Engine initialized');
  }

  /**
   * Sync positions from on-chain data
   * Recovers missing positions by checking wallet holdings
   */
  async syncPositions(): Promise<void> {
    logger.info('Starting position sync...');

    try {
      // 1. Get all token accounts
      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
        new PublicKey(this.walletAddress),
        { programId: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') }
      );

      // 2. Get current known positions from DB
      const knownPositions = await this.getOpenPositions();
      const knownMints = new Set(knownPositions.map(p => p.tokenMint));

      // 3. Check for discrepancies
      for (const account of tokenAccounts.value) {
        const info = account.account.data.parsed.info;
        const mint = info.mint;
        const amount = parseFloat(info.tokenAmount.uiAmountString);

        // Skip SOL (wrapped SOL is usually transient but we can skip 'So111...')
        if (mint === 'So11111111111111111111111111111111111111112') continue;

        // Skip if dust (less than 1 token - assuming meme tokens here, adjust for high value?)
        // Safer: Skip if value < small threshold, but we don't have price yet.
        // Let's assume > 0 is relevant for now if not tracked.
        if (amount <= 0) continue;

        // Skip if already known
        if (knownMints.has(mint)) continue;
        
        logger.info({ mint, amount }, 'Found untracked position on-chain');

        // 4. Restore position
        await this.restorePosition(mint, amount);
      }
      
      logger.info('Position sync complete');
    } catch (error) {
      logger.error({ error }, 'Failed to sync positions');
    }
  }

  /**
   * Restore a missing position by inferring cost basis from history
   */
  private async restorePosition(mint: string, currentAmount: number): Promise<void> {
    logger.info({ mint, currentAmount }, 'Restoring missing position...');

    try {
      // Fetch recent transactions for this mint (to find the buy)
      // We look at wallet history. Helius API allows filtering by token? 
      // getTransactionsForAddress returns all txs. We have to filter.
      // This might be heavy if history is long.
      
      const response = await this.helius.getTransactionsForAddress(this.walletAddress, { limit: 100 });
      let bestBuyTx: any = null;
      let estimatedCostBasis = 0;

      // Scan txs for token transfers involving this mint
      // This is a rough heuristic.
      // Ideally we'd use Helius Enhanced API filter, but our client wrappers might not expose it fully yet.
      // We'll trust the latest large BUY or just default to current price.
      
      // Attempt to get token info for metadata - try PumpPortal first, fallback to DexScreener
      let symbol = 'UNKNOWN';
      let name = 'Unknown Token';
      let price = 0;

      try {
        const info = await this.pumpPortal.getTokenInfo(mint);
        symbol = info.symbol;
        name = info.name;
        price = info.price; // SOL price
      } catch {
        // PumpPortal failed (token may have graduated) - try DexScreener
        logger.debug({ mint }, 'PumpPortal failed in restorePosition, trying DexScreener');
        try {
          const dexData = await dexscreener.getRawPairs(mint);
          if (dexData && dexData.length > 0) {
            symbol = dexData[0].baseToken?.symbol || 'UNKNOWN';
            name = dexData[0].baseToken?.name || 'Unknown Token';
            price = parseFloat(dexData[0].priceNative || '0');
            logger.info({ mint, symbol, price }, 'Got price from DexScreener for sync');
          }
        } catch (dexErr) {
          logger.warn({ mint, error: dexErr }, 'DexScreener also failed');
        }
      }

      // If we can't find a historical buy easily (parsing complicated), we use current price as cost basis
      // to avoid messing up P&L calculations too much (start from 0% P&L).
      estimatedCostBasis = price * currentAmount;

      logger.info({ mint, price, estimatedCostBasis }, 'Restoring with estimated cost basis');

      // Insert "synthetic" trade record
      await this.db.trades.insert({
        signature: `sync-${mint.slice(0, 8)}-${Date.now()}`, // Fake signature
        timestamp: Date.now(),
        type: 'BUY',
        tokenMint: mint,
        tokenSymbol: symbol,
        amountTokens: currentAmount,
        amountSol: estimatedCostBasis,
        pricePerToken: price,
        metadata: {
           isSync: true,
           note: 'Restored from on-chain data',
           tokenName: name
        }
      });

      logger.info({ mint, amount: currentAmount }, 'Position restored in database');
      
    } catch (error) {
       logger.error({ mint, error }, 'Failed to restore position');
    }
  }

  /**
   * Check holder concentration for a token
   * STRICT: Rejects if top 10 holders own >20% or any single holder owns >10%
   */
  private async checkHolderConcentration(mint: string): Promise<HolderConcentrationResult> {
    try {
      const holdersResponse = await this.helius.getTokenHolders(mint, 20);
      const holders = holdersResponse.holders;

      if (holders.length === 0) {
        return {
          top10Percent: 100,
          topHolderPercent: 100,
          isConcentrated: true,
          reason: 'No holder data available - rejecting',
        };
      }

      // Need minimum holder count (no single-holder tokens)
      if (holdersResponse.totalHolders < 10) {
        return {
          top10Percent: 100,
          topHolderPercent: holders[0]?.percentage || 100,
          isConcentrated: true,
          reason: `Only ${holdersResponse.totalHolders} holders - need at least 10`,
        };
      }

      // Filter out LP program addresses before calculating concentration
      const nonLpHolders = holders.filter(h => !LP_PROGRAM_ADDRESSES.has(h.owner));

      if (nonLpHolders.length === 0) {
        return {
          top10Percent: 0,
          topHolderPercent: 0,
          isConcentrated: false,
          reason: 'Only LP pools as holders',
        };
      }

      // Calculate top 10 holder concentration (excluding LPs)
      const top10 = nonLpHolders.slice(0, 10);
      const totalPercent = nonLpHolders.reduce((sum, h) => sum + h.percentage, 0);
      // Normalize percentages after excluding LPs
      const top10Percent = totalPercent > 0 
        ? (top10.reduce((sum, h) => sum + h.percentage, 0) / totalPercent) * 100 
        : 0;
      const topHolderPercent = totalPercent > 0 
        ? (nonLpHolders[0]?.percentage / totalPercent) * 100 
        : 0;

      // RELAXED thresholds: top holder < 15%, top 10 < 50%
      const isConcentrated = topHolderPercent > 15 || top10Percent > 50;
      let reason: string | undefined;

      if (topHolderPercent > 10) {
        reason = `Single holder owns ${topHolderPercent.toFixed(1)}% (>10% limit)`;
      } else if (top10Percent > 20) {
        reason = `Top 10 holders own ${top10Percent.toFixed(1)}% (>20% limit)`;
      }

      logger.debug({
        mint,
        top10Percent: top10Percent.toFixed(1),
        topHolderPercent: topHolderPercent.toFixed(1),
        totalHolders: holdersResponse.totalHolders,
        isConcentrated,
      }, 'Holder concentration check');

      return {
        top10Percent,
        topHolderPercent,
        isConcentrated,
        reason,
      };
    } catch (error) {
      logger.warn({ mint, error }, 'Failed to check holder concentration');
      return {
        top10Percent: 100,
        topHolderPercent: 100,
        isConcentrated: true,
        reason: 'Failed to fetch holder data - rejecting for safety',
      };
    }
  }

  /**
   * Count smart money wallets among token holders
   */
  private async countSmartMoney(mint: string): Promise<{ count: number; wallets: string[] }> {
    try {
      const holdersResponse = await this.helius.getTokenHolders(mint, 50);
      const holders = holdersResponse.holders;

      const smartMoneyWallets: string[] = [];

      // Check each holder against smart money database
      // Process in batches to avoid overwhelming the API
      for (const holder of holders) {
        try {
          const isSmartMoney = await this.smartMoney.isSmartMoney(holder.owner);
          if (isSmartMoney) {
            smartMoneyWallets.push(holder.owner);
          }
        } catch (error) {
          // Skip individual failures
          logger.debug({ wallet: holder.owner, error }, 'Failed to classify wallet');
        }
      }

      logger.info({
        mint,
        smartMoneyCount: smartMoneyWallets.length,
        totalHolders: holders.length,
      }, 'Smart money detection complete');

      return {
        count: smartMoneyWallets.length,
        wallets: smartMoneyWallets,
      };
    } catch (error) {
      logger.warn({ mint, error }, 'Failed to count smart money');
      return { count: 0, wallets: [] };
    }
  }

  /**
   * Evaluate if we should trade a token
   * @param mint - Token mint address
   * @param tokenMetadata - Optional metadata (liquidity, etc.) to avoid extra API calls
   */
  async evaluateToken(mint: string, tokenMetadata?: { liquidity?: number; marketCapSol?: number }): Promise<TradeDecision> {
    logger.info({ mint, hasMetadata: !!tokenMetadata }, 'Evaluating token for trading');

    const reasons: string[] = [];
    let positionSize = this.config.basePositionSol;

    // Step 1: Analyze token safety
    const safetyAnalysis = await this.tokenSafety.analyze(mint);

    // RED FLAGS: Do not trade
    // Check if token has critical risks
    const hasMintAuth = safetyAnalysis.risks.includes('MINT_AUTHORITY_ACTIVE');
    const hasFreezeAuth = safetyAnalysis.risks.includes('FREEZE_AUTHORITY_ACTIVE');
    const hasRiskyAuth = hasMintAuth || hasFreezeAuth;
    
    // RISK DIAL LOGIC: Soft vs Hard Fails
    let allowRiskyTrade = false;
    
    if (hasRiskyAuth) {
        if (this.config.riskProfile === 'AGGRESSIVE') {
            // Check mitigating factors for Aggressive profile
            // 1. Liquidity > $5k (approx 30 SOL)
            // 2. Buy Pressure exists
            // We need metadata for this. If not passed, we skip the risk allowance.
            
            const liquidity = tokenMetadata?.liquidity || 0;
            // Calculate pseudo buy pressure if we have the data, otherwise assume neutral
            // Since we don't have buys/sells passed here explicitly in all cases, we might need to rely on what we have.
            // If tokenMetadata is from ValidationResult, we might want to extend it to carry buy/sell counts or pressure.
            // For now, let's trust liquidity as the main gate + a penalty.
            
            if (liquidity > 5000) {
                 allowRiskyTrade = true;
                 positionSize *= 0.4; // 60% penalty for risky auth
                 reasons.push(`AGGRESSIVE MODE: Allowed risky auth (Mint/Freeze) due to liquidity > $5k. Position slashed 60%.`);
            }
        }
    }
    
    // If it has risky auth and we didn't explicitly allow it, REJECT
    if (hasRiskyAuth && !allowRiskyTrade) {
      reasons.push('Token has critical safety risks: ' + safetyAnalysis.risks.join(', '));
      return {
        shouldTrade: false,
        positionSizeSol: 0,
        reasons,
        safetyAnalysis,
        smartMoneyCount: 0,
      };
    }
    
    // Other critical risks (Token 2022 extensions) are still hard fails for now
    // unless we want to relax those too. Let's keep Permanent Delegate as a HARD fail.
    const otherRisks = safetyAnalysis.risks.filter(r => r !== 'MINT_AUTHORITY_ACTIVE' && r !== 'FREEZE_AUTHORITY_ACTIVE');
    if (otherRisks.length > 0) {
        // ... (existing rejection for other risks)
         reasons.push('Token has critical safety risks: ' + otherRisks.join(', '));
         return {
            shouldTrade: false,
            positionSizeSol: 0,
            reasons,
            safetyAnalysis,
            smartMoneyCount: 0,
         };
    }

    // YELLOW FLAGS: Reduce position size if token has any risks (that we allowed)
    if (safetyAnalysis.risks.length > 0) {
      if (!allowRiskyTrade) {
          // If we are here, it means we have only minor risks (like Mutable Metadata)
           positionSize *= 0.8; // 20% penalty
           reasons.push(`Token has ${safetyAnalysis.risks.length} risk(s) - reduced position size by 20%`);
      }
      // If allowRiskyTrade is true, we already slashed by 60%, so no double penalty needed
    }

    // Step 2: Check holder concentration (reject if too concentrated)
    const concentration = await this.checkHolderConcentration(mint);
    if (concentration.isConcentrated) {
      reasons.push(`REJECTED: ${concentration.reason}`);
      return {
        shouldTrade: false,
        positionSizeSol: 0,
        reasons,
        safetyAnalysis,
        smartMoneyCount: 0,
      };
    }
    reasons.push(`Holder distribution OK (top holder: ${concentration.topHolderPercent.toFixed(1)}%, top 10: ${concentration.top10Percent.toFixed(1)}%)`);

    // Step 3: Check smart money participation - OPTIONAL, used for position sizing bonus
    const smartMoneyResult = await this.countSmartMoney(mint);
    const smartMoneyCount = smartMoneyResult.count;

    // Smart money is now OPTIONAL - we trade based on safety/concentration/liquidity
    // Smart money presence increases position size as a bonus
    if (smartMoneyCount === 0) {
      reasons.push('No smart money detected - using base position size');
    } else if (smartMoneyCount >= 5) {
      positionSize *= 1.5;
      reasons.push(`Strong smart money signal (${smartMoneyCount} wallets) - increased position 50%`);
    } else if (smartMoneyCount >= 3) {
      positionSize *= 1.25;
      reasons.push(`Good smart money signal (${smartMoneyCount} wallets) - increased position 25%`);
    } else {
      positionSize *= 1.1;
      reasons.push(`Smart money present (${smartMoneyCount} wallet(s)) - increased position 10%`);
    }

    // Cap at maximum position size
    if (positionSize > this.config.maxPositionSol) {
      reasons.push(`Position size capped at maximum (${this.config.maxPositionSol} SOL)`);
      positionSize = this.config.maxPositionSol;
    }

    // Check minimum liquidity (use passed metadata or estimate from market cap)
    const liquidity = tokenMetadata?.liquidity || (tokenMetadata?.marketCapSol ? tokenMetadata.marketCapSol * 170 : 0);

    if (liquidity > 0 && liquidity < this.config.minLiquiditySol) {
      reasons.push(`Insufficient liquidity (~${(liquidity / 170).toFixed(1)} SOL < ${this.config.minLiquiditySol} SOL minimum)`);
      return {
        shouldTrade: false,
        positionSizeSol: 0,
        reasons,
        safetyAnalysis,
        smartMoneyCount,
      };
    }

    if (liquidity > 0) {
      reasons.push(`Liquidity check passed (~${(liquidity / 170).toFixed(1)} SOL)`);
    } else {
      reasons.push('Liquidity unknown - proceeding with caution');
    }
    reasons.push(`Final position size: ${positionSize} SOL`);

    // Generate AI reasoning if Claude client available
    let reasoning: string | undefined;
    if (this.claude) {
      try {
        const context: AnalysisContext = {
          tokenMint: mint,
          safetyAnalysis,
          smartMoneyCount,
          decision: {
            shouldTrade: true,
            positionSizeSol: positionSize,
            reasons,
            safetyAnalysis,
            smartMoneyCount,
          },
        };
        reasoning = await this.claude.generateTradeReasoning(context);
      } catch (error) {
        logger.warn({ mint, error }, 'Failed to generate AI reasoning');
      }
    }

    return {
      shouldTrade: true,
      positionSizeSol: positionSize,
      reasons,
      safetyAnalysis,
      smartMoneyCount,
      reasoning,
    };
  }

  /**
   * Execute a buy trade with risk management
   * @param mint - Token mint address
   * @param tokenMetadata - Optional metadata (liquidity, marketCapSol)
   * @param skipEvaluation - Skip re-evaluation when entertainment mode pre-approved
   * @param overridePositionSol - Override position size (from entertainment mode)
   */
  async executeBuy(
    mint: string,
    tokenMetadata?: { liquidity?: number; marketCapSol?: number; symbol?: string; name?: string; imageUrl?: string },
    skipEvaluation?: boolean,
    overridePositionSol?: number
  ): Promise<string | null> {
    logger.info({ 
      mint, 
      symbol: tokenMetadata?.symbol,
      skipEvaluation, 
      overridePositionSol,
      marketCapSol: tokenMetadata?.marketCapSol 
    }, 'üéØ TRADE ATTEMPT STARTED');

    // CRITICAL: Prevent duplicate buys - check database for recent BUY without matching SELL
    const recentTrades = this.db.trades.getRecent(100);
    const tokenTrades = recentTrades.filter(t => t.tokenMint === mint && !t.metadata?.isBuyback);
    const totalBought = tokenTrades.filter(t => t.type === 'BUY').reduce((sum, t) => sum + t.amountTokens, 0);
    const totalSold = tokenTrades.filter(t => t.type === 'SELL').reduce((sum, t) => sum + t.amountTokens, 0);
    const netHolding = totalBought - totalSold;
    
    if (netHolding > 0) {
      logger.error({
        mint,
        netHolding,
        totalBought,
        totalSold,
      }, 'üö´ TRADE BLOCKED: Already holding this token (from DB) - duplicate buy prevented');
      return null;
    } else {
      logger.info({ mint, netHolding }, '‚úÖ No existing position (from DB) - proceeding');
    }

    // HARD BLOCK: Pump.fun Mayhem Mode tokens (2 billion supply)
    // These are extremely high-risk tokens - NEVER trade them
    try {
      const isMayhem = await this.helius.isMayhemModeToken(mint);
      if (isMayhem) {
        logger.warn({ mint }, 'üö´ BLOCKED: Pump.fun Mayhem Mode token (2B supply) - absolute no-go');
        return null;
      }
    } catch (error) {
      logger.debug({ mint, error }, 'Mayhem Mode check failed - proceeding with caution');
    }

    // Check if trading is allowed
    const canTrade = await this.canTrade();
    if (!canTrade) {
      const stats = await this.getStats();
      logger.error({ 
        mint,
        circuitBreakerActive: stats.circuitBreakerActive,
        circuitBreakerReason: stats.circuitBreakerReason,
        openPositions: stats.openPositions,
        maxOpenPositions: this.config.maxOpenPositions
      }, 'üö´ TRADE BLOCKED BY CIRCUIT BREAKER');
      return null;
    }
    
    logger.info({ mint }, '‚úÖ Circuit breaker check passed');

    let positionSizeSol = overridePositionSol || this.config.basePositionSol;

    // Skip evaluation if entertainment mode pre-approved
    if (!skipEvaluation) {
      // Evaluate token
      const decision = await this.evaluateToken(mint, tokenMetadata);

      logger.info({
        mint,
        shouldTrade: decision.shouldTrade,
        positionSize: decision.positionSizeSol,
        reasons: decision.reasons,
        smartMoneyCount: decision.smartMoneyCount
      }, 'ü§î Evaluation complete');

      if (!decision.shouldTrade) {
        logger.error({ mint, reasons: decision.reasons }, `üö´ TRADE REJECTED BY EVALUATION: ${decision.reasons.join(', ')}`);
        return null;
      }
      
      logger.info({ mint, positionSizeSol: decision.positionSizeSol }, '‚úÖ Evaluation passed - proceeding to execution');

      positionSizeSol = decision.positionSizeSol;
    } else {
      logger.info({ mint, positionSizeSol }, 'üé∞ Entertainment mode bypass - skipping re-evaluation');
    }

    // Check if token has graduated (tradeable on Jupiter/Raydium)
    let useJupiter = false;
    
    // CRITICAL: Non-pump.fun tokens (doesn't end with "pump") are always graduated
    // These come from GeckoTerminal/Birdeye and should NEVER use PumpPortal
    const isPumpFunToken = mint.endsWith('pump');
    
    if (!isPumpFunToken) {
      // Token is not from pump.fun - must use Jupiter
      useJupiter = true;
      logger.info({ mint }, 'ü¶Ö Non-pump.fun token detected - routing to Jupiter');
    } else if (this.jupiter) {
      // pump.fun token - check if it graduated to Raydium
      try {
        useJupiter = await this.jupiter.hasGraduated(mint);
        if (useJupiter) {
          logger.info({ mint }, 'Token has graduated - using Jupiter for swap');
        }
      } catch (error) {
        logger.debug({ mint, error }, 'Jupiter graduation check failed - using PumpPortal');
      }
    }
    
    // Validate we have the right client for this token type
    if (useJupiter && !this.jupiter) {
      logger.error({ mint }, 'Token requires Jupiter but Jupiter client not available');
      return null;
    }
    if (!useJupiter && !this.pumpPortal) {
      logger.error({ mint }, 'Token requires PumpPortal but client not available');
      return null;
    }

    // Execute trade via Jupiter (graduated) or PumpPortal (bonding curve)
    logger.info({ 
      mint, 
      useJupiter, 
      positionSizeSol,
      client: useJupiter ? 'Jupiter' : 'PumpPortal'
    }, 'üí∏ Executing trade now...');
    
    try {
      let signature: string;
      let tokensReceived: number;
      let actualSol: number;
      let pricePerToken: number;

      if (useJupiter && this.jupiter) {
        // Use Jupiter for graduated tokens
        const result = await this.jupiter.buy(mint, positionSizeSol, {
          slippageBps: Math.floor(this.config.slippageTolerance * 10000),
        });
        signature = result.signature;
        tokensReceived = result.outputAmount;
        actualSol = result.inputAmount;
        pricePerToken = actualSol / tokensReceived;

        logger.info({
          mint,
          signature,
          method: 'Jupiter',
          priceImpact: result.priceImpactPct,
        }, 'Jupiter buy executed');
      } else {
        // Use PumpPortal for bonding curve tokens
        signature = await this.pumpPortal.buy({
          mint,
          amount: positionSizeSol,
          slippage: this.config.slippageTolerance,
        });

        // Parse the confirmed transaction to get actual amounts
        const parsedTx = await this.txParser.waitAndParse(
          signature,
          this.walletAddress,
          mint,
          'buy',
          30000 // 30 second timeout
        );

        tokensReceived = parsedTx.tokenAmount;
        actualSol = parsedTx.solAmount || positionSizeSol;
        pricePerToken = parsedTx.pricePerToken;
      }

      // Record trade in database
      await this.db.trades.insert({
        signature,
        timestamp: Date.now(),
        type: 'BUY',
        tokenMint: mint,
        tokenSymbol: tokenMetadata?.symbol,
        amountTokens: tokensReceived,
        amountSol: actualSol,
        pricePerToken,
        metadata: {
          requestedSol: positionSizeSol,
          actualSol,
          method: useJupiter ? 'Jupiter' : 'PumpPortal',
          tokenName: tokenMetadata?.name,
          tokenImage: tokenMetadata?.imageUrl,
        },
      });

      logger.info({
        mint,
        signature,
        requestedSol: positionSizeSol,
        actualSol,
        tokensReceived,
        pricePerToken,
        method: useJupiter ? 'Jupiter' : 'PumpPortal',
      }, 'Buy trade executed successfully');

      // Capture entry features for learning engine
      if (this.learningEngine) {
        try {
          const features = await this.captureEntryFeatures(mint, tokenMetadata);
          this.entryFeatures.set(mint, {
            features,
            confidence: 50, // TODO: Get from decision
            entryPrice: pricePerToken,
          });
          logger.debug({ mint }, 'Captured entry features for learning');
        } catch (error) {
          logger.warn({ mint, error }, 'Failed to capture entry features');
        }
      }

      return signature;
    } catch (error) {
      logger.error({ mint, error, method: useJupiter ? 'Jupiter' : 'PumpPortal' }, 'Buy trade failed');
      return null;
    }
  }

  /**
   * Execute a sell trade
   */
  async executeSell(mint: string, amount: number): Promise<string | null> {
    logger.info({ mint, amount }, 'Executing sell trade');

    // Get actual wallet balance - use this instead of DB amount to prevent "insufficient balance" errors
    let actualAmount = amount;
    try {
      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
        new PublicKey(this.walletAddress),
        { mint: new PublicKey(mint) }
      );
      if (tokenAccounts.value.length > 0) {
        const info = tokenAccounts.value[0].account.data.parsed.info;
        actualAmount = parseFloat(info.tokenAmount.uiAmountString);
        if (actualAmount !== amount) {
          logger.warn({ mint, dbAmount: amount, walletAmount: actualAmount }, 'Wallet balance differs from DB - using actual wallet balance');
        }
      }
      if (actualAmount <= 0) {
        logger.warn({ mint }, 'No tokens in wallet to sell - recording sync sell to close position');
        // Record a sync sell to close this position in the DB
        await this.db.trades.insert({
          signature: `sync-sell-${mint.slice(0, 8)}-${Date.now()}`,
          timestamp: Date.now(),
          type: 'SELL',
          tokenMint: mint,
          tokenSymbol: 'UNKNOWN',
          amountTokens: amount, // Close out the DB amount
          amountSol: 0, // Unknown - sold manually
          pricePerToken: 0,
          metadata: {
            isSync: true,
            note: 'Position closed - tokens sold manually or transferred out',
          },
        });
        return null;
      }
    } catch (error) {
      logger.debug({ mint, error }, 'Failed to check wallet balance - using DB amount');
    }

    // Check if trading is allowed
    const canTrade = await this.canTrade();
    if (!canTrade) {
      logger.warn('Trading blocked by circuit breaker');
      return null;
    }

    // Check if token has graduated (tradeable on Jupiter/Raydium)
    let useJupiter = false;
    if (this.jupiter) {
      try {
        useJupiter = await this.jupiter.hasGraduated(mint);
        if (useJupiter) {
          logger.info({ mint }, 'Token has graduated - using Jupiter for sell');
        }
      } catch (error) {
        logger.debug({ mint, error }, 'Jupiter graduation check failed - using PumpPortal');
      }
    }

    // Execute trade via Jupiter (graduated) or PumpPortal (bonding curve)
    try {
      let signature: string;
      let actualTokens: number;
      let solReceived: number;
      let pricePerToken: number;

      if (useJupiter && this.jupiter) {
        // Use Jupiter for graduated tokens - use actualAmount (wallet balance) not DB amount
        const result = await this.jupiter.sell(mint, actualAmount, 6, {
          slippageBps: Math.floor(this.config.slippageTolerance * 10000),
        });
        signature = result.signature;
        actualTokens = result.inputAmount;
        solReceived = result.outputAmount;
        pricePerToken = solReceived / actualTokens;

        logger.info({
          mint,
          signature,
          method: 'Jupiter',
          priceImpact: result.priceImpactPct,
        }, 'Jupiter sell executed');
      } else {
        // Use PumpPortal for bonding curve tokens - use actualAmount (wallet balance) not DB amount
        try {
          signature = await this.pumpPortal.sell({
            mint,
            amount: actualAmount,
            slippage: this.config.slippageTolerance,
          });

          // Parse the confirmed transaction to get actual amounts
          const parsedTx = await this.txParser.waitAndParse(
            signature,
            this.walletAddress,
            mint,
            'sell',
            30000 // 30 second timeout
          );

          actualTokens = parsedTx.tokenAmount || amount;
          solReceived = parsedTx.solAmount || 0;
          pricePerToken = parsedTx.pricePerToken;
        } catch (pumpError: any) {
          // Fallback to Jupiter for ANY error if available (e.g. 429s, timeout, or graduation)
          const errorMsg = pumpError?.message || String(pumpError);
          logger.warn({ mint, error: errorMsg }, '‚ö†Ô∏è PumpPortal sell failed - attempting Jupiter fallback');
          
          if (!this.jupiter) {
            logger.error({ mint }, 'Jupiter client not available - cannot fallback to Jupiter');
            throw pumpError;
          }
          
          try {
            // Retry via Jupiter DEX
            const result = await this.jupiter.sell(
              mint,
              actualAmount,
              6, // Assuming 6 decimals for pump.fun tokens
              { slippageBps: this.config.slippageTolerance * 10000 }
            );

            signature = result.signature;
            actualTokens = result.inputAmount;
            solReceived = result.outputAmount;
            pricePerToken = solReceived / actualTokens;

            logger.info({
              mint,
              signature,
              method: 'Jupiter (fallback)',
              priceImpact: result.priceImpactPct,
              originalError: errorMsg
            }, '‚úÖ Token sold via Jupiter fallback');
          } catch (jupiterError: any) {
             logger.error({ mint, jupiterError: jupiterError?.message }, 'Jupiter fallback also failed');
             throw pumpError; // Throw original error to indicate root cause
          }
        }
      }

      // Record trade in database
      await this.db.trades.insert({
        signature,
        timestamp: Date.now(),
        type: 'SELL',
        tokenMint: mint,
        amountTokens: actualTokens,
        amountSol: solReceived,
        pricePerToken,
        metadata: {
          requestedTokens: amount,
          actualTokens,
          solReceived,
          method: useJupiter ? 'Jupiter' : 'PumpPortal',
        },
      });

      logger.info({
        mint,
        signature,
        requestedTokens: amount,
        actualTokens,
        solReceived,
        pricePerToken,
        method: useJupiter ? 'Jupiter' : 'PumpPortal',
      }, 'Sell trade executed successfully');

      return signature;
    } catch (error) {
      logger.error({ mint, error, method: useJupiter ? 'Jupiter' : 'PumpPortal' }, 'Sell trade failed');
      return null;
    }
  }

  /**
   * Execute a copy trade (SCHIZO MODE)
   * Bypasses some safety checks but still respects critical ones (honeypots)
   */
  async executeCopyTrade(mint: string, sourceWallet: string, solAmount: number): Promise<string | null> {
    logger.info({ mint, sourceWallet, solAmount }, 'Executing COPY TRADE');

    // 0. Check circuit breaker (max positions, daily trades, daily loss)
    const canTrade = await this.canTrade();
    if (!canTrade) {
      logger.warn({ mint, sourceWallet }, 'Copy trade BLOCKED: Circuit breaker active');
      return null;
    }

    // 1. Basic Safety Check (Honeypot only)
    const safetyAnalysis = await this.tokenSafety.analyze(mint);
    const hasCriticalRisk = safetyAnalysis.risks.some(r => 
      r === 'MINT_AUTHORITY_ACTIVE' || r === 'FREEZE_AUTHORITY_ACTIVE'
    );

    if (hasCriticalRisk) {
      logger.warn({ mint, risks: safetyAnalysis.risks }, 'Copy trade BLOCKED: Critical Token Risk');
      return null;
    }

    // 2. Determine Scale
    // We can match the SOL amount or use our own sizing logic.
    // For now, let's stick to our base position but scale slightly if it's a big whale buy.
    let positionSize = this.config.basePositionSol;
    
    // If the whale bought A LOT (> 10 SOL), we might ape harder
    if (solAmount > 10) {
      positionSize = Math.min(positionSize * 2, this.config.maxPositionSol);
    }

    // 3. Execute
    try {
      const signature = await this.pumpPortal.buy({
        mint,
        amount: positionSize,
        slippage: this.config.slippageTolerance * 2, // Higher slippage for copy trading speed
      });

      // 4. Parse & Record
      const parsedTx = await this.txParser.waitAndParse(
        signature,
        this.walletAddress,
        mint,
        'buy'
      );

       await this.db.trades.insert({
        signature,
        timestamp: Date.now(),
        type: 'BUY',
        tokenMint: mint,
        amountTokens: parsedTx.tokenAmount,
        amountSol: parsedTx.solAmount || positionSize,
        pricePerToken: parsedTx.pricePerToken,
        metadata: {
          strategy: 'COPY_TRADE',
          sourceWallet,
          targetSolAmount: solAmount,
          parseSuccess: parsedTx.success,
        },
      });

      logger.info({ signature, mint, positionSize }, 'Copy trade executed successfully');
      
      // Emit event
      agentEvents.emit({
        type: 'TRADE_EXECUTED',
        timestamp: Date.now(),
        data: {
          type: 'BUY',
          mint,
          amount: positionSize,
          signature
        }
      });
      
      return signature;

    } catch (error) {
      logger.error({ mint, error }, 'Copy trade execution failed');
      return null;
    }
  }

  /**
   * Check if trading is allowed (circuit breaker)
   */
  async canTrade(): Promise<boolean> {
    const stats = await this.getStats();

    // Check circuit breaker
    if (stats.circuitBreakerActive) {
      logger.warn({
        reason: stats.circuitBreakerReason,
      }, 'Circuit breaker active');
      return false;
    }

    // Check max open positions
    if (stats.openPositions >= this.config.maxOpenPositions) {
      logger.warn({
        openPositions: stats.openPositions,
        maxOpenPositions: this.config.maxOpenPositions,
      }, 'Max open positions reached');
      return false;
    }

    // Check max daily trades
    if (stats.todayTrades >= this.config.maxDailyTrades) {
      logger.warn({
        todayTrades: stats.todayTrades,
        maxDailyTrades: this.config.maxDailyTrades,
      }, 'Max daily trades reached');
      return false;
    }

    return true;
  }


  /**
   * Execute a buyback of SCHIZO token
   *
   * USES HARDCODED BUYBACK PERCENTAGE: 10% of profit
   * This cannot be overridden by environment variables.
   */
  async executeBuyback(profitSol: number, sourceTrade?: string): Promise<string | null> {
    const schizoMint = process.env.SCHIZO_TOKEN_MINT;
    const executionLogs: string[] = [];

    if (!schizoMint || schizoMint.includes('your-') || schizoMint.length < 32) {
      logger.warn({ schizoMint }, 'SCHIZO_TOKEN_MINT not configured or is placeholder, skipping buyback');
      executionLogs.push('SCHIZO_TOKEN_MINT not set or placeholder - buyback skipped');
      return null;
    }

    // HARDCODED: 10% of profit goes to buyback
    let buybackAmount = profitSol * BUYBACK_PERCENT_OF_PROFIT;

    // Check wallet balance - don't spend more than 50% of available SOL on buyback
    try {
      const lamports = await this.connection.getBalance(new PublicKey(this.walletAddress));
      const balance = lamports / 1e9;
      const maxBuyback = balance * 0.5; // Max 50% of balance for buyback
      if (buybackAmount > maxBuyback) {
        logger.warn({ buybackAmount, balance, maxBuyback }, 'Buyback would exceed 50% of balance, capping');
        buybackAmount = maxBuyback;
      }
      if (buybackAmount < 0.001) {
        logger.warn({ buybackAmount, balance }, 'Buyback amount too small after balance check');
        return null;
      }
    } catch (error) {
      logger.warn({ error }, 'Failed to check balance for buyback');
    }
    const reasoning = `Buyback triggered: ${BUYBACK_PERCENT_OF_PROFIT * 100}% of ${profitSol.toFixed(4)} SOL profit = ${buybackAmount.toFixed(4)} SOL`;

    // Skip if buyback amount is too small (< 0.001 SOL = ~$0.17)
    if (buybackAmount < 0.001) {
      logger.debug({ buybackAmount, profitSol }, 'Buyback amount too small, skipping');
      executionLogs.push(`Buyback amount ${buybackAmount.toFixed(6)} SOL too small (< 0.001), skipped`);
      return null;
    }

    executionLogs.push(`Profit: ${profitSol.toFixed(4)} SOL`);
    executionLogs.push(`Buyback percentage: ${BUYBACK_PERCENT_OF_PROFIT * 100}% (HARDCODED)`);
    executionLogs.push(`Buyback amount: ${buybackAmount.toFixed(4)} SOL`);

    logger.info({
      profitSol,
      buybackPercentage: BUYBACK_PERCENT_OF_PROFIT,
      buybackAmount,
      sourceTrade,
    }, 'Executing buyback (HARDCODED 10%)');

    try {
      // Execute buyback via PumpPortal
      const signature = await this.pumpPortal.buy({
        mint: schizoMint,
        amount: buybackAmount,
        slippage: this.config.slippageTolerance,
      });

      // Record buyback in database
      await this.db.trades.insert({
        signature,
        timestamp: Date.now(),
        type: 'BUY',
        tokenMint: schizoMint,
        amountTokens: 0, // Will be updated when we parse transaction
        amountSol: buybackAmount,
        pricePerToken: 0, // Will be updated when we parse transaction
        metadata: {
          isBuyback: true,
          sourceTrade,
          profitSol,
          buybackPercentage: BUYBACK_PERCENT_OF_PROFIT,
        },
      });

      executionLogs.push(`Buyback executed: ${signature}`);

      logger.info({
        signature,
        buybackAmount,
        schizoMint,
      }, 'Buyback executed successfully');

      // Emit buyback event for dashboard with full context
      agentEvents.emit({
        type: 'BUYBACK_TRIGGERED',
        timestamp: Date.now(),
        data: {
          profit: profitSol,
          amount: buybackAmount,
          signature,
          reasoning,
          logs: executionLogs,
        },
      });

      return signature;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error({ profitSol, error }, 'Buyback execution failed');
      executionLogs.push(`Buyback FAILED: ${errorMessage}`);

      // Emit failure event for observability
      agentEvents.emit({
        type: 'BUYBACK_FAILED',
        timestamp: Date.now(),
        data: {
          reasoning: `Buyback failed after profitable exit`,
          logs: executionLogs,
          profitSol,
          attemptedAmount: buybackAmount,
          error: errorMessage,
        },
      });

      return null;
    }
  }
  /**
   * Get current trading statistics
   */
  async getStats(): Promise<TradingStats> {
    // Get today's trades
    const todayStart = this.getTodayStart();
    const allTrades = this.db.trades.getRecent(1000); // Get recent 1000 trades
    const todayTrades = allTrades.filter((t: { timestamp: number }) => t.timestamp >= todayStart);

    // Calculate realized P&L from completed round-trips (buy + sell pairs)
    const realizedPnL = this.calculateRealizedPnL(todayTrades);

    // Calculate unrealized P&L from open positions
    const unrealizedPnL = await this.calculateUnrealizedPnL();

    // Count open positions by finding tokens with net positive holdings
    const openPositions = this.countOpenPositions(allTrades);

    // Count consecutive losses from recent completed trades
    const consecutiveLosses = this.countConsecutiveLosses(allTrades);

    // Check circuit breaker conditions
    let circuitBreakerActive = false;
    let circuitBreakerReason: string | null = null;

    if (realizedPnL <= this.config.circuitBreakerDailyLoss) {
      circuitBreakerActive = true;
      circuitBreakerReason = `Daily loss limit exceeded (${realizedPnL.toFixed(2)} SOL)`;
    }

    if (consecutiveLosses >= this.config.circuitBreakerConsecutiveLosses) {
      circuitBreakerActive = true;
      circuitBreakerReason = `Consecutive loss limit exceeded (${consecutiveLosses} losses)`;
    }

    return {
      todayTrades: todayTrades.length,
      openPositions,
      realizedPnL,
      unrealizedPnL,
      dailyPnL: realizedPnL, // Backwards compatibility
      consecutiveLosses,
      circuitBreakerActive,
      circuitBreakerReason,
    };
  }

  /**
   * Calculate realized P&L from completed trades (buy + sell pairs)
   * Only counts profit/loss from closed positions using FIFO matching
   */
  private calculateRealizedPnL(trades: Array<{ type: string; tokenMint: string; amountSol: number; metadata?: Record<string, unknown> }>): number {
    // Group by token, match buy/sell pairs (FIFO), sum actual profit/loss
    const tokenBuyCosts = new Map<string, number[]>();
    let realizedPnL = 0;

    for (const trade of trades) {
      // Skip buybacks - they're not trading P&L
      if (trade.metadata?.isBuyback) continue;

      if (trade.type === 'BUY') {
        const costs = tokenBuyCosts.get(trade.tokenMint) || [];
        costs.push(trade.amountSol);
        tokenBuyCosts.set(trade.tokenMint, costs);
      } else if (trade.type === 'SELL') {
        const costs = tokenBuyCosts.get(trade.tokenMint) || [];
        if (costs.length > 0) {
          const buyCost = costs.shift()!; // FIFO matching
          realizedPnL += trade.amountSol - buyCost; // Actual profit/loss
          tokenBuyCosts.set(trade.tokenMint, costs);
        }
      }
    }

    return realizedPnL;
  }

  /**
   * Count open positions (tokens with net positive holdings)
   */
  private countOpenPositions(allTrades: Array<{ type: string; tokenMint: string; amountTokens: number; metadata?: Record<string, unknown> }>): number {
    // Group trades by token
    const positions = new Map<string, number>();

    for (const trade of allTrades) {
      // Skip buybacks for position tracking
      if (trade.metadata?.isBuyback) continue;

      const current = positions.get(trade.tokenMint) || 0;

      if (trade.type === 'BUY') {
        positions.set(trade.tokenMint, current + trade.amountTokens);
      } else if (trade.type === 'SELL') {
        positions.set(trade.tokenMint, current - trade.amountTokens);
      }
    }

    // Count tokens with positive holdings
    let openCount = 0;
    for (const [, amount] of positions) {
      if (amount > 0) openCount++;
    }

    return openCount;
  }

  /**
   * Count consecutive losses from recent trades
   * A loss is a completed round-trip (buy + sell) where sell < buy
   */
  private countConsecutiveLosses(allTrades: Array<{ type: string; tokenMint: string; amountSol: number; timestamp: number; metadata?: Record<string, unknown> }>): number {
    // Find completed round-trips (buy followed by sell for same token)
    // Sort by timestamp descending (most recent first)
    const sortedTrades = [...allTrades]
      .filter(t => !t.metadata?.isBuyback)
      .sort((a, b) => b.timestamp - a.timestamp);

    // Track buy costs per token
    const tokenBuyCosts = new Map<string, number[]>();
    const completedTrades: Array<{ profit: number; timestamp: number }> = [];

    // Process in reverse chronological order to build history
    for (const trade of sortedTrades.reverse()) {
      if (trade.type === 'BUY') {
        const costs = tokenBuyCosts.get(trade.tokenMint) || [];
        costs.push(trade.amountSol);
        tokenBuyCosts.set(trade.tokenMint, costs);
      } else if (trade.type === 'SELL') {
        const costs = tokenBuyCosts.get(trade.tokenMint) || [];
        if (costs.length > 0) {
          const buyCost = costs.shift()!; // FIFO matching
          tokenBuyCosts.set(trade.tokenMint, costs);
          completedTrades.push({
            profit: trade.amountSol - buyCost,
            timestamp: trade.timestamp,
          });
        }
      }
    }

    // Count consecutive losses from most recent
    completedTrades.sort((a, b) => b.timestamp - a.timestamp);

    let consecutiveLosses = 0;
    for (const trade of completedTrades) {
      if (trade.profit < 0) {
        consecutiveLosses++;
      } else {
        break; // Stop counting at first win
      }
    }

    return consecutiveLosses;
  }

  /**
   * Get start of today (midnight) in milliseconds
   */
  private getTodayStart(): number {
    const now = new Date();
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    return todayStart.getTime();
  }

  /**
   * Get all open positions directly from wallet balance (wallet-first approach)
   * Uses database only for entry price lookup
   */
  async getOpenPositions(): Promise<OpenPosition[]> {
    const DUST_THRESHOLD_SOL = 0.0005; 
    const WALLET_CACHE_TTL = 30000; // 30 second cache
    const now = Date.now();
    
    logger.debug('Fetching positions from actual wallet balance...');
    
    // Get actual wallet holdings via Helius DAS API with caching
    let walletTokens: Array<{ mint: string; balance: number }> = [];
    
    // Check cache first
    if (this.walletCache && now - this.walletCache.timestamp < WALLET_CACHE_TTL) {
      walletTokens = this.walletCache.tokens;
      logger.debug({ tokenCount: walletTokens.length, cached: true }, 'Using cached wallet holdings');
    } else {
      // Fetch fresh data
      try {
        walletTokens = await this.helius.getAssetsByOwner(this.walletAddress);
        this.walletCache = { tokens: walletTokens, timestamp: now };
        logger.info({ tokenCount: walletTokens.length, mints: walletTokens.map(t => t.mint) }, 'Helius DAS returned tokens');
      } catch (error) {
        logger.warn({ error }, 'Helius DAS failed, using RPC fallback');
        try {
          // Fallback to RPC
          const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
            new PublicKey(this.walletAddress),
            { programId: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') }
          );
          walletTokens = tokenAccounts.value
            .map(acc => {
              const info = acc.account.data.parsed.info;
              return {
                mint: info.mint,
                balance: parseFloat(info.tokenAmount.uiAmountString),
              };
            })
            .filter(t => t.balance > 0);
          this.walletCache = { tokens: walletTokens, timestamp: now };
          logger.info({ tokenCount: walletTokens.length, mints: walletTokens.map(t => t.mint) }, 'RPC fallback returned tokens');
        } catch (rpcError) {
          logger.error({ error: rpcError }, 'RPC fallback also failed');
          // Use stale cache if available
          if (this.walletCache) {
            logger.warn({ age: now - this.walletCache.timestamp }, 'Using stale wallet cache');
            walletTokens = this.walletCache.tokens;
          } else {
            // Final fallback: Use database to reconstruct positions
            logger.warn('No wallet data available - using database fallback');
            return this.getPositionsFromDatabase();
          }
        }
      }
    }

    if (walletTokens.length === 0) {
      logger.warn('No tokens found in wallet - trying database fallback');
      return this.getPositionsFromDatabase();
    }

    logger.info({ tokenCount: walletTokens.length }, 'Processing wallet tokens');

    // Get trade history to look up entry prices
    const allTrades = this.db.trades.getRecent(1000);
    const entryPrices = new Map<string, { 
      avgPrice: number; 
      totalSol: number; 
      totalTokens: number;
      earliestBuy: number;
      symbol?: string;
      name?: string;
      image?: string;
    }>();

    // Build entry price map from buy trades
    for (const trade of allTrades) {
      if (trade.type !== 'BUY' || trade.metadata?.isBuyback) continue;
      
      const current = entryPrices.get(trade.tokenMint) || {
        avgPrice: 0,
        totalSol: 0,
        totalTokens: 0,
        earliestBuy: Infinity,
        symbol: trade.tokenSymbol,
        name: trade.metadata?.tokenName as string | undefined,
        image: trade.metadata?.tokenImage as string | undefined,
      };

      current.totalSol += trade.amountSol;
      current.totalTokens += trade.amountTokens;
      current.avgPrice = current.totalSol / current.totalTokens;
      if (trade.timestamp < current.earliestBuy) {
        current.earliestBuy = trade.timestamp;
      }

      entryPrices.set(trade.tokenMint, current);
    }

    // Build positions from actual wallet holdings
    const openPositions: OpenPosition[] = [];

    for (const walletToken of walletTokens) {
      const entryData = entryPrices.get(walletToken.mint);
      
      // Calculate entry cost for the current balance
      let entryPrice: number;
      let entrySol: number;
      let entryTimestamp: number;

      if (entryData) {
        // Use database entry price
        entryPrice = entryData.avgPrice;
        entrySol = walletToken.balance * entryPrice;
        entryTimestamp = entryData.earliestBuy;
      } else {
        // No entry data - token may have been received externally
        // Use current price as entry price (0% P&L)
        logger.info({ mint: walletToken.mint, balance: walletToken.balance }, 'No entry data found - fetching current price');
        try {
          const tokenInfo = await this.pumpPortal.getTokenInfo(walletToken.mint);
          entryPrice = tokenInfo.price;
          entrySol = walletToken.balance * entryPrice;
          entryTimestamp = Date.now();
          logger.info({ mint: walletToken.mint, price: entryPrice, entrySol }, 'Using current price for external token');
        } catch (error) {
          // Can't get price - still show the token with 0 entry price
          logger.warn({ mint: walletToken.mint, error }, 'Cannot fetch price - showing token with 0 entry');
          entryPrice = 0;
          entrySol = 0;
          entryTimestamp = Date.now();
        }
      }

      // Skip dust positions
      if (entrySol < DUST_THRESHOLD_SOL) {
        logger.debug({
          mint: walletToken.mint,
          entrySol,
        }, 'Skipping dust position');
        continue;
      }

      openPositions.push({
        tokenMint: walletToken.mint,
        tokenSymbol: entryData?.symbol,
        tokenName: entryData?.name,
        tokenImage: entryData?.image,
        entryAmountSol: entrySol,
        entryAmountTokens: walletToken.balance,
        entryPrice,
        entryTimestamp,
      });
    }

    logger.info({ positionCount: openPositions.length }, 'Open positions loaded from wallet');
    return openPositions;
  }

  /**
   * Fallback: Get positions from database when wallet APIs are down
   * Reconstructs positions from trade history using Weighted Average Cost Basis
   */
  private getPositionsFromDatabase(): OpenPosition[] {
    const DUST_THRESHOLD_SOL = 0.0005;
    const allTrades = this.db.trades.getRecent(1000);
    
    // 1. Group trades by token
    const tradesByToken = new Map<string, typeof allTrades>();
    const tokenMetadata = new Map<string, { symbol?: string; name?: string; image?: string }>();
    
    for (const trade of allTrades) {
      if (trade.metadata?.isBuyback) continue;
      
      const list = tradesByToken.get(trade.tokenMint) || [];
      list.push(trade);
      tradesByToken.set(trade.tokenMint, list);
      
      // Capture metadata if missing
      if (!tokenMetadata.has(trade.tokenMint) && (trade.tokenSymbol || trade.metadata?.tokenName)) {
        tokenMetadata.set(trade.tokenMint, {
          symbol: trade.tokenSymbol,
          name: trade.metadata?.tokenName as string | undefined,
          image: trade.metadata?.tokenImage as string | undefined,
        });
      }
    }

    const openPositions: OpenPosition[] = [];

    // 2. Process each token chronologically
    for (const [mint, trades] of tradesByToken) {
      // Sort oldest first
      trades.sort((a: any, b: any) => a.timestamp - b.timestamp);
      
      let currentTokens = 0;
      let currentCostBasis = 0; // Total SOL spent on *current* holdings
      let earliestBuyTimestamp = Infinity;

      for (const trade of trades) {
        if (trade.type === 'BUY') {
          // If starting a new position (from zero/dust), reset timestamp
          if (currentTokens <= 0.000001) {
            earliestBuyTimestamp = trade.timestamp;
          }
          currentTokens += trade.amountTokens;
          currentCostBasis += trade.amountSol;
        } else if (trade.type === 'SELL') {
           if (currentTokens > 0) {
             // WACB: Reduce cost basis proportionally to preserve average entry price
             // CostRemoved = (AmountSold / CurrentTokens) * CurrentCostBasis
             const costRemoved = (trade.amountTokens / currentTokens) * currentCostBasis;
             currentCostBasis -= costRemoved;
             currentTokens -= trade.amountTokens;
           }
        }
        
        // Safety reset for dust/negatives
        if (currentTokens <= 0.000001) {
          currentTokens = 0;
          currentCostBasis = 0;
          earliestBuyTimestamp = Infinity;
        }
      }

      // Check if we have an open position
      if (currentTokens > 0) {
         // Calculate entry price from remaining cost basis
         const entryPrice = currentCostBasis / currentTokens;
         
         if (currentCostBasis >= DUST_THRESHOLD_SOL) {
             const meta = tokenMetadata.get(mint);
             openPositions.push({
               tokenMint: mint,
               tokenSymbol: meta?.symbol,
               tokenName: meta?.name,
               tokenImage: meta?.image,
               entryAmountSol: currentCostBasis,
               entryAmountTokens: currentTokens,
               entryPrice: entryPrice,
               entryTimestamp: earliestBuyTimestamp,
             });
         }
      }
    }

    logger.info({ positionCount: openPositions.length }, 'Open positions reconstructed from database (WACB)');
    return openPositions;
  }

  /**
   * Get open positions with current prices and PnL
   * Fetches live prices from PumpPortal for each position
   * Uses 10s price cache to avoid rate limits
   */
  async getOpenPositionsWithPrices(): Promise<OpenPosition[]> {
    const positions = await this.getOpenPositions();
    const positionsWithPrices: OpenPosition[] = [];
    const now = Date.now();
    const PRICE_CACHE_TTL = 30000; // Increased from 10s to 30s to reduce API calls

    for (const position of positions) {
      try {
        // Check cache first
        const cached = this.priceCache.get(position.tokenMint);
        let currentPrice: number;

        if (cached && now - cached.timestamp < PRICE_CACHE_TTL) {
          currentPrice = cached.price;
        } else {
          // Get current price - try PumpPortal first, fallback to DexScreener for graduated tokens
          try {
            const tokenInfo = await this.pumpPortal.getTokenInfo(position.tokenMint);
            currentPrice = tokenInfo.price;
          } catch {
            // Token may have graduated - try DexScreener
            const dexData = await dexscreener.getRawPairs(position.tokenMint);
            if (dexData && dexData.length > 0) {
              currentPrice = parseFloat(dexData[0].priceNative || '0');
            } else {
              throw new Error('No price data available');
            }
          }

          // Cache the price
          this.priceCache.set(position.tokenMint, { price: currentPrice, timestamp: now });
        }

        // Calculate P&L percentage
        const pnlPercent = ((currentPrice - position.entryPrice) / position.entryPrice) * 100;

        positionsWithPrices.push({
          ...position,
          currentPrice,
          unrealizedPnLPercent: pnlPercent,
        });
      } catch (error) {
        // If we can't get price, include position without price data
        logger.debug({ mint: position.tokenMint, error }, 'Could not fetch current price for position');
        positionsWithPrices.push(position);
      }
    }

    return positionsWithPrices;
  }

  /**
   * Calculate unrealized P&L from open positions
   * Returns the total unrealized profit/loss across all open positions
   */
  async calculateUnrealizedPnL(): Promise<number> {
    const positions = await this.getOpenPositionsWithPrices();
    let unrealizedPnL = 0;

    for (const position of positions) {
      if (position.currentPrice && position.entryPrice) {
        const currentValue = position.entryAmountTokens * position.currentPrice;
        const entryCost = position.entryAmountSol;
        unrealizedPnL += currentValue - entryCost;
      }
    }

    return unrealizedPnL;
  }

  /**
   * Check open positions and execute stop-loss/take-profit if needed
   * Returns array of exit trade signatures
   *
   * USES HARDCODED RISK VALUES:
   * - Stop Loss: 10%
   * - Take Profit: 30%
   * - Buyback: 10% of profit on ALL profitable exits
   */
  async checkPositionsForExit(): Promise<string[]> {
    const positions = await this.getOpenPositions();
    const exitSignatures: string[] = [];
    const executionLogs: string[] = [];

    executionLogs.push(`Checking ${positions.length} positions for exit signals`);
    logger.debug({ positionCount: positions.length }, 'Checking positions for exit signals');

    for (const position of positions) {
      try {
        // Get current price - try PumpPortal first, fallback to DexScreener for graduated tokens
        let currentPrice: number;
        try {
          const tokenInfo = await this.pumpPortal.getTokenInfo(position.tokenMint);
          currentPrice = tokenInfo.price;
        } catch {
          // Token may have graduated to Raydium - use DexScreener
          logger.debug({ mint: position.tokenMint }, 'PumpPortal failed, trying DexScreener');
          const dexData = await dexscreener.getRawPairs(position.tokenMint);
          if (dexData && dexData.length > 0) {
            // DexScreener returns priceNative which is price in SOL
            currentPrice = parseFloat(dexData[0].priceNative || '0');
            logger.info({ mint: position.tokenMint, symbol: position.tokenSymbol, currentPrice }, 'Got price from DexScreener (graduated token)');
          } else {
            logger.warn({ mint: position.tokenMint }, 'Could not get price from PumpPortal or DexScreener');
            continue;
          }
        }

        // Calculate P&L percentage
        const pnlPercent = (currentPrice - position.entryPrice) / position.entryPrice;

        executionLogs.push(`${position.tokenSymbol || position.tokenMint.slice(0, 6)}: ${(pnlPercent * 100).toFixed(1)}% PnL`);

        logger.debug({
          mint: position.tokenMint,
          entryPrice: position.entryPrice,
          currentPrice,
          pnlPercent: (pnlPercent * 100).toFixed(2) + '%',
          hardStopLoss: (HARD_STOP_LOSS_PERCENT * 100) + '%',
          hardTakeProfit: (HARD_TAKE_PROFIT_PERCENT * 100) + '%',
        }, 'Position P&L check (using HARDCODED risk values)');

        // Check stop-loss - USES HARDCODED VALUE
        if (pnlPercent <= -HARD_STOP_LOSS_PERCENT) {
          const reasoning = `Stop-loss triggered at ${(pnlPercent * 100).toFixed(1)}% (threshold: -${HARD_STOP_LOSS_PERCENT * 100}%)`;
          logger.warn({
            mint: position.tokenMint,
            pnlPercent: (pnlPercent * 100).toFixed(2) + '%',
            stopLoss: (-HARD_STOP_LOSS_PERCENT * 100).toFixed(2) + '%',
          }, 'STOP-LOSS triggered (HARDCODED 10%)');

          const signature = await this.executeSell(position.tokenMint, position.entryAmountTokens);
          if (signature) {
            exitSignatures.push(signature);

            // Emit stop-loss event with reasoning
            agentEvents.emit({
              type: 'STOP_LOSS',
              timestamp: Date.now(),
              data: {
                mint: position.tokenMint,
                entryPrice: position.entryPrice,
                exitPrice: currentPrice,
                lossPercent: pnlPercent * 100,
                signature,
                reasoning,
                logs: [...executionLogs],
              },
            });

            // Record trade lesson for learning engine
            await this.recordTradeLesson(position, currentPrice, Date.now(), pnlPercent);
          }
          continue;
        }

        // Check take-profit - USES HARDCODED VALUE
        if (pnlPercent >= HARD_TAKE_PROFIT_PERCENT) {
          const reasoning = `Take-profit triggered at ${(pnlPercent * 100).toFixed(1)}% (threshold: +${HARD_TAKE_PROFIT_PERCENT * 100}%)`;
          logger.info({
            mint: position.tokenMint,
            pnlPercent: (pnlPercent * 100).toFixed(2) + '%',
            takeProfit: (HARD_TAKE_PROFIT_PERCENT * 100).toFixed(2) + '%',
          }, 'TAKE-PROFIT triggered (HARDCODED 30%)');

          const signature = await this.executeSell(position.tokenMint, position.entryAmountTokens);
          if (signature) {
            exitSignatures.push(signature);

            // Emit take-profit event with reasoning
            agentEvents.emit({
              type: 'TAKE_PROFIT',
              timestamp: Date.now(),
              data: {
                mint: position.tokenMint,
                entryPrice: position.entryPrice,
                exitPrice: currentPrice,
                profitPercent: pnlPercent * 100,
                signature,
                reasoning,
                logs: [...executionLogs],
              },
            });

            // Record trade lesson for learning engine
            await this.recordTradeLesson(position, currentPrice, Date.now(), pnlPercent);

            // Calculate profit and ALWAYS trigger buyback on profitable exits
            const profitSol = position.entryAmountSol * pnlPercent;
            if (profitSol > 0) {
              await this.executeBuyback(profitSol, signature);
            }
          }
        }
      } catch (error) {
        logger.error({ mint: position.tokenMint, error }, 'Error checking position for exit');
        executionLogs.push(`Error checking ${position.tokenMint.slice(0, 6)}: ${error}`);
      }
    }

    return exitSignatures;
  }

  /**
   * Get recent trades for dashboard display
   */
  getRecentTrades(limit: number = 20): Array<{
    signature: string;
    timestamp: number;
    type: 'BUY' | 'SELL';
    mint: string;
    amount: number;
    tokenSymbol?: string;
  }> {
    const trades = this.db.trades.getRecent(limit);
    return trades
      .filter((t: { metadata?: { isBuyback?: boolean } }) => !t.metadata?.isBuyback)
      .map((t: { signature: string; timestamp: number; type: 'BUY' | 'SELL'; tokenMint: string; amountSol: number; tokenSymbol?: string }) => ({
        signature: t.signature,
        timestamp: t.timestamp,
        type: t.type,
        mint: t.tokenMint,
        amount: t.amountSol,
        tokenSymbol: t.tokenSymbol,
      }));
  }

  /**
   * Capture features at trade entry for learning engine
   */
  private async captureEntryFeatures(
    mint: string,
    tokenMetadata?: { liquidity?: number; marketCapSol?: number; symbol?: string; name?: string }
  ): Promise<TradeFeatures> {
    // Get safety analysis
    const safety = await this.tokenSafety.analyze(mint);

    // Get holder concentration
    let holderConcentration: HolderConcentrationResult = {
      top10Percent: 0,
      topHolderPercent: 0,
      isConcentrated: false,
    };
    try {
      holderConcentration = await this.checkHolderConcentration(mint);
    } catch {
      // Ignore errors
    }

    // Get token info from PumpPortal
    let bondingProgress = 0;
    let tokenAgeMins = 0;
    let holderCount = 0;
    try {
      const tokenInfo = await this.pumpPortal.getTokenInfo(mint);
      holderCount = tokenInfo.holderCount ?? 0;
      // Bonding progress and age would need extended API - estimate from liquidity
      bondingProgress = Math.min(100, (tokenInfo.liquidity / 85) * 100); // 85 SOL = 100%
    } catch {
      // Ignore errors
    }

    // Check smart money (simplified)
    const smartMoneyCount = 0; // Would need holder data to check

    return {
      bondingCurveProgress: bondingProgress,
      marketCapSol: tokenMetadata?.marketCapSol ?? 0,
      liquidity: tokenMetadata?.liquidity ?? 0,
      tokenAgeMins,
      buyCount5m: 0, // Would need trade history
      sellCount5m: 0,
      buyVolume5m: 0,
      sellVolume5m: 0,
      heatMetric: 0, // Would need MomentumScanner
      holderCount,
      topHolderPercent: holderConcentration.topHolderPercent,
      top10HoldersPercent: holderConcentration.top10Percent,
      smartMoneyCount,
      smartMoneyBuying: smartMoneyCount > 0,
      mintAuthorityRevoked: !safety.risks.includes('MINT_AUTHORITY_ACTIVE'),
      freezeAuthorityRevoked: !safety.risks.includes('FREEZE_AUTHORITY_ACTIVE'),
      isBundled: false, // Would need BundleDetector
      bundleScore: 0,
      hasTwitter: false, // Would need social data
      hasTelegram: false,
      hasWebsite: false,
    };
  }

  /**
   * Record a trade lesson when position closes
   */
  private async recordTradeLesson(
    position: OpenPosition,
    exitPrice: number,
    exitTimestamp: number,
    pnlPercent: number
  ): Promise<void> {
    if (!this.learningEngine) return;

    const entryData = this.entryFeatures.get(position.tokenMint);
    if (!entryData) {
      logger.warn({ mint: position.tokenMint }, 'No entry features found for trade lesson');
      return;
    }

    const pnlSol = position.entryAmountSol * pnlPercent;
    const outcome: 'win' | 'loss' = pnlPercent > 0 ? 'win' : 'loss';

    const lesson: TradeLesson = {
      id: `${position.tokenMint}-${position.entryTimestamp}`,
      tokenMint: position.tokenMint,
      tokenSymbol: position.tokenSymbol,
      entryTimestamp: position.entryTimestamp,
      exitTimestamp,
      features: entryData.features,
      outcome,
      pnlPercent: pnlPercent * 100, // Convert to percentage
      pnlSol,
      holdTimeMs: exitTimestamp - position.entryTimestamp,
      entryPrice: entryData.entryPrice,
      exitPrice,
      confidenceAtEntry: entryData.confidence,
    };

    await this.learningEngine.recordLesson(lesson);

    // Clean up entry features
    this.entryFeatures.delete(position.tokenMint);

    logger.info({
      mint: position.tokenMint,
      outcome,
      pnlPercent: (pnlPercent * 100).toFixed(1) + '%',
      holdTimeMs: lesson.holdTimeMs,
    }, 'Trade lesson recorded');
  }
}
</file>

</files>
