This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.agent/rules/tradingbot.md
.claude/settings.local.json
.env.example
.gitignore
.playwright-mcp/dashboard-working.png
.playwright-mcp/react-dashboard.png
analysis_report.md
analyze-db.js
analyze-loss.js
check-equity.js
check-schema.js
CLAUDE.md
client/.gitignore
client/eslint.config.js
client/index.html
client/package.json
client/public/header_full.png
client/public/header_logo.png
client/public/logo.png
client/public/vite.svg
client/README.md
client/repomix-output.xml
client/src/App.css
client/src/App.tsx
client/src/assets/react.svg
client/src/components/AIStatus.tsx
client/src/components/C100Card.tsx
client/src/components/ChallengeCard.tsx
client/src/components/EquityChart.tsx
client/src/components/Header.tsx
client/src/components/NarrativeStream.tsx
client/src/components/Positions.tsx
client/src/components/StatsGrid.tsx
client/src/components/TokenDisplay.tsx
client/src/components/TokenScanner.tsx
client/src/components/TradeList.tsx
client/src/components/Watchlist.tsx
client/src/hooks/useSocket.ts
client/src/index.css
client/src/main.tsx
client/src/types.ts
client/src/utils/clipboard.ts
client/tsconfig.app.json
client/tsconfig.json
client/tsconfig.node.json
client/vite.config.ts
compass_artifact_wf-5de4dceb-d091-494d-8f41-98c8abdc8dd6_text_markdown.md
debug-api.js
FLOWCHART.md
full-history.js
jest.config.js
package.json
Procfile
public/assets/index-B0KwH956.js
public/assets/index-BZU8IHLs.css
public/header_full.png
public/header_logo.png
public/index.html
public/logo.png
public/vite.svg
src/__tests__/position-manager.test.ts
src/__tests__/setup.ts
src/__tests__/token-watchlist.test.ts
src/ai/ddqn-agent.ts
src/ai/index.ts
src/ai/position-sizer.ts
src/ai/regime-detector.ts
src/ai/types.ts
src/api/index.ts
src/api/routes.ts
src/api/server.ts
src/api/websocket.ts
src/config/settings.ts
src/data/helius-ws.ts
src/data/index.ts
src/data/price-feed.ts
src/data/pumpportal-ws.ts
src/data/types.ts
src/data/whale-tracker.ts
src/db/repository.ts
src/db/schema.ts
src/db/types.ts
src/execution/index.ts
src/execution/jito-bundle.ts
src/execution/jupiter-swap.ts
src/execution/pumpfun-swap.ts
src/execution/tx-manager.ts
src/execution/types.ts
src/index.ts
src/learning/index.ts
src/learning/model-trainer.ts
src/learning/performance.ts
src/learning/trade-logger.ts
src/learning/types.ts
src/risk/capital-allocator.ts
src/risk/drawdown-guard.ts
src/risk/index.ts
src/risk/position-manager.ts
src/risk/types.ts
src/scripts/analyze-wallets.ts
src/scripts/discover-whales.ts
src/scripts/find-smart-wallets.ts
src/services/c100-buyback.ts
src/services/c100-tracker.ts
src/services/equity-tracker.ts
src/services/index.ts
src/services/position-reconciler.ts
src/services/reward-claimer.ts
src/services/wallet-sync.ts
src/signals/axiom-sensor.ts
src/signals/entry-evaluator.ts
src/signals/feature-extractor.ts
src/signals/index.ts
src/signals/narrative-sensor.ts
src/signals/news-sensor.ts
src/signals/pump-detector.ts
src/signals/rug-detector.ts
src/signals/rug-monitor.ts
src/signals/token-watchlist.ts
src/signals/types.ts
src/signals/velocity-tracker.ts
src/test-velocity.ts
src/utils/logger.ts
tsconfig.json
wallet.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="analysis_report.md">
# ðŸ“Š Wallet Analysis Report

**Generated:** 2026-01-22T17:50:52.050Z
**Total Wallets Analyzed:** 14
**Keepers Found:** 6

| Address | Score | Verdict | Win Rate | ROI | PnL | Tokens | Est. Hold Time | Flags |
|---------|-------|---------|----------|-----|-----|--------|----------------|-------|
| `5NszqQ4X78p7gVVJCRj9heobwHhiPFNAw23Xn8t8swn9` | **66** | âœ… KEEP | 67% | 1092% | 59.32 SOL | 2/3 | 2189s | Fresh Wallet |
| `2573AbP8EUacZZqx5TAkv4XFUkubmRGee2nScjYpMGFg` | **55** | âœ… KEEP | 75% | 152% | 3.44 SOL | 3/4 | 2024s | Fresh Wallet |
| `GTUFPqUSkv3emUSJXjsBMfJMx6R6abNNzaPnLnkNckhu` | **54** | âœ… KEEP | 27% | 213% | 36.83 SOL | 3/11 | 738s | Fresh Wallet |
| `HQYLrckNnctASrmqh4u6nSCqPSQdmjgUVJqb2EZc64V` | **53** | âœ… KEEP | 67% | 32% | 6.31 SOL | 4/6 | 414s | Fresh Wallet |
| `ApeiTAjq3V9grbN2jVbmpLb59wffYmwCBKZnugyuerLZ` | **52** | âœ… KEEP | 49% | 21% | 11.36 SOL | 18/37 | 1374s | Fresh Wallet |
| `Hzrc9hdpkvrMK8GXyHsZCt1B4E5DAkSLWa4pszFVWDXC` | **51** | âœ… KEEP | 42% | 86% | 3.48 SOL | 5/12 | 1196s | Fresh Wallet |
| `CapMjGxH3oa6XCjQVQq2Y8VvHz4PeC7uuYvYoA2GLVzu` | **50** | Xu274 DISCARD | 67% | 11% | 1.01 SOL | 6/9 | 15089s | Fresh Wallet |
| `HguEXBKHhBbLuPhoGLtzww27abKXZvCFu5JkcYiLEeSm` | **47** | Xu274 DISCARD | 38% | 4% | 0.45 SOL | 6/16 | 1448s | Fresh Wallet |
| `CPhA4xZPBhGX1guCPPCJb7Xo3zvzCuiQwAQzCrc95HYY` | **47** | Xu274 DISCARD | 39% | -5% | -1.36 SOL | 7/18 | 28039s | Fresh Wallet |
| `3W4zaACZYjebwGPmxjkgXCUHeHJNBjb2kDAGohT1Wahx` | **46** | Xu274 DISCARD | 50% | -11% | -1.95 SOL | 6/12 | 5410s | Fresh Wallet |
| `7BNaxx6KdUYrjACNQZ9He26NBFoFxujQMAfNLnArLGH5` | **43** | Xu274 DISCARD | 20% | -49% | -50.00 SOL | 12/60 | 251s | Fresh Wallet |
| `Ar2Y6o1QmrRAskjii1cRfijeKugHH13ycxW5cd7rro1x` | **41** | Xu274 DISCARD | 15% | -64% | -63.01 SOL | 10/67 | 346s | Fresh Wallet |
| `3HEihqmG22iZfVTAfAZjeqr5qm2mCJZz2iLvWdGZxvG2` | **40** | Xu274 DISCARD | 33% | -19% | -6.69 SOL | 4/12 | 9872s | Fresh Wallet |
| `AnrR8mHZJuePcsuAEoXp1ugEZMgfjCK5nqE4JJct4KfS` | **31** | Xu274 DISCARD | 33% | 41% | 1.77 SOL | 1/3 | 1130s | Fresh Wallet |

## Metric Explanations
- **Score:** Composite rating (0-100) based on Win Rate, ROI, Consistency, and Profit.
- **Verdict:** KEEP if Score > 40 per user criteria.
- **Win Rate:** Percentage of tokens traded that resulted in profit.
- **ROI:** Total Profit / Total Cost (capped at 300% for scoring).
</file>

<file path="analyze-loss.js">
const https = require('https');

const WALLET = 'GDh3oZJLhCbBXSvVJ97xqbvSwVKERe3P9bsVQ7ayBVdv';
const url = `https://api.helius.xyz/v0/addresses/${WALLET}/transactions?api-key=dd091d8d-f7eb-4d3c-83fc-87cc3232f4f6&limit=50`;

https.get(url, (res) => {
  let data = '';
  res.on('data', chunk => data += chunk);
  res.on('end', () => {
    const txs = JSON.parse(data);
    let totalSolOut = 0;
    let totalSolIn = 0;
    let totalFees = 0;

    console.log('=== ANALYZING TRANSACTIONS ===\n');

    const swaps = [];

    txs.forEach((tx, i) => {
      const fee = tx.fee / 1e9;
      totalFees += fee;

      let solOut = 0;
      let solIn = 0;

      // Check native transfers
      if (tx.nativeTransfers) {
        tx.nativeTransfers.forEach(nt => {
          const amt = nt.amount / 1e9;
          if (nt.fromUserAccount === WALLET) {
            solOut += amt;
            totalSolOut += amt;
          }
          if (nt.toUserAccount === WALLET) {
            solIn += amt;
            totalSolIn += amt;
          }
        });
      }

      // Track swaps
      if (tx.type === 'SWAP') {
        swaps.push({
          index: i + 1,
          description: (tx.description || 'No description').substring(0, 80),
          fee: fee,
          solOut: solOut,
          solIn: solIn,
          net: solIn - solOut - fee,
          tokenTransfers: tx.tokenTransfers || []
        });
      }
    });

    // Show all swaps with their P/L
    console.log('=== SWAP DETAILS ===\n');
    swaps.forEach(s => {
      console.log(`[${s.index}] ${s.description}`);
      console.log(`    SOL Out: ${s.solOut.toFixed(6)}, SOL In: ${s.solIn.toFixed(6)}, Fee: ${s.fee.toFixed(6)}`);
      console.log(`    Net: ${s.net.toFixed(6)} SOL`);
      if (s.tokenTransfers.length > 0) {
        s.tokenTransfers.forEach(tt => {
          const dir = tt.fromUserAccount === WALLET ? 'SOLD' : 'BOUGHT';
          console.log(`    Token ${dir}: ${tt.tokenAmount} of ${tt.mint.substring(0,8)}...`);
        });
      }
      console.log('');
    });

    console.log('=== SUMMARY ===');
    console.log(`Total SOL OUT: ${totalSolOut.toFixed(6)} SOL`);
    console.log(`Total SOL IN:  ${totalSolIn.toFixed(6)} SOL`);
    console.log(`Total Fees:    ${totalFees.toFixed(6)} SOL`);
    console.log(`Net P/L:       ${(totalSolIn - totalSolOut - totalFees).toFixed(6)} SOL`);

    // Group by token
    console.log('\n=== BY TOKEN ===');
    const byToken = {};
    swaps.forEach(s => {
      s.tokenTransfers.forEach(tt => {
        const mint = tt.mint;
        if (!byToken[mint]) {
          byToken[mint] = { bought: 0, sold: 0, solSpent: 0, solReceived: 0, fees: 0 };
        }
        if (tt.fromUserAccount === WALLET) {
          byToken[mint].sold += tt.tokenAmount;
          byToken[mint].solReceived += s.solIn;
        } else {
          byToken[mint].bought += tt.tokenAmount;
          byToken[mint].solSpent += s.solOut;
        }
        byToken[mint].fees += s.fee;
      });
    });

    Object.entries(byToken).forEach(([mint, data]) => {
      const net = data.solReceived - data.solSpent - data.fees;
      console.log(`\n${mint.substring(0,12)}...`);
      console.log(`  SOL Spent: ${data.solSpent.toFixed(6)}, Received: ${data.solReceived.toFixed(6)}`);
      console.log(`  P/L: ${net.toFixed(6)} SOL (${net >= 0 ? 'PROFIT' : 'LOSS'})`);
    });
  });
}).on('error', console.error);
</file>

<file path="client/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="client/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="client/package.json">
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}
</file>

<file path="client/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="client/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="client/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="client/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="client/src/components/C100Card.tsx">
import type { C100Data } from '../types';

interface C100CardProps {
  data: C100Data | null;
}

export function C100Card({ data }: C100CardProps) {
  if (!data || !data.enabled) {
    return null;
  }

  const formatNumber = (num: number, decimals: number = 4) => {
    if (num === 0) return '0';
    if (num < 0.0001) return num.toExponential(2);
    return num.toFixed(decimals);
  };

  const formatLargeNumber = (num: number) => {
    if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
    if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
    if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
    return num.toFixed(2);
  };

  const truncateMint = (mint: string) => {
    if (!mint) return '';
    return `${mint.slice(0, 6)}...${mint.slice(-4)}`;
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
  };

  const priceChange = data.token?.priceChange24h || 0;
  const isPriceUp = priceChange >= 0;

  return (
    <div className="c100-card card">
      <div className="c100-header">
        <div className="c100-token-info">
          <div className="c100-icon">C</div>
          <div className="c100-details">
            <h3>{data.token?.name || 'C100'}</h3>
            <div className="c100-ticker">${data.token?.symbol || 'C100'}</div>
          </div>
        </div>
        {data.token && (
          <div
            className="c100-mint"
            onClick={() => copyToClipboard(data.token!.mint)}
            title="Click to copy"
          >
            {truncateMint(data.token.mint)}
          </div>
        )}
      </div>

      <div className="c100-grid">
        {/* Price Section */}
        <div className="c100-stat">
          <span className="c100-stat-label">Price</span>
          <span className="c100-stat-value">
            ${data.token ? formatNumber(data.token.priceUsd, 8) : 'â€”'}
          </span>
          {data.token && (
            <span className={`c100-stat-change ${isPriceUp ? 'positive' : 'negative'}`}>
              {isPriceUp ? '+' : ''}{priceChange.toFixed(2)}%
            </span>
          )}
        </div>

        {/* Market Cap */}
        <div className="c100-stat">
          <span className="c100-stat-label">Market Cap</span>
          <span className="c100-stat-value">
            ${data.token ? formatLargeNumber(data.token.marketCapUsd) : 'â€”'}
          </span>
        </div>

        {/* SOL Claimed */}
        <div className="c100-stat highlight">
          <span className="c100-stat-label">SOL Claimed</span>
          <span className="c100-stat-value accent">
            {formatNumber(data.claims.totalClaimedSol, 4)}
          </span>
          <span className="c100-stat-sub">{data.claims.claimCount} claims</span>
        </div>

        {/* SOL Buyback */}
        <div className="c100-stat highlight">
          <span className="c100-stat-label">SOL Buyback</span>
          <span className="c100-stat-value accent">
            {formatNumber(data.buybacks.totalBuybackSol, 4)}
          </span>
          <span className="c100-stat-sub">{data.buybacks.buybackCount} buys</span>
        </div>

        {/* Tokens Bought */}
        <div className="c100-stat wide">
          <span className="c100-stat-label">C100 Tokens Bought</span>
          <span className="c100-stat-value large">
            {formatLargeNumber(data.buybacks.totalTokensBought)}
          </span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/ChallengeCard.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats } from '../types';

interface ChallengeCardProps {
  stats: Stats;
}

export const ChallengeCard: React.FC<ChallengeCardProps> = ({ stats }) => {
  const multiplier = parseFloat(stats.multiplier || "1");
  const equity = parseFloat(stats.currentEquity || stats.initialCapital || "1");
  const initial = parseFloat(stats.initialCapital || "1");
  
  // Progress calculation (logarithmic scale feels better but linear for now as per original)
  // Max at 100x
  const progress = Math.min(100, Math.max(1, multiplier));

  const [displayMultiplier, setDisplayMultiplier] = useState(multiplier);
  
  useEffect(() => {
    setDisplayMultiplier(multiplier);
  }, [multiplier]);

  return (
    <div className="card">
      <div className="challenge-card">
        <div className="challenge-label">THE 1 â†’ 100 CHALLENGE</div>
        <div className="challenge-value animate-number">
          {displayMultiplier.toFixed(2)}<span>x</span>
        </div>
        <div className="challenge-sub">
          {equity.toFixed(2)} SOL from {initial} SOL start
        </div>
        <div className="progress-bar-container">
          <div className="progress-bar">
            <div 
              className="progress-fill" 
              style={{ width: `${progress}%` }}
            ></div>
          </div>
          <div className="progress-markers">
            <span className={multiplier >= 1 ? 'active' : ''}>1x</span>
            <span className={multiplier >= 10 ? 'active' : ''}>10x</span>
            <span className={multiplier >= 25 ? 'active' : ''}>25x</span>
            <span className={multiplier >= 50 ? 'active' : ''}>50x</span>
            <span className={multiplier >= 100 ? 'active' : ''}>100x</span>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/EquityChart.tsx">
import React, { useMemo } from 'react';
import type { EquitySnapshot } from '../hooks/useSocket';

interface EquityChartProps {
  history: EquitySnapshot[];
  walletBalance?: number;
}

export const EquityChart: React.FC<EquityChartProps> = ({ history, walletBalance }) => {
  const chartData = useMemo(() => {
    if (history.length < 2) return null;

    const values = history.map(s => s.totalEquity);
    const minVal = Math.min(...values);
    const maxVal = Math.max(...values);
    const range = maxVal - minVal || 1;

    // Chart dimensions
    const width = 300;
    const height = 60;
    const padding = 4;

    // Calculate points
    const points = values.map((val, i) => {
      const x = padding + (i / (values.length - 1)) * (width - padding * 2);
      const y = height - padding - ((val - minVal) / range) * (height - padding * 2);
      return `${x},${y}`;
    }).join(' ');

    // Determine trend
    const firstVal = values[0];
    const lastVal = values[values.length - 1];
    const isUp = lastVal >= firstVal;
    const change = lastVal - firstVal;
    const changePercent = firstVal > 0 ? (change / firstVal) * 100 : 0;

    return {
      points,
      width,
      height,
      isUp,
      change,
      changePercent,
      current: lastVal,
      min: minVal,
      max: maxVal,
    };
  }, [history]);

  if (!chartData) {
    return (
      <div className="card equity-chart-card">
        <div className="card-header">
          <span className="card-title">Equity</span>
        </div>
        <div className="equity-chart-empty">
          <span>Collecting data...</span>
          {walletBalance !== undefined && (
            <span className="wallet-balance">{walletBalance.toFixed(4)} SOL</span>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="card equity-chart-card">
      <div className="card-header">
        <span className="card-title">Equity</span>
        <span className={`card-badge ${chartData.isUp ? 'positive' : 'negative'}`}>
          {chartData.isUp ? '+' : ''}{chartData.changePercent.toFixed(2)}%
        </span>
      </div>
      <div className="equity-chart-content">
        <div className="equity-current">
          <span className="equity-value">{chartData.current.toFixed(4)}</span>
          <span className="equity-label">SOL</span>
        </div>
        <svg
          className="equity-sparkline"
          viewBox={`0 0 ${chartData.width} ${chartData.height}`}
          preserveAspectRatio="none"
        >
          <defs>
            <linearGradient id="equityGradient" x1="0" y1="0" x2="0" y2="1">
              <stop
                offset="0%"
                stopColor={chartData.isUp ? '#10b981' : '#ef4444'}
                stopOpacity="0.3"
              />
              <stop
                offset="100%"
                stopColor={chartData.isUp ? '#10b981' : '#ef4444'}
                stopOpacity="0"
              />
            </linearGradient>
          </defs>
          <polygon
            points={`${4},${chartData.height - 4} ${chartData.points} ${chartData.width - 4},${chartData.height - 4}`}
            fill="url(#equityGradient)"
          />
          <polyline
            points={chartData.points}
            fill="none"
            stroke={chartData.isUp ? '#10b981' : '#ef4444'}
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
        </svg>
        <div className="equity-range">
          <span>{chartData.min.toFixed(2)}</span>
          <span>{chartData.max.toFixed(2)}</span>
        </div>
      </div>
      <div className="equity-footer">
        <span className={chartData.isUp ? 'positive' : 'negative'}>
          {chartData.isUp ? '+' : ''}{chartData.change.toFixed(4)} SOL (24h)
        </span>
        {walletBalance !== undefined && (
          <span className="wallet-indicator">
            Wallet: {walletBalance.toFixed(4)}
          </span>
        )}
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/Header.tsx">
import React from 'react';

interface HeaderProps {
  isConnected: boolean;
}

export const Header: React.FC<HeaderProps> = ({ isConnected }) => {
  return (
    <header className="header">
      <div style={{ position: 'absolute', left: '50%', transform: 'translateX(-50%)', width: '300px', height: '80px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
        <img src="/header_full.png" alt="1 to 100 Sol Challenge" style={{ width: '100%', height: '100%', objectFit: 'contain' }} />
      </div>
      <div 
        className="live-badge" 
        style={{
          background: isConnected ? 'var(--success-subtle)' : 'var(--error-subtle)',
          borderColor: isConnected ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)',
          color: isConnected ? 'var(--success)' : 'var(--error)'
        }}
      >
        {isConnected && <span className="live-dot"></span>}
        <span>{isConnected ? 'Live' : 'Disconnected'}</span>
      </div>
    </header>
  );
};
</file>

<file path="client/src/components/NarrativeStream.tsx">
import React from 'react';
import type { NarrativeSignal } from '../types';

interface NarrativeStreamProps {
  signal: NarrativeSignal | null;
}

export const NarrativeStream: React.FC<NarrativeStreamProps> = ({ signal }) => {
  if (!signal) return null;

  return (
    <div className="card" style={{ marginTop: '24px' }}>
      <div className="card-header">
        <span className="card-title">Narrative Stream</span>
        <div style={{
          padding: '4px 12px',
          borderRadius: '20px',
          fontSize: '11px',
          background: signal.sentiment === 'bullish' ? 'var(--success-subtle)' : 
                      signal.sentiment === 'bearish' ? 'var(--error-subtle)' : 'var(--bg-elevated)',
          color: signal.sentiment === 'bullish' ? 'var(--success)' :
                 signal.sentiment === 'bearish' ? 'var(--error)' : 'var(--text-muted)'
        }}>
          {signal.sentiment.toUpperCase()}
        </div>
      </div>
      <div style={{ padding: '24px' }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '16px' }}>
          <div>
            <div className="stat-label">Bullish Score</div>
            <div className="metric-value" style={{ fontSize: '18px' }}>
              {signal.bullishnessScore.toFixed(2)}
            </div>
          </div>
          <div>
            <div className="stat-label">Hype Score</div>
            <div className="metric-value" style={{ fontSize: '18px', color: 'var(--accent)' }}>
              {(signal.hypeScore * 100).toFixed(0)}%
            </div>
          </div>
        </div>

        <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
          {signal.keywords.map((k, i) => (
            <span key={i} style={{
              background: 'rgba(255,255,255,0.05)',
              padding: '6px 10px',
              borderRadius: '6px',
              fontSize: '12px',
              color: 'var(--text-secondary)'
            }}>
              #{k}
            </span>
          ))}
        </div>
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/StatsGrid.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats } from '../types';

interface StatsGridProps {
  stats: Stats;
}

const NumberDisplay: React.FC<{ value: string | number; className?: string }> = ({ value, className = "" }) => {
  const [displayValue, setDisplayValue] = useState(value);
  const [updating, setUpdating] = useState(false);

  useEffect(() => {
    if (value !== displayValue) {
      setUpdating(true);
      setDisplayValue(value);
      const timer = setTimeout(() => setUpdating(false), 300);
      return () => clearTimeout(timer);
    }
  }, [value, displayValue]);

  return (
    <div className={`animate-number ${updating ? 'updating' : ''} ${className}`}>
      {value}
    </div>
  );
};

export const StatsGrid: React.FC<StatsGridProps> = ({ stats }) => {
  const equity = parseFloat(stats.currentEquity || "0");
  const initial = parseFloat(stats.initialCapital || "0");
  const profit = equity - initial;
  const isProfit = profit >= 0;

  return (
    <div className="stats-grid">
      <div className="stat-card highlight">
        <div className="stat-label">Multiplier</div>
        <NumberDisplay value={`${parseFloat(stats.multiplier || "1").toFixed(2)}x`} className="stat-value accent" />
        <div className={`stat-sub ${isProfit ? 'positive' : ''}`}>
          <span className="arrow">â†‘</span>
          <span>{isProfit ? '+' : ''}{profit.toFixed(2)} SOL profit</span>
        </div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Win Rate</div>
        <NumberDisplay value={`${stats.winRate}%`} className="stat-value" />
        <div className="stat-sub positive">
          <span className="arrow">â†‘</span>
          <span>Creating alpha</span>
        </div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Total Trades</div>
        <NumberDisplay value={stats.totalTrades} className="stat-value" />
        <div className="stat-sub">Lifetime</div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Tokens Scanned</div>
        <NumberDisplay value={stats.tokensScanned} className="stat-value" />
        <div className="stat-sub">Last 24 hours</div>
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/TokenDisplay.tsx">
import React, { useState } from 'react';
import { copyToClipboard } from '../utils/clipboard';

interface TokenDisplayProps {
  mint: string;
  name?: string;
  symbol?: string;
  imageUrl?: string | null;
  size?: 'sm' | 'md' | 'lg';
  showCopy?: boolean;
  inline?: boolean;
}

// Generate a consistent color from a string
const stringToColor = (str: string): string => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = hash % 360;
  return `hsl(${hue}, 65%, 45%)`;
};

const sizeConfig = {
  sm: { img: 20, fontSize: '11px', gap: '6px' },
  md: { img: 28, fontSize: '12px', gap: '8px' },
  lg: { img: 40, fontSize: '14px', gap: '10px' },
};

export const TokenDisplay: React.FC<TokenDisplayProps> = ({
  mint,
  name,
  symbol,
  imageUrl,
  size = 'md',
  showCopy = true,
  inline = false,
}) => {
  const [copied, setCopied] = useState(false);
  const [imgError, setImgError] = useState(false);

  const config = sizeConfig[size];
  const displayName = name || symbol || 'Unknown';
  const displaySymbol = symbol ? `$${symbol}` : `$${mint.substring(0, 6).toUpperCase()}`;
  const truncatedMint = `${mint.substring(0, 6)}...${mint.substring(mint.length - 4)}`;
  const fallbackLetter = (symbol || name || mint)[0].toUpperCase();
  const fallbackColor = stringToColor(mint);

  const handleCopy = async (e: React.MouseEvent) => {
    e.stopPropagation();
    const success = await copyToClipboard(mint);
    if (success) {
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    }
  };

  const renderImage = () => {
    if (imageUrl && !imgError) {
      return (
        <img
          src={imageUrl}
          alt={displayName}
          style={{
            width: config.img,
            height: config.img,
            borderRadius: '50%',
            objectFit: 'cover',
            flexShrink: 0,
          }}
          onError={() => setImgError(true)}
        />
      );
    }

    // Fallback: letter avatar
    return (
      <div
        style={{
          width: config.img,
          height: config.img,
          borderRadius: '50%',
          background: fallbackColor,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          color: '#fff',
          fontSize: config.img * 0.5,
          fontWeight: 600,
          flexShrink: 0,
        }}
      >
        {fallbackLetter}
      </div>
    );
  };

  if (inline) {
    // Compact inline display for lists
    return (
      <div style={{ display: 'flex', alignItems: 'center', gap: config.gap }}>
        {renderImage()}
        <span style={{ fontFamily: 'var(--font-mono)', fontSize: config.fontSize, color: 'var(--text-primary)' }}>
          {displaySymbol}
        </span>
        {showCopy && (
          <button
            onClick={handleCopy}
            style={{
              background: 'none',
              border: 'none',
              padding: '2px',
              cursor: 'pointer',
              color: copied ? 'var(--success)' : 'var(--text-muted)',
              fontSize: '10px',
              display: 'flex',
              alignItems: 'center',
            }}
            title="Copy address"
          >
            {copied ? 'âœ“' : 'âŽ˜'}
          </button>
        )}
      </div>
    );
  }

  // Full display with name, symbol, and address
  return (
    <div style={{ display: 'flex', alignItems: 'flex-start', gap: config.gap }}>
      {renderImage()}
      <div style={{ display: 'flex', flexDirection: 'column', gap: '2px', minWidth: 0 }}>
        {size !== 'sm' && name && (
          <div style={{
            fontSize: config.fontSize,
            fontWeight: 500,
            color: 'var(--text-primary)',
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            whiteSpace: 'nowrap',
          }}>
            {displayName}
          </div>
        )}
        <div style={{
          fontFamily: 'var(--font-mono)',
          fontSize: size === 'lg' ? '12px' : '11px',
          color: 'var(--accent)',
        }}>
          {displaySymbol}
        </div>
        {showCopy && (
          <button
            onClick={handleCopy}
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '4px',
              background: 'none',
              border: 'none',
              padding: 0,
              cursor: 'pointer',
              color: copied ? 'var(--success)' : 'var(--text-muted)',
              fontSize: '10px',
              fontFamily: 'var(--font-mono)',
            }}
            title="Copy full address"
          >
            <span>{truncatedMint}</span>
            <span style={{ fontSize: '9px' }}>{copied ? 'âœ“' : 'âŽ˜'}</span>
          </button>
        )}
      </div>
    </div>
  );
};

// Compact version for tight spaces (just image + symbol)
export const TokenBadge: React.FC<{
  mint: string;
  symbol?: string;
  imageUrl?: string | null;
  onClick?: () => void;
}> = ({ mint, symbol, imageUrl, onClick }) => {
  const [imgError, setImgError] = useState(false);
  const displaySymbol = symbol ? `$${symbol}` : `$${mint.substring(0, 6).toUpperCase()}`;
  const fallbackLetter = (symbol || mint)[0].toUpperCase();
  const fallbackColor = stringToColor(mint);

  return (
    <div
      onClick={onClick}
      style={{
        display: 'inline-flex',
        alignItems: 'center',
        gap: '4px',
        padding: '2px 8px 2px 2px',
        borderRadius: '12px',
        background: 'var(--bg-elevated)',
        cursor: onClick ? 'pointer' : 'default',
      }}
    >
      {imageUrl && !imgError ? (
        <img
          src={imageUrl}
          alt={displaySymbol}
          style={{ width: 18, height: 18, borderRadius: '50%', objectFit: 'cover' }}
          onError={() => setImgError(true)}
        />
      ) : (
        <div
          style={{
            width: 18,
            height: 18,
            borderRadius: '50%',
            background: fallbackColor,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            color: '#fff',
            fontSize: 9,
            fontWeight: 600,
          }}
        >
          {fallbackLetter}
        </div>
      )}
      <span style={{ fontFamily: 'var(--font-mono)', fontSize: '11px', color: 'var(--text-primary)' }}>
        {displaySymbol}
      </span>
    </div>
  );
};
</file>

<file path="client/src/main.tsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  // StrictMode disabled to prevent double-socket connection in dev
  // or handle cleanup carefully in useEffect (which we did).
  // Keeping it enabled is fine if cleanup is robust.
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
</file>

<file path="client/src/utils/clipboard.ts">
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (error) {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
      document.execCommand('copy');
      textArea.remove();
      return true;
    } catch {
      textArea.remove();
      return false;
    }
  }
}
</file>

<file path="client/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "types": [
      "vite/client"
    ],
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": [
    "src"
  ]
}
</file>

<file path="client/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="client/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="compass_artifact_wf-5de4dceb-d091-494d-8f41-98c8abdc8dd6_text_markdown.md">
# Building an AI Trading Bot on Solana: APIs, Repos, and Strategy

**Only 0.4% of Pump.fun traders profit over $10,000**â€”that sobering statistic from on-chain analysis sets the context for this guide. The Solana meme coin ecosystem generates extraordinary stories (2 SOL to $1 million in 3 hours has happened), but 60-90% of traders lose money. This comprehensive guide provides the technical infrastructure to build an AI trading bot while acknowledging the brutal statistical reality. If you proceed, you'll do so with working code, real APIs, and proven risk managementâ€”not false hope.

---

## Part 1: Free Solana APIs and endpoints

The Solana ecosystem offers surprisingly robust free API access. These endpoints form the data and execution backbone for any trading bot.

### RPC providers with free tiers

| Provider | Free Tier | Rate Limit | Endpoint Format |
|----------|-----------|------------|-----------------|
| **Helius** | 1M credits/month | 10 RPS | `https://mainnet.helius-rpc.com/?api-key=YOUR_KEY` |
| **QuickNode** | 10M credits | 15 RPS | Custom endpoint after signup |
| **dRPC** | Unlimited basic | No strict limit | `https://solana.drpc.org` |
| **Chainstack** | Free tier | Geo-balanced | Custom after signup |
| **Alchemy** | Limited free | Rate-limited | `https://solana-mainnet.g.alchemy.com/v2/:apiKey` |

The official Solana public RPC (`https://api.mainnet.solana.com`) exists but **should never be used for production trading**â€”it's rate-limited to 100 requests per 10 seconds and can block your IP without notice. Helius offers the best free balance of speed and reliability, with WebSocket support at `wss://atlas-mainnet.helius-rpc.com/?api-key=YOUR_KEY`.

### DEX and swap APIs (all free, no authentication required)

**Jupiter Aggregator** dominates Solana DeFi with >90% of aggregator volume. Their API requires no authentication and provides optimal swap routing:

```javascript
// Jupiter Quote API (FREE)
const quote = await fetch(
  'https://api.jup.ag/v6/quote?' + 
  'inputMint=So11111111111111111111111111111111111111112&' +  // SOL
  'outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&' + // USDC
  'amount=1000000'  // 0.001 SOL in lamports
);

// Jupiter Swap Execution
const swap = await fetch('https://api.jup.ag/v6/swap', {
  method: 'POST',
  body: JSON.stringify({ quoteResponse: quote, userPublicKey: wallet })
});
```

**Raydium V3 API** provides direct pool access without aggregation overhead:
- Base URL: `https://api-v3.raydium.io/`
- Pool list: `/pools/info/list`
- Token data: `https://api.raydium.io/v2/sdk/token/solana.mainnet.json`
- Full documentation at `https://api-v3.raydium.io/docs/`

**Orca Whirlpools** concentrated liquidity pools use their TypeScript SDK (`@orca-so/whirlpools`) rather than REST endpointsâ€”install via npm for programmatic access.

### Token data and price APIs

**DexScreener** offers the most generous free tier with no API key required:
- Search pairs: `GET https://api.dexscreener.com/latest/dex/search?q={query}`
- Token pairs: `GET https://api.dexscreener.com/token-pairs/v1/solana/{tokenAddress}`
- Boosted/trending: `GET https://api.dexscreener.com/token-boosts/top/v1`
- Rate limit: **300 requests/minute**

**Birdeye** requires a free API key but limits free tier to token price and token list endpoints only (30,000 credits/month). Premium features (OHLCV, trade data, WebSocket streaming) require paid plans starting at $49/month.

**GeckoTerminal** (CoinGecko's on-chain arm) provides free OHLCV data across 250+ networks without authentication: `https://api.geckoterminal.com/api/v2/`

### Specialized infrastructure APIs

**Jito Bundles** for MEV protection is technically freeâ€”you only pay tips (minimum **1,000 lamports** or 0.000001 SOL) for atomic transaction execution. This protects against sandwich attacks and ensures transaction ordering:

```python
# Jito bundle submission pattern
from jito_sdk import JitoClient

client = JitoClient()
bundle = [swap_transaction, take_profit_transaction]
result = await client.send_bundle(bundle, tip_lamports=10000)
```

**Pump.fun** has no official API, but community documentation exists at `github.com/BankkRoll/pumpfun-apis`. Most bots monitor launches via Solana's `logsSubscribe` WebSocket rather than HTTP endpoints. Bitquery offers GraphQL subscriptions for Pump.fun events if you need structured data.

---

## Part 2: GitHub repositories worth using

After reviewing dozens of repositories, these represent the most actively maintained, functional codebases as of January 2025.

### The essential starting point: chainstacklabs/pumpfun-bonkfun-bot

This Python-based bot (**874 stars, actively maintained**) represents the most production-ready open-source implementation for meme coin trading:

```
GitHub: github.com/chainstacklabs/pumpfun-bonkfun-bot
Language: Python 100%
License: Apache-2.0
Features:
- New token sniping via logsSubscribe and blockSubscribe
- Bonding curve tracking and PumpSwap migration listening
- Take profit/stop loss automation
- Dynamic priority fees
- Geyser gRPC integration for low-latency data
```

The repository includes excellent documentation with full walkthrough tutorials at docs.chainstack.com.

### Trading infrastructure repositories

| Repository | Purpose | Language | Best For |
|------------|---------|----------|----------|
| **warp-id/solana-trading-bot** | Automated trading with pool burn detection, mint checks | TypeScript | Full trading automation |
| **outsmartchad/solana-trading-cli** | High-performance library supporting Raydium, Orca, Meteora, Pump.fun | TypeScript | Building custom strategies |
| **ARBProtocol/solana-jupiter-bot** | Arbitrage with config wizard and CLI dashboard | JavaScript | Cross-DEX arbitrage |
| **fdundjer/solana-sniper-bot** | Raydium pool sniping with Jito executors | TypeScript | New pool sniping |
| **DracoR22/handi-cat_wallet-tracker** | Telegram bot for real-time wallet tracking | TypeScript | Copy trading infrastructure |

### AI/ML integration toolkit

**sendaifun/solana-agent-kit** stands out as the most comprehensive AI integration framework, connecting any AI agent to 60+ Solana actions with LangChain/LangGraph integration. The Python version (`solana-agent-kit-py`) is available for those preferring Python over TypeScript.

For reinforcement learning specifically, **sadighian/crypto-rl** provides a complete toolkit including data recording, Gym environments, and DDQN training pipelines designed for limit order book data.

### Essential SDKs you'll need

```bash
# JavaScript/TypeScript
npm install @solana/web3.js @raydium-io/raydium-sdk-v2 @orca-so/whirlpools

# Python
pip install solana solders
```

The official **raydium-io/raydium-sdk-V2** and **jup-ag/jupiter-swap-api-client** repositories provide the canonical implementations for DEX interactions.

---

## Part 3: Strategy framework for 1 SOL to 100 SOL

The math requires a **100x return**â€”achievable in theory but statistically improbable. Only 293 wallets (0.00217% of 13.55 million) have made over $1 million on Pump.fun. Your strategy must acknowledge this reality while optimizing for the slim possibility of success.

### Realistic pathways and their odds

**Meme coin sniping** offers the highest potential returns but worst odds. The bonding curve mechanics of Pump.fun mean earliest buyers get exponentially better pricesâ€”but **98.6% of tokens collapse** into pump-and-dump schemes, and only **1.29% graduate to Raydium**.

Successful snipers use three detection methods:
1. **Twitter/X scraping** for contract addresses dropped by non-crypto influencers
2. **On-chain monitoring** of developer wallets with successful launch histories
3. **Volume/social velocity tracking** for narrative breaks (AI themes, political events)

**Copy trading** successful wallets provides learning opportunities but faces structural problems: by the time you execute, price has moved; "farmer wallets" deliberately exploit copiers by making initial buys, waiting for copy volume, then dumping.

**DEX arbitrage** with 1 SOL is **not viable**â€”the technical infrastructure costs and competition from professional MEV bots eliminate any edge small capital might have.

### Position sizing that survives losing streaks

With 1 SOL (~$150-250 at recent prices), the Kelly Criterion suggests risking **1-5% per trade** (0.01-0.05 SOL) to survive the inevitable losing streaks. A practical framework:

```
Core reserve (40%): 0.4 SOL - Never trade, provides recovery capital
Active trading (40%): 0.4 SOL - Split across 3-5 positions max
High-risk allocation (20%): 0.2 SOL - Meme coin/speculative plays
```

This structure allows approximately **20-40 learning trades** before depletion, assuming average losses of 50% per failed trade.

### Entry and exit discipline

**Entry signals worth acting on:**
- Volume spike >200% in short timeframe with price confirmation
- Whale accumulation visible on Solscan (large wallets buying)
- Locked liquidity + revoked mint authority (verifiable via RugCheck.xyz)
- Top 10 holders controlling <30% of supply

**Exit strategy that captures gains:**
Most meme coins die within 30 seconds to 24 hours. The staged exit approach protects profits:
- At **2x**: Sell 25% (recover partial initial)
- At **3x**: Sell 25% (guarantee profit)
- Remaining **50%**: Trail with 15-20% stop loss

### Pre-trade rug pull checklist

Before every entry, verify:
- [ ] Liquidity locked (check GeckoTerminal, RugCheck.xyz)
- [ ] Mint authority revoked (prevents infinite token creation)
- [ ] Freeze authority revoked (prevents wallet freezing)
- [ ] No bundled buys at launch (coordinated manipulation)
- [ ] Developer wallet has no rug pull history
- [ ] Top 10 holders <30% of supply

---

## Part 4: AI/ML component architecture

Machine learning adds value primarily through **risk management and pattern recognition**â€”not price prediction. Markets are too efficient for simple ML models to consistently predict direction.

### Reinforcement learning implementation

The RL paradigm fits trading naturally: the agent receives market state, takes actions (buy/sell/hold), and receives rewards (PnL). Research shows **DDQN with Sharpe ratio as reward function** outperforms other Q-learning variants.

```python
import gym
import numpy as np
from stable_baselines3 import DQN

# State representation
state = np.array([
    unrealized_pnl,
    available_cash / initial_capital,  # Normalized
    current_position,
    rsi_14,
    volume_relative_to_average,
    price_relative_to_ema_20
])

# Action space: Discrete (0=hold, 1=buy, 2=sell)
env = TradingEnv(state_shape=(6,), action_space=3)
model = DQN('MlpPolicy', env, verbose=1)
model.learn(total_timesteps=100000)
```

The critical insight from research: **even with limited prediction ability, RL agents can react to market changes** rather than predict themâ€”a more tractable problem.

### Sentiment analysis that provides signal

Twitter sentiment correlates with trading volume and short-term volatility. A practical implementation using VADER:

```python
from nltk.sentiment.vader import SentimentIntensityAnalyzer

sia = SentimentIntensityAnalyzer()

def get_sentiment_signal(tweets: list) -> str:
    scores = [sia.polarity_scores(t)['compound'] for t in tweets]
    avg = sum(scores) / len(scores) if scores else 0
    
    if avg > 0.05: return 'bullish'
    elif avg < -0.05: return 'bearish'
    return 'neutral'
```

For crypto-specific accuracy, fine-tuned models like **CryptoBERT** achieve 83.5% classification accuracy versus VADER's ~70%. However, sentiment works best as an **additional signal**, not primaryâ€”combining it with price/volume data improves forecasts by approximately 20%.

### Pump detection algorithm

Z-score based anomaly detection correctly identifies pump-and-dump targets **55.81% of the time** (top 5 ranking). The key features:

```python
def calculate_pump_score(token_data):
    return {
        'price_z': (current_price - rolling_mean) / rolling_std,
        'volume_z': (volume - avg_volume) / volume_std,
        'order_imbalance': bid_volume / ask_volume,
        'trade_intensity': trades_per_minute / avg_trades
    }
    
# Alert threshold: combined z-score > 3
```

For real-time implementation, Random Forest achieves **94.5% F1-score** detecting pump-and-dump events within 25 seconds of startâ€”potentially actionable for exit timing.

### Market regime detection

Hidden Markov Models effectively identify volatility regimes (high/low/crash), enabling dynamic position sizing:

```python
from hmmlearn import hmm

model = hmm.GaussianHMM(n_components=3, covariance_type='full')
model.fit(returns.reshape(-1, 1))

# Regime interpretation
# 0: Low volatility â†’ Trade normally
# 1: High volatility â†’ Reduce position sizes 50%
# 2: Crash regime â†’ Exit positions or short
```

---

## Part 5: What real traders experienced

On-chain data reveals the uncomfortable truth about meme coin trading outcomes.

### The statistical reality

From **13.55 million wallet addresses** that traded on Pump.fun:
- **60% lost money** (Dune Analytics, May 2025)
- **88% either lost money or made less than $100**
- Only **55,296 wallets (0.4%)** profited over $10,000
- Only **293 wallets (0.00217%)** made over $1 million
- **1,700 wallets** lost more than $100,000

The Solana meme coin market follows severe power law distributionâ€”a tiny fraction captures nearly all profits while the majority provides exit liquidity.

### Patterns from successful traders

The rare winners share common characteristics:
1. **Extreme speed**: Using sniping bots (Trojan, BONKbot) for sub-second entry after launch
2. **Early profit-taking**: Selling 50% at 2x to guarantee return of initial capital
3. **Smart money following**: Identifying and tracking profitable wallets via KOLSCAN and Dune Analytics
4. **Small, frequent bets**: Risking 0.5-2 SOL per trade across many opportunities

One documented case: a trader turned **2 SOL into $1 million in 3 hours** during the Gen Z Quant controversyâ€”a 2,141x return representing the extreme right tail of outcomes.

### Common failure patterns

Trader losses cluster around predictable mistakes:
- **FOMO entry after pump**: By the time retail notices, insiders have already bought
- **Holding through reversal**: "Diamond hands" mentality turning gains into losses
- **Copying compromised wallets**: "Farmer wallets" deliberately exploit copy traders
- **Ignoring rug pull signals**: Anonymous teams, unlocked liquidity, concentrated holdings

A crypto influencer publicly shared losing **nearly $1 million** to meme coins after "greed kicked in and I used only max leverage. Left with 460 bucks."

---

## Complete implementation roadmap

### Week 1-2: Infrastructure setup

```bash
# 1. Create dedicated trading wallet (never use main wallet)
# 2. Fund with test amount (0.1 SOL to start)
# 3. Set up development environment

pip install solana solders pandas numpy scikit-learn
npm install @solana/web3.js @raydium-io/raydium-sdk-v2

# 4. Get free API keys
# - Helius: helius.dev
# - Birdeye: birdeye.so (limited free tier)

# 5. Clone reference implementation
git clone https://github.com/chainstacklabs/pumpfun-bonkfun-bot
```

### Week 3-4: Data collection and backtesting

Build your training dataset before deploying capital:
- Collect 3+ months of OHLCV data via GeckoTerminal API
- Scrape Twitter for token mentions (sentiment baseline)
- Record Pump.fun launches and outcomes (graduation rate, price action)
- Implement basic backtesting with `backtesting.py` library

### Month 2: Paper trading and validation

Run the bot in simulation mode:
- Execute 50+ paper trades across different market conditions
- Track win rate, average gain, average loss, maximum drawdown
- Validate that the strategy survives walk-forward testing (not just in-sample)

### Month 3+: Gradual live deployment

Begin with minimal capital (0.1-0.2 SOL):
- Execute real trades with 0.01 SOL position sizes
- Compare live results to backtest expectations
- Scale position sizes only after 30+ profitable trades demonstrate edge

---

## Risk acknowledgment and realistic expectations

**The expected value of meme coin trading is negative for most participants.** The data is unambiguous: 60-90% lose money, and the 0.4% who profit significantly possess advantages in speed, information, and capital that this guide cannot fully replicate.

If you proceed, do so with these principles:

1. **Use only capital you can lose entirely**â€”100% loss is the modal outcome
2. **Treat early attempts as paid education**, not investment
3. **The bot is a tool, not a money printer**â€”no code compensates for unfavorable odds
4. **Take profits aggressively**â€”most tokens die within hours
5. **Study the statistics regularly** to avoid survivorship bias from social media success stories

The APIs work. The code executes. The strategies have internal logic. Whether the mathematics of risk/reward ultimately favors you remains a function of skill, timing, and significant luck. Build the system, run the experiments, and let the dataâ€”not hopeâ€”guide your decisions.
</file>

<file path="debug-api.js">
const https = require('https');

const WALLET = 'GDh3oZJLhCbBXSvVJ97xqbvSwVKERe3P9bsVQ7ayBVdv';
const url = `https://api.helius.xyz/v0/addresses/${WALLET}/transactions?api-key=dd091d8d-f7eb-4d3c-83fc-87cc3232f4f6&limit=50`;

console.log('Fetching:', url);

https.get(url, (res) => {
  let data = '';
  res.on('data', chunk => data += chunk);
  res.on('end', () => {
    console.log('Status:', res.statusCode);
    console.log('Response length:', data.length);

    try {
      const txs = JSON.parse(data);
      console.log('Number of transactions:', txs.length);

      if (txs.length > 0) {
        console.log('\nFirst transaction sample:');
        console.log(JSON.stringify(txs[0], null, 2));
      } else {
        console.log('\nRaw response:', data.substring(0, 500));
      }
    } catch (e) {
      console.log('Parse error:', e.message);
      console.log('Raw:', data.substring(0, 500));
    }
  });
}).on('error', e => console.error('Request error:', e));
</file>

<file path="FLOWCHART.md">
# Trading Bot Flow - AI-Driven Entry System

## High-Level Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           TRADING BOT FLOW                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  PumpPortal  â”‚â”€â”€â”€â–¶â”‚   WATCHLIST  â”‚â”€â”€â”€â–¶â”‚  AI ANALYSIS â”‚â”€â”€â”€â–¶â”‚   TRADE   â”‚ â”‚
â”‚  â”‚   WebSocket  â”‚    â”‚  (Collect    â”‚    â”‚  (DDQN Agent â”‚    â”‚ EXECUTION â”‚ â”‚
â”‚  â”‚              â”‚    â”‚   Data)      â”‚    â”‚   Decision)  â”‚    â”‚           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Detailed Flow

### 1. TOKEN DETECTION (PumpPortal WebSocket)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              NEW TOKEN DETECTED                      â”‚
â”‚                                                      â”‚
â”‚   PumpPortal WS â”€â”€â–¶ newToken event                  â”‚
â”‚        â”‚                                            â”‚
â”‚        â–¼                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ 1. Cache bonding curve data         â”‚          â”‚
â”‚   â”‚ 2. Subscribe to token trades        â”‚          â”‚
â”‚   â”‚ 3. Add to WATCHLIST                 â”‚          â”‚
â”‚   â”‚ 4. Record initial price point       â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                      â”‚
â”‚   OLD: Immediate snipe attempt                      â”‚
â”‚   NEW: Start data collection                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. DATA COLLECTION (Token Watchlist)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    WATCHLIST                         â”‚
â”‚                                                      â”‚
â”‚   For each token, collect:                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ â€¢ Price history (min 10 data points)â”‚          â”‚
â”‚   â”‚ â€¢ Trade data (buys/sells)           â”‚          â”‚
â”‚   â”‚ â€¢ Unique traders count              â”‚          â”‚
â”‚   â”‚ â€¢ Dev wallet activity               â”‚          â”‚
â”‚   â”‚ â€¢ Peak/lowest price                 â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                      â”‚
â”‚   Status progression:                               â”‚
â”‚   COLLECTING â”€â”€â–¶ READY â”€â”€â–¶ ANALYZING â”€â”€â–¶ BOUGHT    â”‚
â”‚        â”‚                        â”‚                   â”‚
â”‚        â””â”€â”€â”€â”€â”€â”€â–¶ REJECTED â—€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. HARD FILTERS (Instant Rejection)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 HARD FILTERS                         â”‚
â”‚         (Check every 5 seconds)                     â”‚
â”‚                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚   â”‚ Token Ready?    â”‚                               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚            â”‚                                        â”‚
â”‚            â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    NO     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ Dev sold?       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ Skip/Wait     â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚            â”‚ NO                                     â”‚
â”‚            â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    NO     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ 10+ data points?â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ Keep          â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚ Collecting    â”‚  â”‚
â”‚            â”‚ YES                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚            â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    YES    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ >30% drawdown?  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ REJECT        â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚ "Crashed"     â”‚  â”‚
â”‚            â”‚ NO                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚            â–¼                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚   â”‚ PASS TO AI      â”‚                               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. AI ANALYSIS (DDQN Agent)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  AI ANALYSIS                         â”‚
â”‚                                                      â”‚
â”‚   Extract Features:                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ â€¢ Price momentum                     â”‚          â”‚
â”‚   â”‚ â€¢ Volatility                         â”‚          â”‚
â”‚   â”‚ â€¢ Drawdown from peak                 â”‚          â”‚
â”‚   â”‚ â€¢ Buy pressure (% buys vs sells)     â”‚          â”‚
â”‚   â”‚ â€¢ Volume trend                       â”‚          â”‚
â”‚   â”‚ â€¢ Token age                          â”‚          â”‚
â”‚   â”‚ â€¢ Unique traders                     â”‚          â”‚
â”‚   â”‚ â€¢ Rug score                          â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚        DDQN Agent Decision          â”‚          â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”       â”‚          â”‚
â”‚   â”‚   â”‚HOLD â”‚  â”‚ BUY â”‚  â”‚ SELL â”‚       â”‚          â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜       â”‚          â”‚
â”‚   â”‚      â”‚        â”‚                     â”‚          â”‚
â”‚   â”‚      â”‚        â–¼                     â”‚          â”‚
â”‚   â”‚      â”‚   Confidence > 70%?          â”‚          â”‚
â”‚   â”‚      â”‚        â”‚                     â”‚          â”‚
â”‚   â”‚      â–¼        â–¼                     â”‚          â”‚
â”‚   â”‚   [SKIP]   [TRADE]                  â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5. TRADE EXECUTION

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               TRADE EXECUTION                        â”‚
â”‚                                                      â”‚
â”‚   Pre-Trade Checks:                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ â€¢ Capital allocation check           â”‚          â”‚
â”‚   â”‚ â€¢ Max positions check                â”‚          â”‚
â”‚   â”‚ â€¢ Daily loss limit check             â”‚          â”‚
â”‚   â”‚ â€¢ Drawdown guard check               â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚        EXECUTE BUY                   â”‚          â”‚
â”‚   â”‚   â€¢ Route to PumpFun (bonding curve) â”‚          â”‚
â”‚   â”‚   â€¢ Or Jupiter (graduated)           â”‚          â”‚
â”‚   â”‚   â€¢ 15% slippage tolerance           â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚        OPEN POSITION                 â”‚          â”‚
â”‚   â”‚   â€¢ Set stop loss: -12%              â”‚          â”‚
â”‚   â”‚   â€¢ Track initial investment         â”‚          â”‚
â”‚   â”‚   â€¢ Start position monitoring        â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6. POSITION MANAGEMENT (New TP Strategy)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            POSITION MONITORING                       â”‚
â”‚              (Every 1 second)                       â”‚
â”‚                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ 1. STOP LOSS CHECK (-12%)           â”‚          â”‚
â”‚   â”‚    If price drops 12% from entry    â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ CLOSE ALL (stop_loss)        â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ 2. TRAILING STOP CHECK              â”‚          â”‚
â”‚   â”‚    If price below trailing stop     â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ CLOSE ALL (trailing_stop)    â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ 3. INITIAL RECOVERY (+50%)          â”‚          â”‚
â”‚   â”‚    If profit >= 50% AND not yet     â”‚          â”‚
â”‚   â”‚    recovered initial:               â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ Sell enough to recover       â”‚          â”‚
â”‚   â”‚        initial investment           â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ Set 15% trailing stop        â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                       â”‚                             â”‚
â”‚                       â–¼                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ 4. SCALED EXITS (+50% intervals)    â”‚          â”‚
â”‚   â”‚    After initial recovered,         â”‚          â”‚
â”‚   â”‚    every +50% gain:                 â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ Sell 20% of remaining        â”‚          â”‚
â”‚   â”‚    â”€â”€â–¶ Update trailing stop         â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Take Profit Example

```
Entry: 0.01 SOL for 1,000,000 tokens

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Price     â”‚ Action                           â”‚ Tokens Left â”‚ SOL Out     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Entry     â”‚ Buy 1M tokens for 0.01 SOL       â”‚ 1,000,000   â”‚ -0.01       â”‚
â”‚  +50%      â”‚ Sell ~666K to recover 0.01 SOL   â”‚   333,333   â”‚  0.01       â”‚
â”‚            â”‚ (Initial recovered!)              â”‚             â”‚             â”‚
â”‚  +100%     â”‚ Sell 20% (66K) = 0.0133 SOL      â”‚   266,667   â”‚  0.0133     â”‚
â”‚  +150%     â”‚ Sell 20% (53K) = 0.0133 SOL      â”‚   213,333   â”‚  0.0133     â”‚
â”‚  +200%     â”‚ Sell 20% (43K) = 0.0172 SOL      â”‚   170,667   â”‚  0.0172     â”‚
â”‚  ...       â”‚ Trailing stop hits at -15%       â”‚      0      â”‚  Rest       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  TOTAL     â”‚ Initial recovered + pure profit  â”‚             â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Comparison: Old vs New

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        OLD SYSTEM                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   New Token â”€â”€â–¶ Velocity Check â”€â”€â–¶ Buy Immediately â”€â”€â–¶ Hope it pumps        â”‚
â”‚                                                                              â”‚
â”‚   Problems:                                                                  â”‚
â”‚   â€¢ Buying tokens with 0 track record                                       â”‚
â”‚   â€¢ 50% stop loss = massive losses                                          â”‚
â”‚   â€¢ Most tokens rug within 1 minute                                         â”‚
â”‚   â€¢ Take profit rarely triggers                                             â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        NEW SYSTEM                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   New Token â”€â”€â–¶ Watchlist â”€â”€â–¶ Collect Data â”€â”€â–¶ Hard Filters â”€â”€â–¶ AI â”€â”€â–¶ Buy  â”‚
â”‚                    â”‚              â”‚                â”‚            â”‚           â”‚
â”‚                    â”‚              â”‚                â”‚            â”‚           â”‚
â”‚              Track trades    10+ points      Dev sold?      High           â”‚
â”‚              Track price                     >30% crash?   confidence      â”‚
â”‚              Track dev                                                      â”‚
â”‚                                                                              â”‚
â”‚   Benefits:                                                                  â”‚
â”‚   â€¢ Only buy proven survivors                                               â”‚
â”‚   â€¢ 12% stop loss = smaller losses                                          â”‚
â”‚   â€¢ Dev dump = instant rejection                                            â”‚
â”‚   â€¢ Recover initial at +50%, then scale out                                 â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Frontend Dashboard

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TOKEN WATCHLIST                          [12 watching] [3 ready] [2 dev]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ BONK...      [READY]                                        2m old  â”‚   â”‚
â”‚  â”‚ Price: +15.2%  Drawdown: -5.1%  Buy Pressure: 72%  Traders: 45     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ABC123...    [COLLECTING]                                   30s old â”‚   â”‚
â”‚  â”‚ [======     ] 6/10 data points                                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ RUGGED...    [REJECTED]                                      1m old â”‚   â”‚
â”‚  â”‚ Reason: Dev sold                                                    â”‚   â”‚
â”‚  â”‚ [! DEV SOLD]                                                        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ CRASH...     [REJECTED]                                      3m old â”‚   â”‚
â”‚  â”‚ Reason: Crashed 45% from peak (max 30%)                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Key Parameters

| Parameter | Old Value | New Value | Reason |
|-----------|-----------|-----------|--------|
| Stop Loss | 50% | 12% | Smaller losses |
| Initial TP | 2x | +50% recover initial | Protect capital |
| Scaled TP | 25% at 2x, 3x | 20% every +50% | Ride winners |
| Trailing Stop | 20% | 15% | Tighter protection |
| Min Data Points | N/A | 10 | Prove token viability |
| Max Drawdown | N/A | 30% | Reject crashed tokens |
| Dev Sold | Not tracked | Instant reject | Avoid rugs |
</file>

<file path="jest.config.js">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.test.ts', '**/*.test.ts'],
  moduleFileExtensions: ['ts', 'js', 'json'],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/index.ts',
  ],
  coverageDirectory: 'coverage',
  verbose: true,
  // Mock environment variables for testing
  setupFiles: ['<rootDir>/src/__tests__/setup.ts'],
  // Increase timeout for async operations
  testTimeout: 10000,
};
</file>

<file path="Procfile">
worker: npm start
</file>

<file path="public/assets/index-B0KwH956.js">
(function(){const u=document.createElement("link").relList;if(u&&u.supports&&u.supports("modulepreload"))return;for(const p of document.querySelectorAll('link[rel="modulepreload"]'))s(p);new MutationObserver(p=>{for(const x of p)if(x.type==="childList")for(const D of x.addedNodes)D.tagName==="LINK"&&D.rel==="modulepreload"&&s(D)}).observe(document,{childList:!0,subtree:!0});function c(p){const x={};return p.integrity&&(x.integrity=p.integrity),p.referrerPolicy&&(x.referrerPolicy=p.referrerPolicy),p.crossOrigin==="use-credentials"?x.credentials="include":p.crossOrigin==="anonymous"?x.credentials="omit":x.credentials="same-origin",x}function s(p){if(p.ep)return;p.ep=!0;const x=c(p);fetch(p.href,x)}})();function fd(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Ts={exports:{}},On={};var kh;function Jy(){if(kh)return On;kh=1;var r=Symbol.for("react.transitional.element"),u=Symbol.for("react.fragment");function c(s,p,x){var D=null;if(x!==void 0&&(D=""+x),p.key!==void 0&&(D=""+p.key),"key"in p){x={};for(var M in p)M!=="key"&&(x[M]=p[M])}else x=p;return p=x.ref,{$$typeof:r,type:s,key:D,ref:p!==void 0?p:null,props:x}}return On.Fragment=u,On.jsx=c,On.jsxs=c,On}var $h;function ky(){return $h||($h=1,Ts.exports=Jy()),Ts.exports}var h=ky(),As={exports:{}},J={};var Wh;function $y(){if(Wh)return J;Wh=1;var r=Symbol.for("react.transitional.element"),u=Symbol.for("react.portal"),c=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),p=Symbol.for("react.profiler"),x=Symbol.for("react.consumer"),D=Symbol.for("react.context"),M=Symbol.for("react.forward_ref"),C=Symbol.for("react.suspense"),z=Symbol.for("react.memo"),G=Symbol.for("react.lazy"),R=Symbol.for("react.activity"),V=Symbol.iterator;function at(d){return d===null||typeof d!="object"?null:(d=V&&d[V]||d["@@iterator"],typeof d=="function"?d:null)}var mt={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},pt=Object.assign,Mt={};function Et(d,E,U){this.props=d,this.context=E,this.refs=Mt,this.updater=U||mt}Et.prototype.isReactComponent={},Et.prototype.setState=function(d,E){if(typeof d!="object"&&typeof d!="function"&&d!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,d,E,"setState")},Et.prototype.forceUpdate=function(d){this.updater.enqueueForceUpdate(this,d,"forceUpdate")};function Kt(){}Kt.prototype=Et.prototype;function bt(d,E,U){this.props=d,this.context=E,this.refs=Mt,this.updater=U||mt}var Jt=bt.prototype=new Kt;Jt.constructor=bt,pt(Jt,Et.prototype),Jt.isPureReactComponent=!0;var Ft=Array.isArray;function Gt(){}var W={H:null,A:null,T:null,S:null},wt=Object.prototype.hasOwnProperty;function ye(d,E,U){var q=U.ref;return{$$typeof:r,type:d,key:E,ref:q!==void 0?q:null,props:U}}function al(d,E){return ye(d.type,E,d.props)}function kt(d){return typeof d=="object"&&d!==null&&d.$$typeof===r}function Vt(d){var E={"=":"=0",":":"=2"};return"$"+d.replace(/[=:]/g,function(U){return E[U]})}var Ye=/\/+/g;function Ne(d,E){return typeof d=="object"&&d!==null&&d.key!=null?Vt(""+d.key):E.toString(36)}function qt(d){switch(d.status){case"fulfilled":return d.value;case"rejected":throw d.reason;default:switch(typeof d.status=="string"?d.then(Gt,Gt):(d.status="pending",d.then(function(E){d.status==="pending"&&(d.status="fulfilled",d.value=E)},function(E){d.status==="pending"&&(d.status="rejected",d.reason=E)})),d.status){case"fulfilled":return d.value;case"rejected":throw d.reason}}throw d}function T(d,E,U,q,K){var Z=typeof d;(Z==="undefined"||Z==="boolean")&&(d=null);var ct=!1;if(d===null)ct=!0;else switch(Z){case"bigint":case"string":case"number":ct=!0;break;case"object":switch(d.$$typeof){case r:case u:ct=!0;break;case G:return ct=d._init,T(ct(d._payload),E,U,q,K)}}if(ct)return K=K(d),ct=q===""?"."+Ne(d,0):q,Ft(K)?(U="",ct!=null&&(U=ct.replace(Ye,"$&/")+"/"),T(K,E,U,"",function(Ua){return Ua})):K!=null&&(kt(K)&&(K=al(K,U+(K.key==null||d&&d.key===K.key?"":(""+K.key).replace(Ye,"$&/")+"/")+ct)),E.push(K)),1;ct=0;var $t=q===""?".":q+":";if(Ft(d))for(var Tt=0;Tt<d.length;Tt++)q=d[Tt],Z=$t+Ne(q,Tt),ct+=T(q,E,U,Z,K);else if(Tt=at(d),typeof Tt=="function")for(d=Tt.call(d),Tt=0;!(q=d.next()).done;)q=q.value,Z=$t+Ne(q,Tt++),ct+=T(q,E,U,Z,K);else if(Z==="object"){if(typeof d.then=="function")return T(qt(d),E,U,q,K);throw E=String(d),Error("Objects are not valid as a React child (found: "+(E==="[object Object]"?"object with keys {"+Object.keys(d).join(", ")+"}":E)+"). If you meant to render a collection of children, use an array instead.")}return ct}function B(d,E,U){if(d==null)return d;var q=[],K=0;return T(d,q,"","",function(Z){return E.call(U,Z,K++)}),q}function X(d){if(d._status===-1){var E=d._result;E=E(),E.then(function(U){(d._status===0||d._status===-1)&&(d._status=1,d._result=U)},function(U){(d._status===0||d._status===-1)&&(d._status=2,d._result=U)}),d._status===-1&&(d._status=0,d._result=E)}if(d._status===1)return d._result.default;throw d._result}var Y=typeof reportError=="function"?reportError:function(d){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var E=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof d=="object"&&d!==null&&typeof d.message=="string"?String(d.message):String(d),error:d});if(!window.dispatchEvent(E))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",d);return}console.error(d)},j={map:B,forEach:function(d,E,U){B(d,function(){E.apply(this,arguments)},U)},count:function(d){var E=0;return B(d,function(){E++}),E},toArray:function(d){return B(d,function(E){return E})||[]},only:function(d){if(!kt(d))throw Error("React.Children.only expected to receive a single React element child.");return d}};return J.Activity=R,J.Children=j,J.Component=Et,J.Fragment=c,J.Profiler=p,J.PureComponent=bt,J.StrictMode=s,J.Suspense=C,J.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=W,J.__COMPILER_RUNTIME={__proto__:null,c:function(d){return W.H.useMemoCache(d)}},J.cache=function(d){return function(){return d.apply(null,arguments)}},J.cacheSignal=function(){return null},J.cloneElement=function(d,E,U){if(d==null)throw Error("The argument must be a React element, but you passed "+d+".");var q=pt({},d.props),K=d.key;if(E!=null)for(Z in E.key!==void 0&&(K=""+E.key),E)!wt.call(E,Z)||Z==="key"||Z==="__self"||Z==="__source"||Z==="ref"&&E.ref===void 0||(q[Z]=E[Z]);var Z=arguments.length-2;if(Z===1)q.children=U;else if(1<Z){for(var ct=Array(Z),$t=0;$t<Z;$t++)ct[$t]=arguments[$t+2];q.children=ct}return ye(d.type,K,q)},J.createContext=function(d){return d={$$typeof:D,_currentValue:d,_currentValue2:d,_threadCount:0,Provider:null,Consumer:null},d.Provider=d,d.Consumer={$$typeof:x,_context:d},d},J.createElement=function(d,E,U){var q,K={},Z=null;if(E!=null)for(q in E.key!==void 0&&(Z=""+E.key),E)wt.call(E,q)&&q!=="key"&&q!=="__self"&&q!=="__source"&&(K[q]=E[q]);var ct=arguments.length-2;if(ct===1)K.children=U;else if(1<ct){for(var $t=Array(ct),Tt=0;Tt<ct;Tt++)$t[Tt]=arguments[Tt+2];K.children=$t}if(d&&d.defaultProps)for(q in ct=d.defaultProps,ct)K[q]===void 0&&(K[q]=ct[q]);return ye(d,Z,K)},J.createRef=function(){return{current:null}},J.forwardRef=function(d){return{$$typeof:M,render:d}},J.isValidElement=kt,J.lazy=function(d){return{$$typeof:G,_payload:{_status:-1,_result:d},_init:X}},J.memo=function(d,E){return{$$typeof:z,type:d,compare:E===void 0?null:E}},J.startTransition=function(d){var E=W.T,U={};W.T=U;try{var q=d(),K=W.S;K!==null&&K(U,q),typeof q=="object"&&q!==null&&typeof q.then=="function"&&q.then(Gt,Y)}catch(Z){Y(Z)}finally{E!==null&&U.types!==null&&(E.types=U.types),W.T=E}},J.unstable_useCacheRefresh=function(){return W.H.useCacheRefresh()},J.use=function(d){return W.H.use(d)},J.useActionState=function(d,E,U){return W.H.useActionState(d,E,U)},J.useCallback=function(d,E){return W.H.useCallback(d,E)},J.useContext=function(d){return W.H.useContext(d)},J.useDebugValue=function(){},J.useDeferredValue=function(d,E){return W.H.useDeferredValue(d,E)},J.useEffect=function(d,E){return W.H.useEffect(d,E)},J.useEffectEvent=function(d){return W.H.useEffectEvent(d)},J.useId=function(){return W.H.useId()},J.useImperativeHandle=function(d,E,U){return W.H.useImperativeHandle(d,E,U)},J.useInsertionEffect=function(d,E){return W.H.useInsertionEffect(d,E)},J.useLayoutEffect=function(d,E){return W.H.useLayoutEffect(d,E)},J.useMemo=function(d,E){return W.H.useMemo(d,E)},J.useOptimistic=function(d,E){return W.H.useOptimistic(d,E)},J.useReducer=function(d,E,U){return W.H.useReducer(d,E,U)},J.useRef=function(d){return W.H.useRef(d)},J.useState=function(d){return W.H.useState(d)},J.useSyncExternalStore=function(d,E,U){return W.H.useSyncExternalStore(d,E,U)},J.useTransition=function(){return W.H.useTransition()},J.version="19.2.3",J}var Fh;function Ls(){return Fh||(Fh=1,As.exports=$y()),As.exports}var st=Ls();const Wy=fd(st);var zs={exports:{}},jn={},Ns={exports:{}},Os={};var Ih;function Fy(){return Ih||(Ih=1,(function(r){function u(T,B){var X=T.length;T.push(B);t:for(;0<X;){var Y=X-1>>>1,j=T[Y];if(0<p(j,B))T[Y]=B,T[X]=j,X=Y;else break t}}function c(T){return T.length===0?null:T[0]}function s(T){if(T.length===0)return null;var B=T[0],X=T.pop();if(X!==B){T[0]=X;t:for(var Y=0,j=T.length,d=j>>>1;Y<d;){var E=2*(Y+1)-1,U=T[E],q=E+1,K=T[q];if(0>p(U,X))q<j&&0>p(K,U)?(T[Y]=K,T[q]=X,Y=q):(T[Y]=U,T[E]=X,Y=E);else if(q<j&&0>p(K,X))T[Y]=K,T[q]=X,Y=q;else break t}}return B}function p(T,B){var X=T.sortIndex-B.sortIndex;return X!==0?X:T.id-B.id}if(r.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var x=performance;r.unstable_now=function(){return x.now()}}else{var D=Date,M=D.now();r.unstable_now=function(){return D.now()-M}}var C=[],z=[],G=1,R=null,V=3,at=!1,mt=!1,pt=!1,Mt=!1,Et=typeof setTimeout=="function"?setTimeout:null,Kt=typeof clearTimeout=="function"?clearTimeout:null,bt=typeof setImmediate<"u"?setImmediate:null;function Jt(T){for(var B=c(z);B!==null;){if(B.callback===null)s(z);else if(B.startTime<=T)s(z),B.sortIndex=B.expirationTime,u(C,B);else break;B=c(z)}}function Ft(T){if(pt=!1,Jt(T),!mt)if(c(C)!==null)mt=!0,Gt||(Gt=!0,Vt());else{var B=c(z);B!==null&&qt(Ft,B.startTime-T)}}var Gt=!1,W=-1,wt=5,ye=-1;function al(){return Mt?!0:!(r.unstable_now()-ye<wt)}function kt(){if(Mt=!1,Gt){var T=r.unstable_now();ye=T;var B=!0;try{t:{mt=!1,pt&&(pt=!1,Kt(W),W=-1),at=!0;var X=V;try{e:{for(Jt(T),R=c(C);R!==null&&!(R.expirationTime>T&&al());){var Y=R.callback;if(typeof Y=="function"){R.callback=null,V=R.priorityLevel;var j=Y(R.expirationTime<=T);if(T=r.unstable_now(),typeof j=="function"){R.callback=j,Jt(T),B=!0;break e}R===c(C)&&s(C),Jt(T)}else s(C);R=c(C)}if(R!==null)B=!0;else{var d=c(z);d!==null&&qt(Ft,d.startTime-T),B=!1}}break t}finally{R=null,V=X,at=!1}B=void 0}}finally{B?Vt():Gt=!1}}}var Vt;if(typeof bt=="function")Vt=function(){bt(kt)};else if(typeof MessageChannel<"u"){var Ye=new MessageChannel,Ne=Ye.port2;Ye.port1.onmessage=kt,Vt=function(){Ne.postMessage(null)}}else Vt=function(){Et(kt,0)};function qt(T,B){W=Et(function(){T(r.unstable_now())},B)}r.unstable_IdlePriority=5,r.unstable_ImmediatePriority=1,r.unstable_LowPriority=4,r.unstable_NormalPriority=3,r.unstable_Profiling=null,r.unstable_UserBlockingPriority=2,r.unstable_cancelCallback=function(T){T.callback=null},r.unstable_forceFrameRate=function(T){0>T||125<T?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):wt=0<T?Math.floor(1e3/T):5},r.unstable_getCurrentPriorityLevel=function(){return V},r.unstable_next=function(T){switch(V){case 1:case 2:case 3:var B=3;break;default:B=V}var X=V;V=B;try{return T()}finally{V=X}},r.unstable_requestPaint=function(){Mt=!0},r.unstable_runWithPriority=function(T,B){switch(T){case 1:case 2:case 3:case 4:case 5:break;default:T=3}var X=V;V=T;try{return B()}finally{V=X}},r.unstable_scheduleCallback=function(T,B,X){var Y=r.unstable_now();switch(typeof X=="object"&&X!==null?(X=X.delay,X=typeof X=="number"&&0<X?Y+X:Y):X=Y,T){case 1:var j=-1;break;case 2:j=250;break;case 5:j=1073741823;break;case 4:j=1e4;break;default:j=5e3}return j=X+j,T={id:G++,callback:B,priorityLevel:T,startTime:X,expirationTime:j,sortIndex:-1},X>Y?(T.sortIndex=X,u(z,T),c(C)===null&&T===c(z)&&(pt?(Kt(W),W=-1):pt=!0,qt(Ft,X-Y))):(T.sortIndex=j,u(C,T),mt||at||(mt=!0,Gt||(Gt=!0,Vt()))),T},r.unstable_shouldYield=al,r.unstable_wrapCallback=function(T){var B=V;return function(){var X=V;V=B;try{return T.apply(this,arguments)}finally{V=X}}}})(Os)),Os}var Ph;function Iy(){return Ph||(Ph=1,Ns.exports=Fy()),Ns.exports}var js={exports:{}},Zt={};var td;function Py(){if(td)return Zt;td=1;var r=Ls();function u(C){var z="https://react.dev/errors/"+C;if(1<arguments.length){z+="?args[]="+encodeURIComponent(arguments[1]);for(var G=2;G<arguments.length;G++)z+="&args[]="+encodeURIComponent(arguments[G])}return"Minified React error #"+C+"; visit "+z+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function c(){}var s={d:{f:c,r:function(){throw Error(u(522))},D:c,C:c,L:c,m:c,X:c,S:c,M:c},p:0,findDOMNode:null},p=Symbol.for("react.portal");function x(C,z,G){var R=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:p,key:R==null?null:""+R,children:C,containerInfo:z,implementation:G}}var D=r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function M(C,z){if(C==="font")return"";if(typeof z=="string")return z==="use-credentials"?z:""}return Zt.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,Zt.createPortal=function(C,z){var G=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!z||z.nodeType!==1&&z.nodeType!==9&&z.nodeType!==11)throw Error(u(299));return x(C,z,null,G)},Zt.flushSync=function(C){var z=D.T,G=s.p;try{if(D.T=null,s.p=2,C)return C()}finally{D.T=z,s.p=G,s.d.f()}},Zt.preconnect=function(C,z){typeof C=="string"&&(z?(z=z.crossOrigin,z=typeof z=="string"?z==="use-credentials"?z:"":void 0):z=null,s.d.C(C,z))},Zt.prefetchDNS=function(C){typeof C=="string"&&s.d.D(C)},Zt.preinit=function(C,z){if(typeof C=="string"&&z&&typeof z.as=="string"){var G=z.as,R=M(G,z.crossOrigin),V=typeof z.integrity=="string"?z.integrity:void 0,at=typeof z.fetchPriority=="string"?z.fetchPriority:void 0;G==="style"?s.d.S(C,typeof z.precedence=="string"?z.precedence:void 0,{crossOrigin:R,integrity:V,fetchPriority:at}):G==="script"&&s.d.X(C,{crossOrigin:R,integrity:V,fetchPriority:at,nonce:typeof z.nonce=="string"?z.nonce:void 0})}},Zt.preinitModule=function(C,z){if(typeof C=="string")if(typeof z=="object"&&z!==null){if(z.as==null||z.as==="script"){var G=M(z.as,z.crossOrigin);s.d.M(C,{crossOrigin:G,integrity:typeof z.integrity=="string"?z.integrity:void 0,nonce:typeof z.nonce=="string"?z.nonce:void 0})}}else z==null&&s.d.M(C)},Zt.preload=function(C,z){if(typeof C=="string"&&typeof z=="object"&&z!==null&&typeof z.as=="string"){var G=z.as,R=M(G,z.crossOrigin);s.d.L(C,G,{crossOrigin:R,integrity:typeof z.integrity=="string"?z.integrity:void 0,nonce:typeof z.nonce=="string"?z.nonce:void 0,type:typeof z.type=="string"?z.type:void 0,fetchPriority:typeof z.fetchPriority=="string"?z.fetchPriority:void 0,referrerPolicy:typeof z.referrerPolicy=="string"?z.referrerPolicy:void 0,imageSrcSet:typeof z.imageSrcSet=="string"?z.imageSrcSet:void 0,imageSizes:typeof z.imageSizes=="string"?z.imageSizes:void 0,media:typeof z.media=="string"?z.media:void 0})}},Zt.preloadModule=function(C,z){if(typeof C=="string")if(z){var G=M(z.as,z.crossOrigin);s.d.m(C,{as:typeof z.as=="string"&&z.as!=="script"?z.as:void 0,crossOrigin:G,integrity:typeof z.integrity=="string"?z.integrity:void 0})}else s.d.m(C)},Zt.requestFormReset=function(C){s.d.r(C)},Zt.unstable_batchedUpdates=function(C,z){return C(z)},Zt.useFormState=function(C,z,G){return D.H.useFormState(C,z,G)},Zt.useFormStatus=function(){return D.H.useHostTransitionStatus()},Zt.version="19.2.3",Zt}var ed;function t0(){if(ed)return js.exports;ed=1;function r(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r)}catch(u){console.error(u)}}return r(),js.exports=Py(),js.exports}var ld;function e0(){if(ld)return jn;ld=1;var r=Iy(),u=Ls(),c=t0();function s(t){var e="https://react.dev/errors/"+t;if(1<arguments.length){e+="?args[]="+encodeURIComponent(arguments[1]);for(var l=2;l<arguments.length;l++)e+="&args[]="+encodeURIComponent(arguments[l])}return"Minified React error #"+t+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function p(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11)}function x(t){var e=t,l=t;if(t.alternate)for(;e.return;)e=e.return;else{t=e;do e=t,(e.flags&4098)!==0&&(l=e.return),t=e.return;while(t)}return e.tag===3?l:null}function D(t){if(t.tag===13){var e=t.memoizedState;if(e===null&&(t=t.alternate,t!==null&&(e=t.memoizedState)),e!==null)return e.dehydrated}return null}function M(t){if(t.tag===31){var e=t.memoizedState;if(e===null&&(t=t.alternate,t!==null&&(e=t.memoizedState)),e!==null)return e.dehydrated}return null}function C(t){if(x(t)!==t)throw Error(s(188))}function z(t){var e=t.alternate;if(!e){if(e=x(t),e===null)throw Error(s(188));return e!==t?null:t}for(var l=t,a=e;;){var n=l.return;if(n===null)break;var i=n.alternate;if(i===null){if(a=n.return,a!==null){l=a;continue}break}if(n.child===i.child){for(i=n.child;i;){if(i===l)return C(n),t;if(i===a)return C(n),e;i=i.sibling}throw Error(s(188))}if(l.return!==a.return)l=n,a=i;else{for(var f=!1,o=n.child;o;){if(o===l){f=!0,l=n,a=i;break}if(o===a){f=!0,a=n,l=i;break}o=o.sibling}if(!f){for(o=i.child;o;){if(o===l){f=!0,l=i,a=n;break}if(o===a){f=!0,a=i,l=n;break}o=o.sibling}if(!f)throw Error(s(189))}}if(l.alternate!==a)throw Error(s(190))}if(l.tag!==3)throw Error(s(188));return l.stateNode.current===l?t:e}function G(t){var e=t.tag;if(e===5||e===26||e===27||e===6)return t;for(t=t.child;t!==null;){if(e=G(t),e!==null)return e;t=t.sibling}return null}var R=Object.assign,V=Symbol.for("react.element"),at=Symbol.for("react.transitional.element"),mt=Symbol.for("react.portal"),pt=Symbol.for("react.fragment"),Mt=Symbol.for("react.strict_mode"),Et=Symbol.for("react.profiler"),Kt=Symbol.for("react.consumer"),bt=Symbol.for("react.context"),Jt=Symbol.for("react.forward_ref"),Ft=Symbol.for("react.suspense"),Gt=Symbol.for("react.suspense_list"),W=Symbol.for("react.memo"),wt=Symbol.for("react.lazy"),ye=Symbol.for("react.activity"),al=Symbol.for("react.memo_cache_sentinel"),kt=Symbol.iterator;function Vt(t){return t===null||typeof t!="object"?null:(t=kt&&t[kt]||t["@@iterator"],typeof t=="function"?t:null)}var Ye=Symbol.for("react.client.reference");function Ne(t){if(t==null)return null;if(typeof t=="function")return t.$$typeof===Ye?null:t.displayName||t.name||null;if(typeof t=="string")return t;switch(t){case pt:return"Fragment";case Et:return"Profiler";case Mt:return"StrictMode";case Ft:return"Suspense";case Gt:return"SuspenseList";case ye:return"Activity"}if(typeof t=="object")switch(t.$$typeof){case mt:return"Portal";case bt:return t.displayName||"Context";case Kt:return(t._context.displayName||"Context")+".Consumer";case Jt:var e=t.render;return t=t.displayName,t||(t=e.displayName||e.name||"",t=t!==""?"ForwardRef("+t+")":"ForwardRef"),t;case W:return e=t.displayName||null,e!==null?e:Ne(t.type)||"Memo";case wt:e=t._payload,t=t._init;try{return Ne(t(e))}catch{}}return null}var qt=Array.isArray,T=u.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,B=c.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,X={pending:!1,data:null,method:null,action:null},Y=[],j=-1;function d(t){return{current:t}}function E(t){0>j||(t.current=Y[j],Y[j]=null,j--)}function U(t,e){j++,Y[j]=t.current,t.current=e}var q=d(null),K=d(null),Z=d(null),ct=d(null);function $t(t,e){switch(U(Z,e),U(K,t),U(q,null),e.nodeType){case 9:case 11:t=(t=e.documentElement)&&(t=t.namespaceURI)?vh(t):0;break;default:if(t=e.tagName,e=e.namespaceURI)e=vh(e),t=gh(e,t);else switch(t){case"svg":t=1;break;case"math":t=2;break;default:t=0}}E(q),U(q,t)}function Tt(){E(q),E(K),E(Z)}function Ua(t){t.memoizedState!==null&&U(ct,t);var e=q.current,l=gh(e,t.type);e!==l&&(U(K,t),U(q,l))}function Mn(t){K.current===t&&(E(q),E(K)),ct.current===t&&(E(ct),Tn._currentValue=X)}var uu,Zs;function Cl(t){if(uu===void 0)try{throw Error()}catch(l){var e=l.stack.trim().match(/\n( *(at )?)/);uu=e&&e[1]||"",Zs=-1<l.stack.indexOf(`
    at`)?" (<anonymous>)":-1<l.stack.indexOf("@")?"@unknown:0:0":""}return`
`+uu+t+Zs}var cu=!1;function su(t,e){if(!t||cu)return"";cu=!0;var l=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var a={DetermineComponentFrameRoot:function(){try{if(e){var O=function(){throw Error()};if(Object.defineProperty(O.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(O,[])}catch(_){var b=_}Reflect.construct(t,[],O)}else{try{O.call()}catch(_){b=_}t.call(O.prototype)}}else{try{throw Error()}catch(_){b=_}(O=t())&&typeof O.catch=="function"&&O.catch(function(){})}}catch(_){if(_&&b&&typeof _.stack=="string")return[_.stack,b.stack]}return[null,null]}};a.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var n=Object.getOwnPropertyDescriptor(a.DetermineComponentFrameRoot,"name");n&&n.configurable&&Object.defineProperty(a.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var i=a.DetermineComponentFrameRoot(),f=i[0],o=i[1];if(f&&o){var m=f.split(`
`),S=o.split(`
`);for(n=a=0;a<m.length&&!m[a].includes("DetermineComponentFrameRoot");)a++;for(;n<S.length&&!S[n].includes("DetermineComponentFrameRoot");)n++;if(a===m.length||n===S.length)for(a=m.length-1,n=S.length-1;1<=a&&0<=n&&m[a]!==S[n];)n--;for(;1<=a&&0<=n;a--,n--)if(m[a]!==S[n]){if(a!==1||n!==1)do if(a--,n--,0>n||m[a]!==S[n]){var A=`
`+m[a].replace(" at new "," at ");return t.displayName&&A.includes("<anonymous>")&&(A=A.replace("<anonymous>",t.displayName)),A}while(1<=a&&0<=n);break}}}finally{cu=!1,Error.prepareStackTrace=l}return(l=t?t.displayName||t.name:"")?Cl(l):""}function Td(t,e){switch(t.tag){case 26:case 27:case 5:return Cl(t.type);case 16:return Cl("Lazy");case 13:return t.child!==e&&e!==null?Cl("Suspense Fallback"):Cl("Suspense");case 19:return Cl("SuspenseList");case 0:case 15:return su(t.type,!1);case 11:return su(t.type.render,!1);case 1:return su(t.type,!0);case 31:return Cl("Activity");default:return""}}function Ks(t){try{var e="",l=null;do e+=Td(t,l),l=t,t=t.return;while(t);return e}catch(a){return`
Error generating stack: `+a.message+`
`+a.stack}}var fu=Object.prototype.hasOwnProperty,ru=r.unstable_scheduleCallback,ou=r.unstable_cancelCallback,Ad=r.unstable_shouldYield,zd=r.unstable_requestPaint,ie=r.unstable_now,Nd=r.unstable_getCurrentPriorityLevel,Js=r.unstable_ImmediatePriority,ks=r.unstable_UserBlockingPriority,Rn=r.unstable_NormalPriority,Od=r.unstable_LowPriority,$s=r.unstable_IdlePriority,jd=r.log,Cd=r.unstable_setDisableYieldValue,Ba=null,ue=null;function nl(t){if(typeof jd=="function"&&Cd(t),ue&&typeof ue.setStrictMode=="function")try{ue.setStrictMode(Ba,t)}catch{}}var ce=Math.clz32?Math.clz32:Rd,Dd=Math.log,Md=Math.LN2;function Rd(t){return t>>>=0,t===0?32:31-(Dd(t)/Md|0)|0}var Un=256,Bn=262144,qn=4194304;function Dl(t){var e=t&42;if(e!==0)return e;switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return t&261888;case 262144:case 524288:case 1048576:case 2097152:return t&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return t&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return t}}function Hn(t,e,l){var a=t.pendingLanes;if(a===0)return 0;var n=0,i=t.suspendedLanes,f=t.pingedLanes;t=t.warmLanes;var o=a&134217727;return o!==0?(a=o&~i,a!==0?n=Dl(a):(f&=o,f!==0?n=Dl(f):l||(l=o&~t,l!==0&&(n=Dl(l))))):(o=a&~i,o!==0?n=Dl(o):f!==0?n=Dl(f):l||(l=a&~t,l!==0&&(n=Dl(l)))),n===0?0:e!==0&&e!==n&&(e&i)===0&&(i=n&-n,l=e&-e,i>=l||i===32&&(l&4194048)!==0)?e:n}function qa(t,e){return(t.pendingLanes&~(t.suspendedLanes&~t.pingedLanes)&e)===0}function Ud(t,e){switch(t){case 1:case 2:case 4:case 8:case 64:return e+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Ws(){var t=qn;return qn<<=1,(qn&62914560)===0&&(qn=4194304),t}function hu(t){for(var e=[],l=0;31>l;l++)e.push(t);return e}function Ha(t,e){t.pendingLanes|=e,e!==268435456&&(t.suspendedLanes=0,t.pingedLanes=0,t.warmLanes=0)}function Bd(t,e,l,a,n,i){var f=t.pendingLanes;t.pendingLanes=l,t.suspendedLanes=0,t.pingedLanes=0,t.warmLanes=0,t.expiredLanes&=l,t.entangledLanes&=l,t.errorRecoveryDisabledLanes&=l,t.shellSuspendCounter=0;var o=t.entanglements,m=t.expirationTimes,S=t.hiddenUpdates;for(l=f&~l;0<l;){var A=31-ce(l),O=1<<A;o[A]=0,m[A]=-1;var b=S[A];if(b!==null)for(S[A]=null,A=0;A<b.length;A++){var _=b[A];_!==null&&(_.lane&=-536870913)}l&=~O}a!==0&&Fs(t,a,0),i!==0&&n===0&&t.tag!==0&&(t.suspendedLanes|=i&~(f&~e))}function Fs(t,e,l){t.pendingLanes|=e,t.suspendedLanes&=~e;var a=31-ce(e);t.entangledLanes|=e,t.entanglements[a]=t.entanglements[a]|1073741824|l&261930}function Is(t,e){var l=t.entangledLanes|=e;for(t=t.entanglements;l;){var a=31-ce(l),n=1<<a;n&e|t[a]&e&&(t[a]|=e),l&=~n}}function Ps(t,e){var l=e&-e;return l=(l&42)!==0?1:du(l),(l&(t.suspendedLanes|e))!==0?0:l}function du(t){switch(t){case 2:t=1;break;case 8:t=4;break;case 32:t=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:t=128;break;case 268435456:t=134217728;break;default:t=0}return t}function mu(t){return t&=-t,2<t?8<t?(t&134217727)!==0?32:268435456:8:2}function tf(){var t=B.p;return t!==0?t:(t=window.event,t===void 0?32:Qh(t.type))}function ef(t,e){var l=B.p;try{return B.p=t,e()}finally{B.p=l}}var il=Math.random().toString(36).slice(2),Ht="__reactFiber$"+il,It="__reactProps$"+il,$l="__reactContainer$"+il,yu="__reactEvents$"+il,qd="__reactListeners$"+il,Hd="__reactHandles$"+il,lf="__reactResources$"+il,Ya="__reactMarker$"+il;function pu(t){delete t[Ht],delete t[It],delete t[yu],delete t[qd],delete t[Hd]}function Wl(t){var e=t[Ht];if(e)return e;for(var l=t.parentNode;l;){if(e=l[$l]||l[Ht]){if(l=e.alternate,e.child!==null||l!==null&&l.child!==null)for(t=Ah(t);t!==null;){if(l=t[Ht])return l;t=Ah(t)}return e}t=l,l=t.parentNode}return null}function Fl(t){if(t=t[Ht]||t[$l]){var e=t.tag;if(e===5||e===6||e===13||e===31||e===26||e===27||e===3)return t}return null}function La(t){var e=t.tag;if(e===5||e===26||e===27||e===6)return t.stateNode;throw Error(s(33))}function Il(t){var e=t[lf];return e||(e=t[lf]={hoistableStyles:new Map,hoistableScripts:new Map}),e}function Ut(t){t[Ya]=!0}var af=new Set,nf={};function Ml(t,e){Pl(t,e),Pl(t+"Capture",e)}function Pl(t,e){for(nf[t]=e,t=0;t<e.length;t++)af.add(e[t])}var Yd=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),uf={},cf={};function Ld(t){return fu.call(cf,t)?!0:fu.call(uf,t)?!1:Yd.test(t)?cf[t]=!0:(uf[t]=!0,!1)}function Yn(t,e,l){if(Ld(e))if(l===null)t.removeAttribute(e);else{switch(typeof l){case"undefined":case"function":case"symbol":t.removeAttribute(e);return;case"boolean":var a=e.toLowerCase().slice(0,5);if(a!=="data-"&&a!=="aria-"){t.removeAttribute(e);return}}t.setAttribute(e,""+l)}}function Ln(t,e,l){if(l===null)t.removeAttribute(e);else{switch(typeof l){case"undefined":case"function":case"symbol":case"boolean":t.removeAttribute(e);return}t.setAttribute(e,""+l)}}function Le(t,e,l,a){if(a===null)t.removeAttribute(l);else{switch(typeof a){case"undefined":case"function":case"symbol":case"boolean":t.removeAttribute(l);return}t.setAttributeNS(e,l,""+a)}}function pe(t){switch(typeof t){case"bigint":case"boolean":case"number":case"string":case"undefined":return t;case"object":return t;default:return""}}function sf(t){var e=t.type;return(t=t.nodeName)&&t.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function Xd(t,e,l){var a=Object.getOwnPropertyDescriptor(t.constructor.prototype,e);if(!t.hasOwnProperty(e)&&typeof a<"u"&&typeof a.get=="function"&&typeof a.set=="function"){var n=a.get,i=a.set;return Object.defineProperty(t,e,{configurable:!0,get:function(){return n.call(this)},set:function(f){l=""+f,i.call(this,f)}}),Object.defineProperty(t,e,{enumerable:a.enumerable}),{getValue:function(){return l},setValue:function(f){l=""+f},stopTracking:function(){t._valueTracker=null,delete t[e]}}}}function vu(t){if(!t._valueTracker){var e=sf(t)?"checked":"value";t._valueTracker=Xd(t,e,""+t[e])}}function ff(t){if(!t)return!1;var e=t._valueTracker;if(!e)return!0;var l=e.getValue(),a="";return t&&(a=sf(t)?t.checked?"true":"false":t.value),t=a,t!==l?(e.setValue(t),!0):!1}function Xn(t){if(t=t||(typeof document<"u"?document:void 0),typeof t>"u")return null;try{return t.activeElement||t.body}catch{return t.body}}var Qd=/[\n"\\]/g;function ve(t){return t.replace(Qd,function(e){return"\\"+e.charCodeAt(0).toString(16)+" "})}function gu(t,e,l,a,n,i,f,o){t.name="",f!=null&&typeof f!="function"&&typeof f!="symbol"&&typeof f!="boolean"?t.type=f:t.removeAttribute("type"),e!=null?f==="number"?(e===0&&t.value===""||t.value!=e)&&(t.value=""+pe(e)):t.value!==""+pe(e)&&(t.value=""+pe(e)):f!=="submit"&&f!=="reset"||t.removeAttribute("value"),e!=null?Su(t,f,pe(e)):l!=null?Su(t,f,pe(l)):a!=null&&t.removeAttribute("value"),n==null&&i!=null&&(t.defaultChecked=!!i),n!=null&&(t.checked=n&&typeof n!="function"&&typeof n!="symbol"),o!=null&&typeof o!="function"&&typeof o!="symbol"&&typeof o!="boolean"?t.name=""+pe(o):t.removeAttribute("name")}function rf(t,e,l,a,n,i,f,o){if(i!=null&&typeof i!="function"&&typeof i!="symbol"&&typeof i!="boolean"&&(t.type=i),e!=null||l!=null){if(!(i!=="submit"&&i!=="reset"||e!=null)){vu(t);return}l=l!=null?""+pe(l):"",e=e!=null?""+pe(e):l,o||e===t.value||(t.value=e),t.defaultValue=e}a=a??n,a=typeof a!="function"&&typeof a!="symbol"&&!!a,t.checked=o?t.checked:!!a,t.defaultChecked=!!a,f!=null&&typeof f!="function"&&typeof f!="symbol"&&typeof f!="boolean"&&(t.name=f),vu(t)}function Su(t,e,l){e==="number"&&Xn(t.ownerDocument)===t||t.defaultValue===""+l||(t.defaultValue=""+l)}function ta(t,e,l,a){if(t=t.options,e){e={};for(var n=0;n<l.length;n++)e["$"+l[n]]=!0;for(l=0;l<t.length;l++)n=e.hasOwnProperty("$"+t[l].value),t[l].selected!==n&&(t[l].selected=n),n&&a&&(t[l].defaultSelected=!0)}else{for(l=""+pe(l),e=null,n=0;n<t.length;n++){if(t[n].value===l){t[n].selected=!0,a&&(t[n].defaultSelected=!0);return}e!==null||t[n].disabled||(e=t[n])}e!==null&&(e.selected=!0)}}function of(t,e,l){if(e!=null&&(e=""+pe(e),e!==t.value&&(t.value=e),l==null)){t.defaultValue!==e&&(t.defaultValue=e);return}t.defaultValue=l!=null?""+pe(l):""}function hf(t,e,l,a){if(e==null){if(a!=null){if(l!=null)throw Error(s(92));if(qt(a)){if(1<a.length)throw Error(s(93));a=a[0]}l=a}l==null&&(l=""),e=l}l=pe(e),t.defaultValue=l,a=t.textContent,a===l&&a!==""&&a!==null&&(t.value=a),vu(t)}function ea(t,e){if(e){var l=t.firstChild;if(l&&l===t.lastChild&&l.nodeType===3){l.nodeValue=e;return}}t.textContent=e}var Gd=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function df(t,e,l){var a=e.indexOf("--")===0;l==null||typeof l=="boolean"||l===""?a?t.setProperty(e,""):e==="float"?t.cssFloat="":t[e]="":a?t.setProperty(e,l):typeof l!="number"||l===0||Gd.has(e)?e==="float"?t.cssFloat=l:t[e]=(""+l).trim():t[e]=l+"px"}function mf(t,e,l){if(e!=null&&typeof e!="object")throw Error(s(62));if(t=t.style,l!=null){for(var a in l)!l.hasOwnProperty(a)||e!=null&&e.hasOwnProperty(a)||(a.indexOf("--")===0?t.setProperty(a,""):a==="float"?t.cssFloat="":t[a]="");for(var n in e)a=e[n],e.hasOwnProperty(n)&&l[n]!==a&&df(t,n,a)}else for(var i in e)e.hasOwnProperty(i)&&df(t,i,e[i])}function bu(t){if(t.indexOf("-")===-1)return!1;switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wd=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Vd=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Qn(t){return Vd.test(""+t)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":t}function Xe(){}var xu=null;function _u(t){return t=t.target||t.srcElement||window,t.correspondingUseElement&&(t=t.correspondingUseElement),t.nodeType===3?t.parentNode:t}var la=null,aa=null;function yf(t){var e=Fl(t);if(e&&(t=e.stateNode)){var l=t[It]||null;t:switch(t=e.stateNode,e.type){case"input":if(gu(t,l.value,l.defaultValue,l.defaultValue,l.checked,l.defaultChecked,l.type,l.name),e=l.name,l.type==="radio"&&e!=null){for(l=t;l.parentNode;)l=l.parentNode;for(l=l.querySelectorAll('input[name="'+ve(""+e)+'"][type="radio"]'),e=0;e<l.length;e++){var a=l[e];if(a!==t&&a.form===t.form){var n=a[It]||null;if(!n)throw Error(s(90));gu(a,n.value,n.defaultValue,n.defaultValue,n.checked,n.defaultChecked,n.type,n.name)}}for(e=0;e<l.length;e++)a=l[e],a.form===t.form&&ff(a)}break t;case"textarea":of(t,l.value,l.defaultValue);break t;case"select":e=l.value,e!=null&&ta(t,!!l.multiple,e,!1)}}}var Eu=!1;function pf(t,e,l){if(Eu)return t(e,l);Eu=!0;try{var a=t(e);return a}finally{if(Eu=!1,(la!==null||aa!==null)&&(Oi(),la&&(e=la,t=aa,aa=la=null,yf(e),t)))for(e=0;e<t.length;e++)yf(t[e])}}function Xa(t,e){var l=t.stateNode;if(l===null)return null;var a=l[It]||null;if(a===null)return null;l=a[e];t:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(t=t.type,a=!(t==="button"||t==="input"||t==="select"||t==="textarea")),t=!a;break t;default:t=!1}if(t)return null;if(l&&typeof l!="function")throw Error(s(231,e,typeof l));return l}var Qe=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Tu=!1;if(Qe)try{var Qa={};Object.defineProperty(Qa,"passive",{get:function(){Tu=!0}}),window.addEventListener("test",Qa,Qa),window.removeEventListener("test",Qa,Qa)}catch{Tu=!1}var ul=null,Au=null,Gn=null;function vf(){if(Gn)return Gn;var t,e=Au,l=e.length,a,n="value"in ul?ul.value:ul.textContent,i=n.length;for(t=0;t<l&&e[t]===n[t];t++);var f=l-t;for(a=1;a<=f&&e[l-a]===n[i-a];a++);return Gn=n.slice(t,1<a?1-a:void 0)}function wn(t){var e=t.keyCode;return"charCode"in t?(t=t.charCode,t===0&&e===13&&(t=13)):t=e,t===10&&(t=13),32<=t||t===13?t:0}function Vn(){return!0}function gf(){return!1}function Pt(t){function e(l,a,n,i,f){this._reactName=l,this._targetInst=n,this.type=a,this.nativeEvent=i,this.target=f,this.currentTarget=null;for(var o in t)t.hasOwnProperty(o)&&(l=t[o],this[o]=l?l(i):i[o]);return this.isDefaultPrevented=(i.defaultPrevented!=null?i.defaultPrevented:i.returnValue===!1)?Vn:gf,this.isPropagationStopped=gf,this}return R(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var l=this.nativeEvent;l&&(l.preventDefault?l.preventDefault():typeof l.returnValue!="unknown"&&(l.returnValue=!1),this.isDefaultPrevented=Vn)},stopPropagation:function(){var l=this.nativeEvent;l&&(l.stopPropagation?l.stopPropagation():typeof l.cancelBubble!="unknown"&&(l.cancelBubble=!0),this.isPropagationStopped=Vn)},persist:function(){},isPersistent:Vn}),e}var Rl={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Zn=Pt(Rl),Ga=R({},Rl,{view:0,detail:0}),Zd=Pt(Ga),zu,Nu,wa,Kn=R({},Ga,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:ju,button:0,buttons:0,relatedTarget:function(t){return t.relatedTarget===void 0?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==wa&&(wa&&t.type==="mousemove"?(zu=t.screenX-wa.screenX,Nu=t.screenY-wa.screenY):Nu=zu=0,wa=t),zu)},movementY:function(t){return"movementY"in t?t.movementY:Nu}}),Sf=Pt(Kn),Kd=R({},Kn,{dataTransfer:0}),Jd=Pt(Kd),kd=R({},Ga,{relatedTarget:0}),Ou=Pt(kd),$d=R({},Rl,{animationName:0,elapsedTime:0,pseudoElement:0}),Wd=Pt($d),Fd=R({},Rl,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),Id=Pt(Fd),Pd=R({},Rl,{data:0}),bf=Pt(Pd),tm={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},em={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},lm={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function am(t){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(t):(t=lm[t])?!!e[t]:!1}function ju(){return am}var nm=R({},Ga,{key:function(t){if(t.key){var e=tm[t.key]||t.key;if(e!=="Unidentified")return e}return t.type==="keypress"?(t=wn(t),t===13?"Enter":String.fromCharCode(t)):t.type==="keydown"||t.type==="keyup"?em[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:ju,charCode:function(t){return t.type==="keypress"?wn(t):0},keyCode:function(t){return t.type==="keydown"||t.type==="keyup"?t.keyCode:0},which:function(t){return t.type==="keypress"?wn(t):t.type==="keydown"||t.type==="keyup"?t.keyCode:0}}),im=Pt(nm),um=R({},Kn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),xf=Pt(um),cm=R({},Ga,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:ju}),sm=Pt(cm),fm=R({},Rl,{propertyName:0,elapsedTime:0,pseudoElement:0}),rm=Pt(fm),om=R({},Kn,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),hm=Pt(om),dm=R({},Rl,{newState:0,oldState:0}),mm=Pt(dm),ym=[9,13,27,32],Cu=Qe&&"CompositionEvent"in window,Va=null;Qe&&"documentMode"in document&&(Va=document.documentMode);var pm=Qe&&"TextEvent"in window&&!Va,_f=Qe&&(!Cu||Va&&8<Va&&11>=Va),Ef=" ",Tf=!1;function Af(t,e){switch(t){case"keyup":return ym.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function zf(t){return t=t.detail,typeof t=="object"&&"data"in t?t.data:null}var na=!1;function vm(t,e){switch(t){case"compositionend":return zf(e);case"keypress":return e.which!==32?null:(Tf=!0,Ef);case"textInput":return t=e.data,t===Ef&&Tf?null:t;default:return null}}function gm(t,e){if(na)return t==="compositionend"||!Cu&&Af(t,e)?(t=vf(),Gn=Au=ul=null,na=!1,t):null;switch(t){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return _f&&e.locale!=="ko"?null:e.data;default:return null}}var Sm={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Nf(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e==="input"?!!Sm[t.type]:e==="textarea"}function Of(t,e,l,a){la?aa?aa.push(a):aa=[a]:la=a,e=Bi(e,"onChange"),0<e.length&&(l=new Zn("onChange","change",null,l,a),t.push({event:l,listeners:e}))}var Za=null,Ka=null;function bm(t){oh(t,0)}function Jn(t){var e=La(t);if(ff(e))return t}function jf(t,e){if(t==="change")return e}var Cf=!1;if(Qe){var Du;if(Qe){var Mu="oninput"in document;if(!Mu){var Df=document.createElement("div");Df.setAttribute("oninput","return;"),Mu=typeof Df.oninput=="function"}Du=Mu}else Du=!1;Cf=Du&&(!document.documentMode||9<document.documentMode)}function Mf(){Za&&(Za.detachEvent("onpropertychange",Rf),Ka=Za=null)}function Rf(t){if(t.propertyName==="value"&&Jn(Ka)){var e=[];Of(e,Ka,t,_u(t)),pf(bm,e)}}function xm(t,e,l){t==="focusin"?(Mf(),Za=e,Ka=l,Za.attachEvent("onpropertychange",Rf)):t==="focusout"&&Mf()}function _m(t){if(t==="selectionchange"||t==="keyup"||t==="keydown")return Jn(Ka)}function Em(t,e){if(t==="click")return Jn(e)}function Tm(t,e){if(t==="input"||t==="change")return Jn(e)}function Am(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var se=typeof Object.is=="function"?Object.is:Am;function Ja(t,e){if(se(t,e))return!0;if(typeof t!="object"||t===null||typeof e!="object"||e===null)return!1;var l=Object.keys(t),a=Object.keys(e);if(l.length!==a.length)return!1;for(a=0;a<l.length;a++){var n=l[a];if(!fu.call(e,n)||!se(t[n],e[n]))return!1}return!0}function Uf(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function Bf(t,e){var l=Uf(t);t=0;for(var a;l;){if(l.nodeType===3){if(a=t+l.textContent.length,t<=e&&a>=e)return{node:l,offset:e-t};t=a}t:{for(;l;){if(l.nextSibling){l=l.nextSibling;break t}l=l.parentNode}l=void 0}l=Uf(l)}}function qf(t,e){return t&&e?t===e?!0:t&&t.nodeType===3?!1:e&&e.nodeType===3?qf(t,e.parentNode):"contains"in t?t.contains(e):t.compareDocumentPosition?!!(t.compareDocumentPosition(e)&16):!1:!1}function Hf(t){t=t!=null&&t.ownerDocument!=null&&t.ownerDocument.defaultView!=null?t.ownerDocument.defaultView:window;for(var e=Xn(t.document);e instanceof t.HTMLIFrameElement;){try{var l=typeof e.contentWindow.location.href=="string"}catch{l=!1}if(l)t=e.contentWindow;else break;e=Xn(t.document)}return e}function Ru(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e&&(e==="input"&&(t.type==="text"||t.type==="search"||t.type==="tel"||t.type==="url"||t.type==="password")||e==="textarea"||t.contentEditable==="true")}var zm=Qe&&"documentMode"in document&&11>=document.documentMode,ia=null,Uu=null,ka=null,Bu=!1;function Yf(t,e,l){var a=l.window===l?l.document:l.nodeType===9?l:l.ownerDocument;Bu||ia==null||ia!==Xn(a)||(a=ia,"selectionStart"in a&&Ru(a)?a={start:a.selectionStart,end:a.selectionEnd}:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection(),a={anchorNode:a.anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset}),ka&&Ja(ka,a)||(ka=a,a=Bi(Uu,"onSelect"),0<a.length&&(e=new Zn("onSelect","select",null,e,l),t.push({event:e,listeners:a}),e.target=ia)))}function Ul(t,e){var l={};return l[t.toLowerCase()]=e.toLowerCase(),l["Webkit"+t]="webkit"+e,l["Moz"+t]="moz"+e,l}var ua={animationend:Ul("Animation","AnimationEnd"),animationiteration:Ul("Animation","AnimationIteration"),animationstart:Ul("Animation","AnimationStart"),transitionrun:Ul("Transition","TransitionRun"),transitionstart:Ul("Transition","TransitionStart"),transitioncancel:Ul("Transition","TransitionCancel"),transitionend:Ul("Transition","TransitionEnd")},qu={},Lf={};Qe&&(Lf=document.createElement("div").style,"AnimationEvent"in window||(delete ua.animationend.animation,delete ua.animationiteration.animation,delete ua.animationstart.animation),"TransitionEvent"in window||delete ua.transitionend.transition);function Bl(t){if(qu[t])return qu[t];if(!ua[t])return t;var e=ua[t],l;for(l in e)if(e.hasOwnProperty(l)&&l in Lf)return qu[t]=e[l];return t}var Xf=Bl("animationend"),Qf=Bl("animationiteration"),Gf=Bl("animationstart"),Nm=Bl("transitionrun"),Om=Bl("transitionstart"),jm=Bl("transitioncancel"),wf=Bl("transitionend"),Vf=new Map,Hu="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Hu.push("scrollEnd");function Oe(t,e){Vf.set(t,e),Ml(e,[t])}var kn=typeof reportError=="function"?reportError:function(t){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var e=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof t=="object"&&t!==null&&typeof t.message=="string"?String(t.message):String(t),error:t});if(!window.dispatchEvent(e))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",t);return}console.error(t)},ge=[],ca=0,Yu=0;function $n(){for(var t=ca,e=Yu=ca=0;e<t;){var l=ge[e];ge[e++]=null;var a=ge[e];ge[e++]=null;var n=ge[e];ge[e++]=null;var i=ge[e];if(ge[e++]=null,a!==null&&n!==null){var f=a.pending;f===null?n.next=n:(n.next=f.next,f.next=n),a.pending=n}i!==0&&Zf(l,n,i)}}function Wn(t,e,l,a){ge[ca++]=t,ge[ca++]=e,ge[ca++]=l,ge[ca++]=a,Yu|=a,t.lanes|=a,t=t.alternate,t!==null&&(t.lanes|=a)}function Lu(t,e,l,a){return Wn(t,e,l,a),Fn(t)}function ql(t,e){return Wn(t,null,null,e),Fn(t)}function Zf(t,e,l){t.lanes|=l;var a=t.alternate;a!==null&&(a.lanes|=l);for(var n=!1,i=t.return;i!==null;)i.childLanes|=l,a=i.alternate,a!==null&&(a.childLanes|=l),i.tag===22&&(t=i.stateNode,t===null||t._visibility&1||(n=!0)),t=i,i=i.return;return t.tag===3?(i=t.stateNode,n&&e!==null&&(n=31-ce(l),t=i.hiddenUpdates,a=t[n],a===null?t[n]=[e]:a.push(e),e.lane=l|536870912),i):null}function Fn(t){if(50<vn)throw vn=0,kc=null,Error(s(185));for(var e=t.return;e!==null;)t=e,e=t.return;return t.tag===3?t.stateNode:null}var sa={};function Cm(t,e,l,a){this.tag=t,this.key=l,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function fe(t,e,l,a){return new Cm(t,e,l,a)}function Xu(t){return t=t.prototype,!(!t||!t.isReactComponent)}function Ge(t,e){var l=t.alternate;return l===null?(l=fe(t.tag,e,t.key,t.mode),l.elementType=t.elementType,l.type=t.type,l.stateNode=t.stateNode,l.alternate=t,t.alternate=l):(l.pendingProps=e,l.type=t.type,l.flags=0,l.subtreeFlags=0,l.deletions=null),l.flags=t.flags&65011712,l.childLanes=t.childLanes,l.lanes=t.lanes,l.child=t.child,l.memoizedProps=t.memoizedProps,l.memoizedState=t.memoizedState,l.updateQueue=t.updateQueue,e=t.dependencies,l.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},l.sibling=t.sibling,l.index=t.index,l.ref=t.ref,l.refCleanup=t.refCleanup,l}function Kf(t,e){t.flags&=65011714;var l=t.alternate;return l===null?(t.childLanes=0,t.lanes=e,t.child=null,t.subtreeFlags=0,t.memoizedProps=null,t.memoizedState=null,t.updateQueue=null,t.dependencies=null,t.stateNode=null):(t.childLanes=l.childLanes,t.lanes=l.lanes,t.child=l.child,t.subtreeFlags=0,t.deletions=null,t.memoizedProps=l.memoizedProps,t.memoizedState=l.memoizedState,t.updateQueue=l.updateQueue,t.type=l.type,e=l.dependencies,t.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),t}function In(t,e,l,a,n,i){var f=0;if(a=t,typeof t=="function")Xu(t)&&(f=1);else if(typeof t=="string")f=By(t,l,q.current)?26:t==="html"||t==="head"||t==="body"?27:5;else t:switch(t){case ye:return t=fe(31,l,e,n),t.elementType=ye,t.lanes=i,t;case pt:return Hl(l.children,n,i,e);case Mt:f=8,n|=24;break;case Et:return t=fe(12,l,e,n|2),t.elementType=Et,t.lanes=i,t;case Ft:return t=fe(13,l,e,n),t.elementType=Ft,t.lanes=i,t;case Gt:return t=fe(19,l,e,n),t.elementType=Gt,t.lanes=i,t;default:if(typeof t=="object"&&t!==null)switch(t.$$typeof){case bt:f=10;break t;case Kt:f=9;break t;case Jt:f=11;break t;case W:f=14;break t;case wt:f=16,a=null;break t}f=29,l=Error(s(130,t===null?"null":typeof t,"")),a=null}return e=fe(f,l,e,n),e.elementType=t,e.type=a,e.lanes=i,e}function Hl(t,e,l,a){return t=fe(7,t,a,e),t.lanes=l,t}function Qu(t,e,l){return t=fe(6,t,null,e),t.lanes=l,t}function Jf(t){var e=fe(18,null,null,0);return e.stateNode=t,e}function Gu(t,e,l){return e=fe(4,t.children!==null?t.children:[],t.key,e),e.lanes=l,e.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},e}var kf=new WeakMap;function Se(t,e){if(typeof t=="object"&&t!==null){var l=kf.get(t);return l!==void 0?l:(e={value:t,source:e,stack:Ks(e)},kf.set(t,e),e)}return{value:t,source:e,stack:Ks(e)}}var fa=[],ra=0,Pn=null,$a=0,be=[],xe=0,cl=null,Me=1,Re="";function we(t,e){fa[ra++]=$a,fa[ra++]=Pn,Pn=t,$a=e}function $f(t,e,l){be[xe++]=Me,be[xe++]=Re,be[xe++]=cl,cl=t;var a=Me;t=Re;var n=32-ce(a)-1;a&=~(1<<n),l+=1;var i=32-ce(e)+n;if(30<i){var f=n-n%5;i=(a&(1<<f)-1).toString(32),a>>=f,n-=f,Me=1<<32-ce(e)+n|l<<n|a,Re=i+t}else Me=1<<i|l<<n|a,Re=t}function wu(t){t.return!==null&&(we(t,1),$f(t,1,0))}function Vu(t){for(;t===Pn;)Pn=fa[--ra],fa[ra]=null,$a=fa[--ra],fa[ra]=null;for(;t===cl;)cl=be[--xe],be[xe]=null,Re=be[--xe],be[xe]=null,Me=be[--xe],be[xe]=null}function Wf(t,e){be[xe++]=Me,be[xe++]=Re,be[xe++]=cl,Me=e.id,Re=e.overflow,cl=t}var Yt=null,vt=null,et=!1,sl=null,_e=!1,Zu=Error(s(519));function fl(t){var e=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Wa(Se(e,t)),Zu}function Ff(t){var e=t.stateNode,l=t.type,a=t.memoizedProps;switch(e[Ht]=t,e[It]=a,l){case"dialog":I("cancel",e),I("close",e);break;case"iframe":case"object":case"embed":I("load",e);break;case"video":case"audio":for(l=0;l<Sn.length;l++)I(Sn[l],e);break;case"source":I("error",e);break;case"img":case"image":case"link":I("error",e),I("load",e);break;case"details":I("toggle",e);break;case"input":I("invalid",e),rf(e,a.value,a.defaultValue,a.checked,a.defaultChecked,a.type,a.name,!0);break;case"select":I("invalid",e);break;case"textarea":I("invalid",e),hf(e,a.value,a.defaultValue,a.children)}l=a.children,typeof l!="string"&&typeof l!="number"&&typeof l!="bigint"||e.textContent===""+l||a.suppressHydrationWarning===!0||yh(e.textContent,l)?(a.popover!=null&&(I("beforetoggle",e),I("toggle",e)),a.onScroll!=null&&I("scroll",e),a.onScrollEnd!=null&&I("scrollend",e),a.onClick!=null&&(e.onclick=Xe),e=!0):e=!1,e||fl(t,!0)}function If(t){for(Yt=t.return;Yt;)switch(Yt.tag){case 5:case 31:case 13:_e=!1;return;case 27:case 3:_e=!0;return;default:Yt=Yt.return}}function oa(t){if(t!==Yt)return!1;if(!et)return If(t),et=!0,!1;var e=t.tag,l;if((l=e!==3&&e!==27)&&((l=e===5)&&(l=t.type,l=!(l!=="form"&&l!=="button")||fs(t.type,t.memoizedProps)),l=!l),l&&vt&&fl(t),If(t),e===13){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(s(317));vt=Th(t)}else if(e===31){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(s(317));vt=Th(t)}else e===27?(e=vt,El(t.type)?(t=ms,ms=null,vt=t):vt=e):vt=Yt?Te(t.stateNode.nextSibling):null;return!0}function Yl(){vt=Yt=null,et=!1}function Ku(){var t=sl;return t!==null&&(ae===null?ae=t:ae.push.apply(ae,t),sl=null),t}function Wa(t){sl===null?sl=[t]:sl.push(t)}var Ju=d(null),Ll=null,Ve=null;function rl(t,e,l){U(Ju,e._currentValue),e._currentValue=l}function Ze(t){t._currentValue=Ju.current,E(Ju)}function ku(t,e,l){for(;t!==null;){var a=t.alternate;if((t.childLanes&e)!==e?(t.childLanes|=e,a!==null&&(a.childLanes|=e)):a!==null&&(a.childLanes&e)!==e&&(a.childLanes|=e),t===l)break;t=t.return}}function $u(t,e,l,a){var n=t.child;for(n!==null&&(n.return=t);n!==null;){var i=n.dependencies;if(i!==null){var f=n.child;i=i.firstContext;t:for(;i!==null;){var o=i;i=n;for(var m=0;m<e.length;m++)if(o.context===e[m]){i.lanes|=l,o=i.alternate,o!==null&&(o.lanes|=l),ku(i.return,l,t),a||(f=null);break t}i=o.next}}else if(n.tag===18){if(f=n.return,f===null)throw Error(s(341));f.lanes|=l,i=f.alternate,i!==null&&(i.lanes|=l),ku(f,l,t),f=null}else f=n.child;if(f!==null)f.return=n;else for(f=n;f!==null;){if(f===t){f=null;break}if(n=f.sibling,n!==null){n.return=f.return,f=n;break}f=f.return}n=f}}function ha(t,e,l,a){t=null;for(var n=e,i=!1;n!==null;){if(!i){if((n.flags&524288)!==0)i=!0;else if((n.flags&262144)!==0)break}if(n.tag===10){var f=n.alternate;if(f===null)throw Error(s(387));if(f=f.memoizedProps,f!==null){var o=n.type;se(n.pendingProps.value,f.value)||(t!==null?t.push(o):t=[o])}}else if(n===ct.current){if(f=n.alternate,f===null)throw Error(s(387));f.memoizedState.memoizedState!==n.memoizedState.memoizedState&&(t!==null?t.push(Tn):t=[Tn])}n=n.return}t!==null&&$u(e,t,l,a),e.flags|=262144}function ti(t){for(t=t.firstContext;t!==null;){if(!se(t.context._currentValue,t.memoizedValue))return!0;t=t.next}return!1}function Xl(t){Ll=t,Ve=null,t=t.dependencies,t!==null&&(t.firstContext=null)}function Lt(t){return Pf(Ll,t)}function ei(t,e){return Ll===null&&Xl(t),Pf(t,e)}function Pf(t,e){var l=e._currentValue;if(e={context:e,memoizedValue:l,next:null},Ve===null){if(t===null)throw Error(s(308));Ve=e,t.dependencies={lanes:0,firstContext:e},t.flags|=524288}else Ve=Ve.next=e;return l}var Dm=typeof AbortController<"u"?AbortController:function(){var t=[],e=this.signal={aborted:!1,addEventListener:function(l,a){t.push(a)}};this.abort=function(){e.aborted=!0,t.forEach(function(l){return l()})}},Mm=r.unstable_scheduleCallback,Rm=r.unstable_NormalPriority,Nt={$$typeof:bt,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Wu(){return{controller:new Dm,data:new Map,refCount:0}}function Fa(t){t.refCount--,t.refCount===0&&Mm(Rm,function(){t.controller.abort()})}var Ia=null,Fu=0,da=0,ma=null;function Um(t,e){if(Ia===null){var l=Ia=[];Fu=0,da=ts(),ma={status:"pending",value:void 0,then:function(a){l.push(a)}}}return Fu++,e.then(tr,tr),e}function tr(){if(--Fu===0&&Ia!==null){ma!==null&&(ma.status="fulfilled");var t=Ia;Ia=null,da=0,ma=null;for(var e=0;e<t.length;e++)(0,t[e])()}}function Bm(t,e){var l=[],a={status:"pending",value:null,reason:null,then:function(n){l.push(n)}};return t.then(function(){a.status="fulfilled",a.value=e;for(var n=0;n<l.length;n++)(0,l[n])(e)},function(n){for(a.status="rejected",a.reason=n,n=0;n<l.length;n++)(0,l[n])(void 0)}),a}var er=T.S;T.S=function(t,e){Lo=ie(),typeof e=="object"&&e!==null&&typeof e.then=="function"&&Um(t,e),er!==null&&er(t,e)};var Ql=d(null);function Iu(){var t=Ql.current;return t!==null?t:yt.pooledCache}function li(t,e){e===null?U(Ql,Ql.current):U(Ql,e.pool)}function lr(){var t=Iu();return t===null?null:{parent:Nt._currentValue,pool:t}}var ya=Error(s(460)),Pu=Error(s(474)),ai=Error(s(542)),ni={then:function(){}};function ar(t){return t=t.status,t==="fulfilled"||t==="rejected"}function nr(t,e,l){switch(l=t[l],l===void 0?t.push(e):l!==e&&(e.then(Xe,Xe),e=l),e.status){case"fulfilled":return e.value;case"rejected":throw t=e.reason,ur(t),t;default:if(typeof e.status=="string")e.then(Xe,Xe);else{if(t=yt,t!==null&&100<t.shellSuspendCounter)throw Error(s(482));t=e,t.status="pending",t.then(function(a){if(e.status==="pending"){var n=e;n.status="fulfilled",n.value=a}},function(a){if(e.status==="pending"){var n=e;n.status="rejected",n.reason=a}})}switch(e.status){case"fulfilled":return e.value;case"rejected":throw t=e.reason,ur(t),t}throw wl=e,ya}}function Gl(t){try{var e=t._init;return e(t._payload)}catch(l){throw l!==null&&typeof l=="object"&&typeof l.then=="function"?(wl=l,ya):l}}var wl=null;function ir(){if(wl===null)throw Error(s(459));var t=wl;return wl=null,t}function ur(t){if(t===ya||t===ai)throw Error(s(483))}var pa=null,Pa=0;function ii(t){var e=Pa;return Pa+=1,pa===null&&(pa=[]),nr(pa,t,e)}function tn(t,e){e=e.props.ref,t.ref=e!==void 0?e:null}function ui(t,e){throw e.$$typeof===V?Error(s(525)):(t=Object.prototype.toString.call(e),Error(s(31,t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)))}function cr(t){function e(v,y){if(t){var g=v.deletions;g===null?(v.deletions=[y],v.flags|=16):g.push(y)}}function l(v,y){if(!t)return null;for(;y!==null;)e(v,y),y=y.sibling;return null}function a(v){for(var y=new Map;v!==null;)v.key!==null?y.set(v.key,v):y.set(v.index,v),v=v.sibling;return y}function n(v,y){return v=Ge(v,y),v.index=0,v.sibling=null,v}function i(v,y,g){return v.index=g,t?(g=v.alternate,g!==null?(g=g.index,g<y?(v.flags|=67108866,y):g):(v.flags|=67108866,y)):(v.flags|=1048576,y)}function f(v){return t&&v.alternate===null&&(v.flags|=67108866),v}function o(v,y,g,N){return y===null||y.tag!==6?(y=Qu(g,v.mode,N),y.return=v,y):(y=n(y,g),y.return=v,y)}function m(v,y,g,N){var Q=g.type;return Q===pt?A(v,y,g.props.children,N,g.key):y!==null&&(y.elementType===Q||typeof Q=="object"&&Q!==null&&Q.$$typeof===wt&&Gl(Q)===y.type)?(y=n(y,g.props),tn(y,g),y.return=v,y):(y=In(g.type,g.key,g.props,null,v.mode,N),tn(y,g),y.return=v,y)}function S(v,y,g,N){return y===null||y.tag!==4||y.stateNode.containerInfo!==g.containerInfo||y.stateNode.implementation!==g.implementation?(y=Gu(g,v.mode,N),y.return=v,y):(y=n(y,g.children||[]),y.return=v,y)}function A(v,y,g,N,Q){return y===null||y.tag!==7?(y=Hl(g,v.mode,N,Q),y.return=v,y):(y=n(y,g),y.return=v,y)}function O(v,y,g){if(typeof y=="string"&&y!==""||typeof y=="number"||typeof y=="bigint")return y=Qu(""+y,v.mode,g),y.return=v,y;if(typeof y=="object"&&y!==null){switch(y.$$typeof){case at:return g=In(y.type,y.key,y.props,null,v.mode,g),tn(g,y),g.return=v,g;case mt:return y=Gu(y,v.mode,g),y.return=v,y;case wt:return y=Gl(y),O(v,y,g)}if(qt(y)||Vt(y))return y=Hl(y,v.mode,g,null),y.return=v,y;if(typeof y.then=="function")return O(v,ii(y),g);if(y.$$typeof===bt)return O(v,ei(v,y),g);ui(v,y)}return null}function b(v,y,g,N){var Q=y!==null?y.key:null;if(typeof g=="string"&&g!==""||typeof g=="number"||typeof g=="bigint")return Q!==null?null:o(v,y,""+g,N);if(typeof g=="object"&&g!==null){switch(g.$$typeof){case at:return g.key===Q?m(v,y,g,N):null;case mt:return g.key===Q?S(v,y,g,N):null;case wt:return g=Gl(g),b(v,y,g,N)}if(qt(g)||Vt(g))return Q!==null?null:A(v,y,g,N,null);if(typeof g.then=="function")return b(v,y,ii(g),N);if(g.$$typeof===bt)return b(v,y,ei(v,g),N);ui(v,g)}return null}function _(v,y,g,N,Q){if(typeof N=="string"&&N!==""||typeof N=="number"||typeof N=="bigint")return v=v.get(g)||null,o(y,v,""+N,Q);if(typeof N=="object"&&N!==null){switch(N.$$typeof){case at:return v=v.get(N.key===null?g:N.key)||null,m(y,v,N,Q);case mt:return v=v.get(N.key===null?g:N.key)||null,S(y,v,N,Q);case wt:return N=Gl(N),_(v,y,g,N,Q)}if(qt(N)||Vt(N))return v=v.get(g)||null,A(y,v,N,Q,null);if(typeof N.then=="function")return _(v,y,g,ii(N),Q);if(N.$$typeof===bt)return _(v,y,g,ei(y,N),Q);ui(y,N)}return null}function H(v,y,g,N){for(var Q=null,nt=null,L=y,$=y=0,tt=null;L!==null&&$<g.length;$++){L.index>$?(tt=L,L=null):tt=L.sibling;var it=b(v,L,g[$],N);if(it===null){L===null&&(L=tt);break}t&&L&&it.alternate===null&&e(v,L),y=i(it,y,$),nt===null?Q=it:nt.sibling=it,nt=it,L=tt}if($===g.length)return l(v,L),et&&we(v,$),Q;if(L===null){for(;$<g.length;$++)L=O(v,g[$],N),L!==null&&(y=i(L,y,$),nt===null?Q=L:nt.sibling=L,nt=L);return et&&we(v,$),Q}for(L=a(L);$<g.length;$++)tt=_(L,v,$,g[$],N),tt!==null&&(t&&tt.alternate!==null&&L.delete(tt.key===null?$:tt.key),y=i(tt,y,$),nt===null?Q=tt:nt.sibling=tt,nt=tt);return t&&L.forEach(function(Ol){return e(v,Ol)}),et&&we(v,$),Q}function w(v,y,g,N){if(g==null)throw Error(s(151));for(var Q=null,nt=null,L=y,$=y=0,tt=null,it=g.next();L!==null&&!it.done;$++,it=g.next()){L.index>$?(tt=L,L=null):tt=L.sibling;var Ol=b(v,L,it.value,N);if(Ol===null){L===null&&(L=tt);break}t&&L&&Ol.alternate===null&&e(v,L),y=i(Ol,y,$),nt===null?Q=Ol:nt.sibling=Ol,nt=Ol,L=tt}if(it.done)return l(v,L),et&&we(v,$),Q;if(L===null){for(;!it.done;$++,it=g.next())it=O(v,it.value,N),it!==null&&(y=i(it,y,$),nt===null?Q=it:nt.sibling=it,nt=it);return et&&we(v,$),Q}for(L=a(L);!it.done;$++,it=g.next())it=_(L,v,$,it.value,N),it!==null&&(t&&it.alternate!==null&&L.delete(it.key===null?$:it.key),y=i(it,y,$),nt===null?Q=it:nt.sibling=it,nt=it);return t&&L.forEach(function(Ky){return e(v,Ky)}),et&&we(v,$),Q}function dt(v,y,g,N){if(typeof g=="object"&&g!==null&&g.type===pt&&g.key===null&&(g=g.props.children),typeof g=="object"&&g!==null){switch(g.$$typeof){case at:t:{for(var Q=g.key;y!==null;){if(y.key===Q){if(Q=g.type,Q===pt){if(y.tag===7){l(v,y.sibling),N=n(y,g.props.children),N.return=v,v=N;break t}}else if(y.elementType===Q||typeof Q=="object"&&Q!==null&&Q.$$typeof===wt&&Gl(Q)===y.type){l(v,y.sibling),N=n(y,g.props),tn(N,g),N.return=v,v=N;break t}l(v,y);break}else e(v,y);y=y.sibling}g.type===pt?(N=Hl(g.props.children,v.mode,N,g.key),N.return=v,v=N):(N=In(g.type,g.key,g.props,null,v.mode,N),tn(N,g),N.return=v,v=N)}return f(v);case mt:t:{for(Q=g.key;y!==null;){if(y.key===Q)if(y.tag===4&&y.stateNode.containerInfo===g.containerInfo&&y.stateNode.implementation===g.implementation){l(v,y.sibling),N=n(y,g.children||[]),N.return=v,v=N;break t}else{l(v,y);break}else e(v,y);y=y.sibling}N=Gu(g,v.mode,N),N.return=v,v=N}return f(v);case wt:return g=Gl(g),dt(v,y,g,N)}if(qt(g))return H(v,y,g,N);if(Vt(g)){if(Q=Vt(g),typeof Q!="function")throw Error(s(150));return g=Q.call(g),w(v,y,g,N)}if(typeof g.then=="function")return dt(v,y,ii(g),N);if(g.$$typeof===bt)return dt(v,y,ei(v,g),N);ui(v,g)}return typeof g=="string"&&g!==""||typeof g=="number"||typeof g=="bigint"?(g=""+g,y!==null&&y.tag===6?(l(v,y.sibling),N=n(y,g),N.return=v,v=N):(l(v,y),N=Qu(g,v.mode,N),N.return=v,v=N),f(v)):l(v,y)}return function(v,y,g,N){try{Pa=0;var Q=dt(v,y,g,N);return pa=null,Q}catch(L){if(L===ya||L===ai)throw L;var nt=fe(29,L,null,v.mode);return nt.lanes=N,nt.return=v,nt}}}var Vl=cr(!0),sr=cr(!1),ol=!1;function tc(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function ec(t,e){t=t.updateQueue,e.updateQueue===t&&(e.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,callbacks:null})}function hl(t){return{lane:t,tag:0,payload:null,callback:null,next:null}}function dl(t,e,l){var a=t.updateQueue;if(a===null)return null;if(a=a.shared,(ut&2)!==0){var n=a.pending;return n===null?e.next=e:(e.next=n.next,n.next=e),a.pending=e,e=Fn(t),Zf(t,null,l),e}return Wn(t,a,e,l),Fn(t)}function en(t,e,l){if(e=e.updateQueue,e!==null&&(e=e.shared,(l&4194048)!==0)){var a=e.lanes;a&=t.pendingLanes,l|=a,e.lanes=l,Is(t,l)}}function lc(t,e){var l=t.updateQueue,a=t.alternate;if(a!==null&&(a=a.updateQueue,l===a)){var n=null,i=null;if(l=l.firstBaseUpdate,l!==null){do{var f={lane:l.lane,tag:l.tag,payload:l.payload,callback:null,next:null};i===null?n=i=f:i=i.next=f,l=l.next}while(l!==null);i===null?n=i=e:i=i.next=e}else n=i=e;l={baseState:a.baseState,firstBaseUpdate:n,lastBaseUpdate:i,shared:a.shared,callbacks:a.callbacks},t.updateQueue=l;return}t=l.lastBaseUpdate,t===null?l.firstBaseUpdate=e:t.next=e,l.lastBaseUpdate=e}var ac=!1;function ln(){if(ac){var t=ma;if(t!==null)throw t}}function an(t,e,l,a){ac=!1;var n=t.updateQueue;ol=!1;var i=n.firstBaseUpdate,f=n.lastBaseUpdate,o=n.shared.pending;if(o!==null){n.shared.pending=null;var m=o,S=m.next;m.next=null,f===null?i=S:f.next=S,f=m;var A=t.alternate;A!==null&&(A=A.updateQueue,o=A.lastBaseUpdate,o!==f&&(o===null?A.firstBaseUpdate=S:o.next=S,A.lastBaseUpdate=m))}if(i!==null){var O=n.baseState;f=0,A=S=m=null,o=i;do{var b=o.lane&-536870913,_=b!==o.lane;if(_?(P&b)===b:(a&b)===b){b!==0&&b===da&&(ac=!0),A!==null&&(A=A.next={lane:0,tag:o.tag,payload:o.payload,callback:null,next:null});t:{var H=t,w=o;b=e;var dt=l;switch(w.tag){case 1:if(H=w.payload,typeof H=="function"){O=H.call(dt,O,b);break t}O=H;break t;case 3:H.flags=H.flags&-65537|128;case 0:if(H=w.payload,b=typeof H=="function"?H.call(dt,O,b):H,b==null)break t;O=R({},O,b);break t;case 2:ol=!0}}b=o.callback,b!==null&&(t.flags|=64,_&&(t.flags|=8192),_=n.callbacks,_===null?n.callbacks=[b]:_.push(b))}else _={lane:b,tag:o.tag,payload:o.payload,callback:o.callback,next:null},A===null?(S=A=_,m=O):A=A.next=_,f|=b;if(o=o.next,o===null){if(o=n.shared.pending,o===null)break;_=o,o=_.next,_.next=null,n.lastBaseUpdate=_,n.shared.pending=null}}while(!0);A===null&&(m=O),n.baseState=m,n.firstBaseUpdate=S,n.lastBaseUpdate=A,i===null&&(n.shared.lanes=0),gl|=f,t.lanes=f,t.memoizedState=O}}function fr(t,e){if(typeof t!="function")throw Error(s(191,t));t.call(e)}function rr(t,e){var l=t.callbacks;if(l!==null)for(t.callbacks=null,t=0;t<l.length;t++)fr(l[t],e)}var va=d(null),ci=d(0);function or(t,e){t=tl,U(ci,t),U(va,e),tl=t|e.baseLanes}function nc(){U(ci,tl),U(va,va.current)}function ic(){tl=ci.current,E(va),E(ci)}var re=d(null),Ee=null;function ml(t){var e=t.alternate;U(At,At.current&1),U(re,t),Ee===null&&(e===null||va.current!==null||e.memoizedState!==null)&&(Ee=t)}function uc(t){U(At,At.current),U(re,t),Ee===null&&(Ee=t)}function hr(t){t.tag===22?(U(At,At.current),U(re,t),Ee===null&&(Ee=t)):yl()}function yl(){U(At,At.current),U(re,re.current)}function oe(t){E(re),Ee===t&&(Ee=null),E(At)}var At=d(0);function si(t){for(var e=t;e!==null;){if(e.tag===13){var l=e.memoizedState;if(l!==null&&(l=l.dehydrated,l===null||hs(l)||ds(l)))return e}else if(e.tag===19&&(e.memoizedProps.revealOrder==="forwards"||e.memoizedProps.revealOrder==="backwards"||e.memoizedProps.revealOrder==="unstable_legacy-backwards"||e.memoizedProps.revealOrder==="together")){if((e.flags&128)!==0)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break;for(;e.sibling===null;){if(e.return===null||e.return===t)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var Ke=0,k=null,ot=null,Ot=null,fi=!1,ga=!1,Zl=!1,ri=0,nn=0,Sa=null,qm=0;function xt(){throw Error(s(321))}function cc(t,e){if(e===null)return!1;for(var l=0;l<e.length&&l<t.length;l++)if(!se(t[l],e[l]))return!1;return!0}function sc(t,e,l,a,n,i){return Ke=i,k=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,T.H=t===null||t.memoizedState===null?$r:Ec,Zl=!1,i=l(a,n),Zl=!1,ga&&(i=mr(e,l,a,n)),dr(t),i}function dr(t){T.H=sn;var e=ot!==null&&ot.next!==null;if(Ke=0,Ot=ot=k=null,fi=!1,nn=0,Sa=null,e)throw Error(s(300));t===null||jt||(t=t.dependencies,t!==null&&ti(t)&&(jt=!0))}function mr(t,e,l,a){k=t;var n=0;do{if(ga&&(Sa=null),nn=0,ga=!1,25<=n)throw Error(s(301));if(n+=1,Ot=ot=null,t.updateQueue!=null){var i=t.updateQueue;i.lastEffect=null,i.events=null,i.stores=null,i.memoCache!=null&&(i.memoCache.index=0)}T.H=Wr,i=e(l,a)}while(ga);return i}function Hm(){var t=T.H,e=t.useState()[0];return e=typeof e.then=="function"?un(e):e,t=t.useState()[0],(ot!==null?ot.memoizedState:null)!==t&&(k.flags|=1024),e}function fc(){var t=ri!==0;return ri=0,t}function rc(t,e,l){e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~l}function oc(t){if(fi){for(t=t.memoizedState;t!==null;){var e=t.queue;e!==null&&(e.pending=null),t=t.next}fi=!1}Ke=0,Ot=ot=k=null,ga=!1,nn=ri=0,Sa=null}function Wt(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Ot===null?k.memoizedState=Ot=t:Ot=Ot.next=t,Ot}function zt(){if(ot===null){var t=k.alternate;t=t!==null?t.memoizedState:null}else t=ot.next;var e=Ot===null?k.memoizedState:Ot.next;if(e!==null)Ot=e,ot=t;else{if(t===null)throw k.alternate===null?Error(s(467)):Error(s(310));ot=t,t={memoizedState:ot.memoizedState,baseState:ot.baseState,baseQueue:ot.baseQueue,queue:ot.queue,next:null},Ot===null?k.memoizedState=Ot=t:Ot=Ot.next=t}return Ot}function oi(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function un(t){var e=nn;return nn+=1,Sa===null&&(Sa=[]),t=nr(Sa,t,e),e=k,(Ot===null?e.memoizedState:Ot.next)===null&&(e=e.alternate,T.H=e===null||e.memoizedState===null?$r:Ec),t}function hi(t){if(t!==null&&typeof t=="object"){if(typeof t.then=="function")return un(t);if(t.$$typeof===bt)return Lt(t)}throw Error(s(438,String(t)))}function hc(t){var e=null,l=k.updateQueue;if(l!==null&&(e=l.memoCache),e==null){var a=k.alternate;a!==null&&(a=a.updateQueue,a!==null&&(a=a.memoCache,a!=null&&(e={data:a.data.map(function(n){return n.slice()}),index:0})))}if(e==null&&(e={data:[],index:0}),l===null&&(l=oi(),k.updateQueue=l),l.memoCache=e,l=e.data[e.index],l===void 0)for(l=e.data[e.index]=Array(t),a=0;a<t;a++)l[a]=al;return e.index++,l}function Je(t,e){return typeof e=="function"?e(t):e}function di(t){var e=zt();return dc(e,ot,t)}function dc(t,e,l){var a=t.queue;if(a===null)throw Error(s(311));a.lastRenderedReducer=l;var n=t.baseQueue,i=a.pending;if(i!==null){if(n!==null){var f=n.next;n.next=i.next,i.next=f}e.baseQueue=n=i,a.pending=null}if(i=t.baseState,n===null)t.memoizedState=i;else{e=n.next;var o=f=null,m=null,S=e,A=!1;do{var O=S.lane&-536870913;if(O!==S.lane?(P&O)===O:(Ke&O)===O){var b=S.revertLane;if(b===0)m!==null&&(m=m.next={lane:0,revertLane:0,gesture:null,action:S.action,hasEagerState:S.hasEagerState,eagerState:S.eagerState,next:null}),O===da&&(A=!0);else if((Ke&b)===b){S=S.next,b===da&&(A=!0);continue}else O={lane:0,revertLane:S.revertLane,gesture:null,action:S.action,hasEagerState:S.hasEagerState,eagerState:S.eagerState,next:null},m===null?(o=m=O,f=i):m=m.next=O,k.lanes|=b,gl|=b;O=S.action,Zl&&l(i,O),i=S.hasEagerState?S.eagerState:l(i,O)}else b={lane:O,revertLane:S.revertLane,gesture:S.gesture,action:S.action,hasEagerState:S.hasEagerState,eagerState:S.eagerState,next:null},m===null?(o=m=b,f=i):m=m.next=b,k.lanes|=O,gl|=O;S=S.next}while(S!==null&&S!==e);if(m===null?f=i:m.next=o,!se(i,t.memoizedState)&&(jt=!0,A&&(l=ma,l!==null)))throw l;t.memoizedState=i,t.baseState=f,t.baseQueue=m,a.lastRenderedState=i}return n===null&&(a.lanes=0),[t.memoizedState,a.dispatch]}function mc(t){var e=zt(),l=e.queue;if(l===null)throw Error(s(311));l.lastRenderedReducer=t;var a=l.dispatch,n=l.pending,i=e.memoizedState;if(n!==null){l.pending=null;var f=n=n.next;do i=t(i,f.action),f=f.next;while(f!==n);se(i,e.memoizedState)||(jt=!0),e.memoizedState=i,e.baseQueue===null&&(e.baseState=i),l.lastRenderedState=i}return[i,a]}function yr(t,e,l){var a=k,n=zt(),i=et;if(i){if(l===void 0)throw Error(s(407));l=l()}else l=e();var f=!se((ot||n).memoizedState,l);if(f&&(n.memoizedState=l,jt=!0),n=n.queue,vc(gr.bind(null,a,n,t),[t]),n.getSnapshot!==e||f||Ot!==null&&Ot.memoizedState.tag&1){if(a.flags|=2048,ba(9,{destroy:void 0},vr.bind(null,a,n,l,e),null),yt===null)throw Error(s(349));i||(Ke&127)!==0||pr(a,e,l)}return l}function pr(t,e,l){t.flags|=16384,t={getSnapshot:e,value:l},e=k.updateQueue,e===null?(e=oi(),k.updateQueue=e,e.stores=[t]):(l=e.stores,l===null?e.stores=[t]:l.push(t))}function vr(t,e,l,a){e.value=l,e.getSnapshot=a,Sr(e)&&br(t)}function gr(t,e,l){return l(function(){Sr(e)&&br(t)})}function Sr(t){var e=t.getSnapshot;t=t.value;try{var l=e();return!se(t,l)}catch{return!0}}function br(t){var e=ql(t,2);e!==null&&ne(e,t,2)}function yc(t){var e=Wt();if(typeof t=="function"){var l=t;if(t=l(),Zl){nl(!0);try{l()}finally{nl(!1)}}}return e.memoizedState=e.baseState=t,e.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Je,lastRenderedState:t},e}function xr(t,e,l,a){return t.baseState=l,dc(t,ot,typeof a=="function"?a:Je)}function Ym(t,e,l,a,n){if(pi(t))throw Error(s(485));if(t=e.action,t!==null){var i={payload:n,action:t,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(f){i.listeners.push(f)}};T.T!==null?l(!0):i.isTransition=!1,a(i),l=e.pending,l===null?(i.next=e.pending=i,_r(e,i)):(i.next=l.next,e.pending=l.next=i)}}function _r(t,e){var l=e.action,a=e.payload,n=t.state;if(e.isTransition){var i=T.T,f={};T.T=f;try{var o=l(n,a),m=T.S;m!==null&&m(f,o),Er(t,e,o)}catch(S){pc(t,e,S)}finally{i!==null&&f.types!==null&&(i.types=f.types),T.T=i}}else try{i=l(n,a),Er(t,e,i)}catch(S){pc(t,e,S)}}function Er(t,e,l){l!==null&&typeof l=="object"&&typeof l.then=="function"?l.then(function(a){Tr(t,e,a)},function(a){return pc(t,e,a)}):Tr(t,e,l)}function Tr(t,e,l){e.status="fulfilled",e.value=l,Ar(e),t.state=l,e=t.pending,e!==null&&(l=e.next,l===e?t.pending=null:(l=l.next,e.next=l,_r(t,l)))}function pc(t,e,l){var a=t.pending;if(t.pending=null,a!==null){a=a.next;do e.status="rejected",e.reason=l,Ar(e),e=e.next;while(e!==a)}t.action=null}function Ar(t){t=t.listeners;for(var e=0;e<t.length;e++)(0,t[e])()}function zr(t,e){return e}function Nr(t,e){if(et){var l=yt.formState;if(l!==null){t:{var a=k;if(et){if(vt){e:{for(var n=vt,i=_e;n.nodeType!==8;){if(!i){n=null;break e}if(n=Te(n.nextSibling),n===null){n=null;break e}}i=n.data,n=i==="F!"||i==="F"?n:null}if(n){vt=Te(n.nextSibling),a=n.data==="F!";break t}}fl(a)}a=!1}a&&(e=l[0])}}return l=Wt(),l.memoizedState=l.baseState=e,a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:zr,lastRenderedState:e},l.queue=a,l=Kr.bind(null,k,a),a.dispatch=l,a=yc(!1),i=_c.bind(null,k,!1,a.queue),a=Wt(),n={state:e,dispatch:null,action:t,pending:null},a.queue=n,l=Ym.bind(null,k,n,i,l),n.dispatch=l,a.memoizedState=t,[e,l,!1]}function Or(t){var e=zt();return jr(e,ot,t)}function jr(t,e,l){if(e=dc(t,e,zr)[0],t=di(Je)[0],typeof e=="object"&&e!==null&&typeof e.then=="function")try{var a=un(e)}catch(f){throw f===ya?ai:f}else a=e;e=zt();var n=e.queue,i=n.dispatch;return l!==e.memoizedState&&(k.flags|=2048,ba(9,{destroy:void 0},Lm.bind(null,n,l),null)),[a,i,t]}function Lm(t,e){t.action=e}function Cr(t){var e=zt(),l=ot;if(l!==null)return jr(e,l,t);zt(),e=e.memoizedState,l=zt();var a=l.queue.dispatch;return l.memoizedState=t,[e,a,!1]}function ba(t,e,l,a){return t={tag:t,create:l,deps:a,inst:e,next:null},e=k.updateQueue,e===null&&(e=oi(),k.updateQueue=e),l=e.lastEffect,l===null?e.lastEffect=t.next=t:(a=l.next,l.next=t,t.next=a,e.lastEffect=t),t}function Dr(){return zt().memoizedState}function mi(t,e,l,a){var n=Wt();k.flags|=t,n.memoizedState=ba(1|e,{destroy:void 0},l,a===void 0?null:a)}function yi(t,e,l,a){var n=zt();a=a===void 0?null:a;var i=n.memoizedState.inst;ot!==null&&a!==null&&cc(a,ot.memoizedState.deps)?n.memoizedState=ba(e,i,l,a):(k.flags|=t,n.memoizedState=ba(1|e,i,l,a))}function Mr(t,e){mi(8390656,8,t,e)}function vc(t,e){yi(2048,8,t,e)}function Xm(t){k.flags|=4;var e=k.updateQueue;if(e===null)e=oi(),k.updateQueue=e,e.events=[t];else{var l=e.events;l===null?e.events=[t]:l.push(t)}}function Rr(t){var e=zt().memoizedState;return Xm({ref:e,nextImpl:t}),function(){if((ut&2)!==0)throw Error(s(440));return e.impl.apply(void 0,arguments)}}function Ur(t,e){return yi(4,2,t,e)}function Br(t,e){return yi(4,4,t,e)}function qr(t,e){if(typeof e=="function"){t=t();var l=e(t);return function(){typeof l=="function"?l():e(null)}}if(e!=null)return t=t(),e.current=t,function(){e.current=null}}function Hr(t,e,l){l=l!=null?l.concat([t]):null,yi(4,4,qr.bind(null,e,t),l)}function gc(){}function Yr(t,e){var l=zt();e=e===void 0?null:e;var a=l.memoizedState;return e!==null&&cc(e,a[1])?a[0]:(l.memoizedState=[t,e],t)}function Lr(t,e){var l=zt();e=e===void 0?null:e;var a=l.memoizedState;if(e!==null&&cc(e,a[1]))return a[0];if(a=t(),Zl){nl(!0);try{t()}finally{nl(!1)}}return l.memoizedState=[a,e],a}function Sc(t,e,l){return l===void 0||(Ke&1073741824)!==0&&(P&261930)===0?t.memoizedState=e:(t.memoizedState=l,t=Qo(),k.lanes|=t,gl|=t,l)}function Xr(t,e,l,a){return se(l,e)?l:va.current!==null?(t=Sc(t,l,a),se(t,e)||(jt=!0),t):(Ke&42)===0||(Ke&1073741824)!==0&&(P&261930)===0?(jt=!0,t.memoizedState=l):(t=Qo(),k.lanes|=t,gl|=t,e)}function Qr(t,e,l,a,n){var i=B.p;B.p=i!==0&&8>i?i:8;var f=T.T,o={};T.T=o,_c(t,!1,e,l);try{var m=n(),S=T.S;if(S!==null&&S(o,m),m!==null&&typeof m=="object"&&typeof m.then=="function"){var A=Bm(m,a);cn(t,e,A,me(t))}else cn(t,e,a,me(t))}catch(O){cn(t,e,{then:function(){},status:"rejected",reason:O},me())}finally{B.p=i,f!==null&&o.types!==null&&(f.types=o.types),T.T=f}}function Qm(){}function bc(t,e,l,a){if(t.tag!==5)throw Error(s(476));var n=Gr(t).queue;Qr(t,n,e,X,l===null?Qm:function(){return wr(t),l(a)})}function Gr(t){var e=t.memoizedState;if(e!==null)return e;e={memoizedState:X,baseState:X,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Je,lastRenderedState:X},next:null};var l={};return e.next={memoizedState:l,baseState:l,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Je,lastRenderedState:l},next:null},t.memoizedState=e,t=t.alternate,t!==null&&(t.memoizedState=e),e}function wr(t){var e=Gr(t);e.next===null&&(e=t.alternate.memoizedState),cn(t,e.next.queue,{},me())}function xc(){return Lt(Tn)}function Vr(){return zt().memoizedState}function Zr(){return zt().memoizedState}function Gm(t){for(var e=t.return;e!==null;){switch(e.tag){case 24:case 3:var l=me();t=hl(l);var a=dl(e,t,l);a!==null&&(ne(a,e,l),en(a,e,l)),e={cache:Wu()},t.payload=e;return}e=e.return}}function wm(t,e,l){var a=me();l={lane:a,revertLane:0,gesture:null,action:l,hasEagerState:!1,eagerState:null,next:null},pi(t)?Jr(e,l):(l=Lu(t,e,l,a),l!==null&&(ne(l,t,a),kr(l,e,a)))}function Kr(t,e,l){var a=me();cn(t,e,l,a)}function cn(t,e,l,a){var n={lane:a,revertLane:0,gesture:null,action:l,hasEagerState:!1,eagerState:null,next:null};if(pi(t))Jr(e,n);else{var i=t.alternate;if(t.lanes===0&&(i===null||i.lanes===0)&&(i=e.lastRenderedReducer,i!==null))try{var f=e.lastRenderedState,o=i(f,l);if(n.hasEagerState=!0,n.eagerState=o,se(o,f))return Wn(t,e,n,0),yt===null&&$n(),!1}catch{}if(l=Lu(t,e,n,a),l!==null)return ne(l,t,a),kr(l,e,a),!0}return!1}function _c(t,e,l,a){if(a={lane:2,revertLane:ts(),gesture:null,action:a,hasEagerState:!1,eagerState:null,next:null},pi(t)){if(e)throw Error(s(479))}else e=Lu(t,l,a,2),e!==null&&ne(e,t,2)}function pi(t){var e=t.alternate;return t===k||e!==null&&e===k}function Jr(t,e){ga=fi=!0;var l=t.pending;l===null?e.next=e:(e.next=l.next,l.next=e),t.pending=e}function kr(t,e,l){if((l&4194048)!==0){var a=e.lanes;a&=t.pendingLanes,l|=a,e.lanes=l,Is(t,l)}}var sn={readContext:Lt,use:hi,useCallback:xt,useContext:xt,useEffect:xt,useImperativeHandle:xt,useLayoutEffect:xt,useInsertionEffect:xt,useMemo:xt,useReducer:xt,useRef:xt,useState:xt,useDebugValue:xt,useDeferredValue:xt,useTransition:xt,useSyncExternalStore:xt,useId:xt,useHostTransitionStatus:xt,useFormState:xt,useActionState:xt,useOptimistic:xt,useMemoCache:xt,useCacheRefresh:xt};sn.useEffectEvent=xt;var $r={readContext:Lt,use:hi,useCallback:function(t,e){return Wt().memoizedState=[t,e===void 0?null:e],t},useContext:Lt,useEffect:Mr,useImperativeHandle:function(t,e,l){l=l!=null?l.concat([t]):null,mi(4194308,4,qr.bind(null,e,t),l)},useLayoutEffect:function(t,e){return mi(4194308,4,t,e)},useInsertionEffect:function(t,e){mi(4,2,t,e)},useMemo:function(t,e){var l=Wt();e=e===void 0?null:e;var a=t();if(Zl){nl(!0);try{t()}finally{nl(!1)}}return l.memoizedState=[a,e],a},useReducer:function(t,e,l){var a=Wt();if(l!==void 0){var n=l(e);if(Zl){nl(!0);try{l(e)}finally{nl(!1)}}}else n=e;return a.memoizedState=a.baseState=n,t={pending:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:n},a.queue=t,t=t.dispatch=wm.bind(null,k,t),[a.memoizedState,t]},useRef:function(t){var e=Wt();return t={current:t},e.memoizedState=t},useState:function(t){t=yc(t);var e=t.queue,l=Kr.bind(null,k,e);return e.dispatch=l,[t.memoizedState,l]},useDebugValue:gc,useDeferredValue:function(t,e){var l=Wt();return Sc(l,t,e)},useTransition:function(){var t=yc(!1);return t=Qr.bind(null,k,t.queue,!0,!1),Wt().memoizedState=t,[!1,t]},useSyncExternalStore:function(t,e,l){var a=k,n=Wt();if(et){if(l===void 0)throw Error(s(407));l=l()}else{if(l=e(),yt===null)throw Error(s(349));(P&127)!==0||pr(a,e,l)}n.memoizedState=l;var i={value:l,getSnapshot:e};return n.queue=i,Mr(gr.bind(null,a,i,t),[t]),a.flags|=2048,ba(9,{destroy:void 0},vr.bind(null,a,i,l,e),null),l},useId:function(){var t=Wt(),e=yt.identifierPrefix;if(et){var l=Re,a=Me;l=(a&~(1<<32-ce(a)-1)).toString(32)+l,e="_"+e+"R_"+l,l=ri++,0<l&&(e+="H"+l.toString(32)),e+="_"}else l=qm++,e="_"+e+"r_"+l.toString(32)+"_";return t.memoizedState=e},useHostTransitionStatus:xc,useFormState:Nr,useActionState:Nr,useOptimistic:function(t){var e=Wt();e.memoizedState=e.baseState=t;var l={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return e.queue=l,e=_c.bind(null,k,!0,l),l.dispatch=e,[t,e]},useMemoCache:hc,useCacheRefresh:function(){return Wt().memoizedState=Gm.bind(null,k)},useEffectEvent:function(t){var e=Wt(),l={impl:t};return e.memoizedState=l,function(){if((ut&2)!==0)throw Error(s(440));return l.impl.apply(void 0,arguments)}}},Ec={readContext:Lt,use:hi,useCallback:Yr,useContext:Lt,useEffect:vc,useImperativeHandle:Hr,useInsertionEffect:Ur,useLayoutEffect:Br,useMemo:Lr,useReducer:di,useRef:Dr,useState:function(){return di(Je)},useDebugValue:gc,useDeferredValue:function(t,e){var l=zt();return Xr(l,ot.memoizedState,t,e)},useTransition:function(){var t=di(Je)[0],e=zt().memoizedState;return[typeof t=="boolean"?t:un(t),e]},useSyncExternalStore:yr,useId:Vr,useHostTransitionStatus:xc,useFormState:Or,useActionState:Or,useOptimistic:function(t,e){var l=zt();return xr(l,ot,t,e)},useMemoCache:hc,useCacheRefresh:Zr};Ec.useEffectEvent=Rr;var Wr={readContext:Lt,use:hi,useCallback:Yr,useContext:Lt,useEffect:vc,useImperativeHandle:Hr,useInsertionEffect:Ur,useLayoutEffect:Br,useMemo:Lr,useReducer:mc,useRef:Dr,useState:function(){return mc(Je)},useDebugValue:gc,useDeferredValue:function(t,e){var l=zt();return ot===null?Sc(l,t,e):Xr(l,ot.memoizedState,t,e)},useTransition:function(){var t=mc(Je)[0],e=zt().memoizedState;return[typeof t=="boolean"?t:un(t),e]},useSyncExternalStore:yr,useId:Vr,useHostTransitionStatus:xc,useFormState:Cr,useActionState:Cr,useOptimistic:function(t,e){var l=zt();return ot!==null?xr(l,ot,t,e):(l.baseState=t,[t,l.queue.dispatch])},useMemoCache:hc,useCacheRefresh:Zr};Wr.useEffectEvent=Rr;function Tc(t,e,l,a){e=t.memoizedState,l=l(a,e),l=l==null?e:R({},e,l),t.memoizedState=l,t.lanes===0&&(t.updateQueue.baseState=l)}var Ac={enqueueSetState:function(t,e,l){t=t._reactInternals;var a=me(),n=hl(a);n.payload=e,l!=null&&(n.callback=l),e=dl(t,n,a),e!==null&&(ne(e,t,a),en(e,t,a))},enqueueReplaceState:function(t,e,l){t=t._reactInternals;var a=me(),n=hl(a);n.tag=1,n.payload=e,l!=null&&(n.callback=l),e=dl(t,n,a),e!==null&&(ne(e,t,a),en(e,t,a))},enqueueForceUpdate:function(t,e){t=t._reactInternals;var l=me(),a=hl(l);a.tag=2,e!=null&&(a.callback=e),e=dl(t,a,l),e!==null&&(ne(e,t,l),en(e,t,l))}};function Fr(t,e,l,a,n,i,f){return t=t.stateNode,typeof t.shouldComponentUpdate=="function"?t.shouldComponentUpdate(a,i,f):e.prototype&&e.prototype.isPureReactComponent?!Ja(l,a)||!Ja(n,i):!0}function Ir(t,e,l,a){t=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(l,a),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(l,a),e.state!==t&&Ac.enqueueReplaceState(e,e.state,null)}function Kl(t,e){var l=e;if("ref"in e){l={};for(var a in e)a!=="ref"&&(l[a]=e[a])}if(t=t.defaultProps){l===e&&(l=R({},l));for(var n in t)l[n]===void 0&&(l[n]=t[n])}return l}function Pr(t){kn(t)}function to(t){console.error(t)}function eo(t){kn(t)}function vi(t,e){try{var l=t.onUncaughtError;l(e.value,{componentStack:e.stack})}catch(a){setTimeout(function(){throw a})}}function lo(t,e,l){try{var a=t.onCaughtError;a(l.value,{componentStack:l.stack,errorBoundary:e.tag===1?e.stateNode:null})}catch(n){setTimeout(function(){throw n})}}function zc(t,e,l){return l=hl(l),l.tag=3,l.payload={element:null},l.callback=function(){vi(t,e)},l}function ao(t){return t=hl(t),t.tag=3,t}function no(t,e,l,a){var n=l.type.getDerivedStateFromError;if(typeof n=="function"){var i=a.value;t.payload=function(){return n(i)},t.callback=function(){lo(e,l,a)}}var f=l.stateNode;f!==null&&typeof f.componentDidCatch=="function"&&(t.callback=function(){lo(e,l,a),typeof n!="function"&&(Sl===null?Sl=new Set([this]):Sl.add(this));var o=a.stack;this.componentDidCatch(a.value,{componentStack:o!==null?o:""})})}function Vm(t,e,l,a,n){if(l.flags|=32768,a!==null&&typeof a=="object"&&typeof a.then=="function"){if(e=l.alternate,e!==null&&ha(e,l,n,!0),l=re.current,l!==null){switch(l.tag){case 31:case 13:return Ee===null?ji():l.alternate===null&&_t===0&&(_t=3),l.flags&=-257,l.flags|=65536,l.lanes=n,a===ni?l.flags|=16384:(e=l.updateQueue,e===null?l.updateQueue=new Set([a]):e.add(a),Fc(t,a,n)),!1;case 22:return l.flags|=65536,a===ni?l.flags|=16384:(e=l.updateQueue,e===null?(e={transitions:null,markerInstances:null,retryQueue:new Set([a])},l.updateQueue=e):(l=e.retryQueue,l===null?e.retryQueue=new Set([a]):l.add(a)),Fc(t,a,n)),!1}throw Error(s(435,l.tag))}return Fc(t,a,n),ji(),!1}if(et)return e=re.current,e!==null?((e.flags&65536)===0&&(e.flags|=256),e.flags|=65536,e.lanes=n,a!==Zu&&(t=Error(s(422),{cause:a}),Wa(Se(t,l)))):(a!==Zu&&(e=Error(s(423),{cause:a}),Wa(Se(e,l))),t=t.current.alternate,t.flags|=65536,n&=-n,t.lanes|=n,a=Se(a,l),n=zc(t.stateNode,a,n),lc(t,n),_t!==4&&(_t=2)),!1;var i=Error(s(520),{cause:a});if(i=Se(i,l),pn===null?pn=[i]:pn.push(i),_t!==4&&(_t=2),e===null)return!0;a=Se(a,l),l=e;do{switch(l.tag){case 3:return l.flags|=65536,t=n&-n,l.lanes|=t,t=zc(l.stateNode,a,t),lc(l,t),!1;case 1:if(e=l.type,i=l.stateNode,(l.flags&128)===0&&(typeof e.getDerivedStateFromError=="function"||i!==null&&typeof i.componentDidCatch=="function"&&(Sl===null||!Sl.has(i))))return l.flags|=65536,n&=-n,l.lanes|=n,n=ao(n),no(n,t,l,a),lc(l,n),!1}l=l.return}while(l!==null);return!1}var Nc=Error(s(461)),jt=!1;function Xt(t,e,l,a){e.child=t===null?sr(e,null,l,a):Vl(e,t.child,l,a)}function io(t,e,l,a,n){l=l.render;var i=e.ref;if("ref"in a){var f={};for(var o in a)o!=="ref"&&(f[o]=a[o])}else f=a;return Xl(e),a=sc(t,e,l,f,i,n),o=fc(),t!==null&&!jt?(rc(t,e,n),ke(t,e,n)):(et&&o&&wu(e),e.flags|=1,Xt(t,e,a,n),e.child)}function uo(t,e,l,a,n){if(t===null){var i=l.type;return typeof i=="function"&&!Xu(i)&&i.defaultProps===void 0&&l.compare===null?(e.tag=15,e.type=i,co(t,e,i,a,n)):(t=In(l.type,null,a,e,e.mode,n),t.ref=e.ref,t.return=e,e.child=t)}if(i=t.child,!Bc(t,n)){var f=i.memoizedProps;if(l=l.compare,l=l!==null?l:Ja,l(f,a)&&t.ref===e.ref)return ke(t,e,n)}return e.flags|=1,t=Ge(i,a),t.ref=e.ref,t.return=e,e.child=t}function co(t,e,l,a,n){if(t!==null){var i=t.memoizedProps;if(Ja(i,a)&&t.ref===e.ref)if(jt=!1,e.pendingProps=a=i,Bc(t,n))(t.flags&131072)!==0&&(jt=!0);else return e.lanes=t.lanes,ke(t,e,n)}return Oc(t,e,l,a,n)}function so(t,e,l,a){var n=a.children,i=t!==null?t.memoizedState:null;if(t===null&&e.stateNode===null&&(e.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),a.mode==="hidden"){if((e.flags&128)!==0){if(i=i!==null?i.baseLanes|l:l,t!==null){for(a=e.child=t.child,n=0;a!==null;)n=n|a.lanes|a.childLanes,a=a.sibling;a=n&~i}else a=0,e.child=null;return fo(t,e,i,l,a)}if((l&536870912)!==0)e.memoizedState={baseLanes:0,cachePool:null},t!==null&&li(e,i!==null?i.cachePool:null),i!==null?or(e,i):nc(),hr(e);else return a=e.lanes=536870912,fo(t,e,i!==null?i.baseLanes|l:l,l,a)}else i!==null?(li(e,i.cachePool),or(e,i),yl(),e.memoizedState=null):(t!==null&&li(e,null),nc(),yl());return Xt(t,e,n,l),e.child}function fn(t,e){return t!==null&&t.tag===22||e.stateNode!==null||(e.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),e.sibling}function fo(t,e,l,a,n){var i=Iu();return i=i===null?null:{parent:Nt._currentValue,pool:i},e.memoizedState={baseLanes:l,cachePool:i},t!==null&&li(e,null),nc(),hr(e),t!==null&&ha(t,e,a,!0),e.childLanes=n,null}function gi(t,e){return e=bi({mode:e.mode,children:e.children},t.mode),e.ref=t.ref,t.child=e,e.return=t,e}function ro(t,e,l){return Vl(e,t.child,null,l),t=gi(e,e.pendingProps),t.flags|=2,oe(e),e.memoizedState=null,t}function Zm(t,e,l){var a=e.pendingProps,n=(e.flags&128)!==0;if(e.flags&=-129,t===null){if(et){if(a.mode==="hidden")return t=gi(e,a),e.lanes=536870912,fn(null,t);if(uc(e),(t=vt)?(t=Eh(t,_e),t=t!==null&&t.data==="&"?t:null,t!==null&&(e.memoizedState={dehydrated:t,treeContext:cl!==null?{id:Me,overflow:Re}:null,retryLane:536870912,hydrationErrors:null},l=Jf(t),l.return=e,e.child=l,Yt=e,vt=null)):t=null,t===null)throw fl(e);return e.lanes=536870912,null}return gi(e,a)}var i=t.memoizedState;if(i!==null){var f=i.dehydrated;if(uc(e),n)if(e.flags&256)e.flags&=-257,e=ro(t,e,l);else if(e.memoizedState!==null)e.child=t.child,e.flags|=128,e=null;else throw Error(s(558));else if(jt||ha(t,e,l,!1),n=(l&t.childLanes)!==0,jt||n){if(a=yt,a!==null&&(f=Ps(a,l),f!==0&&f!==i.retryLane))throw i.retryLane=f,ql(t,f),ne(a,t,f),Nc;ji(),e=ro(t,e,l)}else t=i.treeContext,vt=Te(f.nextSibling),Yt=e,et=!0,sl=null,_e=!1,t!==null&&Wf(e,t),e=gi(e,a),e.flags|=4096;return e}return t=Ge(t.child,{mode:a.mode,children:a.children}),t.ref=e.ref,e.child=t,t.return=e,t}function Si(t,e){var l=e.ref;if(l===null)t!==null&&t.ref!==null&&(e.flags|=4194816);else{if(typeof l!="function"&&typeof l!="object")throw Error(s(284));(t===null||t.ref!==l)&&(e.flags|=4194816)}}function Oc(t,e,l,a,n){return Xl(e),l=sc(t,e,l,a,void 0,n),a=fc(),t!==null&&!jt?(rc(t,e,n),ke(t,e,n)):(et&&a&&wu(e),e.flags|=1,Xt(t,e,l,n),e.child)}function oo(t,e,l,a,n,i){return Xl(e),e.updateQueue=null,l=mr(e,a,l,n),dr(t),a=fc(),t!==null&&!jt?(rc(t,e,i),ke(t,e,i)):(et&&a&&wu(e),e.flags|=1,Xt(t,e,l,i),e.child)}function ho(t,e,l,a,n){if(Xl(e),e.stateNode===null){var i=sa,f=l.contextType;typeof f=="object"&&f!==null&&(i=Lt(f)),i=new l(a,i),e.memoizedState=i.state!==null&&i.state!==void 0?i.state:null,i.updater=Ac,e.stateNode=i,i._reactInternals=e,i=e.stateNode,i.props=a,i.state=e.memoizedState,i.refs={},tc(e),f=l.contextType,i.context=typeof f=="object"&&f!==null?Lt(f):sa,i.state=e.memoizedState,f=l.getDerivedStateFromProps,typeof f=="function"&&(Tc(e,l,f,a),i.state=e.memoizedState),typeof l.getDerivedStateFromProps=="function"||typeof i.getSnapshotBeforeUpdate=="function"||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(f=i.state,typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount(),f!==i.state&&Ac.enqueueReplaceState(i,i.state,null),an(e,a,i,n),ln(),i.state=e.memoizedState),typeof i.componentDidMount=="function"&&(e.flags|=4194308),a=!0}else if(t===null){i=e.stateNode;var o=e.memoizedProps,m=Kl(l,o);i.props=m;var S=i.context,A=l.contextType;f=sa,typeof A=="object"&&A!==null&&(f=Lt(A));var O=l.getDerivedStateFromProps;A=typeof O=="function"||typeof i.getSnapshotBeforeUpdate=="function",o=e.pendingProps!==o,A||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(o||S!==f)&&Ir(e,i,a,f),ol=!1;var b=e.memoizedState;i.state=b,an(e,a,i,n),ln(),S=e.memoizedState,o||b!==S||ol?(typeof O=="function"&&(Tc(e,l,O,a),S=e.memoizedState),(m=ol||Fr(e,l,m,a,b,S,f))?(A||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount()),typeof i.componentDidMount=="function"&&(e.flags|=4194308)):(typeof i.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=a,e.memoizedState=S),i.props=a,i.state=S,i.context=f,a=m):(typeof i.componentDidMount=="function"&&(e.flags|=4194308),a=!1)}else{i=e.stateNode,ec(t,e),f=e.memoizedProps,A=Kl(l,f),i.props=A,O=e.pendingProps,b=i.context,S=l.contextType,m=sa,typeof S=="object"&&S!==null&&(m=Lt(S)),o=l.getDerivedStateFromProps,(S=typeof o=="function"||typeof i.getSnapshotBeforeUpdate=="function")||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(f!==O||b!==m)&&Ir(e,i,a,m),ol=!1,b=e.memoizedState,i.state=b,an(e,a,i,n),ln();var _=e.memoizedState;f!==O||b!==_||ol||t!==null&&t.dependencies!==null&&ti(t.dependencies)?(typeof o=="function"&&(Tc(e,l,o,a),_=e.memoizedState),(A=ol||Fr(e,l,A,a,b,_,m)||t!==null&&t.dependencies!==null&&ti(t.dependencies))?(S||typeof i.UNSAFE_componentWillUpdate!="function"&&typeof i.componentWillUpdate!="function"||(typeof i.componentWillUpdate=="function"&&i.componentWillUpdate(a,_,m),typeof i.UNSAFE_componentWillUpdate=="function"&&i.UNSAFE_componentWillUpdate(a,_,m)),typeof i.componentDidUpdate=="function"&&(e.flags|=4),typeof i.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof i.componentDidUpdate!="function"||f===t.memoizedProps&&b===t.memoizedState||(e.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||f===t.memoizedProps&&b===t.memoizedState||(e.flags|=1024),e.memoizedProps=a,e.memoizedState=_),i.props=a,i.state=_,i.context=m,a=A):(typeof i.componentDidUpdate!="function"||f===t.memoizedProps&&b===t.memoizedState||(e.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||f===t.memoizedProps&&b===t.memoizedState||(e.flags|=1024),a=!1)}return i=a,Si(t,e),a=(e.flags&128)!==0,i||a?(i=e.stateNode,l=a&&typeof l.getDerivedStateFromError!="function"?null:i.render(),e.flags|=1,t!==null&&a?(e.child=Vl(e,t.child,null,n),e.child=Vl(e,null,l,n)):Xt(t,e,l,n),e.memoizedState=i.state,t=e.child):t=ke(t,e,n),t}function mo(t,e,l,a){return Yl(),e.flags|=256,Xt(t,e,l,a),e.child}var jc={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Cc(t){return{baseLanes:t,cachePool:lr()}}function Dc(t,e,l){return t=t!==null?t.childLanes&~l:0,e&&(t|=de),t}function yo(t,e,l){var a=e.pendingProps,n=!1,i=(e.flags&128)!==0,f;if((f=i)||(f=t!==null&&t.memoizedState===null?!1:(At.current&2)!==0),f&&(n=!0,e.flags&=-129),f=(e.flags&32)!==0,e.flags&=-33,t===null){if(et){if(n?ml(e):yl(),(t=vt)?(t=Eh(t,_e),t=t!==null&&t.data!=="&"?t:null,t!==null&&(e.memoizedState={dehydrated:t,treeContext:cl!==null?{id:Me,overflow:Re}:null,retryLane:536870912,hydrationErrors:null},l=Jf(t),l.return=e,e.child=l,Yt=e,vt=null)):t=null,t===null)throw fl(e);return ds(t)?e.lanes=32:e.lanes=536870912,null}var o=a.children;return a=a.fallback,n?(yl(),n=e.mode,o=bi({mode:"hidden",children:o},n),a=Hl(a,n,l,null),o.return=e,a.return=e,o.sibling=a,e.child=o,a=e.child,a.memoizedState=Cc(l),a.childLanes=Dc(t,f,l),e.memoizedState=jc,fn(null,a)):(ml(e),Mc(e,o))}var m=t.memoizedState;if(m!==null&&(o=m.dehydrated,o!==null)){if(i)e.flags&256?(ml(e),e.flags&=-257,e=Rc(t,e,l)):e.memoizedState!==null?(yl(),e.child=t.child,e.flags|=128,e=null):(yl(),o=a.fallback,n=e.mode,a=bi({mode:"visible",children:a.children},n),o=Hl(o,n,l,null),o.flags|=2,a.return=e,o.return=e,a.sibling=o,e.child=a,Vl(e,t.child,null,l),a=e.child,a.memoizedState=Cc(l),a.childLanes=Dc(t,f,l),e.memoizedState=jc,e=fn(null,a));else if(ml(e),ds(o)){if(f=o.nextSibling&&o.nextSibling.dataset,f)var S=f.dgst;f=S,a=Error(s(419)),a.stack="",a.digest=f,Wa({value:a,source:null,stack:null}),e=Rc(t,e,l)}else if(jt||ha(t,e,l,!1),f=(l&t.childLanes)!==0,jt||f){if(f=yt,f!==null&&(a=Ps(f,l),a!==0&&a!==m.retryLane))throw m.retryLane=a,ql(t,a),ne(f,t,a),Nc;hs(o)||ji(),e=Rc(t,e,l)}else hs(o)?(e.flags|=192,e.child=t.child,e=null):(t=m.treeContext,vt=Te(o.nextSibling),Yt=e,et=!0,sl=null,_e=!1,t!==null&&Wf(e,t),e=Mc(e,a.children),e.flags|=4096);return e}return n?(yl(),o=a.fallback,n=e.mode,m=t.child,S=m.sibling,a=Ge(m,{mode:"hidden",children:a.children}),a.subtreeFlags=m.subtreeFlags&65011712,S!==null?o=Ge(S,o):(o=Hl(o,n,l,null),o.flags|=2),o.return=e,a.return=e,a.sibling=o,e.child=a,fn(null,a),a=e.child,o=t.child.memoizedState,o===null?o=Cc(l):(n=o.cachePool,n!==null?(m=Nt._currentValue,n=n.parent!==m?{parent:m,pool:m}:n):n=lr(),o={baseLanes:o.baseLanes|l,cachePool:n}),a.memoizedState=o,a.childLanes=Dc(t,f,l),e.memoizedState=jc,fn(t.child,a)):(ml(e),l=t.child,t=l.sibling,l=Ge(l,{mode:"visible",children:a.children}),l.return=e,l.sibling=null,t!==null&&(f=e.deletions,f===null?(e.deletions=[t],e.flags|=16):f.push(t)),e.child=l,e.memoizedState=null,l)}function Mc(t,e){return e=bi({mode:"visible",children:e},t.mode),e.return=t,t.child=e}function bi(t,e){return t=fe(22,t,null,e),t.lanes=0,t}function Rc(t,e,l){return Vl(e,t.child,null,l),t=Mc(e,e.pendingProps.children),t.flags|=2,e.memoizedState=null,t}function po(t,e,l){t.lanes|=e;var a=t.alternate;a!==null&&(a.lanes|=e),ku(t.return,e,l)}function Uc(t,e,l,a,n,i){var f=t.memoizedState;f===null?t.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:a,tail:l,tailMode:n,treeForkCount:i}:(f.isBackwards=e,f.rendering=null,f.renderingStartTime=0,f.last=a,f.tail=l,f.tailMode=n,f.treeForkCount=i)}function vo(t,e,l){var a=e.pendingProps,n=a.revealOrder,i=a.tail;a=a.children;var f=At.current,o=(f&2)!==0;if(o?(f=f&1|2,e.flags|=128):f&=1,U(At,f),Xt(t,e,a,l),a=et?$a:0,!o&&t!==null&&(t.flags&128)!==0)t:for(t=e.child;t!==null;){if(t.tag===13)t.memoizedState!==null&&po(t,l,e);else if(t.tag===19)po(t,l,e);else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break t;for(;t.sibling===null;){if(t.return===null||t.return===e)break t;t=t.return}t.sibling.return=t.return,t=t.sibling}switch(n){case"forwards":for(l=e.child,n=null;l!==null;)t=l.alternate,t!==null&&si(t)===null&&(n=l),l=l.sibling;l=n,l===null?(n=e.child,e.child=null):(n=l.sibling,l.sibling=null),Uc(e,!1,n,l,i,a);break;case"backwards":case"unstable_legacy-backwards":for(l=null,n=e.child,e.child=null;n!==null;){if(t=n.alternate,t!==null&&si(t)===null){e.child=n;break}t=n.sibling,n.sibling=l,l=n,n=t}Uc(e,!0,l,null,i,a);break;case"together":Uc(e,!1,null,null,void 0,a);break;default:e.memoizedState=null}return e.child}function ke(t,e,l){if(t!==null&&(e.dependencies=t.dependencies),gl|=e.lanes,(l&e.childLanes)===0)if(t!==null){if(ha(t,e,l,!1),(l&e.childLanes)===0)return null}else return null;if(t!==null&&e.child!==t.child)throw Error(s(153));if(e.child!==null){for(t=e.child,l=Ge(t,t.pendingProps),e.child=l,l.return=e;t.sibling!==null;)t=t.sibling,l=l.sibling=Ge(t,t.pendingProps),l.return=e;l.sibling=null}return e.child}function Bc(t,e){return(t.lanes&e)!==0?!0:(t=t.dependencies,!!(t!==null&&ti(t)))}function Km(t,e,l){switch(e.tag){case 3:$t(e,e.stateNode.containerInfo),rl(e,Nt,t.memoizedState.cache),Yl();break;case 27:case 5:Ua(e);break;case 4:$t(e,e.stateNode.containerInfo);break;case 10:rl(e,e.type,e.memoizedProps.value);break;case 31:if(e.memoizedState!==null)return e.flags|=128,uc(e),null;break;case 13:var a=e.memoizedState;if(a!==null)return a.dehydrated!==null?(ml(e),e.flags|=128,null):(l&e.child.childLanes)!==0?yo(t,e,l):(ml(e),t=ke(t,e,l),t!==null?t.sibling:null);ml(e);break;case 19:var n=(t.flags&128)!==0;if(a=(l&e.childLanes)!==0,a||(ha(t,e,l,!1),a=(l&e.childLanes)!==0),n){if(a)return vo(t,e,l);e.flags|=128}if(n=e.memoizedState,n!==null&&(n.rendering=null,n.tail=null,n.lastEffect=null),U(At,At.current),a)break;return null;case 22:return e.lanes=0,so(t,e,l,e.pendingProps);case 24:rl(e,Nt,t.memoizedState.cache)}return ke(t,e,l)}function go(t,e,l){if(t!==null)if(t.memoizedProps!==e.pendingProps)jt=!0;else{if(!Bc(t,l)&&(e.flags&128)===0)return jt=!1,Km(t,e,l);jt=(t.flags&131072)!==0}else jt=!1,et&&(e.flags&1048576)!==0&&$f(e,$a,e.index);switch(e.lanes=0,e.tag){case 16:t:{var a=e.pendingProps;if(t=Gl(e.elementType),e.type=t,typeof t=="function")Xu(t)?(a=Kl(t,a),e.tag=1,e=ho(null,e,t,a,l)):(e.tag=0,e=Oc(null,e,t,a,l));else{if(t!=null){var n=t.$$typeof;if(n===Jt){e.tag=11,e=io(null,e,t,a,l);break t}else if(n===W){e.tag=14,e=uo(null,e,t,a,l);break t}}throw e=Ne(t)||t,Error(s(306,e,""))}}return e;case 0:return Oc(t,e,e.type,e.pendingProps,l);case 1:return a=e.type,n=Kl(a,e.pendingProps),ho(t,e,a,n,l);case 3:t:{if($t(e,e.stateNode.containerInfo),t===null)throw Error(s(387));a=e.pendingProps;var i=e.memoizedState;n=i.element,ec(t,e),an(e,a,null,l);var f=e.memoizedState;if(a=f.cache,rl(e,Nt,a),a!==i.cache&&$u(e,[Nt],l,!0),ln(),a=f.element,i.isDehydrated)if(i={element:a,isDehydrated:!1,cache:f.cache},e.updateQueue.baseState=i,e.memoizedState=i,e.flags&256){e=mo(t,e,a,l);break t}else if(a!==n){n=Se(Error(s(424)),e),Wa(n),e=mo(t,e,a,l);break t}else for(t=e.stateNode.containerInfo,t.nodeType===9?t=t.body:t=t.nodeName==="HTML"?t.ownerDocument.body:t,vt=Te(t.firstChild),Yt=e,et=!0,sl=null,_e=!0,l=sr(e,null,a,l),e.child=l;l;)l.flags=l.flags&-3|4096,l=l.sibling;else{if(Yl(),a===n){e=ke(t,e,l);break t}Xt(t,e,a,l)}e=e.child}return e;case 26:return Si(t,e),t===null?(l=jh(e.type,null,e.pendingProps,null))?e.memoizedState=l:et||(l=e.type,t=e.pendingProps,a=qi(Z.current).createElement(l),a[Ht]=e,a[It]=t,Qt(a,l,t),Ut(a),e.stateNode=a):e.memoizedState=jh(e.type,t.memoizedProps,e.pendingProps,t.memoizedState),null;case 27:return Ua(e),t===null&&et&&(a=e.stateNode=zh(e.type,e.pendingProps,Z.current),Yt=e,_e=!0,n=vt,El(e.type)?(ms=n,vt=Te(a.firstChild)):vt=n),Xt(t,e,e.pendingProps.children,l),Si(t,e),t===null&&(e.flags|=4194304),e.child;case 5:return t===null&&et&&((n=a=vt)&&(a=_y(a,e.type,e.pendingProps,_e),a!==null?(e.stateNode=a,Yt=e,vt=Te(a.firstChild),_e=!1,n=!0):n=!1),n||fl(e)),Ua(e),n=e.type,i=e.pendingProps,f=t!==null?t.memoizedProps:null,a=i.children,fs(n,i)?a=null:f!==null&&fs(n,f)&&(e.flags|=32),e.memoizedState!==null&&(n=sc(t,e,Hm,null,null,l),Tn._currentValue=n),Si(t,e),Xt(t,e,a,l),e.child;case 6:return t===null&&et&&((t=l=vt)&&(l=Ey(l,e.pendingProps,_e),l!==null?(e.stateNode=l,Yt=e,vt=null,t=!0):t=!1),t||fl(e)),null;case 13:return yo(t,e,l);case 4:return $t(e,e.stateNode.containerInfo),a=e.pendingProps,t===null?e.child=Vl(e,null,a,l):Xt(t,e,a,l),e.child;case 11:return io(t,e,e.type,e.pendingProps,l);case 7:return Xt(t,e,e.pendingProps,l),e.child;case 8:return Xt(t,e,e.pendingProps.children,l),e.child;case 12:return Xt(t,e,e.pendingProps.children,l),e.child;case 10:return a=e.pendingProps,rl(e,e.type,a.value),Xt(t,e,a.children,l),e.child;case 9:return n=e.type._context,a=e.pendingProps.children,Xl(e),n=Lt(n),a=a(n),e.flags|=1,Xt(t,e,a,l),e.child;case 14:return uo(t,e,e.type,e.pendingProps,l);case 15:return co(t,e,e.type,e.pendingProps,l);case 19:return vo(t,e,l);case 31:return Zm(t,e,l);case 22:return so(t,e,l,e.pendingProps);case 24:return Xl(e),a=Lt(Nt),t===null?(n=Iu(),n===null&&(n=yt,i=Wu(),n.pooledCache=i,i.refCount++,i!==null&&(n.pooledCacheLanes|=l),n=i),e.memoizedState={parent:a,cache:n},tc(e),rl(e,Nt,n)):((t.lanes&l)!==0&&(ec(t,e),an(e,null,null,l),ln()),n=t.memoizedState,i=e.memoizedState,n.parent!==a?(n={parent:a,cache:a},e.memoizedState=n,e.lanes===0&&(e.memoizedState=e.updateQueue.baseState=n),rl(e,Nt,a)):(a=i.cache,rl(e,Nt,a),a!==n.cache&&$u(e,[Nt],l,!0))),Xt(t,e,e.pendingProps.children,l),e.child;case 29:throw e.pendingProps}throw Error(s(156,e.tag))}function $e(t){t.flags|=4}function qc(t,e,l,a,n){if((e=(t.mode&32)!==0)&&(e=!1),e){if(t.flags|=16777216,(n&335544128)===n)if(t.stateNode.complete)t.flags|=8192;else if(Zo())t.flags|=8192;else throw wl=ni,Pu}else t.flags&=-16777217}function So(t,e){if(e.type!=="stylesheet"||(e.state.loading&4)!==0)t.flags&=-16777217;else if(t.flags|=16777216,!Uh(e))if(Zo())t.flags|=8192;else throw wl=ni,Pu}function xi(t,e){e!==null&&(t.flags|=4),t.flags&16384&&(e=t.tag!==22?Ws():536870912,t.lanes|=e,Ta|=e)}function rn(t,e){if(!et)switch(t.tailMode){case"hidden":e=t.tail;for(var l=null;e!==null;)e.alternate!==null&&(l=e),e=e.sibling;l===null?t.tail=null:l.sibling=null;break;case"collapsed":l=t.tail;for(var a=null;l!==null;)l.alternate!==null&&(a=l),l=l.sibling;a===null?e||t.tail===null?t.tail=null:t.tail.sibling=null:a.sibling=null}}function gt(t){var e=t.alternate!==null&&t.alternate.child===t.child,l=0,a=0;if(e)for(var n=t.child;n!==null;)l|=n.lanes|n.childLanes,a|=n.subtreeFlags&65011712,a|=n.flags&65011712,n.return=t,n=n.sibling;else for(n=t.child;n!==null;)l|=n.lanes|n.childLanes,a|=n.subtreeFlags,a|=n.flags,n.return=t,n=n.sibling;return t.subtreeFlags|=a,t.childLanes=l,e}function Jm(t,e,l){var a=e.pendingProps;switch(Vu(e),e.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return gt(e),null;case 1:return gt(e),null;case 3:return l=e.stateNode,a=null,t!==null&&(a=t.memoizedState.cache),e.memoizedState.cache!==a&&(e.flags|=2048),Ze(Nt),Tt(),l.pendingContext&&(l.context=l.pendingContext,l.pendingContext=null),(t===null||t.child===null)&&(oa(e)?$e(e):t===null||t.memoizedState.isDehydrated&&(e.flags&256)===0||(e.flags|=1024,Ku())),gt(e),null;case 26:var n=e.type,i=e.memoizedState;return t===null?($e(e),i!==null?(gt(e),So(e,i)):(gt(e),qc(e,n,null,a,l))):i?i!==t.memoizedState?($e(e),gt(e),So(e,i)):(gt(e),e.flags&=-16777217):(t=t.memoizedProps,t!==a&&$e(e),gt(e),qc(e,n,t,a,l)),null;case 27:if(Mn(e),l=Z.current,n=e.type,t!==null&&e.stateNode!=null)t.memoizedProps!==a&&$e(e);else{if(!a){if(e.stateNode===null)throw Error(s(166));return gt(e),null}t=q.current,oa(e)?Ff(e):(t=zh(n,a,l),e.stateNode=t,$e(e))}return gt(e),null;case 5:if(Mn(e),n=e.type,t!==null&&e.stateNode!=null)t.memoizedProps!==a&&$e(e);else{if(!a){if(e.stateNode===null)throw Error(s(166));return gt(e),null}if(i=q.current,oa(e))Ff(e);else{var f=qi(Z.current);switch(i){case 1:i=f.createElementNS("http://www.w3.org/2000/svg",n);break;case 2:i=f.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;default:switch(n){case"svg":i=f.createElementNS("http://www.w3.org/2000/svg",n);break;case"math":i=f.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;case"script":i=f.createElement("div"),i.innerHTML="<script><\/script>",i=i.removeChild(i.firstChild);break;case"select":i=typeof a.is=="string"?f.createElement("select",{is:a.is}):f.createElement("select"),a.multiple?i.multiple=!0:a.size&&(i.size=a.size);break;default:i=typeof a.is=="string"?f.createElement(n,{is:a.is}):f.createElement(n)}}i[Ht]=e,i[It]=a;t:for(f=e.child;f!==null;){if(f.tag===5||f.tag===6)i.appendChild(f.stateNode);else if(f.tag!==4&&f.tag!==27&&f.child!==null){f.child.return=f,f=f.child;continue}if(f===e)break t;for(;f.sibling===null;){if(f.return===null||f.return===e)break t;f=f.return}f.sibling.return=f.return,f=f.sibling}e.stateNode=i;t:switch(Qt(i,n,a),n){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break t;case"img":a=!0;break t;default:a=!1}a&&$e(e)}}return gt(e),qc(e,e.type,t===null?null:t.memoizedProps,e.pendingProps,l),null;case 6:if(t&&e.stateNode!=null)t.memoizedProps!==a&&$e(e);else{if(typeof a!="string"&&e.stateNode===null)throw Error(s(166));if(t=Z.current,oa(e)){if(t=e.stateNode,l=e.memoizedProps,a=null,n=Yt,n!==null)switch(n.tag){case 27:case 5:a=n.memoizedProps}t[Ht]=e,t=!!(t.nodeValue===l||a!==null&&a.suppressHydrationWarning===!0||yh(t.nodeValue,l)),t||fl(e,!0)}else t=qi(t).createTextNode(a),t[Ht]=e,e.stateNode=t}return gt(e),null;case 31:if(l=e.memoizedState,t===null||t.memoizedState!==null){if(a=oa(e),l!==null){if(t===null){if(!a)throw Error(s(318));if(t=e.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(s(557));t[Ht]=e}else Yl(),(e.flags&128)===0&&(e.memoizedState=null),e.flags|=4;gt(e),t=!1}else l=Ku(),t!==null&&t.memoizedState!==null&&(t.memoizedState.hydrationErrors=l),t=!0;if(!t)return e.flags&256?(oe(e),e):(oe(e),null);if((e.flags&128)!==0)throw Error(s(558))}return gt(e),null;case 13:if(a=e.memoizedState,t===null||t.memoizedState!==null&&t.memoizedState.dehydrated!==null){if(n=oa(e),a!==null&&a.dehydrated!==null){if(t===null){if(!n)throw Error(s(318));if(n=e.memoizedState,n=n!==null?n.dehydrated:null,!n)throw Error(s(317));n[Ht]=e}else Yl(),(e.flags&128)===0&&(e.memoizedState=null),e.flags|=4;gt(e),n=!1}else n=Ku(),t!==null&&t.memoizedState!==null&&(t.memoizedState.hydrationErrors=n),n=!0;if(!n)return e.flags&256?(oe(e),e):(oe(e),null)}return oe(e),(e.flags&128)!==0?(e.lanes=l,e):(l=a!==null,t=t!==null&&t.memoizedState!==null,l&&(a=e.child,n=null,a.alternate!==null&&a.alternate.memoizedState!==null&&a.alternate.memoizedState.cachePool!==null&&(n=a.alternate.memoizedState.cachePool.pool),i=null,a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(i=a.memoizedState.cachePool.pool),i!==n&&(a.flags|=2048)),l!==t&&l&&(e.child.flags|=8192),xi(e,e.updateQueue),gt(e),null);case 4:return Tt(),t===null&&ns(e.stateNode.containerInfo),gt(e),null;case 10:return Ze(e.type),gt(e),null;case 19:if(E(At),a=e.memoizedState,a===null)return gt(e),null;if(n=(e.flags&128)!==0,i=a.rendering,i===null)if(n)rn(a,!1);else{if(_t!==0||t!==null&&(t.flags&128)!==0)for(t=e.child;t!==null;){if(i=si(t),i!==null){for(e.flags|=128,rn(a,!1),t=i.updateQueue,e.updateQueue=t,xi(e,t),e.subtreeFlags=0,t=l,l=e.child;l!==null;)Kf(l,t),l=l.sibling;return U(At,At.current&1|2),et&&we(e,a.treeForkCount),e.child}t=t.sibling}a.tail!==null&&ie()>zi&&(e.flags|=128,n=!0,rn(a,!1),e.lanes=4194304)}else{if(!n)if(t=si(i),t!==null){if(e.flags|=128,n=!0,t=t.updateQueue,e.updateQueue=t,xi(e,t),rn(a,!0),a.tail===null&&a.tailMode==="hidden"&&!i.alternate&&!et)return gt(e),null}else 2*ie()-a.renderingStartTime>zi&&l!==536870912&&(e.flags|=128,n=!0,rn(a,!1),e.lanes=4194304);a.isBackwards?(i.sibling=e.child,e.child=i):(t=a.last,t!==null?t.sibling=i:e.child=i,a.last=i)}return a.tail!==null?(t=a.tail,a.rendering=t,a.tail=t.sibling,a.renderingStartTime=ie(),t.sibling=null,l=At.current,U(At,n?l&1|2:l&1),et&&we(e,a.treeForkCount),t):(gt(e),null);case 22:case 23:return oe(e),ic(),a=e.memoizedState!==null,t!==null?t.memoizedState!==null!==a&&(e.flags|=8192):a&&(e.flags|=8192),a?(l&536870912)!==0&&(e.flags&128)===0&&(gt(e),e.subtreeFlags&6&&(e.flags|=8192)):gt(e),l=e.updateQueue,l!==null&&xi(e,l.retryQueue),l=null,t!==null&&t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(l=t.memoizedState.cachePool.pool),a=null,e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(a=e.memoizedState.cachePool.pool),a!==l&&(e.flags|=2048),t!==null&&E(Ql),null;case 24:return l=null,t!==null&&(l=t.memoizedState.cache),e.memoizedState.cache!==l&&(e.flags|=2048),Ze(Nt),gt(e),null;case 25:return null;case 30:return null}throw Error(s(156,e.tag))}function km(t,e){switch(Vu(e),e.tag){case 1:return t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 3:return Ze(Nt),Tt(),t=e.flags,(t&65536)!==0&&(t&128)===0?(e.flags=t&-65537|128,e):null;case 26:case 27:case 5:return Mn(e),null;case 31:if(e.memoizedState!==null){if(oe(e),e.alternate===null)throw Error(s(340));Yl()}return t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 13:if(oe(e),t=e.memoizedState,t!==null&&t.dehydrated!==null){if(e.alternate===null)throw Error(s(340));Yl()}return t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 19:return E(At),null;case 4:return Tt(),null;case 10:return Ze(e.type),null;case 22:case 23:return oe(e),ic(),t!==null&&E(Ql),t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 24:return Ze(Nt),null;case 25:return null;default:return null}}function bo(t,e){switch(Vu(e),e.tag){case 3:Ze(Nt),Tt();break;case 26:case 27:case 5:Mn(e);break;case 4:Tt();break;case 31:e.memoizedState!==null&&oe(e);break;case 13:oe(e);break;case 19:E(At);break;case 10:Ze(e.type);break;case 22:case 23:oe(e),ic(),t!==null&&E(Ql);break;case 24:Ze(Nt)}}function on(t,e){try{var l=e.updateQueue,a=l!==null?l.lastEffect:null;if(a!==null){var n=a.next;l=n;do{if((l.tag&t)===t){a=void 0;var i=l.create,f=l.inst;a=i(),f.destroy=a}l=l.next}while(l!==n)}}catch(o){rt(e,e.return,o)}}function pl(t,e,l){try{var a=e.updateQueue,n=a!==null?a.lastEffect:null;if(n!==null){var i=n.next;a=i;do{if((a.tag&t)===t){var f=a.inst,o=f.destroy;if(o!==void 0){f.destroy=void 0,n=e;var m=l,S=o;try{S()}catch(A){rt(n,m,A)}}}a=a.next}while(a!==i)}}catch(A){rt(e,e.return,A)}}function xo(t){var e=t.updateQueue;if(e!==null){var l=t.stateNode;try{rr(e,l)}catch(a){rt(t,t.return,a)}}}function _o(t,e,l){l.props=Kl(t.type,t.memoizedProps),l.state=t.memoizedState;try{l.componentWillUnmount()}catch(a){rt(t,e,a)}}function hn(t,e){try{var l=t.ref;if(l!==null){switch(t.tag){case 26:case 27:case 5:var a=t.stateNode;break;case 30:a=t.stateNode;break;default:a=t.stateNode}typeof l=="function"?t.refCleanup=l(a):l.current=a}}catch(n){rt(t,e,n)}}function Ue(t,e){var l=t.ref,a=t.refCleanup;if(l!==null)if(typeof a=="function")try{a()}catch(n){rt(t,e,n)}finally{t.refCleanup=null,t=t.alternate,t!=null&&(t.refCleanup=null)}else if(typeof l=="function")try{l(null)}catch(n){rt(t,e,n)}else l.current=null}function Eo(t){var e=t.type,l=t.memoizedProps,a=t.stateNode;try{t:switch(e){case"button":case"input":case"select":case"textarea":l.autoFocus&&a.focus();break t;case"img":l.src?a.src=l.src:l.srcSet&&(a.srcset=l.srcSet)}}catch(n){rt(t,t.return,n)}}function Hc(t,e,l){try{var a=t.stateNode;py(a,t.type,l,e),a[It]=e}catch(n){rt(t,t.return,n)}}function To(t){return t.tag===5||t.tag===3||t.tag===26||t.tag===27&&El(t.type)||t.tag===4}function Yc(t){t:for(;;){for(;t.sibling===null;){if(t.return===null||To(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;t.tag!==5&&t.tag!==6&&t.tag!==18;){if(t.tag===27&&El(t.type)||t.flags&2||t.child===null||t.tag===4)continue t;t.child.return=t,t=t.child}if(!(t.flags&2))return t.stateNode}}function Lc(t,e,l){var a=t.tag;if(a===5||a===6)t=t.stateNode,e?(l.nodeType===9?l.body:l.nodeName==="HTML"?l.ownerDocument.body:l).insertBefore(t,e):(e=l.nodeType===9?l.body:l.nodeName==="HTML"?l.ownerDocument.body:l,e.appendChild(t),l=l._reactRootContainer,l!=null||e.onclick!==null||(e.onclick=Xe));else if(a!==4&&(a===27&&El(t.type)&&(l=t.stateNode,e=null),t=t.child,t!==null))for(Lc(t,e,l),t=t.sibling;t!==null;)Lc(t,e,l),t=t.sibling}function _i(t,e,l){var a=t.tag;if(a===5||a===6)t=t.stateNode,e?l.insertBefore(t,e):l.appendChild(t);else if(a!==4&&(a===27&&El(t.type)&&(l=t.stateNode),t=t.child,t!==null))for(_i(t,e,l),t=t.sibling;t!==null;)_i(t,e,l),t=t.sibling}function Ao(t){var e=t.stateNode,l=t.memoizedProps;try{for(var a=t.type,n=e.attributes;n.length;)e.removeAttributeNode(n[0]);Qt(e,a,l),e[Ht]=t,e[It]=l}catch(i){rt(t,t.return,i)}}var We=!1,Ct=!1,Xc=!1,zo=typeof WeakSet=="function"?WeakSet:Set,Bt=null;function $m(t,e){if(t=t.containerInfo,cs=wi,t=Hf(t),Ru(t)){if("selectionStart"in t)var l={start:t.selectionStart,end:t.selectionEnd};else t:{l=(l=t.ownerDocument)&&l.defaultView||window;var a=l.getSelection&&l.getSelection();if(a&&a.rangeCount!==0){l=a.anchorNode;var n=a.anchorOffset,i=a.focusNode;a=a.focusOffset;try{l.nodeType,i.nodeType}catch{l=null;break t}var f=0,o=-1,m=-1,S=0,A=0,O=t,b=null;e:for(;;){for(var _;O!==l||n!==0&&O.nodeType!==3||(o=f+n),O!==i||a!==0&&O.nodeType!==3||(m=f+a),O.nodeType===3&&(f+=O.nodeValue.length),(_=O.firstChild)!==null;)b=O,O=_;for(;;){if(O===t)break e;if(b===l&&++S===n&&(o=f),b===i&&++A===a&&(m=f),(_=O.nextSibling)!==null)break;O=b,b=O.parentNode}O=_}l=o===-1||m===-1?null:{start:o,end:m}}else l=null}l=l||{start:0,end:0}}else l=null;for(ss={focusedElem:t,selectionRange:l},wi=!1,Bt=e;Bt!==null;)if(e=Bt,t=e.child,(e.subtreeFlags&1028)!==0&&t!==null)t.return=e,Bt=t;else for(;Bt!==null;){switch(e=Bt,i=e.alternate,t=e.flags,e.tag){case 0:if((t&4)!==0&&(t=e.updateQueue,t=t!==null?t.events:null,t!==null))for(l=0;l<t.length;l++)n=t[l],n.ref.impl=n.nextImpl;break;case 11:case 15:break;case 1:if((t&1024)!==0&&i!==null){t=void 0,l=e,n=i.memoizedProps,i=i.memoizedState,a=l.stateNode;try{var H=Kl(l.type,n);t=a.getSnapshotBeforeUpdate(H,i),a.__reactInternalSnapshotBeforeUpdate=t}catch(w){rt(l,l.return,w)}}break;case 3:if((t&1024)!==0){if(t=e.stateNode.containerInfo,l=t.nodeType,l===9)os(t);else if(l===1)switch(t.nodeName){case"HEAD":case"HTML":case"BODY":os(t);break;default:t.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((t&1024)!==0)throw Error(s(163))}if(t=e.sibling,t!==null){t.return=e.return,Bt=t;break}Bt=e.return}}function No(t,e,l){var a=l.flags;switch(l.tag){case 0:case 11:case 15:Ie(t,l),a&4&&on(5,l);break;case 1:if(Ie(t,l),a&4)if(t=l.stateNode,e===null)try{t.componentDidMount()}catch(f){rt(l,l.return,f)}else{var n=Kl(l.type,e.memoizedProps);e=e.memoizedState;try{t.componentDidUpdate(n,e,t.__reactInternalSnapshotBeforeUpdate)}catch(f){rt(l,l.return,f)}}a&64&&xo(l),a&512&&hn(l,l.return);break;case 3:if(Ie(t,l),a&64&&(t=l.updateQueue,t!==null)){if(e=null,l.child!==null)switch(l.child.tag){case 27:case 5:e=l.child.stateNode;break;case 1:e=l.child.stateNode}try{rr(t,e)}catch(f){rt(l,l.return,f)}}break;case 27:e===null&&a&4&&Ao(l);case 26:case 5:Ie(t,l),e===null&&a&4&&Eo(l),a&512&&hn(l,l.return);break;case 12:Ie(t,l);break;case 31:Ie(t,l),a&4&&Co(t,l);break;case 13:Ie(t,l),a&4&&Do(t,l),a&64&&(t=l.memoizedState,t!==null&&(t=t.dehydrated,t!==null&&(l=ny.bind(null,l),Ty(t,l))));break;case 22:if(a=l.memoizedState!==null||We,!a){e=e!==null&&e.memoizedState!==null||Ct,n=We;var i=Ct;We=a,(Ct=e)&&!i?Pe(t,l,(l.subtreeFlags&8772)!==0):Ie(t,l),We=n,Ct=i}break;case 30:break;default:Ie(t,l)}}function Oo(t){var e=t.alternate;e!==null&&(t.alternate=null,Oo(e)),t.child=null,t.deletions=null,t.sibling=null,t.tag===5&&(e=t.stateNode,e!==null&&pu(e)),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}var St=null,te=!1;function Fe(t,e,l){for(l=l.child;l!==null;)jo(t,e,l),l=l.sibling}function jo(t,e,l){if(ue&&typeof ue.onCommitFiberUnmount=="function")try{ue.onCommitFiberUnmount(Ba,l)}catch{}switch(l.tag){case 26:Ct||Ue(l,e),Fe(t,e,l),l.memoizedState?l.memoizedState.count--:l.stateNode&&(l=l.stateNode,l.parentNode.removeChild(l));break;case 27:Ct||Ue(l,e);var a=St,n=te;El(l.type)&&(St=l.stateNode,te=!1),Fe(t,e,l),xn(l.stateNode),St=a,te=n;break;case 5:Ct||Ue(l,e);case 6:if(a=St,n=te,St=null,Fe(t,e,l),St=a,te=n,St!==null)if(te)try{(St.nodeType===9?St.body:St.nodeName==="HTML"?St.ownerDocument.body:St).removeChild(l.stateNode)}catch(i){rt(l,e,i)}else try{St.removeChild(l.stateNode)}catch(i){rt(l,e,i)}break;case 18:St!==null&&(te?(t=St,xh(t.nodeType===9?t.body:t.nodeName==="HTML"?t.ownerDocument.body:t,l.stateNode),Ma(t)):xh(St,l.stateNode));break;case 4:a=St,n=te,St=l.stateNode.containerInfo,te=!0,Fe(t,e,l),St=a,te=n;break;case 0:case 11:case 14:case 15:pl(2,l,e),Ct||pl(4,l,e),Fe(t,e,l);break;case 1:Ct||(Ue(l,e),a=l.stateNode,typeof a.componentWillUnmount=="function"&&_o(l,e,a)),Fe(t,e,l);break;case 21:Fe(t,e,l);break;case 22:Ct=(a=Ct)||l.memoizedState!==null,Fe(t,e,l),Ct=a;break;default:Fe(t,e,l)}}function Co(t,e){if(e.memoizedState===null&&(t=e.alternate,t!==null&&(t=t.memoizedState,t!==null))){t=t.dehydrated;try{Ma(t)}catch(l){rt(e,e.return,l)}}}function Do(t,e){if(e.memoizedState===null&&(t=e.alternate,t!==null&&(t=t.memoizedState,t!==null&&(t=t.dehydrated,t!==null))))try{Ma(t)}catch(l){rt(e,e.return,l)}}function Wm(t){switch(t.tag){case 31:case 13:case 19:var e=t.stateNode;return e===null&&(e=t.stateNode=new zo),e;case 22:return t=t.stateNode,e=t._retryCache,e===null&&(e=t._retryCache=new zo),e;default:throw Error(s(435,t.tag))}}function Ei(t,e){var l=Wm(t);e.forEach(function(a){if(!l.has(a)){l.add(a);var n=iy.bind(null,t,a);a.then(n,n)}})}function ee(t,e){var l=e.deletions;if(l!==null)for(var a=0;a<l.length;a++){var n=l[a],i=t,f=e,o=f;t:for(;o!==null;){switch(o.tag){case 27:if(El(o.type)){St=o.stateNode,te=!1;break t}break;case 5:St=o.stateNode,te=!1;break t;case 3:case 4:St=o.stateNode.containerInfo,te=!0;break t}o=o.return}if(St===null)throw Error(s(160));jo(i,f,n),St=null,te=!1,i=n.alternate,i!==null&&(i.return=null),n.return=null}if(e.subtreeFlags&13886)for(e=e.child;e!==null;)Mo(e,t),e=e.sibling}var je=null;function Mo(t,e){var l=t.alternate,a=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:ee(e,t),le(t),a&4&&(pl(3,t,t.return),on(3,t),pl(5,t,t.return));break;case 1:ee(e,t),le(t),a&512&&(Ct||l===null||Ue(l,l.return)),a&64&&We&&(t=t.updateQueue,t!==null&&(a=t.callbacks,a!==null&&(l=t.shared.hiddenCallbacks,t.shared.hiddenCallbacks=l===null?a:l.concat(a))));break;case 26:var n=je;if(ee(e,t),le(t),a&512&&(Ct||l===null||Ue(l,l.return)),a&4){var i=l!==null?l.memoizedState:null;if(a=t.memoizedState,l===null)if(a===null)if(t.stateNode===null){t:{a=t.type,l=t.memoizedProps,n=n.ownerDocument||n;e:switch(a){case"title":i=n.getElementsByTagName("title")[0],(!i||i[Ya]||i[Ht]||i.namespaceURI==="http://www.w3.org/2000/svg"||i.hasAttribute("itemprop"))&&(i=n.createElement(a),n.head.insertBefore(i,n.querySelector("head > title"))),Qt(i,a,l),i[Ht]=t,Ut(i),a=i;break t;case"link":var f=Mh("link","href",n).get(a+(l.href||""));if(f){for(var o=0;o<f.length;o++)if(i=f[o],i.getAttribute("href")===(l.href==null||l.href===""?null:l.href)&&i.getAttribute("rel")===(l.rel==null?null:l.rel)&&i.getAttribute("title")===(l.title==null?null:l.title)&&i.getAttribute("crossorigin")===(l.crossOrigin==null?null:l.crossOrigin)){f.splice(o,1);break e}}i=n.createElement(a),Qt(i,a,l),n.head.appendChild(i);break;case"meta":if(f=Mh("meta","content",n).get(a+(l.content||""))){for(o=0;o<f.length;o++)if(i=f[o],i.getAttribute("content")===(l.content==null?null:""+l.content)&&i.getAttribute("name")===(l.name==null?null:l.name)&&i.getAttribute("property")===(l.property==null?null:l.property)&&i.getAttribute("http-equiv")===(l.httpEquiv==null?null:l.httpEquiv)&&i.getAttribute("charset")===(l.charSet==null?null:l.charSet)){f.splice(o,1);break e}}i=n.createElement(a),Qt(i,a,l),n.head.appendChild(i);break;default:throw Error(s(468,a))}i[Ht]=t,Ut(i),a=i}t.stateNode=a}else Rh(n,t.type,t.stateNode);else t.stateNode=Dh(n,a,t.memoizedProps);else i!==a?(i===null?l.stateNode!==null&&(l=l.stateNode,l.parentNode.removeChild(l)):i.count--,a===null?Rh(n,t.type,t.stateNode):Dh(n,a,t.memoizedProps)):a===null&&t.stateNode!==null&&Hc(t,t.memoizedProps,l.memoizedProps)}break;case 27:ee(e,t),le(t),a&512&&(Ct||l===null||Ue(l,l.return)),l!==null&&a&4&&Hc(t,t.memoizedProps,l.memoizedProps);break;case 5:if(ee(e,t),le(t),a&512&&(Ct||l===null||Ue(l,l.return)),t.flags&32){n=t.stateNode;try{ea(n,"")}catch(H){rt(t,t.return,H)}}a&4&&t.stateNode!=null&&(n=t.memoizedProps,Hc(t,n,l!==null?l.memoizedProps:n)),a&1024&&(Xc=!0);break;case 6:if(ee(e,t),le(t),a&4){if(t.stateNode===null)throw Error(s(162));a=t.memoizedProps,l=t.stateNode;try{l.nodeValue=a}catch(H){rt(t,t.return,H)}}break;case 3:if(Li=null,n=je,je=Hi(e.containerInfo),ee(e,t),je=n,le(t),a&4&&l!==null&&l.memoizedState.isDehydrated)try{Ma(e.containerInfo)}catch(H){rt(t,t.return,H)}Xc&&(Xc=!1,Ro(t));break;case 4:a=je,je=Hi(t.stateNode.containerInfo),ee(e,t),le(t),je=a;break;case 12:ee(e,t),le(t);break;case 31:ee(e,t),le(t),a&4&&(a=t.updateQueue,a!==null&&(t.updateQueue=null,Ei(t,a)));break;case 13:ee(e,t),le(t),t.child.flags&8192&&t.memoizedState!==null!=(l!==null&&l.memoizedState!==null)&&(Ai=ie()),a&4&&(a=t.updateQueue,a!==null&&(t.updateQueue=null,Ei(t,a)));break;case 22:n=t.memoizedState!==null;var m=l!==null&&l.memoizedState!==null,S=We,A=Ct;if(We=S||n,Ct=A||m,ee(e,t),Ct=A,We=S,le(t),a&8192)t:for(e=t.stateNode,e._visibility=n?e._visibility&-2:e._visibility|1,n&&(l===null||m||We||Ct||Jl(t)),l=null,e=t;;){if(e.tag===5||e.tag===26){if(l===null){m=l=e;try{if(i=m.stateNode,n)f=i.style,typeof f.setProperty=="function"?f.setProperty("display","none","important"):f.display="none";else{o=m.stateNode;var O=m.memoizedProps.style,b=O!=null&&O.hasOwnProperty("display")?O.display:null;o.style.display=b==null||typeof b=="boolean"?"":(""+b).trim()}}catch(H){rt(m,m.return,H)}}}else if(e.tag===6){if(l===null){m=e;try{m.stateNode.nodeValue=n?"":m.memoizedProps}catch(H){rt(m,m.return,H)}}}else if(e.tag===18){if(l===null){m=e;try{var _=m.stateNode;n?_h(_,!0):_h(m.stateNode,!1)}catch(H){rt(m,m.return,H)}}}else if((e.tag!==22&&e.tag!==23||e.memoizedState===null||e===t)&&e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break t;for(;e.sibling===null;){if(e.return===null||e.return===t)break t;l===e&&(l=null),e=e.return}l===e&&(l=null),e.sibling.return=e.return,e=e.sibling}a&4&&(a=t.updateQueue,a!==null&&(l=a.retryQueue,l!==null&&(a.retryQueue=null,Ei(t,l))));break;case 19:ee(e,t),le(t),a&4&&(a=t.updateQueue,a!==null&&(t.updateQueue=null,Ei(t,a)));break;case 30:break;case 21:break;default:ee(e,t),le(t)}}function le(t){var e=t.flags;if(e&2){try{for(var l,a=t.return;a!==null;){if(To(a)){l=a;break}a=a.return}if(l==null)throw Error(s(160));switch(l.tag){case 27:var n=l.stateNode,i=Yc(t);_i(t,i,n);break;case 5:var f=l.stateNode;l.flags&32&&(ea(f,""),l.flags&=-33);var o=Yc(t);_i(t,o,f);break;case 3:case 4:var m=l.stateNode.containerInfo,S=Yc(t);Lc(t,S,m);break;default:throw Error(s(161))}}catch(A){rt(t,t.return,A)}t.flags&=-3}e&4096&&(t.flags&=-4097)}function Ro(t){if(t.subtreeFlags&1024)for(t=t.child;t!==null;){var e=t;Ro(e),e.tag===5&&e.flags&1024&&e.stateNode.reset(),t=t.sibling}}function Ie(t,e){if(e.subtreeFlags&8772)for(e=e.child;e!==null;)No(t,e.alternate,e),e=e.sibling}function Jl(t){for(t=t.child;t!==null;){var e=t;switch(e.tag){case 0:case 11:case 14:case 15:pl(4,e,e.return),Jl(e);break;case 1:Ue(e,e.return);var l=e.stateNode;typeof l.componentWillUnmount=="function"&&_o(e,e.return,l),Jl(e);break;case 27:xn(e.stateNode);case 26:case 5:Ue(e,e.return),Jl(e);break;case 22:e.memoizedState===null&&Jl(e);break;case 30:Jl(e);break;default:Jl(e)}t=t.sibling}}function Pe(t,e,l){for(l=l&&(e.subtreeFlags&8772)!==0,e=e.child;e!==null;){var a=e.alternate,n=t,i=e,f=i.flags;switch(i.tag){case 0:case 11:case 15:Pe(n,i,l),on(4,i);break;case 1:if(Pe(n,i,l),a=i,n=a.stateNode,typeof n.componentDidMount=="function")try{n.componentDidMount()}catch(S){rt(a,a.return,S)}if(a=i,n=a.updateQueue,n!==null){var o=a.stateNode;try{var m=n.shared.hiddenCallbacks;if(m!==null)for(n.shared.hiddenCallbacks=null,n=0;n<m.length;n++)fr(m[n],o)}catch(S){rt(a,a.return,S)}}l&&f&64&&xo(i),hn(i,i.return);break;case 27:Ao(i);case 26:case 5:Pe(n,i,l),l&&a===null&&f&4&&Eo(i),hn(i,i.return);break;case 12:Pe(n,i,l);break;case 31:Pe(n,i,l),l&&f&4&&Co(n,i);break;case 13:Pe(n,i,l),l&&f&4&&Do(n,i);break;case 22:i.memoizedState===null&&Pe(n,i,l),hn(i,i.return);break;case 30:break;default:Pe(n,i,l)}e=e.sibling}}function Qc(t,e){var l=null;t!==null&&t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(l=t.memoizedState.cachePool.pool),t=null,e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(t=e.memoizedState.cachePool.pool),t!==l&&(t!=null&&t.refCount++,l!=null&&Fa(l))}function Gc(t,e){t=null,e.alternate!==null&&(t=e.alternate.memoizedState.cache),e=e.memoizedState.cache,e!==t&&(e.refCount++,t!=null&&Fa(t))}function Ce(t,e,l,a){if(e.subtreeFlags&10256)for(e=e.child;e!==null;)Uo(t,e,l,a),e=e.sibling}function Uo(t,e,l,a){var n=e.flags;switch(e.tag){case 0:case 11:case 15:Ce(t,e,l,a),n&2048&&on(9,e);break;case 1:Ce(t,e,l,a);break;case 3:Ce(t,e,l,a),n&2048&&(t=null,e.alternate!==null&&(t=e.alternate.memoizedState.cache),e=e.memoizedState.cache,e!==t&&(e.refCount++,t!=null&&Fa(t)));break;case 12:if(n&2048){Ce(t,e,l,a),t=e.stateNode;try{var i=e.memoizedProps,f=i.id,o=i.onPostCommit;typeof o=="function"&&o(f,e.alternate===null?"mount":"update",t.passiveEffectDuration,-0)}catch(m){rt(e,e.return,m)}}else Ce(t,e,l,a);break;case 31:Ce(t,e,l,a);break;case 13:Ce(t,e,l,a);break;case 23:break;case 22:i=e.stateNode,f=e.alternate,e.memoizedState!==null?i._visibility&2?Ce(t,e,l,a):dn(t,e):i._visibility&2?Ce(t,e,l,a):(i._visibility|=2,xa(t,e,l,a,(e.subtreeFlags&10256)!==0||!1)),n&2048&&Qc(f,e);break;case 24:Ce(t,e,l,a),n&2048&&Gc(e.alternate,e);break;default:Ce(t,e,l,a)}}function xa(t,e,l,a,n){for(n=n&&((e.subtreeFlags&10256)!==0||!1),e=e.child;e!==null;){var i=t,f=e,o=l,m=a,S=f.flags;switch(f.tag){case 0:case 11:case 15:xa(i,f,o,m,n),on(8,f);break;case 23:break;case 22:var A=f.stateNode;f.memoizedState!==null?A._visibility&2?xa(i,f,o,m,n):dn(i,f):(A._visibility|=2,xa(i,f,o,m,n)),n&&S&2048&&Qc(f.alternate,f);break;case 24:xa(i,f,o,m,n),n&&S&2048&&Gc(f.alternate,f);break;default:xa(i,f,o,m,n)}e=e.sibling}}function dn(t,e){if(e.subtreeFlags&10256)for(e=e.child;e!==null;){var l=t,a=e,n=a.flags;switch(a.tag){case 22:dn(l,a),n&2048&&Qc(a.alternate,a);break;case 24:dn(l,a),n&2048&&Gc(a.alternate,a);break;default:dn(l,a)}e=e.sibling}}var mn=8192;function _a(t,e,l){if(t.subtreeFlags&mn)for(t=t.child;t!==null;)Bo(t,e,l),t=t.sibling}function Bo(t,e,l){switch(t.tag){case 26:_a(t,e,l),t.flags&mn&&t.memoizedState!==null&&qy(l,je,t.memoizedState,t.memoizedProps);break;case 5:_a(t,e,l);break;case 3:case 4:var a=je;je=Hi(t.stateNode.containerInfo),_a(t,e,l),je=a;break;case 22:t.memoizedState===null&&(a=t.alternate,a!==null&&a.memoizedState!==null?(a=mn,mn=16777216,_a(t,e,l),mn=a):_a(t,e,l));break;default:_a(t,e,l)}}function qo(t){var e=t.alternate;if(e!==null&&(t=e.child,t!==null)){e.child=null;do e=t.sibling,t.sibling=null,t=e;while(t!==null)}}function yn(t){var e=t.deletions;if((t.flags&16)!==0){if(e!==null)for(var l=0;l<e.length;l++){var a=e[l];Bt=a,Yo(a,t)}qo(t)}if(t.subtreeFlags&10256)for(t=t.child;t!==null;)Ho(t),t=t.sibling}function Ho(t){switch(t.tag){case 0:case 11:case 15:yn(t),t.flags&2048&&pl(9,t,t.return);break;case 3:yn(t);break;case 12:yn(t);break;case 22:var e=t.stateNode;t.memoizedState!==null&&e._visibility&2&&(t.return===null||t.return.tag!==13)?(e._visibility&=-3,Ti(t)):yn(t);break;default:yn(t)}}function Ti(t){var e=t.deletions;if((t.flags&16)!==0){if(e!==null)for(var l=0;l<e.length;l++){var a=e[l];Bt=a,Yo(a,t)}qo(t)}for(t=t.child;t!==null;){switch(e=t,e.tag){case 0:case 11:case 15:pl(8,e,e.return),Ti(e);break;case 22:l=e.stateNode,l._visibility&2&&(l._visibility&=-3,Ti(e));break;default:Ti(e)}t=t.sibling}}function Yo(t,e){for(;Bt!==null;){var l=Bt;switch(l.tag){case 0:case 11:case 15:pl(8,l,e);break;case 23:case 22:if(l.memoizedState!==null&&l.memoizedState.cachePool!==null){var a=l.memoizedState.cachePool.pool;a!=null&&a.refCount++}break;case 24:Fa(l.memoizedState.cache)}if(a=l.child,a!==null)a.return=l,Bt=a;else t:for(l=t;Bt!==null;){a=Bt;var n=a.sibling,i=a.return;if(Oo(a),a===l){Bt=null;break t}if(n!==null){n.return=i,Bt=n;break t}Bt=i}}}var Fm={getCacheForType:function(t){var e=Lt(Nt),l=e.data.get(t);return l===void 0&&(l=t(),e.data.set(t,l)),l},cacheSignal:function(){return Lt(Nt).controller.signal}},Im=typeof WeakMap=="function"?WeakMap:Map,ut=0,yt=null,F=null,P=0,ft=0,he=null,vl=!1,Ea=!1,wc=!1,tl=0,_t=0,gl=0,kl=0,Vc=0,de=0,Ta=0,pn=null,ae=null,Zc=!1,Ai=0,Lo=0,zi=1/0,Ni=null,Sl=null,Rt=0,bl=null,Aa=null,el=0,Kc=0,Jc=null,Xo=null,vn=0,kc=null;function me(){return(ut&2)!==0&&P!==0?P&-P:T.T!==null?ts():tf()}function Qo(){if(de===0)if((P&536870912)===0||et){var t=Bn;Bn<<=1,(Bn&3932160)===0&&(Bn=262144),de=t}else de=536870912;return t=re.current,t!==null&&(t.flags|=32),de}function ne(t,e,l){(t===yt&&(ft===2||ft===9)||t.cancelPendingCommit!==null)&&(za(t,0),xl(t,P,de,!1)),Ha(t,l),((ut&2)===0||t!==yt)&&(t===yt&&((ut&2)===0&&(kl|=l),_t===4&&xl(t,P,de,!1)),Be(t))}function Go(t,e,l){if((ut&6)!==0)throw Error(s(327));var a=!l&&(e&127)===0&&(e&t.expiredLanes)===0||qa(t,e),n=a?ey(t,e):Wc(t,e,!0),i=a;do{if(n===0){Ea&&!a&&xl(t,e,0,!1);break}else{if(l=t.current.alternate,i&&!Pm(l)){n=Wc(t,e,!1),i=!1;continue}if(n===2){if(i=e,t.errorRecoveryDisabledLanes&i)var f=0;else f=t.pendingLanes&-536870913,f=f!==0?f:f&536870912?536870912:0;if(f!==0){e=f;t:{var o=t;n=pn;var m=o.current.memoizedState.isDehydrated;if(m&&(za(o,f).flags|=256),f=Wc(o,f,!1),f!==2){if(wc&&!m){o.errorRecoveryDisabledLanes|=i,kl|=i,n=4;break t}i=ae,ae=n,i!==null&&(ae===null?ae=i:ae.push.apply(ae,i))}n=f}if(i=!1,n!==2)continue}}if(n===1){za(t,0),xl(t,e,0,!0);break}t:{switch(a=t,i=n,i){case 0:case 1:throw Error(s(345));case 4:if((e&4194048)!==e)break;case 6:xl(a,e,de,!vl);break t;case 2:ae=null;break;case 3:case 5:break;default:throw Error(s(329))}if((e&62914560)===e&&(n=Ai+300-ie(),10<n)){if(xl(a,e,de,!vl),Hn(a,0,!0)!==0)break t;el=e,a.timeoutHandle=Sh(wo.bind(null,a,l,ae,Ni,Zc,e,de,kl,Ta,vl,i,"Throttled",-0,0),n);break t}wo(a,l,ae,Ni,Zc,e,de,kl,Ta,vl,i,null,-0,0)}}break}while(!0);Be(t)}function wo(t,e,l,a,n,i,f,o,m,S,A,O,b,_){if(t.timeoutHandle=-1,O=e.subtreeFlags,O&8192||(O&16785408)===16785408){O={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Xe},Bo(e,i,O);var H=(i&62914560)===i?Ai-ie():(i&4194048)===i?Lo-ie():0;if(H=Hy(O,H),H!==null){el=i,t.cancelPendingCommit=H(Fo.bind(null,t,e,i,l,a,n,f,o,m,A,O,null,b,_)),xl(t,i,f,!S);return}}Fo(t,e,i,l,a,n,f,o,m)}function Pm(t){for(var e=t;;){var l=e.tag;if((l===0||l===11||l===15)&&e.flags&16384&&(l=e.updateQueue,l!==null&&(l=l.stores,l!==null)))for(var a=0;a<l.length;a++){var n=l[a],i=n.getSnapshot;n=n.value;try{if(!se(i(),n))return!1}catch{return!1}}if(l=e.child,e.subtreeFlags&16384&&l!==null)l.return=e,e=l;else{if(e===t)break;for(;e.sibling===null;){if(e.return===null||e.return===t)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function xl(t,e,l,a){e&=~Vc,e&=~kl,t.suspendedLanes|=e,t.pingedLanes&=~e,a&&(t.warmLanes|=e),a=t.expirationTimes;for(var n=e;0<n;){var i=31-ce(n),f=1<<i;a[i]=-1,n&=~f}l!==0&&Fs(t,l,e)}function Oi(){return(ut&6)===0?(gn(0),!1):!0}function $c(){if(F!==null){if(ft===0)var t=F.return;else t=F,Ve=Ll=null,oc(t),pa=null,Pa=0,t=F;for(;t!==null;)bo(t.alternate,t),t=t.return;F=null}}function za(t,e){var l=t.timeoutHandle;l!==-1&&(t.timeoutHandle=-1,Sy(l)),l=t.cancelPendingCommit,l!==null&&(t.cancelPendingCommit=null,l()),el=0,$c(),yt=t,F=l=Ge(t.current,null),P=e,ft=0,he=null,vl=!1,Ea=qa(t,e),wc=!1,Ta=de=Vc=kl=gl=_t=0,ae=pn=null,Zc=!1,(e&8)!==0&&(e|=e&32);var a=t.entangledLanes;if(a!==0)for(t=t.entanglements,a&=e;0<a;){var n=31-ce(a),i=1<<n;e|=t[n],a&=~i}return tl=e,$n(),l}function Vo(t,e){k=null,T.H=sn,e===ya||e===ai?(e=ir(),ft=3):e===Pu?(e=ir(),ft=4):ft=e===Nc?8:e!==null&&typeof e=="object"&&typeof e.then=="function"?6:1,he=e,F===null&&(_t=1,vi(t,Se(e,t.current)))}function Zo(){var t=re.current;return t===null?!0:(P&4194048)===P?Ee===null:(P&62914560)===P||(P&536870912)!==0?t===Ee:!1}function Ko(){var t=T.H;return T.H=sn,t===null?sn:t}function Jo(){var t=T.A;return T.A=Fm,t}function ji(){_t=4,vl||(P&4194048)!==P&&re.current!==null||(Ea=!0),(gl&134217727)===0&&(kl&134217727)===0||yt===null||xl(yt,P,de,!1)}function Wc(t,e,l){var a=ut;ut|=2;var n=Ko(),i=Jo();(yt!==t||P!==e)&&(Ni=null,za(t,e)),e=!1;var f=_t;t:do try{if(ft!==0&&F!==null){var o=F,m=he;switch(ft){case 8:$c(),f=6;break t;case 3:case 2:case 9:case 6:re.current===null&&(e=!0);var S=ft;if(ft=0,he=null,Na(t,o,m,S),l&&Ea){f=0;break t}break;default:S=ft,ft=0,he=null,Na(t,o,m,S)}}ty(),f=_t;break}catch(A){Vo(t,A)}while(!0);return e&&t.shellSuspendCounter++,Ve=Ll=null,ut=a,T.H=n,T.A=i,F===null&&(yt=null,P=0,$n()),f}function ty(){for(;F!==null;)ko(F)}function ey(t,e){var l=ut;ut|=2;var a=Ko(),n=Jo();yt!==t||P!==e?(Ni=null,zi=ie()+500,za(t,e)):Ea=qa(t,e);t:do try{if(ft!==0&&F!==null){e=F;var i=he;e:switch(ft){case 1:ft=0,he=null,Na(t,e,i,1);break;case 2:case 9:if(ar(i)){ft=0,he=null,$o(e);break}e=function(){ft!==2&&ft!==9||yt!==t||(ft=7),Be(t)},i.then(e,e);break t;case 3:ft=7;break t;case 4:ft=5;break t;case 7:ar(i)?(ft=0,he=null,$o(e)):(ft=0,he=null,Na(t,e,i,7));break;case 5:var f=null;switch(F.tag){case 26:f=F.memoizedState;case 5:case 27:var o=F;if(f?Uh(f):o.stateNode.complete){ft=0,he=null;var m=o.sibling;if(m!==null)F=m;else{var S=o.return;S!==null?(F=S,Ci(S)):F=null}break e}}ft=0,he=null,Na(t,e,i,5);break;case 6:ft=0,he=null,Na(t,e,i,6);break;case 8:$c(),_t=6;break t;default:throw Error(s(462))}}ly();break}catch(A){Vo(t,A)}while(!0);return Ve=Ll=null,T.H=a,T.A=n,ut=l,F!==null?0:(yt=null,P=0,$n(),_t)}function ly(){for(;F!==null&&!Ad();)ko(F)}function ko(t){var e=go(t.alternate,t,tl);t.memoizedProps=t.pendingProps,e===null?Ci(t):F=e}function $o(t){var e=t,l=e.alternate;switch(e.tag){case 15:case 0:e=oo(l,e,e.pendingProps,e.type,void 0,P);break;case 11:e=oo(l,e,e.pendingProps,e.type.render,e.ref,P);break;case 5:oc(e);default:bo(l,e),e=F=Kf(e,tl),e=go(l,e,tl)}t.memoizedProps=t.pendingProps,e===null?Ci(t):F=e}function Na(t,e,l,a){Ve=Ll=null,oc(e),pa=null,Pa=0;var n=e.return;try{if(Vm(t,n,e,l,P)){_t=1,vi(t,Se(l,t.current)),F=null;return}}catch(i){if(n!==null)throw F=n,i;_t=1,vi(t,Se(l,t.current)),F=null;return}e.flags&32768?(et||a===1?t=!0:Ea||(P&536870912)!==0?t=!1:(vl=t=!0,(a===2||a===9||a===3||a===6)&&(a=re.current,a!==null&&a.tag===13&&(a.flags|=16384))),Wo(e,t)):Ci(e)}function Ci(t){var e=t;do{if((e.flags&32768)!==0){Wo(e,vl);return}t=e.return;var l=Jm(e.alternate,e,tl);if(l!==null){F=l;return}if(e=e.sibling,e!==null){F=e;return}F=e=t}while(e!==null);_t===0&&(_t=5)}function Wo(t,e){do{var l=km(t.alternate,t);if(l!==null){l.flags&=32767,F=l;return}if(l=t.return,l!==null&&(l.flags|=32768,l.subtreeFlags=0,l.deletions=null),!e&&(t=t.sibling,t!==null)){F=t;return}F=t=l}while(t!==null);_t=6,F=null}function Fo(t,e,l,a,n,i,f,o,m){t.cancelPendingCommit=null;do Di();while(Rt!==0);if((ut&6)!==0)throw Error(s(327));if(e!==null){if(e===t.current)throw Error(s(177));if(i=e.lanes|e.childLanes,i|=Yu,Bd(t,l,i,f,o,m),t===yt&&(F=yt=null,P=0),Aa=e,bl=t,el=l,Kc=i,Jc=n,Xo=a,(e.subtreeFlags&10256)!==0||(e.flags&10256)!==0?(t.callbackNode=null,t.callbackPriority=0,uy(Rn,function(){return lh(),null})):(t.callbackNode=null,t.callbackPriority=0),a=(e.flags&13878)!==0,(e.subtreeFlags&13878)!==0||a){a=T.T,T.T=null,n=B.p,B.p=2,f=ut,ut|=4;try{$m(t,e,l)}finally{ut=f,B.p=n,T.T=a}}Rt=1,Io(),Po(),th()}}function Io(){if(Rt===1){Rt=0;var t=bl,e=Aa,l=(e.flags&13878)!==0;if((e.subtreeFlags&13878)!==0||l){l=T.T,T.T=null;var a=B.p;B.p=2;var n=ut;ut|=4;try{Mo(e,t);var i=ss,f=Hf(t.containerInfo),o=i.focusedElem,m=i.selectionRange;if(f!==o&&o&&o.ownerDocument&&qf(o.ownerDocument.documentElement,o)){if(m!==null&&Ru(o)){var S=m.start,A=m.end;if(A===void 0&&(A=S),"selectionStart"in o)o.selectionStart=S,o.selectionEnd=Math.min(A,o.value.length);else{var O=o.ownerDocument||document,b=O&&O.defaultView||window;if(b.getSelection){var _=b.getSelection(),H=o.textContent.length,w=Math.min(m.start,H),dt=m.end===void 0?w:Math.min(m.end,H);!_.extend&&w>dt&&(f=dt,dt=w,w=f);var v=Bf(o,w),y=Bf(o,dt);if(v&&y&&(_.rangeCount!==1||_.anchorNode!==v.node||_.anchorOffset!==v.offset||_.focusNode!==y.node||_.focusOffset!==y.offset)){var g=O.createRange();g.setStart(v.node,v.offset),_.removeAllRanges(),w>dt?(_.addRange(g),_.extend(y.node,y.offset)):(g.setEnd(y.node,y.offset),_.addRange(g))}}}}for(O=[],_=o;_=_.parentNode;)_.nodeType===1&&O.push({element:_,left:_.scrollLeft,top:_.scrollTop});for(typeof o.focus=="function"&&o.focus(),o=0;o<O.length;o++){var N=O[o];N.element.scrollLeft=N.left,N.element.scrollTop=N.top}}wi=!!cs,ss=cs=null}finally{ut=n,B.p=a,T.T=l}}t.current=e,Rt=2}}function Po(){if(Rt===2){Rt=0;var t=bl,e=Aa,l=(e.flags&8772)!==0;if((e.subtreeFlags&8772)!==0||l){l=T.T,T.T=null;var a=B.p;B.p=2;var n=ut;ut|=4;try{No(t,e.alternate,e)}finally{ut=n,B.p=a,T.T=l}}Rt=3}}function th(){if(Rt===4||Rt===3){Rt=0,zd();var t=bl,e=Aa,l=el,a=Xo;(e.subtreeFlags&10256)!==0||(e.flags&10256)!==0?Rt=5:(Rt=0,Aa=bl=null,eh(t,t.pendingLanes));var n=t.pendingLanes;if(n===0&&(Sl=null),mu(l),e=e.stateNode,ue&&typeof ue.onCommitFiberRoot=="function")try{ue.onCommitFiberRoot(Ba,e,void 0,(e.current.flags&128)===128)}catch{}if(a!==null){e=T.T,n=B.p,B.p=2,T.T=null;try{for(var i=t.onRecoverableError,f=0;f<a.length;f++){var o=a[f];i(o.value,{componentStack:o.stack})}}finally{T.T=e,B.p=n}}(el&3)!==0&&Di(),Be(t),n=t.pendingLanes,(l&261930)!==0&&(n&42)!==0?t===kc?vn++:(vn=0,kc=t):vn=0,gn(0)}}function eh(t,e){(t.pooledCacheLanes&=e)===0&&(e=t.pooledCache,e!=null&&(t.pooledCache=null,Fa(e)))}function Di(){return Io(),Po(),th(),lh()}function lh(){if(Rt!==5)return!1;var t=bl,e=Kc;Kc=0;var l=mu(el),a=T.T,n=B.p;try{B.p=32>l?32:l,T.T=null,l=Jc,Jc=null;var i=bl,f=el;if(Rt=0,Aa=bl=null,el=0,(ut&6)!==0)throw Error(s(331));var o=ut;if(ut|=4,Ho(i.current),Uo(i,i.current,f,l),ut=o,gn(0,!1),ue&&typeof ue.onPostCommitFiberRoot=="function")try{ue.onPostCommitFiberRoot(Ba,i)}catch{}return!0}finally{B.p=n,T.T=a,eh(t,e)}}function ah(t,e,l){e=Se(l,e),e=zc(t.stateNode,e,2),t=dl(t,e,2),t!==null&&(Ha(t,2),Be(t))}function rt(t,e,l){if(t.tag===3)ah(t,t,l);else for(;e!==null;){if(e.tag===3){ah(e,t,l);break}else if(e.tag===1){var a=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof a.componentDidCatch=="function"&&(Sl===null||!Sl.has(a))){t=Se(l,t),l=ao(2),a=dl(e,l,2),a!==null&&(no(l,a,e,t),Ha(a,2),Be(a));break}}e=e.return}}function Fc(t,e,l){var a=t.pingCache;if(a===null){a=t.pingCache=new Im;var n=new Set;a.set(e,n)}else n=a.get(e),n===void 0&&(n=new Set,a.set(e,n));n.has(l)||(wc=!0,n.add(l),t=ay.bind(null,t,e,l),e.then(t,t))}function ay(t,e,l){var a=t.pingCache;a!==null&&a.delete(e),t.pingedLanes|=t.suspendedLanes&l,t.warmLanes&=~l,yt===t&&(P&l)===l&&(_t===4||_t===3&&(P&62914560)===P&&300>ie()-Ai?(ut&2)===0&&za(t,0):Vc|=l,Ta===P&&(Ta=0)),Be(t)}function nh(t,e){e===0&&(e=Ws()),t=ql(t,e),t!==null&&(Ha(t,e),Be(t))}function ny(t){var e=t.memoizedState,l=0;e!==null&&(l=e.retryLane),nh(t,l)}function iy(t,e){var l=0;switch(t.tag){case 31:case 13:var a=t.stateNode,n=t.memoizedState;n!==null&&(l=n.retryLane);break;case 19:a=t.stateNode;break;case 22:a=t.stateNode._retryCache;break;default:throw Error(s(314))}a!==null&&a.delete(e),nh(t,l)}function uy(t,e){return ru(t,e)}var Mi=null,Oa=null,Ic=!1,Ri=!1,Pc=!1,_l=0;function Be(t){t!==Oa&&t.next===null&&(Oa===null?Mi=Oa=t:Oa=Oa.next=t),Ri=!0,Ic||(Ic=!0,sy())}function gn(t,e){if(!Pc&&Ri){Pc=!0;do for(var l=!1,a=Mi;a!==null;){if(t!==0){var n=a.pendingLanes;if(n===0)var i=0;else{var f=a.suspendedLanes,o=a.pingedLanes;i=(1<<31-ce(42|t)+1)-1,i&=n&~(f&~o),i=i&201326741?i&201326741|1:i?i|2:0}i!==0&&(l=!0,sh(a,i))}else i=P,i=Hn(a,a===yt?i:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),(i&3)===0||qa(a,i)||(l=!0,sh(a,i));a=a.next}while(l);Pc=!1}}function cy(){ih()}function ih(){Ri=Ic=!1;var t=0;_l!==0&&gy()&&(t=_l);for(var e=ie(),l=null,a=Mi;a!==null;){var n=a.next,i=uh(a,e);i===0?(a.next=null,l===null?Mi=n:l.next=n,n===null&&(Oa=l)):(l=a,(t!==0||(i&3)!==0)&&(Ri=!0)),a=n}Rt!==0&&Rt!==5||gn(t),_l!==0&&(_l=0)}function uh(t,e){for(var l=t.suspendedLanes,a=t.pingedLanes,n=t.expirationTimes,i=t.pendingLanes&-62914561;0<i;){var f=31-ce(i),o=1<<f,m=n[f];m===-1?((o&l)===0||(o&a)!==0)&&(n[f]=Ud(o,e)):m<=e&&(t.expiredLanes|=o),i&=~o}if(e=yt,l=P,l=Hn(t,t===e?l:0,t.cancelPendingCommit!==null||t.timeoutHandle!==-1),a=t.callbackNode,l===0||t===e&&(ft===2||ft===9)||t.cancelPendingCommit!==null)return a!==null&&a!==null&&ou(a),t.callbackNode=null,t.callbackPriority=0;if((l&3)===0||qa(t,l)){if(e=l&-l,e===t.callbackPriority)return e;switch(a!==null&&ou(a),mu(l)){case 2:case 8:l=ks;break;case 32:l=Rn;break;case 268435456:l=$s;break;default:l=Rn}return a=ch.bind(null,t),l=ru(l,a),t.callbackPriority=e,t.callbackNode=l,e}return a!==null&&a!==null&&ou(a),t.callbackPriority=2,t.callbackNode=null,2}function ch(t,e){if(Rt!==0&&Rt!==5)return t.callbackNode=null,t.callbackPriority=0,null;var l=t.callbackNode;if(Di()&&t.callbackNode!==l)return null;var a=P;return a=Hn(t,t===yt?a:0,t.cancelPendingCommit!==null||t.timeoutHandle!==-1),a===0?null:(Go(t,a,e),uh(t,ie()),t.callbackNode!=null&&t.callbackNode===l?ch.bind(null,t):null)}function sh(t,e){if(Di())return null;Go(t,e,!0)}function sy(){by(function(){(ut&6)!==0?ru(Js,cy):ih()})}function ts(){if(_l===0){var t=da;t===0&&(t=Un,Un<<=1,(Un&261888)===0&&(Un=256)),_l=t}return _l}function fh(t){return t==null||typeof t=="symbol"||typeof t=="boolean"?null:typeof t=="function"?t:Qn(""+t)}function rh(t,e){var l=e.ownerDocument.createElement("input");return l.name=e.name,l.value=e.value,t.id&&l.setAttribute("form",t.id),e.parentNode.insertBefore(l,e),t=new FormData(t),l.parentNode.removeChild(l),t}function fy(t,e,l,a,n){if(e==="submit"&&l&&l.stateNode===n){var i=fh((n[It]||null).action),f=a.submitter;f&&(e=(e=f[It]||null)?fh(e.formAction):f.getAttribute("formAction"),e!==null&&(i=e,f=null));var o=new Zn("action","action",null,a,n);t.push({event:o,listeners:[{instance:null,listener:function(){if(a.defaultPrevented){if(_l!==0){var m=f?rh(n,f):new FormData(n);bc(l,{pending:!0,data:m,method:n.method,action:i},null,m)}}else typeof i=="function"&&(o.preventDefault(),m=f?rh(n,f):new FormData(n),bc(l,{pending:!0,data:m,method:n.method,action:i},i,m))},currentTarget:n}]})}}for(var es=0;es<Hu.length;es++){var ls=Hu[es],ry=ls.toLowerCase(),oy=ls[0].toUpperCase()+ls.slice(1);Oe(ry,"on"+oy)}Oe(Xf,"onAnimationEnd"),Oe(Qf,"onAnimationIteration"),Oe(Gf,"onAnimationStart"),Oe("dblclick","onDoubleClick"),Oe("focusin","onFocus"),Oe("focusout","onBlur"),Oe(Nm,"onTransitionRun"),Oe(Om,"onTransitionStart"),Oe(jm,"onTransitionCancel"),Oe(wf,"onTransitionEnd"),Pl("onMouseEnter",["mouseout","mouseover"]),Pl("onMouseLeave",["mouseout","mouseover"]),Pl("onPointerEnter",["pointerout","pointerover"]),Pl("onPointerLeave",["pointerout","pointerover"]),Ml("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Ml("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Ml("onBeforeInput",["compositionend","keypress","textInput","paste"]),Ml("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Ml("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Ml("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Sn="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),hy=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Sn));function oh(t,e){e=(e&4)!==0;for(var l=0;l<t.length;l++){var a=t[l],n=a.event;a=a.listeners;t:{var i=void 0;if(e)for(var f=a.length-1;0<=f;f--){var o=a[f],m=o.instance,S=o.currentTarget;if(o=o.listener,m!==i&&n.isPropagationStopped())break t;i=o,n.currentTarget=S;try{i(n)}catch(A){kn(A)}n.currentTarget=null,i=m}else for(f=0;f<a.length;f++){if(o=a[f],m=o.instance,S=o.currentTarget,o=o.listener,m!==i&&n.isPropagationStopped())break t;i=o,n.currentTarget=S;try{i(n)}catch(A){kn(A)}n.currentTarget=null,i=m}}}}function I(t,e){var l=e[yu];l===void 0&&(l=e[yu]=new Set);var a=t+"__bubble";l.has(a)||(hh(e,t,2,!1),l.add(a))}function as(t,e,l){var a=0;e&&(a|=4),hh(l,t,a,e)}var Ui="_reactListening"+Math.random().toString(36).slice(2);function ns(t){if(!t[Ui]){t[Ui]=!0,af.forEach(function(l){l!=="selectionchange"&&(hy.has(l)||as(l,!1,t),as(l,!0,t))});var e=t.nodeType===9?t:t.ownerDocument;e===null||e[Ui]||(e[Ui]=!0,as("selectionchange",!1,e))}}function hh(t,e,l,a){switch(Qh(e)){case 2:var n=Xy;break;case 8:n=Qy;break;default:n=Ss}l=n.bind(null,e,l,t),n=void 0,!Tu||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(n=!0),a?n!==void 0?t.addEventListener(e,l,{capture:!0,passive:n}):t.addEventListener(e,l,!0):n!==void 0?t.addEventListener(e,l,{passive:n}):t.addEventListener(e,l,!1)}function is(t,e,l,a,n){var i=a;if((e&1)===0&&(e&2)===0&&a!==null)t:for(;;){if(a===null)return;var f=a.tag;if(f===3||f===4){var o=a.stateNode.containerInfo;if(o===n)break;if(f===4)for(f=a.return;f!==null;){var m=f.tag;if((m===3||m===4)&&f.stateNode.containerInfo===n)return;f=f.return}for(;o!==null;){if(f=Wl(o),f===null)return;if(m=f.tag,m===5||m===6||m===26||m===27){a=i=f;continue t}o=o.parentNode}}a=a.return}pf(function(){var S=i,A=_u(l),O=[];t:{var b=Vf.get(t);if(b!==void 0){var _=Zn,H=t;switch(t){case"keypress":if(wn(l)===0)break t;case"keydown":case"keyup":_=im;break;case"focusin":H="focus",_=Ou;break;case"focusout":H="blur",_=Ou;break;case"beforeblur":case"afterblur":_=Ou;break;case"click":if(l.button===2)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":_=Sf;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":_=Jd;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":_=sm;break;case Xf:case Qf:case Gf:_=Wd;break;case wf:_=rm;break;case"scroll":case"scrollend":_=Zd;break;case"wheel":_=hm;break;case"copy":case"cut":case"paste":_=Id;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":_=xf;break;case"toggle":case"beforetoggle":_=mm}var w=(e&4)!==0,dt=!w&&(t==="scroll"||t==="scrollend"),v=w?b!==null?b+"Capture":null:b;w=[];for(var y=S,g;y!==null;){var N=y;if(g=N.stateNode,N=N.tag,N!==5&&N!==26&&N!==27||g===null||v===null||(N=Xa(y,v),N!=null&&w.push(bn(y,N,g))),dt)break;y=y.return}0<w.length&&(b=new _(b,H,null,l,A),O.push({event:b,listeners:w}))}}if((e&7)===0){t:{if(b=t==="mouseover"||t==="pointerover",_=t==="mouseout"||t==="pointerout",b&&l!==xu&&(H=l.relatedTarget||l.fromElement)&&(Wl(H)||H[$l]))break t;if((_||b)&&(b=A.window===A?A:(b=A.ownerDocument)?b.defaultView||b.parentWindow:window,_?(H=l.relatedTarget||l.toElement,_=S,H=H?Wl(H):null,H!==null&&(dt=x(H),w=H.tag,H!==dt||w!==5&&w!==27&&w!==6)&&(H=null)):(_=null,H=S),_!==H)){if(w=Sf,N="onMouseLeave",v="onMouseEnter",y="mouse",(t==="pointerout"||t==="pointerover")&&(w=xf,N="onPointerLeave",v="onPointerEnter",y="pointer"),dt=_==null?b:La(_),g=H==null?b:La(H),b=new w(N,y+"leave",_,l,A),b.target=dt,b.relatedTarget=g,N=null,Wl(A)===S&&(w=new w(v,y+"enter",H,l,A),w.target=g,w.relatedTarget=dt,N=w),dt=N,_&&H)e:{for(w=dy,v=_,y=H,g=0,N=v;N;N=w(N))g++;N=0;for(var Q=y;Q;Q=w(Q))N++;for(;0<g-N;)v=w(v),g--;for(;0<N-g;)y=w(y),N--;for(;g--;){if(v===y||y!==null&&v===y.alternate){w=v;break e}v=w(v),y=w(y)}w=null}else w=null;_!==null&&dh(O,b,_,w,!1),H!==null&&dt!==null&&dh(O,dt,H,w,!0)}}t:{if(b=S?La(S):window,_=b.nodeName&&b.nodeName.toLowerCase(),_==="select"||_==="input"&&b.type==="file")var nt=jf;else if(Nf(b))if(Cf)nt=Tm;else{nt=_m;var L=xm}else _=b.nodeName,!_||_.toLowerCase()!=="input"||b.type!=="checkbox"&&b.type!=="radio"?S&&bu(S.elementType)&&(nt=jf):nt=Em;if(nt&&(nt=nt(t,S))){Of(O,nt,l,A);break t}L&&L(t,b,S),t==="focusout"&&S&&b.type==="number"&&S.memoizedProps.value!=null&&Su(b,"number",b.value)}switch(L=S?La(S):window,t){case"focusin":(Nf(L)||L.contentEditable==="true")&&(ia=L,Uu=S,ka=null);break;case"focusout":ka=Uu=ia=null;break;case"mousedown":Bu=!0;break;case"contextmenu":case"mouseup":case"dragend":Bu=!1,Yf(O,l,A);break;case"selectionchange":if(zm)break;case"keydown":case"keyup":Yf(O,l,A)}var $;if(Cu)t:{switch(t){case"compositionstart":var tt="onCompositionStart";break t;case"compositionend":tt="onCompositionEnd";break t;case"compositionupdate":tt="onCompositionUpdate";break t}tt=void 0}else na?Af(t,l)&&(tt="onCompositionEnd"):t==="keydown"&&l.keyCode===229&&(tt="onCompositionStart");tt&&(_f&&l.locale!=="ko"&&(na||tt!=="onCompositionStart"?tt==="onCompositionEnd"&&na&&($=vf()):(ul=A,Au="value"in ul?ul.value:ul.textContent,na=!0)),L=Bi(S,tt),0<L.length&&(tt=new bf(tt,t,null,l,A),O.push({event:tt,listeners:L}),$?tt.data=$:($=zf(l),$!==null&&(tt.data=$)))),($=pm?vm(t,l):gm(t,l))&&(tt=Bi(S,"onBeforeInput"),0<tt.length&&(L=new bf("onBeforeInput","beforeinput",null,l,A),O.push({event:L,listeners:tt}),L.data=$)),fy(O,t,S,l,A)}oh(O,e)})}function bn(t,e,l){return{instance:t,listener:e,currentTarget:l}}function Bi(t,e){for(var l=e+"Capture",a=[];t!==null;){var n=t,i=n.stateNode;if(n=n.tag,n!==5&&n!==26&&n!==27||i===null||(n=Xa(t,l),n!=null&&a.unshift(bn(t,n,i)),n=Xa(t,e),n!=null&&a.push(bn(t,n,i))),t.tag===3)return a;t=t.return}return[]}function dy(t){if(t===null)return null;do t=t.return;while(t&&t.tag!==5&&t.tag!==27);return t||null}function dh(t,e,l,a,n){for(var i=e._reactName,f=[];l!==null&&l!==a;){var o=l,m=o.alternate,S=o.stateNode;if(o=o.tag,m!==null&&m===a)break;o!==5&&o!==26&&o!==27||S===null||(m=S,n?(S=Xa(l,i),S!=null&&f.unshift(bn(l,S,m))):n||(S=Xa(l,i),S!=null&&f.push(bn(l,S,m)))),l=l.return}f.length!==0&&t.push({event:e,listeners:f})}var my=/\r\n?/g,yy=/\u0000|\uFFFD/g;function mh(t){return(typeof t=="string"?t:""+t).replace(my,`
`).replace(yy,"")}function yh(t,e){return e=mh(e),mh(t)===e}function ht(t,e,l,a,n,i){switch(l){case"children":typeof a=="string"?e==="body"||e==="textarea"&&a===""||ea(t,a):(typeof a=="number"||typeof a=="bigint")&&e!=="body"&&ea(t,""+a);break;case"className":Ln(t,"class",a);break;case"tabIndex":Ln(t,"tabindex",a);break;case"dir":case"role":case"viewBox":case"width":case"height":Ln(t,l,a);break;case"style":mf(t,a,i);break;case"data":if(e!=="object"){Ln(t,"data",a);break}case"src":case"href":if(a===""&&(e!=="a"||l!=="href")){t.removeAttribute(l);break}if(a==null||typeof a=="function"||typeof a=="symbol"||typeof a=="boolean"){t.removeAttribute(l);break}a=Qn(""+a),t.setAttribute(l,a);break;case"action":case"formAction":if(typeof a=="function"){t.setAttribute(l,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof i=="function"&&(l==="formAction"?(e!=="input"&&ht(t,e,"name",n.name,n,null),ht(t,e,"formEncType",n.formEncType,n,null),ht(t,e,"formMethod",n.formMethod,n,null),ht(t,e,"formTarget",n.formTarget,n,null)):(ht(t,e,"encType",n.encType,n,null),ht(t,e,"method",n.method,n,null),ht(t,e,"target",n.target,n,null)));if(a==null||typeof a=="symbol"||typeof a=="boolean"){t.removeAttribute(l);break}a=Qn(""+a),t.setAttribute(l,a);break;case"onClick":a!=null&&(t.onclick=Xe);break;case"onScroll":a!=null&&I("scroll",t);break;case"onScrollEnd":a!=null&&I("scrollend",t);break;case"dangerouslySetInnerHTML":if(a!=null){if(typeof a!="object"||!("__html"in a))throw Error(s(61));if(l=a.__html,l!=null){if(n.children!=null)throw Error(s(60));t.innerHTML=l}}break;case"multiple":t.multiple=a&&typeof a!="function"&&typeof a!="symbol";break;case"muted":t.muted=a&&typeof a!="function"&&typeof a!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(a==null||typeof a=="function"||typeof a=="boolean"||typeof a=="symbol"){t.removeAttribute("xlink:href");break}l=Qn(""+a),t.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",l);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":a!=null&&typeof a!="function"&&typeof a!="symbol"?t.setAttribute(l,""+a):t.removeAttribute(l);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":a&&typeof a!="function"&&typeof a!="symbol"?t.setAttribute(l,""):t.removeAttribute(l);break;case"capture":case"download":a===!0?t.setAttribute(l,""):a!==!1&&a!=null&&typeof a!="function"&&typeof a!="symbol"?t.setAttribute(l,a):t.removeAttribute(l);break;case"cols":case"rows":case"size":case"span":a!=null&&typeof a!="function"&&typeof a!="symbol"&&!isNaN(a)&&1<=a?t.setAttribute(l,a):t.removeAttribute(l);break;case"rowSpan":case"start":a==null||typeof a=="function"||typeof a=="symbol"||isNaN(a)?t.removeAttribute(l):t.setAttribute(l,a);break;case"popover":I("beforetoggle",t),I("toggle",t),Yn(t,"popover",a);break;case"xlinkActuate":Le(t,"http://www.w3.org/1999/xlink","xlink:actuate",a);break;case"xlinkArcrole":Le(t,"http://www.w3.org/1999/xlink","xlink:arcrole",a);break;case"xlinkRole":Le(t,"http://www.w3.org/1999/xlink","xlink:role",a);break;case"xlinkShow":Le(t,"http://www.w3.org/1999/xlink","xlink:show",a);break;case"xlinkTitle":Le(t,"http://www.w3.org/1999/xlink","xlink:title",a);break;case"xlinkType":Le(t,"http://www.w3.org/1999/xlink","xlink:type",a);break;case"xmlBase":Le(t,"http://www.w3.org/XML/1998/namespace","xml:base",a);break;case"xmlLang":Le(t,"http://www.w3.org/XML/1998/namespace","xml:lang",a);break;case"xmlSpace":Le(t,"http://www.w3.org/XML/1998/namespace","xml:space",a);break;case"is":Yn(t,"is",a);break;case"innerText":case"textContent":break;default:(!(2<l.length)||l[0]!=="o"&&l[0]!=="O"||l[1]!=="n"&&l[1]!=="N")&&(l=wd.get(l)||l,Yn(t,l,a))}}function us(t,e,l,a,n,i){switch(l){case"style":mf(t,a,i);break;case"dangerouslySetInnerHTML":if(a!=null){if(typeof a!="object"||!("__html"in a))throw Error(s(61));if(l=a.__html,l!=null){if(n.children!=null)throw Error(s(60));t.innerHTML=l}}break;case"children":typeof a=="string"?ea(t,a):(typeof a=="number"||typeof a=="bigint")&&ea(t,""+a);break;case"onScroll":a!=null&&I("scroll",t);break;case"onScrollEnd":a!=null&&I("scrollend",t);break;case"onClick":a!=null&&(t.onclick=Xe);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!nf.hasOwnProperty(l))t:{if(l[0]==="o"&&l[1]==="n"&&(n=l.endsWith("Capture"),e=l.slice(2,n?l.length-7:void 0),i=t[It]||null,i=i!=null?i[l]:null,typeof i=="function"&&t.removeEventListener(e,i,n),typeof a=="function")){typeof i!="function"&&i!==null&&(l in t?t[l]=null:t.hasAttribute(l)&&t.removeAttribute(l)),t.addEventListener(e,a,n);break t}l in t?t[l]=a:a===!0?t.setAttribute(l,""):Yn(t,l,a)}}}function Qt(t,e,l){switch(e){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":I("error",t),I("load",t);var a=!1,n=!1,i;for(i in l)if(l.hasOwnProperty(i)){var f=l[i];if(f!=null)switch(i){case"src":a=!0;break;case"srcSet":n=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,e));default:ht(t,e,i,f,l,null)}}n&&ht(t,e,"srcSet",l.srcSet,l,null),a&&ht(t,e,"src",l.src,l,null);return;case"input":I("invalid",t);var o=i=f=n=null,m=null,S=null;for(a in l)if(l.hasOwnProperty(a)){var A=l[a];if(A!=null)switch(a){case"name":n=A;break;case"type":f=A;break;case"checked":m=A;break;case"defaultChecked":S=A;break;case"value":i=A;break;case"defaultValue":o=A;break;case"children":case"dangerouslySetInnerHTML":if(A!=null)throw Error(s(137,e));break;default:ht(t,e,a,A,l,null)}}rf(t,i,o,m,S,f,n,!1);return;case"select":I("invalid",t),a=f=i=null;for(n in l)if(l.hasOwnProperty(n)&&(o=l[n],o!=null))switch(n){case"value":i=o;break;case"defaultValue":f=o;break;case"multiple":a=o;default:ht(t,e,n,o,l,null)}e=i,l=f,t.multiple=!!a,e!=null?ta(t,!!a,e,!1):l!=null&&ta(t,!!a,l,!0);return;case"textarea":I("invalid",t),i=n=a=null;for(f in l)if(l.hasOwnProperty(f)&&(o=l[f],o!=null))switch(f){case"value":a=o;break;case"defaultValue":n=o;break;case"children":i=o;break;case"dangerouslySetInnerHTML":if(o!=null)throw Error(s(91));break;default:ht(t,e,f,o,l,null)}hf(t,a,n,i);return;case"option":for(m in l)l.hasOwnProperty(m)&&(a=l[m],a!=null)&&(m==="selected"?t.selected=a&&typeof a!="function"&&typeof a!="symbol":ht(t,e,m,a,l,null));return;case"dialog":I("beforetoggle",t),I("toggle",t),I("cancel",t),I("close",t);break;case"iframe":case"object":I("load",t);break;case"video":case"audio":for(a=0;a<Sn.length;a++)I(Sn[a],t);break;case"image":I("error",t),I("load",t);break;case"details":I("toggle",t);break;case"embed":case"source":case"link":I("error",t),I("load",t);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(S in l)if(l.hasOwnProperty(S)&&(a=l[S],a!=null))switch(S){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,e));default:ht(t,e,S,a,l,null)}return;default:if(bu(e)){for(A in l)l.hasOwnProperty(A)&&(a=l[A],a!==void 0&&us(t,e,A,a,l,void 0));return}}for(o in l)l.hasOwnProperty(o)&&(a=l[o],a!=null&&ht(t,e,o,a,l,null))}function py(t,e,l,a){switch(e){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var n=null,i=null,f=null,o=null,m=null,S=null,A=null;for(_ in l){var O=l[_];if(l.hasOwnProperty(_)&&O!=null)switch(_){case"checked":break;case"value":break;case"defaultValue":m=O;default:a.hasOwnProperty(_)||ht(t,e,_,null,a,O)}}for(var b in a){var _=a[b];if(O=l[b],a.hasOwnProperty(b)&&(_!=null||O!=null))switch(b){case"type":i=_;break;case"name":n=_;break;case"checked":S=_;break;case"defaultChecked":A=_;break;case"value":f=_;break;case"defaultValue":o=_;break;case"children":case"dangerouslySetInnerHTML":if(_!=null)throw Error(s(137,e));break;default:_!==O&&ht(t,e,b,_,a,O)}}gu(t,f,o,m,S,A,i,n);return;case"select":_=f=o=b=null;for(i in l)if(m=l[i],l.hasOwnProperty(i)&&m!=null)switch(i){case"value":break;case"multiple":_=m;default:a.hasOwnProperty(i)||ht(t,e,i,null,a,m)}for(n in a)if(i=a[n],m=l[n],a.hasOwnProperty(n)&&(i!=null||m!=null))switch(n){case"value":b=i;break;case"defaultValue":o=i;break;case"multiple":f=i;default:i!==m&&ht(t,e,n,i,a,m)}e=o,l=f,a=_,b!=null?ta(t,!!l,b,!1):!!a!=!!l&&(e!=null?ta(t,!!l,e,!0):ta(t,!!l,l?[]:"",!1));return;case"textarea":_=b=null;for(o in l)if(n=l[o],l.hasOwnProperty(o)&&n!=null&&!a.hasOwnProperty(o))switch(o){case"value":break;case"children":break;default:ht(t,e,o,null,a,n)}for(f in a)if(n=a[f],i=l[f],a.hasOwnProperty(f)&&(n!=null||i!=null))switch(f){case"value":b=n;break;case"defaultValue":_=n;break;case"children":break;case"dangerouslySetInnerHTML":if(n!=null)throw Error(s(91));break;default:n!==i&&ht(t,e,f,n,a,i)}of(t,b,_);return;case"option":for(var H in l)b=l[H],l.hasOwnProperty(H)&&b!=null&&!a.hasOwnProperty(H)&&(H==="selected"?t.selected=!1:ht(t,e,H,null,a,b));for(m in a)b=a[m],_=l[m],a.hasOwnProperty(m)&&b!==_&&(b!=null||_!=null)&&(m==="selected"?t.selected=b&&typeof b!="function"&&typeof b!="symbol":ht(t,e,m,b,a,_));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var w in l)b=l[w],l.hasOwnProperty(w)&&b!=null&&!a.hasOwnProperty(w)&&ht(t,e,w,null,a,b);for(S in a)if(b=a[S],_=l[S],a.hasOwnProperty(S)&&b!==_&&(b!=null||_!=null))switch(S){case"children":case"dangerouslySetInnerHTML":if(b!=null)throw Error(s(137,e));break;default:ht(t,e,S,b,a,_)}return;default:if(bu(e)){for(var dt in l)b=l[dt],l.hasOwnProperty(dt)&&b!==void 0&&!a.hasOwnProperty(dt)&&us(t,e,dt,void 0,a,b);for(A in a)b=a[A],_=l[A],!a.hasOwnProperty(A)||b===_||b===void 0&&_===void 0||us(t,e,A,b,a,_);return}}for(var v in l)b=l[v],l.hasOwnProperty(v)&&b!=null&&!a.hasOwnProperty(v)&&ht(t,e,v,null,a,b);for(O in a)b=a[O],_=l[O],!a.hasOwnProperty(O)||b===_||b==null&&_==null||ht(t,e,O,b,a,_)}function ph(t){switch(t){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function vy(){if(typeof performance.getEntriesByType=="function"){for(var t=0,e=0,l=performance.getEntriesByType("resource"),a=0;a<l.length;a++){var n=l[a],i=n.transferSize,f=n.initiatorType,o=n.duration;if(i&&o&&ph(f)){for(f=0,o=n.responseEnd,a+=1;a<l.length;a++){var m=l[a],S=m.startTime;if(S>o)break;var A=m.transferSize,O=m.initiatorType;A&&ph(O)&&(m=m.responseEnd,f+=A*(m<o?1:(o-S)/(m-S)))}if(--a,e+=8*(i+f)/(n.duration/1e3),t++,10<t)break}}if(0<t)return e/t/1e6}return navigator.connection&&(t=navigator.connection.downlink,typeof t=="number")?t:5}var cs=null,ss=null;function qi(t){return t.nodeType===9?t:t.ownerDocument}function vh(t){switch(t){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function gh(t,e){if(t===0)switch(e){case"svg":return 1;case"math":return 2;default:return 0}return t===1&&e==="foreignObject"?0:t}function fs(t,e){return t==="textarea"||t==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.children=="bigint"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var rs=null;function gy(){var t=window.event;return t&&t.type==="popstate"?t===rs?!1:(rs=t,!0):(rs=null,!1)}var Sh=typeof setTimeout=="function"?setTimeout:void 0,Sy=typeof clearTimeout=="function"?clearTimeout:void 0,bh=typeof Promise=="function"?Promise:void 0,by=typeof queueMicrotask=="function"?queueMicrotask:typeof bh<"u"?function(t){return bh.resolve(null).then(t).catch(xy)}:Sh;function xy(t){setTimeout(function(){throw t})}function El(t){return t==="head"}function xh(t,e){var l=e,a=0;do{var n=l.nextSibling;if(t.removeChild(l),n&&n.nodeType===8)if(l=n.data,l==="/$"||l==="/&"){if(a===0){t.removeChild(n),Ma(e);return}a--}else if(l==="$"||l==="$?"||l==="$~"||l==="$!"||l==="&")a++;else if(l==="html")xn(t.ownerDocument.documentElement);else if(l==="head"){l=t.ownerDocument.head,xn(l);for(var i=l.firstChild;i;){var f=i.nextSibling,o=i.nodeName;i[Ya]||o==="SCRIPT"||o==="STYLE"||o==="LINK"&&i.rel.toLowerCase()==="stylesheet"||l.removeChild(i),i=f}}else l==="body"&&xn(t.ownerDocument.body);l=n}while(l);Ma(e)}function _h(t,e){var l=t;t=0;do{var a=l.nextSibling;if(l.nodeType===1?e?(l._stashedDisplay=l.style.display,l.style.display="none"):(l.style.display=l._stashedDisplay||"",l.getAttribute("style")===""&&l.removeAttribute("style")):l.nodeType===3&&(e?(l._stashedText=l.nodeValue,l.nodeValue=""):l.nodeValue=l._stashedText||""),a&&a.nodeType===8)if(l=a.data,l==="/$"){if(t===0)break;t--}else l!=="$"&&l!=="$?"&&l!=="$~"&&l!=="$!"||t++;l=a}while(l)}function os(t){var e=t.firstChild;for(e&&e.nodeType===10&&(e=e.nextSibling);e;){var l=e;switch(e=e.nextSibling,l.nodeName){case"HTML":case"HEAD":case"BODY":os(l),pu(l);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(l.rel.toLowerCase()==="stylesheet")continue}t.removeChild(l)}}function _y(t,e,l,a){for(;t.nodeType===1;){var n=l;if(t.nodeName.toLowerCase()!==e.toLowerCase()){if(!a&&(t.nodeName!=="INPUT"||t.type!=="hidden"))break}else if(a){if(!t[Ya])switch(e){case"meta":if(!t.hasAttribute("itemprop"))break;return t;case"link":if(i=t.getAttribute("rel"),i==="stylesheet"&&t.hasAttribute("data-precedence"))break;if(i!==n.rel||t.getAttribute("href")!==(n.href==null||n.href===""?null:n.href)||t.getAttribute("crossorigin")!==(n.crossOrigin==null?null:n.crossOrigin)||t.getAttribute("title")!==(n.title==null?null:n.title))break;return t;case"style":if(t.hasAttribute("data-precedence"))break;return t;case"script":if(i=t.getAttribute("src"),(i!==(n.src==null?null:n.src)||t.getAttribute("type")!==(n.type==null?null:n.type)||t.getAttribute("crossorigin")!==(n.crossOrigin==null?null:n.crossOrigin))&&i&&t.hasAttribute("async")&&!t.hasAttribute("itemprop"))break;return t;default:return t}}else if(e==="input"&&t.type==="hidden"){var i=n.name==null?null:""+n.name;if(n.type==="hidden"&&t.getAttribute("name")===i)return t}else return t;if(t=Te(t.nextSibling),t===null)break}return null}function Ey(t,e,l){if(e==="")return null;for(;t.nodeType!==3;)if((t.nodeType!==1||t.nodeName!=="INPUT"||t.type!=="hidden")&&!l||(t=Te(t.nextSibling),t===null))return null;return t}function Eh(t,e){for(;t.nodeType!==8;)if((t.nodeType!==1||t.nodeName!=="INPUT"||t.type!=="hidden")&&!e||(t=Te(t.nextSibling),t===null))return null;return t}function hs(t){return t.data==="$?"||t.data==="$~"}function ds(t){return t.data==="$!"||t.data==="$?"&&t.ownerDocument.readyState!=="loading"}function Ty(t,e){var l=t.ownerDocument;if(t.data==="$~")t._reactRetry=e;else if(t.data!=="$?"||l.readyState!=="loading")e();else{var a=function(){e(),l.removeEventListener("DOMContentLoaded",a)};l.addEventListener("DOMContentLoaded",a),t._reactRetry=a}}function Te(t){for(;t!=null;t=t.nextSibling){var e=t.nodeType;if(e===1||e===3)break;if(e===8){if(e=t.data,e==="$"||e==="$!"||e==="$?"||e==="$~"||e==="&"||e==="F!"||e==="F")break;if(e==="/$"||e==="/&")return null}}return t}var ms=null;function Th(t){t=t.nextSibling;for(var e=0;t;){if(t.nodeType===8){var l=t.data;if(l==="/$"||l==="/&"){if(e===0)return Te(t.nextSibling);e--}else l!=="$"&&l!=="$!"&&l!=="$?"&&l!=="$~"&&l!=="&"||e++}t=t.nextSibling}return null}function Ah(t){t=t.previousSibling;for(var e=0;t;){if(t.nodeType===8){var l=t.data;if(l==="$"||l==="$!"||l==="$?"||l==="$~"||l==="&"){if(e===0)return t;e--}else l!=="/$"&&l!=="/&"||e++}t=t.previousSibling}return null}function zh(t,e,l){switch(e=qi(l),t){case"html":if(t=e.documentElement,!t)throw Error(s(452));return t;case"head":if(t=e.head,!t)throw Error(s(453));return t;case"body":if(t=e.body,!t)throw Error(s(454));return t;default:throw Error(s(451))}}function xn(t){for(var e=t.attributes;e.length;)t.removeAttributeNode(e[0]);pu(t)}var Ae=new Map,Nh=new Set;function Hi(t){return typeof t.getRootNode=="function"?t.getRootNode():t.nodeType===9?t:t.ownerDocument}var ll=B.d;B.d={f:Ay,r:zy,D:Ny,C:Oy,L:jy,m:Cy,X:My,S:Dy,M:Ry};function Ay(){var t=ll.f(),e=Oi();return t||e}function zy(t){var e=Fl(t);e!==null&&e.tag===5&&e.type==="form"?wr(e):ll.r(t)}var ja=typeof document>"u"?null:document;function Oh(t,e,l){var a=ja;if(a&&typeof e=="string"&&e){var n=ve(e);n='link[rel="'+t+'"][href="'+n+'"]',typeof l=="string"&&(n+='[crossorigin="'+l+'"]'),Nh.has(n)||(Nh.add(n),t={rel:t,crossOrigin:l,href:e},a.querySelector(n)===null&&(e=a.createElement("link"),Qt(e,"link",t),Ut(e),a.head.appendChild(e)))}}function Ny(t){ll.D(t),Oh("dns-prefetch",t,null)}function Oy(t,e){ll.C(t,e),Oh("preconnect",t,e)}function jy(t,e,l){ll.L(t,e,l);var a=ja;if(a&&t&&e){var n='link[rel="preload"][as="'+ve(e)+'"]';e==="image"&&l&&l.imageSrcSet?(n+='[imagesrcset="'+ve(l.imageSrcSet)+'"]',typeof l.imageSizes=="string"&&(n+='[imagesizes="'+ve(l.imageSizes)+'"]')):n+='[href="'+ve(t)+'"]';var i=n;switch(e){case"style":i=Ca(t);break;case"script":i=Da(t)}Ae.has(i)||(t=R({rel:"preload",href:e==="image"&&l&&l.imageSrcSet?void 0:t,as:e},l),Ae.set(i,t),a.querySelector(n)!==null||e==="style"&&a.querySelector(_n(i))||e==="script"&&a.querySelector(En(i))||(e=a.createElement("link"),Qt(e,"link",t),Ut(e),a.head.appendChild(e)))}}function Cy(t,e){ll.m(t,e);var l=ja;if(l&&t){var a=e&&typeof e.as=="string"?e.as:"script",n='link[rel="modulepreload"][as="'+ve(a)+'"][href="'+ve(t)+'"]',i=n;switch(a){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":i=Da(t)}if(!Ae.has(i)&&(t=R({rel:"modulepreload",href:t},e),Ae.set(i,t),l.querySelector(n)===null)){switch(a){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(l.querySelector(En(i)))return}a=l.createElement("link"),Qt(a,"link",t),Ut(a),l.head.appendChild(a)}}}function Dy(t,e,l){ll.S(t,e,l);var a=ja;if(a&&t){var n=Il(a).hoistableStyles,i=Ca(t);e=e||"default";var f=n.get(i);if(!f){var o={loading:0,preload:null};if(f=a.querySelector(_n(i)))o.loading=5;else{t=R({rel:"stylesheet",href:t,"data-precedence":e},l),(l=Ae.get(i))&&ys(t,l);var m=f=a.createElement("link");Ut(m),Qt(m,"link",t),m._p=new Promise(function(S,A){m.onload=S,m.onerror=A}),m.addEventListener("load",function(){o.loading|=1}),m.addEventListener("error",function(){o.loading|=2}),o.loading|=4,Yi(f,e,a)}f={type:"stylesheet",instance:f,count:1,state:o},n.set(i,f)}}}function My(t,e){ll.X(t,e);var l=ja;if(l&&t){var a=Il(l).hoistableScripts,n=Da(t),i=a.get(n);i||(i=l.querySelector(En(n)),i||(t=R({src:t,async:!0},e),(e=Ae.get(n))&&ps(t,e),i=l.createElement("script"),Ut(i),Qt(i,"link",t),l.head.appendChild(i)),i={type:"script",instance:i,count:1,state:null},a.set(n,i))}}function Ry(t,e){ll.M(t,e);var l=ja;if(l&&t){var a=Il(l).hoistableScripts,n=Da(t),i=a.get(n);i||(i=l.querySelector(En(n)),i||(t=R({src:t,async:!0,type:"module"},e),(e=Ae.get(n))&&ps(t,e),i=l.createElement("script"),Ut(i),Qt(i,"link",t),l.head.appendChild(i)),i={type:"script",instance:i,count:1,state:null},a.set(n,i))}}function jh(t,e,l,a){var n=(n=Z.current)?Hi(n):null;if(!n)throw Error(s(446));switch(t){case"meta":case"title":return null;case"style":return typeof l.precedence=="string"&&typeof l.href=="string"?(e=Ca(l.href),l=Il(n).hoistableStyles,a=l.get(e),a||(a={type:"style",instance:null,count:0,state:null},l.set(e,a)),a):{type:"void",instance:null,count:0,state:null};case"link":if(l.rel==="stylesheet"&&typeof l.href=="string"&&typeof l.precedence=="string"){t=Ca(l.href);var i=Il(n).hoistableStyles,f=i.get(t);if(f||(n=n.ownerDocument||n,f={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},i.set(t,f),(i=n.querySelector(_n(t)))&&!i._p&&(f.instance=i,f.state.loading=5),Ae.has(t)||(l={rel:"preload",as:"style",href:l.href,crossOrigin:l.crossOrigin,integrity:l.integrity,media:l.media,hrefLang:l.hrefLang,referrerPolicy:l.referrerPolicy},Ae.set(t,l),i||Uy(n,t,l,f.state))),e&&a===null)throw Error(s(528,""));return f}if(e&&a!==null)throw Error(s(529,""));return null;case"script":return e=l.async,l=l.src,typeof l=="string"&&e&&typeof e!="function"&&typeof e!="symbol"?(e=Da(l),l=Il(n).hoistableScripts,a=l.get(e),a||(a={type:"script",instance:null,count:0,state:null},l.set(e,a)),a):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,t))}}function Ca(t){return'href="'+ve(t)+'"'}function _n(t){return'link[rel="stylesheet"]['+t+"]"}function Ch(t){return R({},t,{"data-precedence":t.precedence,precedence:null})}function Uy(t,e,l,a){t.querySelector('link[rel="preload"][as="style"]['+e+"]")?a.loading=1:(e=t.createElement("link"),a.preload=e,e.addEventListener("load",function(){return a.loading|=1}),e.addEventListener("error",function(){return a.loading|=2}),Qt(e,"link",l),Ut(e),t.head.appendChild(e))}function Da(t){return'[src="'+ve(t)+'"]'}function En(t){return"script[async]"+t}function Dh(t,e,l){if(e.count++,e.instance===null)switch(e.type){case"style":var a=t.querySelector('style[data-href~="'+ve(l.href)+'"]');if(a)return e.instance=a,Ut(a),a;var n=R({},l,{"data-href":l.href,"data-precedence":l.precedence,href:null,precedence:null});return a=(t.ownerDocument||t).createElement("style"),Ut(a),Qt(a,"style",n),Yi(a,l.precedence,t),e.instance=a;case"stylesheet":n=Ca(l.href);var i=t.querySelector(_n(n));if(i)return e.state.loading|=4,e.instance=i,Ut(i),i;a=Ch(l),(n=Ae.get(n))&&ys(a,n),i=(t.ownerDocument||t).createElement("link"),Ut(i);var f=i;return f._p=new Promise(function(o,m){f.onload=o,f.onerror=m}),Qt(i,"link",a),e.state.loading|=4,Yi(i,l.precedence,t),e.instance=i;case"script":return i=Da(l.src),(n=t.querySelector(En(i)))?(e.instance=n,Ut(n),n):(a=l,(n=Ae.get(i))&&(a=R({},l),ps(a,n)),t=t.ownerDocument||t,n=t.createElement("script"),Ut(n),Qt(n,"link",a),t.head.appendChild(n),e.instance=n);case"void":return null;default:throw Error(s(443,e.type))}else e.type==="stylesheet"&&(e.state.loading&4)===0&&(a=e.instance,e.state.loading|=4,Yi(a,l.precedence,t));return e.instance}function Yi(t,e,l){for(var a=l.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),n=a.length?a[a.length-1]:null,i=n,f=0;f<a.length;f++){var o=a[f];if(o.dataset.precedence===e)i=o;else if(i!==n)break}i?i.parentNode.insertBefore(t,i.nextSibling):(e=l.nodeType===9?l.head:l,e.insertBefore(t,e.firstChild))}function ys(t,e){t.crossOrigin==null&&(t.crossOrigin=e.crossOrigin),t.referrerPolicy==null&&(t.referrerPolicy=e.referrerPolicy),t.title==null&&(t.title=e.title)}function ps(t,e){t.crossOrigin==null&&(t.crossOrigin=e.crossOrigin),t.referrerPolicy==null&&(t.referrerPolicy=e.referrerPolicy),t.integrity==null&&(t.integrity=e.integrity)}var Li=null;function Mh(t,e,l){if(Li===null){var a=new Map,n=Li=new Map;n.set(l,a)}else n=Li,a=n.get(l),a||(a=new Map,n.set(l,a));if(a.has(t))return a;for(a.set(t,null),l=l.getElementsByTagName(t),n=0;n<l.length;n++){var i=l[n];if(!(i[Ya]||i[Ht]||t==="link"&&i.getAttribute("rel")==="stylesheet")&&i.namespaceURI!=="http://www.w3.org/2000/svg"){var f=i.getAttribute(e)||"";f=t+f;var o=a.get(f);o?o.push(i):a.set(f,[i])}}return a}function Rh(t,e,l){t=t.ownerDocument||t,t.head.insertBefore(l,e==="title"?t.querySelector("head > title"):null)}function By(t,e,l){if(l===1||e.itemProp!=null)return!1;switch(t){case"meta":case"title":return!0;case"style":if(typeof e.precedence!="string"||typeof e.href!="string"||e.href==="")break;return!0;case"link":if(typeof e.rel!="string"||typeof e.href!="string"||e.href===""||e.onLoad||e.onError)break;return e.rel==="stylesheet"?(t=e.disabled,typeof e.precedence=="string"&&t==null):!0;case"script":if(e.async&&typeof e.async!="function"&&typeof e.async!="symbol"&&!e.onLoad&&!e.onError&&e.src&&typeof e.src=="string")return!0}return!1}function Uh(t){return!(t.type==="stylesheet"&&(t.state.loading&3)===0)}function qy(t,e,l,a){if(l.type==="stylesheet"&&(typeof a.media!="string"||matchMedia(a.media).matches!==!1)&&(l.state.loading&4)===0){if(l.instance===null){var n=Ca(a.href),i=e.querySelector(_n(n));if(i){e=i._p,e!==null&&typeof e=="object"&&typeof e.then=="function"&&(t.count++,t=Xi.bind(t),e.then(t,t)),l.state.loading|=4,l.instance=i,Ut(i);return}i=e.ownerDocument||e,a=Ch(a),(n=Ae.get(n))&&ys(a,n),i=i.createElement("link"),Ut(i);var f=i;f._p=new Promise(function(o,m){f.onload=o,f.onerror=m}),Qt(i,"link",a),l.instance=i}t.stylesheets===null&&(t.stylesheets=new Map),t.stylesheets.set(l,e),(e=l.state.preload)&&(l.state.loading&3)===0&&(t.count++,l=Xi.bind(t),e.addEventListener("load",l),e.addEventListener("error",l))}}var vs=0;function Hy(t,e){return t.stylesheets&&t.count===0&&Gi(t,t.stylesheets),0<t.count||0<t.imgCount?function(l){var a=setTimeout(function(){if(t.stylesheets&&Gi(t,t.stylesheets),t.unsuspend){var i=t.unsuspend;t.unsuspend=null,i()}},6e4+e);0<t.imgBytes&&vs===0&&(vs=62500*vy());var n=setTimeout(function(){if(t.waitingForImages=!1,t.count===0&&(t.stylesheets&&Gi(t,t.stylesheets),t.unsuspend)){var i=t.unsuspend;t.unsuspend=null,i()}},(t.imgBytes>vs?50:800)+e);return t.unsuspend=l,function(){t.unsuspend=null,clearTimeout(a),clearTimeout(n)}}:null}function Xi(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)Gi(this,this.stylesheets);else if(this.unsuspend){var t=this.unsuspend;this.unsuspend=null,t()}}}var Qi=null;function Gi(t,e){t.stylesheets=null,t.unsuspend!==null&&(t.count++,Qi=new Map,e.forEach(Yy,t),Qi=null,Xi.call(t))}function Yy(t,e){if(!(e.state.loading&4)){var l=Qi.get(t);if(l)var a=l.get(null);else{l=new Map,Qi.set(t,l);for(var n=t.querySelectorAll("link[data-precedence],style[data-precedence]"),i=0;i<n.length;i++){var f=n[i];(f.nodeName==="LINK"||f.getAttribute("media")!=="not all")&&(l.set(f.dataset.precedence,f),a=f)}a&&l.set(null,a)}n=e.instance,f=n.getAttribute("data-precedence"),i=l.get(f)||a,i===a&&l.set(null,n),l.set(f,n),this.count++,a=Xi.bind(this),n.addEventListener("load",a),n.addEventListener("error",a),i?i.parentNode.insertBefore(n,i.nextSibling):(t=t.nodeType===9?t.head:t,t.insertBefore(n,t.firstChild)),e.state.loading|=4}}var Tn={$$typeof:bt,Provider:null,Consumer:null,_currentValue:X,_currentValue2:X,_threadCount:0};function Ly(t,e,l,a,n,i,f,o,m){this.tag=1,this.containerInfo=t,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=hu(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=hu(0),this.hiddenUpdates=hu(null),this.identifierPrefix=a,this.onUncaughtError=n,this.onCaughtError=i,this.onRecoverableError=f,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=m,this.incompleteTransitions=new Map}function Bh(t,e,l,a,n,i,f,o,m,S,A,O){return t=new Ly(t,e,l,f,m,S,A,O,o),e=1,i===!0&&(e|=24),i=fe(3,null,null,e),t.current=i,i.stateNode=t,e=Wu(),e.refCount++,t.pooledCache=e,e.refCount++,i.memoizedState={element:a,isDehydrated:l,cache:e},tc(i),t}function qh(t){return t?(t=sa,t):sa}function Hh(t,e,l,a,n,i){n=qh(n),a.context===null?a.context=n:a.pendingContext=n,a=hl(e),a.payload={element:l},i=i===void 0?null:i,i!==null&&(a.callback=i),l=dl(t,a,e),l!==null&&(ne(l,t,e),en(l,t,e))}function Yh(t,e){if(t=t.memoizedState,t!==null&&t.dehydrated!==null){var l=t.retryLane;t.retryLane=l!==0&&l<e?l:e}}function gs(t,e){Yh(t,e),(t=t.alternate)&&Yh(t,e)}function Lh(t){if(t.tag===13||t.tag===31){var e=ql(t,67108864);e!==null&&ne(e,t,67108864),gs(t,67108864)}}function Xh(t){if(t.tag===13||t.tag===31){var e=me();e=du(e);var l=ql(t,e);l!==null&&ne(l,t,e),gs(t,e)}}var wi=!0;function Xy(t,e,l,a){var n=T.T;T.T=null;var i=B.p;try{B.p=2,Ss(t,e,l,a)}finally{B.p=i,T.T=n}}function Qy(t,e,l,a){var n=T.T;T.T=null;var i=B.p;try{B.p=8,Ss(t,e,l,a)}finally{B.p=i,T.T=n}}function Ss(t,e,l,a){if(wi){var n=bs(a);if(n===null)is(t,e,a,Vi,l),Gh(t,a);else if(wy(n,t,e,l,a))a.stopPropagation();else if(Gh(t,a),e&4&&-1<Gy.indexOf(t)){for(;n!==null;){var i=Fl(n);if(i!==null)switch(i.tag){case 3:if(i=i.stateNode,i.current.memoizedState.isDehydrated){var f=Dl(i.pendingLanes);if(f!==0){var o=i;for(o.pendingLanes|=2,o.entangledLanes|=2;f;){var m=1<<31-ce(f);o.entanglements[1]|=m,f&=~m}Be(i),(ut&6)===0&&(zi=ie()+500,gn(0))}}break;case 31:case 13:o=ql(i,2),o!==null&&ne(o,i,2),Oi(),gs(i,2)}if(i=bs(a),i===null&&is(t,e,a,Vi,l),i===n)break;n=i}n!==null&&a.stopPropagation()}else is(t,e,a,null,l)}}function bs(t){return t=_u(t),xs(t)}var Vi=null;function xs(t){if(Vi=null,t=Wl(t),t!==null){var e=x(t);if(e===null)t=null;else{var l=e.tag;if(l===13){if(t=D(e),t!==null)return t;t=null}else if(l===31){if(t=M(e),t!==null)return t;t=null}else if(l===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;t=null}else e!==t&&(t=null)}}return Vi=t,null}function Qh(t){switch(t){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Nd()){case Js:return 2;case ks:return 8;case Rn:case Od:return 32;case $s:return 268435456;default:return 32}default:return 32}}var _s=!1,Tl=null,Al=null,zl=null,An=new Map,zn=new Map,Nl=[],Gy="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function Gh(t,e){switch(t){case"focusin":case"focusout":Tl=null;break;case"dragenter":case"dragleave":Al=null;break;case"mouseover":case"mouseout":zl=null;break;case"pointerover":case"pointerout":An.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":zn.delete(e.pointerId)}}function Nn(t,e,l,a,n,i){return t===null||t.nativeEvent!==i?(t={blockedOn:e,domEventName:l,eventSystemFlags:a,nativeEvent:i,targetContainers:[n]},e!==null&&(e=Fl(e),e!==null&&Lh(e)),t):(t.eventSystemFlags|=a,e=t.targetContainers,n!==null&&e.indexOf(n)===-1&&e.push(n),t)}function wy(t,e,l,a,n){switch(e){case"focusin":return Tl=Nn(Tl,t,e,l,a,n),!0;case"dragenter":return Al=Nn(Al,t,e,l,a,n),!0;case"mouseover":return zl=Nn(zl,t,e,l,a,n),!0;case"pointerover":var i=n.pointerId;return An.set(i,Nn(An.get(i)||null,t,e,l,a,n)),!0;case"gotpointercapture":return i=n.pointerId,zn.set(i,Nn(zn.get(i)||null,t,e,l,a,n)),!0}return!1}function wh(t){var e=Wl(t.target);if(e!==null){var l=x(e);if(l!==null){if(e=l.tag,e===13){if(e=D(l),e!==null){t.blockedOn=e,ef(t.priority,function(){Xh(l)});return}}else if(e===31){if(e=M(l),e!==null){t.blockedOn=e,ef(t.priority,function(){Xh(l)});return}}else if(e===3&&l.stateNode.current.memoizedState.isDehydrated){t.blockedOn=l.tag===3?l.stateNode.containerInfo:null;return}}}t.blockedOn=null}function Zi(t){if(t.blockedOn!==null)return!1;for(var e=t.targetContainers;0<e.length;){var l=bs(t.nativeEvent);if(l===null){l=t.nativeEvent;var a=new l.constructor(l.type,l);xu=a,l.target.dispatchEvent(a),xu=null}else return e=Fl(l),e!==null&&Lh(e),t.blockedOn=l,!1;e.shift()}return!0}function Vh(t,e,l){Zi(t)&&l.delete(e)}function Vy(){_s=!1,Tl!==null&&Zi(Tl)&&(Tl=null),Al!==null&&Zi(Al)&&(Al=null),zl!==null&&Zi(zl)&&(zl=null),An.forEach(Vh),zn.forEach(Vh)}function Ki(t,e){t.blockedOn===e&&(t.blockedOn=null,_s||(_s=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Vy)))}var Ji=null;function Zh(t){Ji!==t&&(Ji=t,r.unstable_scheduleCallback(r.unstable_NormalPriority,function(){Ji===t&&(Ji=null);for(var e=0;e<t.length;e+=3){var l=t[e],a=t[e+1],n=t[e+2];if(typeof a!="function"){if(xs(a||l)===null)continue;break}var i=Fl(l);i!==null&&(t.splice(e,3),e-=3,bc(i,{pending:!0,data:n,method:l.method,action:a},a,n))}}))}function Ma(t){function e(m){return Ki(m,t)}Tl!==null&&Ki(Tl,t),Al!==null&&Ki(Al,t),zl!==null&&Ki(zl,t),An.forEach(e),zn.forEach(e);for(var l=0;l<Nl.length;l++){var a=Nl[l];a.blockedOn===t&&(a.blockedOn=null)}for(;0<Nl.length&&(l=Nl[0],l.blockedOn===null);)wh(l),l.blockedOn===null&&Nl.shift();if(l=(t.ownerDocument||t).$$reactFormReplay,l!=null)for(a=0;a<l.length;a+=3){var n=l[a],i=l[a+1],f=n[It]||null;if(typeof i=="function")f||Zh(l);else if(f){var o=null;if(i&&i.hasAttribute("formAction")){if(n=i,f=i[It]||null)o=f.formAction;else if(xs(n)!==null)continue}else o=f.action;typeof o=="function"?l[a+1]=o:(l.splice(a,3),a-=3),Zh(l)}}}function Kh(){function t(i){i.canIntercept&&i.info==="react-transition"&&i.intercept({handler:function(){return new Promise(function(f){return n=f})},focusReset:"manual",scroll:"manual"})}function e(){n!==null&&(n(),n=null),a||setTimeout(l,20)}function l(){if(!a&&!navigation.transition){var i=navigation.currentEntry;i&&i.url!=null&&navigation.navigate(i.url,{state:i.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var a=!1,n=null;return navigation.addEventListener("navigate",t),navigation.addEventListener("navigatesuccess",e),navigation.addEventListener("navigateerror",e),setTimeout(l,100),function(){a=!0,navigation.removeEventListener("navigate",t),navigation.removeEventListener("navigatesuccess",e),navigation.removeEventListener("navigateerror",e),n!==null&&(n(),n=null)}}}function Es(t){this._internalRoot=t}ki.prototype.render=Es.prototype.render=function(t){var e=this._internalRoot;if(e===null)throw Error(s(409));var l=e.current,a=me();Hh(l,a,t,e,null,null)},ki.prototype.unmount=Es.prototype.unmount=function(){var t=this._internalRoot;if(t!==null){this._internalRoot=null;var e=t.containerInfo;Hh(t.current,2,null,t,null,null),Oi(),e[$l]=null}};function ki(t){this._internalRoot=t}ki.prototype.unstable_scheduleHydration=function(t){if(t){var e=tf();t={blockedOn:null,target:t,priority:e};for(var l=0;l<Nl.length&&e!==0&&e<Nl[l].priority;l++);Nl.splice(l,0,t),l===0&&wh(t)}};var Jh=u.version;if(Jh!=="19.2.3")throw Error(s(527,Jh,"19.2.3"));B.findDOMNode=function(t){var e=t._reactInternals;if(e===void 0)throw typeof t.render=="function"?Error(s(188)):(t=Object.keys(t).join(","),Error(s(268,t)));return t=z(e),t=t!==null?G(t):null,t=t===null?null:t.stateNode,t};var Zy={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:T,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var $i=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!$i.isDisabled&&$i.supportsFiber)try{Ba=$i.inject(Zy),ue=$i}catch{}}return jn.createRoot=function(t,e){if(!p(t))throw Error(s(299));var l=!1,a="",n=Pr,i=to,f=eo;return e!=null&&(e.unstable_strictMode===!0&&(l=!0),e.identifierPrefix!==void 0&&(a=e.identifierPrefix),e.onUncaughtError!==void 0&&(n=e.onUncaughtError),e.onCaughtError!==void 0&&(i=e.onCaughtError),e.onRecoverableError!==void 0&&(f=e.onRecoverableError)),e=Bh(t,1,!1,null,null,l,a,null,n,i,f,Kh),t[$l]=e.current,ns(t),new Es(e)},jn.hydrateRoot=function(t,e,l){if(!p(t))throw Error(s(299));var a=!1,n="",i=Pr,f=to,o=eo,m=null;return l!=null&&(l.unstable_strictMode===!0&&(a=!0),l.identifierPrefix!==void 0&&(n=l.identifierPrefix),l.onUncaughtError!==void 0&&(i=l.onUncaughtError),l.onCaughtError!==void 0&&(f=l.onCaughtError),l.onRecoverableError!==void 0&&(o=l.onRecoverableError),l.formState!==void 0&&(m=l.formState)),e=Bh(t,1,!0,e,l??null,a,n,m,i,f,o,Kh),e.context=qh(null),l=e.current,a=me(),a=du(a),n=hl(a),n.callback=null,dl(l,n,a),l=a,e.current.lanes=l,Ha(e,l),Be(e),t[$l]=e.current,ns(t),new ki(e)},jn.version="19.2.3",jn}var ad;function l0(){if(ad)return zs.exports;ad=1;function r(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r)}catch(u){console.error(u)}}return r(),zs.exports=e0(),zs.exports}var a0=l0();const n0=fd(a0),i0=({isConnected:r})=>h.jsxs("header",{className:"header",children:[h.jsx("div",{style:{position:"absolute",left:"50%",transform:"translateX(-50%)",width:"300px",height:"80px",display:"flex",alignItems:"center",justifyContent:"center"},children:h.jsx("img",{src:"/header_full.png",alt:"1 to 100 Sol Challenge",style:{width:"100%",height:"100%",objectFit:"contain"}})}),h.jsxs("div",{className:"live-badge",style:{background:r?"var(--success-subtle)":"var(--error-subtle)",borderColor:r?"rgba(16, 185, 129, 0.2)":"rgba(239, 68, 68, 0.2)",color:r?"var(--success)":"var(--error)"},children:[r&&h.jsx("span",{className:"live-dot"}),h.jsx("span",{children:r?"Live":"Disconnected"})]})]}),Wi=({value:r,className:u=""})=>{const[c,s]=st.useState(r),[p,x]=st.useState(!1);return st.useEffect(()=>{if(r!==c){x(!0),s(r);const D=setTimeout(()=>x(!1),300);return()=>clearTimeout(D)}},[r,c]),h.jsx("div",{className:`animate-number ${p?"updating":""} ${u}`,children:r})},u0=({stats:r})=>{const u=parseFloat(r.currentEquity||"0"),c=parseFloat(r.initialCapital||"0"),s=u-c,p=s>=0;return h.jsxs("div",{className:"stats-grid",children:[h.jsxs("div",{className:"stat-card highlight",children:[h.jsx("div",{className:"stat-label",children:"Multiplier"}),h.jsx(Wi,{value:`${parseFloat(r.multiplier||"1").toFixed(2)}x`,className:"stat-value accent"}),h.jsxs("div",{className:`stat-sub ${p?"positive":""}`,children:[h.jsx("span",{className:"arrow",children:"â†‘"}),h.jsxs("span",{children:[p?"+":"",s.toFixed(2)," SOL profit"]})]})]}),h.jsxs("div",{className:"stat-card",children:[h.jsx("div",{className:"stat-label",children:"Win Rate"}),h.jsx(Wi,{value:`${r.winRate}%`,className:"stat-value"}),h.jsxs("div",{className:"stat-sub positive",children:[h.jsx("span",{className:"arrow",children:"â†‘"}),h.jsx("span",{children:"Creating alpha"})]})]}),h.jsxs("div",{className:"stat-card",children:[h.jsx("div",{className:"stat-label",children:"Total Trades"}),h.jsx(Wi,{value:r.totalTrades,className:"stat-value"}),h.jsx("div",{className:"stat-sub",children:"Lifetime"})]}),h.jsxs("div",{className:"stat-card",children:[h.jsx("div",{className:"stat-label",children:"Tokens Scanned"}),h.jsx(Wi,{value:r.tokensScanned,className:"stat-value"}),h.jsx("div",{className:"stat-sub",children:"Last 24 hours"})]})]})},c0=({stats:r})=>{const u=parseFloat(r.multiplier||"1"),c=parseFloat(r.currentEquity||r.initialCapital||"1"),s=parseFloat(r.initialCapital||"1"),p=Math.min(100,Math.max(1,u)),[x,D]=st.useState(u);return st.useEffect(()=>{D(u)},[u]),h.jsx("div",{className:"card",children:h.jsxs("div",{className:"challenge-card",children:[h.jsx("div",{className:"challenge-label",children:"THE 1 â†’ 100 CHALLENGE"}),h.jsxs("div",{className:"challenge-value animate-number",children:[x.toFixed(2),h.jsx("span",{children:"x"})]}),h.jsxs("div",{className:"challenge-sub",children:[c.toFixed(2)," SOL from ",s," SOL start"]}),h.jsxs("div",{className:"progress-bar-container",children:[h.jsx("div",{className:"progress-bar",children:h.jsx("div",{className:"progress-fill",style:{width:`${p}%`}})}),h.jsxs("div",{className:"progress-markers",children:[h.jsx("span",{className:u>=1?"active":"",children:"1x"}),h.jsx("span",{className:u>=10?"active":"",children:"10x"}),h.jsx("span",{className:u>=25?"active":"",children:"25x"}),h.jsx("span",{className:u>=50?"active":"",children:"50x"}),h.jsx("span",{className:u>=100?"active":"",children:"100x"})]})]})]})})};async function s0(r){try{return await navigator.clipboard.writeText(r),!0}catch{const c=document.createElement("textarea");c.value=r,c.style.position="fixed",c.style.left="-999999px",c.style.top="-999999px",document.body.appendChild(c),c.focus(),c.select();try{return document.execCommand("copy"),c.remove(),!0}catch{return c.remove(),!1}}}const rd=r=>{let u=0;for(let s=0;s<r.length;s++)u=r.charCodeAt(s)+((u<<5)-u);return`hsl(${u%360}, 65%, 45%)`},f0={sm:{img:20,fontSize:"11px",gap:"6px"},md:{img:28,fontSize:"12px",gap:"8px"},lg:{img:40,fontSize:"14px",gap:"10px"}},au=({mint:r,name:u,symbol:c,imageUrl:s,size:p="md",showCopy:x=!0,inline:D=!1})=>{const[M,C]=st.useState(!1),[z,G]=st.useState(!1),R=f0[p],V=u||c||"Unknown",at=c?`$${c}`:`$${r.substring(0,6).toUpperCase()}`,mt=`${r.substring(0,6)}...${r.substring(r.length-4)}`,pt=(c||u||r)[0].toUpperCase(),Mt=rd(r),Et=async bt=>{bt.stopPropagation(),await s0(r)&&(C(!0),setTimeout(()=>C(!1),1500))},Kt=()=>s&&!z?h.jsx("img",{src:s,alt:V,style:{width:R.img,height:R.img,borderRadius:"50%",objectFit:"cover",flexShrink:0},onError:()=>G(!0)}):h.jsx("div",{style:{width:R.img,height:R.img,borderRadius:"50%",background:Mt,display:"flex",alignItems:"center",justifyContent:"center",color:"#fff",fontSize:R.img*.5,fontWeight:600,flexShrink:0},children:pt});return D?h.jsxs("div",{style:{display:"flex",alignItems:"center",gap:R.gap},children:[Kt(),h.jsx("span",{style:{fontFamily:"var(--font-mono)",fontSize:R.fontSize,color:"var(--text-primary)"},children:at}),x&&h.jsx("button",{onClick:Et,style:{background:"none",border:"none",padding:"2px",cursor:"pointer",color:M?"var(--success)":"var(--text-muted)",fontSize:"10px",display:"flex",alignItems:"center"},title:"Copy address",children:M?"âœ“":"âŽ˜"})]}):h.jsxs("div",{style:{display:"flex",alignItems:"flex-start",gap:R.gap},children:[Kt(),h.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:"2px",minWidth:0},children:[p!=="sm"&&u&&h.jsx("div",{style:{fontSize:R.fontSize,fontWeight:500,color:"var(--text-primary)",overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"},children:V}),h.jsx("div",{style:{fontFamily:"var(--font-mono)",fontSize:p==="lg"?"12px":"11px",color:"var(--accent)"},children:at}),x&&h.jsxs("button",{onClick:Et,style:{display:"flex",alignItems:"center",gap:"4px",background:"none",border:"none",padding:0,cursor:"pointer",color:M?"var(--success)":"var(--text-muted)",fontSize:"10px",fontFamily:"var(--font-mono)"},title:"Copy full address",children:[h.jsx("span",{children:mt}),h.jsx("span",{style:{fontSize:"9px"},children:M?"âœ“":"âŽ˜"})]})]})]})},r0=({mint:r,symbol:u,imageUrl:c,onClick:s})=>{const[p,x]=st.useState(!1),D=u?`$${u}`:`$${r.substring(0,6).toUpperCase()}`,M=(u||r)[0].toUpperCase(),C=rd(r);return h.jsxs("div",{onClick:s,style:{display:"inline-flex",alignItems:"center",gap:"4px",padding:"2px 8px 2px 2px",borderRadius:"12px",background:"var(--bg-elevated)",cursor:s?"pointer":"default"},children:[c&&!p?h.jsx("img",{src:c,alt:D,style:{width:18,height:18,borderRadius:"50%",objectFit:"cover"},onError:()=>x(!0)}):h.jsx("div",{style:{width:18,height:18,borderRadius:"50%",background:C,display:"flex",alignItems:"center",justifyContent:"center",color:"#fff",fontSize:9,fontWeight:600},children:M}),h.jsx("span",{style:{fontFamily:"var(--font-mono)",fontSize:"11px",color:"var(--text-primary)"},children:D})]})},o0=({data:r,isScanning:u,tokensScanned:c=0})=>h.jsxs("div",{className:"card scanner-card",children:[h.jsxs("div",{className:"card-header",children:[h.jsx("span",{className:"card-title",children:"Token Scanner"}),h.jsxs("span",{style:{fontSize:"11px",color:"var(--text-muted)",background:"var(--bg-elevated)",padding:"4px 10px",borderRadius:"12px"},children:[c.toLocaleString()," scanned"]})]}),h.jsxs("div",{className:"scanner-content",children:[h.jsxs("div",{className:"scanner-token",children:[h.jsx("div",{className:`scanner-icon ${u?"scanning":""}`,children:"âŸ³"}),h.jsx("div",{className:"scanner-token-info",children:r?.mint?h.jsx(au,{mint:r.mint,name:r.name,symbol:r.symbol,imageUrl:r.imageUrl,size:"lg",showCopy:!0}):h.jsxs("div",{style:{padding:"8px 0"},children:[h.jsx("h4",{style:{margin:0,color:"var(--text-primary)"},children:u?"Scanning...":"Waiting for tokens"}),h.jsx("p",{style:{margin:"4px 0 0",fontSize:"12px",color:"var(--text-muted)"},children:"Monitoring pump.fun for new launches"})]})})]}),r?.mint&&h.jsx("div",{style:{marginTop:"16px",padding:"12px",background:"var(--bg-elevated)",borderRadius:"8px",fontSize:"12px",color:"var(--text-muted)",textAlign:"center"},children:"Collecting price data for watchlist analysis..."})]})]}),h0=({trades:r})=>h.jsxs("div",{className:"card",children:[h.jsx("div",{className:"card-header",children:h.jsx("span",{className:"card-title",children:"Recent Trades"})}),h.jsx("div",{className:"trades-list",children:r.length===0?h.jsx("div",{className:"empty-state",children:"No trades yet"}):r.map((u,c)=>{const s=parseFloat(u.pnlSol||"0"),p=parseFloat(u.pnlPercent||"0"),x=s>=0,D=new Date(u.exitTime||u.entryTime).toLocaleTimeString("en-US",{hour:"numeric",minute:"2-digit",hour12:!0});return h.jsxs("div",{className:"trade-item",children:[h.jsx("div",{className:`trade-arrow ${x?"up":"down"}`,children:x?"â†‘":"â†“"}),h.jsxs("div",{className:"trade-info",children:[h.jsx(au,{mint:u.mint,name:u.name,symbol:u.symbol,imageUrl:u.imageUrl,size:"sm",showCopy:!0,inline:!0}),h.jsx("div",{className:"trade-time",children:D})]}),h.jsxs("div",{className:"trade-pnl",children:[h.jsxs("div",{className:`trade-pnl-value ${x?"positive":"negative"}`,children:[x?"+":"",s.toFixed(3)," SOL"]}),x&&h.jsxs("div",{className:"trade-pnl-percent",children:["+",p.toFixed(0),"%"]})]})]},c)})})]}),d0=({stats:r,decision:u})=>{const[c,s]=st.useState("Initializing AI Model..."),p=parseFloat(r.winRate||"0"),x=r.winStreak||0;st.useEffect(()=>{if(!u)return;const V=["BULL","VOLATILE","CRASH"][u.regime];let at;switch(u.action){case 0:at="Watching";break;case 1:at="Buying";break;case 2:at="Passing on";break;default:at="Evaluating"}s(`${V}: ${at}`)},[u]),st.useEffect(()=>{if(u)return;const R=["Analyzing market structure","Calculating Q-values","Scanning liquidity"];let V=0;const at=setInterval(()=>{V=(V+1)%R.length,s(R[V])},3e3);return()=>clearInterval(at)},[u]);const D=u?.qValues||[0,0,0],M=Math.max(...D.map(Math.abs),1),C=u?u.confidence:p/100,z=Math.min(100,Math.max(0,C*500)),G=u?z:Math.min(100,Math.max(0,p*1.2));return h.jsxs("div",{className:"card",children:[h.jsx("div",{className:"card-header",children:h.jsx("span",{className:"card-title",children:"Claude's Thoughts"})}),h.jsxs("div",{className:"ai-content",children:[h.jsxs("div",{className:"ai-indicator",children:[h.jsx("div",{className:"ai-ring-outer"}),h.jsx("div",{className:"ai-ring",style:{animationDuration:u?"0.5s":"1.5s"}}),h.jsx("div",{className:"ai-ring-inner"}),h.jsx("div",{className:"ai-center",children:h.jsx("div",{className:"ai-center-dot",style:{background:u?.action===1?"var(--success)":u?.action===2?"var(--error)":"#FAFAF9"}})})]}),h.jsxs("div",{className:"ai-status",style:{minHeight:"40px",display:"flex",alignItems:"center",justifyContent:"center",gap:"8px",flexWrap:"wrap"},children:[h.jsx("span",{children:c}),u&&h.jsx(r0,{mint:u.mint,symbol:u.symbol,imageUrl:u.imageUrl})]}),h.jsx("div",{style:{display:"flex",gap:"8px",marginBottom:"20px",height:"60px",alignItems:"flex-end"},children:["WATCH","BUY","PASS"].map((R,V)=>{const at=D[V]||0,mt=Math.abs(at)/M*100,pt=at>0?"var(--success)":"var(--error)",Mt=u?.action===V;return h.jsxs("div",{style:{flex:1,display:"flex",flexDirection:"column",alignItems:"center",opacity:Mt?1:.5},children:[h.jsx("div",{style:{width:"100%",height:`${Math.max(10,mt)}%`,background:pt,borderRadius:"4px",transition:"all 0.3s ease"}}),h.jsx("span",{style:{fontSize:"10px",marginTop:"4px",color:"var(--text-muted)"},children:R})]},R)})}),h.jsxs("div",{className:"confidence-bar",children:[h.jsxs("div",{className:"confidence-header",children:[h.jsx("span",{children:"Confidence"}),h.jsxs("span",{children:[G.toFixed(0),"%"]})]}),h.jsx("div",{className:"confidence-track",children:h.jsx("div",{className:"confidence-fill",style:{width:`${G}%`}})})]}),h.jsxs("div",{className:"win-streak-box",children:[h.jsx("div",{className:"win-streak-value animate-number",children:x}),h.jsx("div",{className:"win-streak-label",children:"Win streak"})]})]})]})},m0=r=>{switch(r){case"collecting":return"var(--text-muted)";case"ready":return"var(--accent)";case"analyzing":return"var(--warning)";case"rejected":return"var(--error)";case"bought":return"var(--success)";default:return"var(--text-muted)"}},y0=r=>{switch(r){case"collecting":return"rgba(255,255,255,0.05)";case"ready":return"var(--accent-subtle)";case"analyzing":return"var(--warning-subtle)";case"rejected":return"var(--error-subtle)";case"bought":return"var(--success-subtle)";default:return"rgba(255,255,255,0.05)"}},p0=r=>{const u=Date.now()-r,c=Math.floor(u/1e3);if(c<60)return`${c}s`;const s=Math.floor(c/60);return s<60?`${s}m`:`${Math.floor(s/60)}h`},v0=({tokens:r,stats:u})=>h.jsxs("div",{className:"card",style:{marginTop:"24px"},children:[h.jsxs("div",{className:"card-header",children:[h.jsx("span",{className:"card-title",children:"Token Watchlist"}),h.jsxs("div",{style:{display:"flex",gap:"12px",alignItems:"center"},children:[h.jsxs("div",{style:{padding:"4px 12px",borderRadius:"20px",fontSize:"11px",background:"var(--bg-elevated)",color:"var(--text-muted)"},children:[u.total," watching"]}),h.jsxs("div",{style:{padding:"4px 12px",borderRadius:"20px",fontSize:"11px",background:"var(--accent-subtle)",color:"var(--accent)"},children:[u.ready," ready"]}),u.devSold>0&&h.jsxs("div",{style:{padding:"4px 12px",borderRadius:"20px",fontSize:"11px",background:"var(--error-subtle)",color:"var(--error)"},children:[u.devSold," dev sold"]})]})]}),h.jsx("div",{style:{padding:"16px",maxHeight:"400px",overflowY:"auto"},children:r.length===0?h.jsx("div",{style:{textAlign:"center",color:"var(--text-muted)",padding:"24px",fontSize:"13px"},children:"Waiting for new tokens..."}):h.jsx("div",{style:{display:"flex",flexDirection:"column",gap:"8px"},children:r.map(c=>h.jsxs("div",{style:{background:"var(--bg-elevated)",borderRadius:"8px",padding:"12px",border:c.devSold?"1px solid var(--error)":"1px solid transparent"},children:[h.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"8px"},children:[h.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"8px"},children:[h.jsx(au,{mint:c.mint,name:c.name,symbol:c.symbol,imageUrl:c.imageUrl,size:"sm",showCopy:!0,inline:!0}),h.jsx("span",{style:{padding:"2px 8px",borderRadius:"4px",fontSize:"10px",background:y0(c.status),color:m0(c.status),textTransform:"uppercase"},children:c.status})]}),h.jsxs("span",{style:{fontSize:"11px",color:"var(--text-muted)"},children:[p0(c.firstSeen)," old"]})]}),c.status==="collecting"&&h.jsxs("div",{style:{marginBottom:"8px"},children:[h.jsx("div",{style:{background:"rgba(255,255,255,0.1)",borderRadius:"4px",height:"4px",overflow:"hidden"},children:h.jsx("div",{style:{background:"var(--accent)",height:"100%",width:`${Math.min(c.dataPoints*10,100)}%`,transition:"width 0.3s ease"}})}),h.jsxs("div",{style:{fontSize:"10px",color:"var(--text-muted)",marginTop:"4px"},children:[c.dataPoints,"/10 data points"]})]}),c.status==="rejected"&&c.rejectReason&&h.jsx("div",{style:{fontSize:"11px",color:"var(--error)",marginBottom:"8px"},children:c.rejectReason}),(c.status==="ready"||c.status==="analyzing")&&h.jsxs("div",{style:{display:"flex",gap:"16px",flexWrap:"wrap"},children:[h.jsxs("div",{children:[h.jsx("div",{style:{fontSize:"10px",color:"var(--text-muted)"},children:"Price"}),h.jsxs("div",{style:{fontSize:"12px",color:c.priceChange>=0?"var(--success)":"var(--error)"},children:[c.priceChange>=0?"+":"",(c.priceChange*100).toFixed(1),"%"]})]}),h.jsxs("div",{children:[h.jsx("div",{style:{fontSize:"10px",color:"var(--text-muted)"},children:"Drawdown"}),h.jsxs("div",{style:{fontSize:"12px",color:c.drawdown>.2?"var(--error)":"var(--text-secondary)"},children:["-",(c.drawdown*100).toFixed(1),"%"]})]}),h.jsxs("div",{children:[h.jsx("div",{style:{fontSize:"10px",color:"var(--text-muted)"},children:"Buy Pressure"}),h.jsxs("div",{style:{fontSize:"12px",color:c.buyPressure>.6?"var(--success)":"var(--text-secondary)"},children:[(c.buyPressure*100).toFixed(0),"%"]})]}),h.jsxs("div",{children:[h.jsx("div",{style:{fontSize:"10px",color:"var(--text-muted)"},children:"Traders"}),h.jsx("div",{style:{fontSize:"12px",color:"var(--text-secondary)"},children:c.uniqueTraders})]})]}),c.devSold&&h.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"6px",marginTop:"8px",padding:"6px 10px",background:"var(--error-subtle)",borderRadius:"4px"},children:[h.jsx("span",{style:{fontSize:"14px"},children:"!"}),h.jsx("span",{style:{fontSize:"11px",color:"var(--error)"},children:"DEV SOLD"})]})]},c.mint))})})]}),g0=r=>{const u=Math.floor(r/1e3),c=Math.floor(u/60),s=Math.floor(c/60);return s>0?`${s}h ${c%60}m`:c>0?`${c}m ${u%60}s`:`${u}s`},S0=({positions:r,summary:u})=>h.jsxs("div",{className:"card",children:[h.jsxs("div",{className:"card-header",children:[h.jsx("span",{className:"card-title",children:"Open Positions"}),u&&h.jsxs("span",{className:`card-badge ${parseFloat(u.totalUnrealizedPnl)>=0?"positive":"negative"}`,children:[parseFloat(u.totalUnrealizedPnl)>=0?"+":"",parseFloat(u.totalUnrealizedPnl).toFixed(4)," SOL"]})]}),h.jsx("div",{className:"positions-list",children:r.length===0?h.jsx("div",{className:"empty-state",children:"No open positions"}):r.map(c=>{const s=parseFloat(String(c.unrealizedPnl)),p=parseFloat(String(c.unrealizedPnlPercent)),x=c.realizedPnl?parseFloat(String(c.realizedPnl)):0,D=s>=0,M=g0(c.holdTime);return h.jsxs("div",{className:"position-item",children:[h.jsx("div",{className:`position-indicator ${D?"profit":"loss"}`}),h.jsxs("div",{className:"position-info",children:[h.jsxs("div",{className:"position-header",children:[h.jsx(au,{mint:c.mint,name:c.name,symbol:c.symbol,imageUrl:c.imageUrl,size:"sm",showCopy:!0,inline:!0}),h.jsx("span",{className:"position-pool",children:c.poolType})]}),h.jsxs("div",{className:"position-details",children:[h.jsxs("span",{className:"position-size",children:[c.amountSol.toFixed(4)," SOL"]}),h.jsx("span",{className:"position-hold",children:M})]})]}),h.jsxs("div",{className:"position-pnl",children:[h.jsxs("div",{className:`position-unrealized ${D?"positive":"negative"}`,children:[D?"+":"",s.toFixed(4),h.jsxs("span",{className:"position-pnl-percent",children:["(",p.toFixed(1),"%)"]})]}),x!==0&&h.jsxs("div",{className:"position-realized",children:["Realized: ",x>=0?"+":"",x.toFixed(4)]})]}),h.jsxs("div",{className:"position-status",children:[c.initialRecovered&&h.jsx("span",{className:"status-badge recovered",children:"IR"}),c.scaledExitsTaken&&c.scaledExitsTaken>0&&h.jsxs("span",{className:"status-badge exits",children:["x",c.scaledExitsTaken]}),c.trailingStop&&h.jsx("span",{className:"status-badge trailing",children:"TS"})]})]},c.id)})}),u&&r.length>0&&h.jsxs("div",{className:"positions-footer",children:[h.jsxs("span",{children:["Total Exposure: ",u.totalExposure," SOL"]}),h.jsxs("span",{children:[u.positionCount," position",u.positionCount!==1?"s":""]})]})]}),b0=({history:r,walletBalance:u})=>{const c=st.useMemo(()=>{if(r.length<2)return null;const s=r.map(Mt=>Mt.totalEquity),p=Math.min(...s),x=Math.max(...s),D=x-p||1,M=300,C=60,z=4,G=s.map((Mt,Et)=>{const Kt=z+Et/(s.length-1)*(M-z*2),bt=C-z-(Mt-p)/D*(C-z*2);return`${Kt},${bt}`}).join(" "),R=s[0],V=s[s.length-1],at=V>=R,mt=V-R,pt=R>0?mt/R*100:0;return{points:G,width:M,height:C,isUp:at,change:mt,changePercent:pt,current:V,min:p,max:x}},[r]);return c?h.jsxs("div",{className:"card equity-chart-card",children:[h.jsxs("div",{className:"card-header",children:[h.jsx("span",{className:"card-title",children:"Equity"}),h.jsxs("span",{className:`card-badge ${c.isUp?"positive":"negative"}`,children:[c.isUp?"+":"",c.changePercent.toFixed(2),"%"]})]}),h.jsxs("div",{className:"equity-chart-content",children:[h.jsxs("div",{className:"equity-current",children:[h.jsx("span",{className:"equity-value",children:c.current.toFixed(4)}),h.jsx("span",{className:"equity-label",children:"SOL"})]}),h.jsxs("svg",{className:"equity-sparkline",viewBox:`0 0 ${c.width} ${c.height}`,preserveAspectRatio:"none",children:[h.jsx("defs",{children:h.jsxs("linearGradient",{id:"equityGradient",x1:"0",y1:"0",x2:"0",y2:"1",children:[h.jsx("stop",{offset:"0%",stopColor:c.isUp?"#10b981":"#ef4444",stopOpacity:"0.3"}),h.jsx("stop",{offset:"100%",stopColor:c.isUp?"#10b981":"#ef4444",stopOpacity:"0"})]})}),h.jsx("polygon",{points:`4,${c.height-4} ${c.points} ${c.width-4},${c.height-4}`,fill:"url(#equityGradient)"}),h.jsx("polyline",{points:c.points,fill:"none",stroke:c.isUp?"#10b981":"#ef4444",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"})]}),h.jsxs("div",{className:"equity-range",children:[h.jsx("span",{children:c.min.toFixed(2)}),h.jsx("span",{children:c.max.toFixed(2)})]})]}),h.jsxs("div",{className:"equity-footer",children:[h.jsxs("span",{className:c.isUp?"positive":"negative",children:[c.isUp?"+":"",c.change.toFixed(4)," SOL (24h)"]}),u!==void 0&&h.jsxs("span",{className:"wallet-indicator",children:["Wallet: ",u.toFixed(4)]})]})]}):h.jsxs("div",{className:"card equity-chart-card",children:[h.jsx("div",{className:"card-header",children:h.jsx("span",{className:"card-title",children:"Equity"})}),h.jsxs("div",{className:"equity-chart-empty",children:[h.jsx("span",{children:"Collecting data..."}),u!==void 0&&h.jsxs("span",{className:"wallet-balance",children:[u.toFixed(4)," SOL"]})]})]})};function x0({data:r}){if(!r||!r.enabled)return null;const u=(M,C=4)=>M===0?"0":M<1e-4?M.toExponential(2):M.toFixed(C),c=M=>M>=1e9?(M/1e9).toFixed(2)+"B":M>=1e6?(M/1e6).toFixed(2)+"M":M>=1e3?(M/1e3).toFixed(2)+"K":M.toFixed(2),s=M=>M?`${M.slice(0,6)}...${M.slice(-4)}`:"",p=M=>{navigator.clipboard.writeText(M)},x=r.token?.priceChange24h||0,D=x>=0;return h.jsxs("div",{className:"c100-card card",children:[h.jsxs("div",{className:"c100-header",children:[h.jsxs("div",{className:"c100-token-info",children:[h.jsx("div",{className:"c100-icon",children:"C"}),h.jsxs("div",{className:"c100-details",children:[h.jsx("h3",{children:r.token?.name||"C100"}),h.jsxs("div",{className:"c100-ticker",children:["$",r.token?.symbol||"C100"]})]})]}),r.token&&h.jsx("div",{className:"c100-mint",onClick:()=>p(r.token.mint),title:"Click to copy",children:s(r.token.mint)})]}),h.jsxs("div",{className:"c100-grid",children:[h.jsxs("div",{className:"c100-stat",children:[h.jsx("span",{className:"c100-stat-label",children:"Price"}),h.jsxs("span",{className:"c100-stat-value",children:["$",r.token?u(r.token.priceUsd,8):"â€”"]}),r.token&&h.jsxs("span",{className:`c100-stat-change ${D?"positive":"negative"}`,children:[D?"+":"",x.toFixed(2),"%"]})]}),h.jsxs("div",{className:"c100-stat",children:[h.jsx("span",{className:"c100-stat-label",children:"Market Cap"}),h.jsxs("span",{className:"c100-stat-value",children:["$",r.token?c(r.token.marketCapUsd):"â€”"]})]}),h.jsxs("div",{className:"c100-stat highlight",children:[h.jsx("span",{className:"c100-stat-label",children:"SOL Claimed"}),h.jsx("span",{className:"c100-stat-value accent",children:u(r.claims.totalClaimedSol,4)}),h.jsxs("span",{className:"c100-stat-sub",children:[r.claims.claimCount," claims"]})]}),h.jsxs("div",{className:"c100-stat highlight",children:[h.jsx("span",{className:"c100-stat-label",children:"SOL Buyback"}),h.jsx("span",{className:"c100-stat-value accent",children:u(r.buybacks.totalBuybackSol,4)}),h.jsxs("span",{className:"c100-stat-sub",children:[r.buybacks.buybackCount," buys"]})]}),h.jsxs("div",{className:"c100-stat wide",children:[h.jsx("span",{className:"c100-stat-label",children:"C100 Tokens Bought"}),h.jsx("span",{className:"c100-stat-value large",children:c(r.buybacks.totalTokensBought)})]})]})]})}const He=Object.create(null);He.open="0";He.close="1";He.ping="2";He.pong="3";He.message="4";He.upgrade="5";He.noop="6";const Pi=Object.create(null);Object.keys(He).forEach(r=>{Pi[He[r]]=r});const Rs={type:"error",data:"parser error"},od=typeof Blob=="function"||typeof Blob<"u"&&Object.prototype.toString.call(Blob)==="[object BlobConstructor]",hd=typeof ArrayBuffer=="function",dd=r=>typeof ArrayBuffer.isView=="function"?ArrayBuffer.isView(r):r&&r.buffer instanceof ArrayBuffer,Xs=({type:r,data:u},c,s)=>od&&u instanceof Blob?c?s(u):nd(u,s):hd&&(u instanceof ArrayBuffer||dd(u))?c?s(u):nd(new Blob([u]),s):s(He[r]+(u||"")),nd=(r,u)=>{const c=new FileReader;return c.onload=function(){const s=c.result.split(",")[1];u("b"+(s||""))},c.readAsDataURL(r)};function id(r){return r instanceof Uint8Array?r:r instanceof ArrayBuffer?new Uint8Array(r):new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}let Cs;function _0(r,u){if(od&&r.data instanceof Blob)return r.data.arrayBuffer().then(id).then(u);if(hd&&(r.data instanceof ArrayBuffer||dd(r.data)))return u(id(r.data));Xs(r,!1,c=>{Cs||(Cs=new TextEncoder),u(Cs.encode(c))})}const ud="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",Dn=typeof Uint8Array>"u"?[]:new Uint8Array(256);for(let r=0;r<ud.length;r++)Dn[ud.charCodeAt(r)]=r;const E0=r=>{let u=r.length*.75,c=r.length,s,p=0,x,D,M,C;r[r.length-1]==="="&&(u--,r[r.length-2]==="="&&u--);const z=new ArrayBuffer(u),G=new Uint8Array(z);for(s=0;s<c;s+=4)x=Dn[r.charCodeAt(s)],D=Dn[r.charCodeAt(s+1)],M=Dn[r.charCodeAt(s+2)],C=Dn[r.charCodeAt(s+3)],G[p++]=x<<2|D>>4,G[p++]=(D&15)<<4|M>>2,G[p++]=(M&3)<<6|C&63;return z},T0=typeof ArrayBuffer=="function",Qs=(r,u)=>{if(typeof r!="string")return{type:"message",data:md(r,u)};const c=r.charAt(0);return c==="b"?{type:"message",data:A0(r.substring(1),u)}:Pi[c]?r.length>1?{type:Pi[c],data:r.substring(1)}:{type:Pi[c]}:Rs},A0=(r,u)=>{if(T0){const c=E0(r);return md(c,u)}else return{base64:!0,data:r}},md=(r,u)=>u==="blob"?r instanceof Blob?r:new Blob([r]):r instanceof ArrayBuffer?r:r.buffer,yd="",z0=(r,u)=>{const c=r.length,s=new Array(c);let p=0;r.forEach((x,D)=>{Xs(x,!1,M=>{s[D]=M,++p===c&&u(s.join(yd))})})},N0=(r,u)=>{const c=r.split(yd),s=[];for(let p=0;p<c.length;p++){const x=Qs(c[p],u);if(s.push(x),x.type==="error")break}return s};function O0(){return new TransformStream({transform(r,u){_0(r,c=>{const s=c.length;let p;if(s<126)p=new Uint8Array(1),new DataView(p.buffer).setUint8(0,s);else if(s<65536){p=new Uint8Array(3);const x=new DataView(p.buffer);x.setUint8(0,126),x.setUint16(1,s)}else{p=new Uint8Array(9);const x=new DataView(p.buffer);x.setUint8(0,127),x.setBigUint64(1,BigInt(s))}r.data&&typeof r.data!="string"&&(p[0]|=128),u.enqueue(p),u.enqueue(c)})}})}let Ds;function Fi(r){return r.reduce((u,c)=>u+c.length,0)}function Ii(r,u){if(r[0].length===u)return r.shift();const c=new Uint8Array(u);let s=0;for(let p=0;p<u;p++)c[p]=r[0][s++],s===r[0].length&&(r.shift(),s=0);return r.length&&s<r[0].length&&(r[0]=r[0].slice(s)),c}function j0(r,u){Ds||(Ds=new TextDecoder);const c=[];let s=0,p=-1,x=!1;return new TransformStream({transform(D,M){for(c.push(D);;){if(s===0){if(Fi(c)<1)break;const C=Ii(c,1);x=(C[0]&128)===128,p=C[0]&127,p<126?s=3:p===126?s=1:s=2}else if(s===1){if(Fi(c)<2)break;const C=Ii(c,2);p=new DataView(C.buffer,C.byteOffset,C.length).getUint16(0),s=3}else if(s===2){if(Fi(c)<8)break;const C=Ii(c,8),z=new DataView(C.buffer,C.byteOffset,C.length),G=z.getUint32(0);if(G>Math.pow(2,21)-1){M.enqueue(Rs);break}p=G*Math.pow(2,32)+z.getUint32(4),s=3}else{if(Fi(c)<p)break;const C=Ii(c,p);M.enqueue(Qs(x?C:Ds.decode(C),u)),s=0}if(p===0||p>r){M.enqueue(Rs);break}}}})}const pd=4;function Dt(r){if(r)return C0(r)}function C0(r){for(var u in Dt.prototype)r[u]=Dt.prototype[u];return r}Dt.prototype.on=Dt.prototype.addEventListener=function(r,u){return this._callbacks=this._callbacks||{},(this._callbacks["$"+r]=this._callbacks["$"+r]||[]).push(u),this};Dt.prototype.once=function(r,u){function c(){this.off(r,c),u.apply(this,arguments)}return c.fn=u,this.on(r,c),this};Dt.prototype.off=Dt.prototype.removeListener=Dt.prototype.removeAllListeners=Dt.prototype.removeEventListener=function(r,u){if(this._callbacks=this._callbacks||{},arguments.length==0)return this._callbacks={},this;var c=this._callbacks["$"+r];if(!c)return this;if(arguments.length==1)return delete this._callbacks["$"+r],this;for(var s,p=0;p<c.length;p++)if(s=c[p],s===u||s.fn===u){c.splice(p,1);break}return c.length===0&&delete this._callbacks["$"+r],this};Dt.prototype.emit=function(r){this._callbacks=this._callbacks||{};for(var u=new Array(arguments.length-1),c=this._callbacks["$"+r],s=1;s<arguments.length;s++)u[s-1]=arguments[s];if(c){c=c.slice(0);for(var s=0,p=c.length;s<p;++s)c[s].apply(this,u)}return this};Dt.prototype.emitReserved=Dt.prototype.emit;Dt.prototype.listeners=function(r){return this._callbacks=this._callbacks||{},this._callbacks["$"+r]||[]};Dt.prototype.hasListeners=function(r){return!!this.listeners(r).length};const nu=typeof Promise=="function"&&typeof Promise.resolve=="function"?u=>Promise.resolve().then(u):(u,c)=>c(u,0),ze=typeof self<"u"?self:typeof window<"u"?window:Function("return this")(),D0="arraybuffer";function vd(r,...u){return u.reduce((c,s)=>(r.hasOwnProperty(s)&&(c[s]=r[s]),c),{})}const M0=ze.setTimeout,R0=ze.clearTimeout;function iu(r,u){u.useNativeTimers?(r.setTimeoutFn=M0.bind(ze),r.clearTimeoutFn=R0.bind(ze)):(r.setTimeoutFn=ze.setTimeout.bind(ze),r.clearTimeoutFn=ze.clearTimeout.bind(ze))}const U0=1.33;function B0(r){return typeof r=="string"?q0(r):Math.ceil((r.byteLength||r.size)*U0)}function q0(r){let u=0,c=0;for(let s=0,p=r.length;s<p;s++)u=r.charCodeAt(s),u<128?c+=1:u<2048?c+=2:u<55296||u>=57344?c+=3:(s++,c+=4);return c}function gd(){return Date.now().toString(36).substring(3)+Math.random().toString(36).substring(2,5)}function H0(r){let u="";for(let c in r)r.hasOwnProperty(c)&&(u.length&&(u+="&"),u+=encodeURIComponent(c)+"="+encodeURIComponent(r[c]));return u}function Y0(r){let u={},c=r.split("&");for(let s=0,p=c.length;s<p;s++){let x=c[s].split("=");u[decodeURIComponent(x[0])]=decodeURIComponent(x[1])}return u}class L0 extends Error{constructor(u,c,s){super(u),this.description=c,this.context=s,this.type="TransportError"}}class Gs extends Dt{constructor(u){super(),this.writable=!1,iu(this,u),this.opts=u,this.query=u.query,this.socket=u.socket,this.supportsBinary=!u.forceBase64}onError(u,c,s){return super.emitReserved("error",new L0(u,c,s)),this}open(){return this.readyState="opening",this.doOpen(),this}close(){return(this.readyState==="opening"||this.readyState==="open")&&(this.doClose(),this.onClose()),this}send(u){this.readyState==="open"&&this.write(u)}onOpen(){this.readyState="open",this.writable=!0,super.emitReserved("open")}onData(u){const c=Qs(u,this.socket.binaryType);this.onPacket(c)}onPacket(u){super.emitReserved("packet",u)}onClose(u){this.readyState="closed",super.emitReserved("close",u)}pause(u){}createUri(u,c={}){return u+"://"+this._hostname()+this._port()+this.opts.path+this._query(c)}_hostname(){const u=this.opts.hostname;return u.indexOf(":")===-1?u:"["+u+"]"}_port(){return this.opts.port&&(this.opts.secure&&Number(this.opts.port)!==443||!this.opts.secure&&Number(this.opts.port)!==80)?":"+this.opts.port:""}_query(u){const c=H0(u);return c.length?"?"+c:""}}class X0 extends Gs{constructor(){super(...arguments),this._polling=!1}get name(){return"polling"}doOpen(){this._poll()}pause(u){this.readyState="pausing";const c=()=>{this.readyState="paused",u()};if(this._polling||!this.writable){let s=0;this._polling&&(s++,this.once("pollComplete",function(){--s||c()})),this.writable||(s++,this.once("drain",function(){--s||c()}))}else c()}_poll(){this._polling=!0,this.doPoll(),this.emitReserved("poll")}onData(u){const c=s=>{if(this.readyState==="opening"&&s.type==="open"&&this.onOpen(),s.type==="close")return this.onClose({description:"transport closed by the server"}),!1;this.onPacket(s)};N0(u,this.socket.binaryType).forEach(c),this.readyState!=="closed"&&(this._polling=!1,this.emitReserved("pollComplete"),this.readyState==="open"&&this._poll())}doClose(){const u=()=>{this.write([{type:"close"}])};this.readyState==="open"?u():this.once("open",u)}write(u){this.writable=!1,z0(u,c=>{this.doWrite(c,()=>{this.writable=!0,this.emitReserved("drain")})})}uri(){const u=this.opts.secure?"https":"http",c=this.query||{};return this.opts.timestampRequests!==!1&&(c[this.opts.timestampParam]=gd()),!this.supportsBinary&&!c.sid&&(c.b64=1),this.createUri(u,c)}}let Sd=!1;try{Sd=typeof XMLHttpRequest<"u"&&"withCredentials"in new XMLHttpRequest}catch{}const Q0=Sd;function G0(){}class w0 extends X0{constructor(u){if(super(u),typeof location<"u"){const c=location.protocol==="https:";let s=location.port;s||(s=c?"443":"80"),this.xd=typeof location<"u"&&u.hostname!==location.hostname||s!==u.port}}doWrite(u,c){const s=this.request({method:"POST",data:u});s.on("success",c),s.on("error",(p,x)=>{this.onError("xhr post error",p,x)})}doPoll(){const u=this.request();u.on("data",this.onData.bind(this)),u.on("error",(c,s)=>{this.onError("xhr poll error",c,s)}),this.pollXhr=u}}class qe extends Dt{constructor(u,c,s){super(),this.createRequest=u,iu(this,s),this._opts=s,this._method=s.method||"GET",this._uri=c,this._data=s.data!==void 0?s.data:null,this._create()}_create(){var u;const c=vd(this._opts,"agent","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","autoUnref");c.xdomain=!!this._opts.xd;const s=this._xhr=this.createRequest(c);try{s.open(this._method,this._uri,!0);try{if(this._opts.extraHeaders){s.setDisableHeaderCheck&&s.setDisableHeaderCheck(!0);for(let p in this._opts.extraHeaders)this._opts.extraHeaders.hasOwnProperty(p)&&s.setRequestHeader(p,this._opts.extraHeaders[p])}}catch{}if(this._method==="POST")try{s.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch{}try{s.setRequestHeader("Accept","*/*")}catch{}(u=this._opts.cookieJar)===null||u===void 0||u.addCookies(s),"withCredentials"in s&&(s.withCredentials=this._opts.withCredentials),this._opts.requestTimeout&&(s.timeout=this._opts.requestTimeout),s.onreadystatechange=()=>{var p;s.readyState===3&&((p=this._opts.cookieJar)===null||p===void 0||p.parseCookies(s.getResponseHeader("set-cookie"))),s.readyState===4&&(s.status===200||s.status===1223?this._onLoad():this.setTimeoutFn(()=>{this._onError(typeof s.status=="number"?s.status:0)},0))},s.send(this._data)}catch(p){this.setTimeoutFn(()=>{this._onError(p)},0);return}typeof document<"u"&&(this._index=qe.requestsCount++,qe.requests[this._index]=this)}_onError(u){this.emitReserved("error",u,this._xhr),this._cleanup(!0)}_cleanup(u){if(!(typeof this._xhr>"u"||this._xhr===null)){if(this._xhr.onreadystatechange=G0,u)try{this._xhr.abort()}catch{}typeof document<"u"&&delete qe.requests[this._index],this._xhr=null}}_onLoad(){const u=this._xhr.responseText;u!==null&&(this.emitReserved("data",u),this.emitReserved("success"),this._cleanup())}abort(){this._cleanup()}}qe.requestsCount=0;qe.requests={};if(typeof document<"u"){if(typeof attachEvent=="function")attachEvent("onunload",cd);else if(typeof addEventListener=="function"){const r="onpagehide"in ze?"pagehide":"unload";addEventListener(r,cd,!1)}}function cd(){for(let r in qe.requests)qe.requests.hasOwnProperty(r)&&qe.requests[r].abort()}const V0=(function(){const r=bd({xdomain:!1});return r&&r.responseType!==null})();class Z0 extends w0{constructor(u){super(u);const c=u&&u.forceBase64;this.supportsBinary=V0&&!c}request(u={}){return Object.assign(u,{xd:this.xd},this.opts),new qe(bd,this.uri(),u)}}function bd(r){const u=r.xdomain;try{if(typeof XMLHttpRequest<"u"&&(!u||Q0))return new XMLHttpRequest}catch{}if(!u)try{return new ze[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")}catch{}}const xd=typeof navigator<"u"&&typeof navigator.product=="string"&&navigator.product.toLowerCase()==="reactnative";class K0 extends Gs{get name(){return"websocket"}doOpen(){const u=this.uri(),c=this.opts.protocols,s=xd?{}:vd(this.opts,"agent","perMessageDeflate","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","localAddress","protocolVersion","origin","maxPayload","family","checkServerIdentity");this.opts.extraHeaders&&(s.headers=this.opts.extraHeaders);try{this.ws=this.createSocket(u,c,s)}catch(p){return this.emitReserved("error",p)}this.ws.binaryType=this.socket.binaryType,this.addEventListeners()}addEventListeners(){this.ws.onopen=()=>{this.opts.autoUnref&&this.ws._socket.unref(),this.onOpen()},this.ws.onclose=u=>this.onClose({description:"websocket connection closed",context:u}),this.ws.onmessage=u=>this.onData(u.data),this.ws.onerror=u=>this.onError("websocket error",u)}write(u){this.writable=!1;for(let c=0;c<u.length;c++){const s=u[c],p=c===u.length-1;Xs(s,this.supportsBinary,x=>{try{this.doWrite(s,x)}catch{}p&&nu(()=>{this.writable=!0,this.emitReserved("drain")},this.setTimeoutFn)})}}doClose(){typeof this.ws<"u"&&(this.ws.onerror=()=>{},this.ws.close(),this.ws=null)}uri(){const u=this.opts.secure?"wss":"ws",c=this.query||{};return this.opts.timestampRequests&&(c[this.opts.timestampParam]=gd()),this.supportsBinary||(c.b64=1),this.createUri(u,c)}}const Ms=ze.WebSocket||ze.MozWebSocket;class J0 extends K0{createSocket(u,c,s){return xd?new Ms(u,c,s):c?new Ms(u,c):new Ms(u)}doWrite(u,c){this.ws.send(c)}}class k0 extends Gs{get name(){return"webtransport"}doOpen(){try{this._transport=new WebTransport(this.createUri("https"),this.opts.transportOptions[this.name])}catch(u){return this.emitReserved("error",u)}this._transport.closed.then(()=>{this.onClose()}).catch(u=>{this.onError("webtransport error",u)}),this._transport.ready.then(()=>{this._transport.createBidirectionalStream().then(u=>{const c=j0(Number.MAX_SAFE_INTEGER,this.socket.binaryType),s=u.readable.pipeThrough(c).getReader(),p=O0();p.readable.pipeTo(u.writable),this._writer=p.writable.getWriter();const x=()=>{s.read().then(({done:M,value:C})=>{M||(this.onPacket(C),x())}).catch(M=>{})};x();const D={type:"open"};this.query.sid&&(D.data=`{"sid":"${this.query.sid}"}`),this._writer.write(D).then(()=>this.onOpen())})})}write(u){this.writable=!1;for(let c=0;c<u.length;c++){const s=u[c],p=c===u.length-1;this._writer.write(s).then(()=>{p&&nu(()=>{this.writable=!0,this.emitReserved("drain")},this.setTimeoutFn)})}}doClose(){var u;(u=this._transport)===null||u===void 0||u.close()}}const $0={websocket:J0,webtransport:k0,polling:Z0},W0=/^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,F0=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];function Us(r){if(r.length>8e3)throw"URI too long";const u=r,c=r.indexOf("["),s=r.indexOf("]");c!=-1&&s!=-1&&(r=r.substring(0,c)+r.substring(c,s).replace(/:/g,";")+r.substring(s,r.length));let p=W0.exec(r||""),x={},D=14;for(;D--;)x[F0[D]]=p[D]||"";return c!=-1&&s!=-1&&(x.source=u,x.host=x.host.substring(1,x.host.length-1).replace(/;/g,":"),x.authority=x.authority.replace("[","").replace("]","").replace(/;/g,":"),x.ipv6uri=!0),x.pathNames=I0(x,x.path),x.queryKey=P0(x,x.query),x}function I0(r,u){const c=/\/{2,9}/g,s=u.replace(c,"/").split("/");return(u.slice(0,1)=="/"||u.length===0)&&s.splice(0,1),u.slice(-1)=="/"&&s.splice(s.length-1,1),s}function P0(r,u){const c={};return u.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,function(s,p,x){p&&(c[p]=x)}),c}const Bs=typeof addEventListener=="function"&&typeof removeEventListener=="function",tu=[];Bs&&addEventListener("offline",()=>{tu.forEach(r=>r())},!1);class jl extends Dt{constructor(u,c){if(super(),this.binaryType=D0,this.writeBuffer=[],this._prevBufferLen=0,this._pingInterval=-1,this._pingTimeout=-1,this._maxPayload=-1,this._pingTimeoutTime=1/0,u&&typeof u=="object"&&(c=u,u=null),u){const s=Us(u);c.hostname=s.host,c.secure=s.protocol==="https"||s.protocol==="wss",c.port=s.port,s.query&&(c.query=s.query)}else c.host&&(c.hostname=Us(c.host).host);iu(this,c),this.secure=c.secure!=null?c.secure:typeof location<"u"&&location.protocol==="https:",c.hostname&&!c.port&&(c.port=this.secure?"443":"80"),this.hostname=c.hostname||(typeof location<"u"?location.hostname:"localhost"),this.port=c.port||(typeof location<"u"&&location.port?location.port:this.secure?"443":"80"),this.transports=[],this._transportsByName={},c.transports.forEach(s=>{const p=s.prototype.name;this.transports.push(p),this._transportsByName[p]=s}),this.opts=Object.assign({path:"/engine.io",agent:!1,withCredentials:!1,upgrade:!0,timestampParam:"t",rememberUpgrade:!1,addTrailingSlash:!0,rejectUnauthorized:!0,perMessageDeflate:{threshold:1024},transportOptions:{},closeOnBeforeunload:!1},c),this.opts.path=this.opts.path.replace(/\/$/,"")+(this.opts.addTrailingSlash?"/":""),typeof this.opts.query=="string"&&(this.opts.query=Y0(this.opts.query)),Bs&&(this.opts.closeOnBeforeunload&&(this._beforeunloadEventListener=()=>{this.transport&&(this.transport.removeAllListeners(),this.transport.close())},addEventListener("beforeunload",this._beforeunloadEventListener,!1)),this.hostname!=="localhost"&&(this._offlineEventListener=()=>{this._onClose("transport close",{description:"network connection lost"})},tu.push(this._offlineEventListener))),this.opts.withCredentials&&(this._cookieJar=void 0),this._open()}createTransport(u){const c=Object.assign({},this.opts.query);c.EIO=pd,c.transport=u,this.id&&(c.sid=this.id);const s=Object.assign({},this.opts,{query:c,socket:this,hostname:this.hostname,secure:this.secure,port:this.port},this.opts.transportOptions[u]);return new this._transportsByName[u](s)}_open(){if(this.transports.length===0){this.setTimeoutFn(()=>{this.emitReserved("error","No transports available")},0);return}const u=this.opts.rememberUpgrade&&jl.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1?"websocket":this.transports[0];this.readyState="opening";const c=this.createTransport(u);c.open(),this.setTransport(c)}setTransport(u){this.transport&&this.transport.removeAllListeners(),this.transport=u,u.on("drain",this._onDrain.bind(this)).on("packet",this._onPacket.bind(this)).on("error",this._onError.bind(this)).on("close",c=>this._onClose("transport close",c))}onOpen(){this.readyState="open",jl.priorWebsocketSuccess=this.transport.name==="websocket",this.emitReserved("open"),this.flush()}_onPacket(u){if(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing")switch(this.emitReserved("packet",u),this.emitReserved("heartbeat"),u.type){case"open":this.onHandshake(JSON.parse(u.data));break;case"ping":this._sendPacket("pong"),this.emitReserved("ping"),this.emitReserved("pong"),this._resetPingTimeout();break;case"error":const c=new Error("server error");c.code=u.data,this._onError(c);break;case"message":this.emitReserved("data",u.data),this.emitReserved("message",u.data);break}}onHandshake(u){this.emitReserved("handshake",u),this.id=u.sid,this.transport.query.sid=u.sid,this._pingInterval=u.pingInterval,this._pingTimeout=u.pingTimeout,this._maxPayload=u.maxPayload,this.onOpen(),this.readyState!=="closed"&&this._resetPingTimeout()}_resetPingTimeout(){this.clearTimeoutFn(this._pingTimeoutTimer);const u=this._pingInterval+this._pingTimeout;this._pingTimeoutTime=Date.now()+u,this._pingTimeoutTimer=this.setTimeoutFn(()=>{this._onClose("ping timeout")},u),this.opts.autoUnref&&this._pingTimeoutTimer.unref()}_onDrain(){this.writeBuffer.splice(0,this._prevBufferLen),this._prevBufferLen=0,this.writeBuffer.length===0?this.emitReserved("drain"):this.flush()}flush(){if(this.readyState!=="closed"&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length){const u=this._getWritablePackets();this.transport.send(u),this._prevBufferLen=u.length,this.emitReserved("flush")}}_getWritablePackets(){if(!(this._maxPayload&&this.transport.name==="polling"&&this.writeBuffer.length>1))return this.writeBuffer;let c=1;for(let s=0;s<this.writeBuffer.length;s++){const p=this.writeBuffer[s].data;if(p&&(c+=B0(p)),s>0&&c>this._maxPayload)return this.writeBuffer.slice(0,s);c+=2}return this.writeBuffer}_hasPingExpired(){if(!this._pingTimeoutTime)return!0;const u=Date.now()>this._pingTimeoutTime;return u&&(this._pingTimeoutTime=0,nu(()=>{this._onClose("ping timeout")},this.setTimeoutFn)),u}write(u,c,s){return this._sendPacket("message",u,c,s),this}send(u,c,s){return this._sendPacket("message",u,c,s),this}_sendPacket(u,c,s,p){if(typeof c=="function"&&(p=c,c=void 0),typeof s=="function"&&(p=s,s=null),this.readyState==="closing"||this.readyState==="closed")return;s=s||{},s.compress=s.compress!==!1;const x={type:u,data:c,options:s};this.emitReserved("packetCreate",x),this.writeBuffer.push(x),p&&this.once("flush",p),this.flush()}close(){const u=()=>{this._onClose("forced close"),this.transport.close()},c=()=>{this.off("upgrade",c),this.off("upgradeError",c),u()},s=()=>{this.once("upgrade",c),this.once("upgradeError",c)};return(this.readyState==="opening"||this.readyState==="open")&&(this.readyState="closing",this.writeBuffer.length?this.once("drain",()=>{this.upgrading?s():u()}):this.upgrading?s():u()),this}_onError(u){if(jl.priorWebsocketSuccess=!1,this.opts.tryAllTransports&&this.transports.length>1&&this.readyState==="opening")return this.transports.shift(),this._open();this.emitReserved("error",u),this._onClose("transport error",u)}_onClose(u,c){if(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing"){if(this.clearTimeoutFn(this._pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),Bs&&(this._beforeunloadEventListener&&removeEventListener("beforeunload",this._beforeunloadEventListener,!1),this._offlineEventListener)){const s=tu.indexOf(this._offlineEventListener);s!==-1&&tu.splice(s,1)}this.readyState="closed",this.id=null,this.emitReserved("close",u,c),this.writeBuffer=[],this._prevBufferLen=0}}}jl.protocol=pd;class tp extends jl{constructor(){super(...arguments),this._upgrades=[]}onOpen(){if(super.onOpen(),this.readyState==="open"&&this.opts.upgrade)for(let u=0;u<this._upgrades.length;u++)this._probe(this._upgrades[u])}_probe(u){let c=this.createTransport(u),s=!1;jl.priorWebsocketSuccess=!1;const p=()=>{s||(c.send([{type:"ping",data:"probe"}]),c.once("packet",R=>{if(!s)if(R.type==="pong"&&R.data==="probe"){if(this.upgrading=!0,this.emitReserved("upgrading",c),!c)return;jl.priorWebsocketSuccess=c.name==="websocket",this.transport.pause(()=>{s||this.readyState!=="closed"&&(G(),this.setTransport(c),c.send([{type:"upgrade"}]),this.emitReserved("upgrade",c),c=null,this.upgrading=!1,this.flush())})}else{const V=new Error("probe error");V.transport=c.name,this.emitReserved("upgradeError",V)}}))};function x(){s||(s=!0,G(),c.close(),c=null)}const D=R=>{const V=new Error("probe error: "+R);V.transport=c.name,x(),this.emitReserved("upgradeError",V)};function M(){D("transport closed")}function C(){D("socket closed")}function z(R){c&&R.name!==c.name&&x()}const G=()=>{c.removeListener("open",p),c.removeListener("error",D),c.removeListener("close",M),this.off("close",C),this.off("upgrading",z)};c.once("open",p),c.once("error",D),c.once("close",M),this.once("close",C),this.once("upgrading",z),this._upgrades.indexOf("webtransport")!==-1&&u!=="webtransport"?this.setTimeoutFn(()=>{s||c.open()},200):c.open()}onHandshake(u){this._upgrades=this._filterUpgrades(u.upgrades),super.onHandshake(u)}_filterUpgrades(u){const c=[];for(let s=0;s<u.length;s++)~this.transports.indexOf(u[s])&&c.push(u[s]);return c}}let ep=class extends tp{constructor(u,c={}){const s=typeof u=="object"?u:c;(!s.transports||s.transports&&typeof s.transports[0]=="string")&&(s.transports=(s.transports||["polling","websocket","webtransport"]).map(p=>$0[p]).filter(p=>!!p)),super(u,s)}};function lp(r,u="",c){let s=r;c=c||typeof location<"u"&&location,r==null&&(r=c.protocol+"//"+c.host),typeof r=="string"&&(r.charAt(0)==="/"&&(r.charAt(1)==="/"?r=c.protocol+r:r=c.host+r),/^(https?|wss?):\/\//.test(r)||(typeof c<"u"?r=c.protocol+"//"+r:r="https://"+r),s=Us(r)),s.port||(/^(http|ws)$/.test(s.protocol)?s.port="80":/^(http|ws)s$/.test(s.protocol)&&(s.port="443")),s.path=s.path||"/";const x=s.host.indexOf(":")!==-1?"["+s.host+"]":s.host;return s.id=s.protocol+"://"+x+":"+s.port+u,s.href=s.protocol+"://"+x+(c&&c.port===s.port?"":":"+s.port),s}const ap=typeof ArrayBuffer=="function",np=r=>typeof ArrayBuffer.isView=="function"?ArrayBuffer.isView(r):r.buffer instanceof ArrayBuffer,_d=Object.prototype.toString,ip=typeof Blob=="function"||typeof Blob<"u"&&_d.call(Blob)==="[object BlobConstructor]",up=typeof File=="function"||typeof File<"u"&&_d.call(File)==="[object FileConstructor]";function ws(r){return ap&&(r instanceof ArrayBuffer||np(r))||ip&&r instanceof Blob||up&&r instanceof File}function eu(r,u){if(!r||typeof r!="object")return!1;if(Array.isArray(r)){for(let c=0,s=r.length;c<s;c++)if(eu(r[c]))return!0;return!1}if(ws(r))return!0;if(r.toJSON&&typeof r.toJSON=="function"&&arguments.length===1)return eu(r.toJSON(),!0);for(const c in r)if(Object.prototype.hasOwnProperty.call(r,c)&&eu(r[c]))return!0;return!1}function cp(r){const u=[],c=r.data,s=r;return s.data=qs(c,u),s.attachments=u.length,{packet:s,buffers:u}}function qs(r,u){if(!r)return r;if(ws(r)){const c={_placeholder:!0,num:u.length};return u.push(r),c}else if(Array.isArray(r)){const c=new Array(r.length);for(let s=0;s<r.length;s++)c[s]=qs(r[s],u);return c}else if(typeof r=="object"&&!(r instanceof Date)){const c={};for(const s in r)Object.prototype.hasOwnProperty.call(r,s)&&(c[s]=qs(r[s],u));return c}return r}function sp(r,u){return r.data=Hs(r.data,u),delete r.attachments,r}function Hs(r,u){if(!r)return r;if(r&&r._placeholder===!0){if(typeof r.num=="number"&&r.num>=0&&r.num<u.length)return u[r.num];throw new Error("illegal attachments")}else if(Array.isArray(r))for(let c=0;c<r.length;c++)r[c]=Hs(r[c],u);else if(typeof r=="object")for(const c in r)Object.prototype.hasOwnProperty.call(r,c)&&(r[c]=Hs(r[c],u));return r}const fp=["connect","connect_error","disconnect","disconnecting","newListener","removeListener"];var lt;(function(r){r[r.CONNECT=0]="CONNECT",r[r.DISCONNECT=1]="DISCONNECT",r[r.EVENT=2]="EVENT",r[r.ACK=3]="ACK",r[r.CONNECT_ERROR=4]="CONNECT_ERROR",r[r.BINARY_EVENT=5]="BINARY_EVENT",r[r.BINARY_ACK=6]="BINARY_ACK"})(lt||(lt={}));class rp{constructor(u){this.replacer=u}encode(u){return(u.type===lt.EVENT||u.type===lt.ACK)&&eu(u)?this.encodeAsBinary({type:u.type===lt.EVENT?lt.BINARY_EVENT:lt.BINARY_ACK,nsp:u.nsp,data:u.data,id:u.id}):[this.encodeAsString(u)]}encodeAsString(u){let c=""+u.type;return(u.type===lt.BINARY_EVENT||u.type===lt.BINARY_ACK)&&(c+=u.attachments+"-"),u.nsp&&u.nsp!=="/"&&(c+=u.nsp+","),u.id!=null&&(c+=u.id),u.data!=null&&(c+=JSON.stringify(u.data,this.replacer)),c}encodeAsBinary(u){const c=cp(u),s=this.encodeAsString(c.packet),p=c.buffers;return p.unshift(s),p}}class Vs extends Dt{constructor(u){super(),this.reviver=u}add(u){let c;if(typeof u=="string"){if(this.reconstructor)throw new Error("got plaintext data when reconstructing a packet");c=this.decodeString(u);const s=c.type===lt.BINARY_EVENT;s||c.type===lt.BINARY_ACK?(c.type=s?lt.EVENT:lt.ACK,this.reconstructor=new op(c),c.attachments===0&&super.emitReserved("decoded",c)):super.emitReserved("decoded",c)}else if(ws(u)||u.base64)if(this.reconstructor)c=this.reconstructor.takeBinaryData(u),c&&(this.reconstructor=null,super.emitReserved("decoded",c));else throw new Error("got binary data when not reconstructing a packet");else throw new Error("Unknown type: "+u)}decodeString(u){let c=0;const s={type:Number(u.charAt(0))};if(lt[s.type]===void 0)throw new Error("unknown packet type "+s.type);if(s.type===lt.BINARY_EVENT||s.type===lt.BINARY_ACK){const x=c+1;for(;u.charAt(++c)!=="-"&&c!=u.length;);const D=u.substring(x,c);if(D!=Number(D)||u.charAt(c)!=="-")throw new Error("Illegal attachments");s.attachments=Number(D)}if(u.charAt(c+1)==="/"){const x=c+1;for(;++c&&!(u.charAt(c)===","||c===u.length););s.nsp=u.substring(x,c)}else s.nsp="/";const p=u.charAt(c+1);if(p!==""&&Number(p)==p){const x=c+1;for(;++c;){const D=u.charAt(c);if(D==null||Number(D)!=D){--c;break}if(c===u.length)break}s.id=Number(u.substring(x,c+1))}if(u.charAt(++c)){const x=this.tryParse(u.substr(c));if(Vs.isPayloadValid(s.type,x))s.data=x;else throw new Error("invalid payload")}return s}tryParse(u){try{return JSON.parse(u,this.reviver)}catch{return!1}}static isPayloadValid(u,c){switch(u){case lt.CONNECT:return sd(c);case lt.DISCONNECT:return c===void 0;case lt.CONNECT_ERROR:return typeof c=="string"||sd(c);case lt.EVENT:case lt.BINARY_EVENT:return Array.isArray(c)&&(typeof c[0]=="number"||typeof c[0]=="string"&&fp.indexOf(c[0])===-1);case lt.ACK:case lt.BINARY_ACK:return Array.isArray(c)}}destroy(){this.reconstructor&&(this.reconstructor.finishedReconstruction(),this.reconstructor=null)}}class op{constructor(u){this.packet=u,this.buffers=[],this.reconPack=u}takeBinaryData(u){if(this.buffers.push(u),this.buffers.length===this.reconPack.attachments){const c=sp(this.reconPack,this.buffers);return this.finishedReconstruction(),c}return null}finishedReconstruction(){this.reconPack=null,this.buffers=[]}}function sd(r){return Object.prototype.toString.call(r)==="[object Object]"}const hp=Object.freeze(Object.defineProperty({__proto__:null,Decoder:Vs,Encoder:rp,get PacketType(){return lt}},Symbol.toStringTag,{value:"Module"}));function De(r,u,c){return r.on(u,c),function(){r.off(u,c)}}const dp=Object.freeze({connect:1,connect_error:1,disconnect:1,disconnecting:1,newListener:1,removeListener:1});class Ed extends Dt{constructor(u,c,s){super(),this.connected=!1,this.recovered=!1,this.receiveBuffer=[],this.sendBuffer=[],this._queue=[],this._queueSeq=0,this.ids=0,this.acks={},this.flags={},this.io=u,this.nsp=c,s&&s.auth&&(this.auth=s.auth),this._opts=Object.assign({},s),this.io._autoConnect&&this.open()}get disconnected(){return!this.connected}subEvents(){if(this.subs)return;const u=this.io;this.subs=[De(u,"open",this.onopen.bind(this)),De(u,"packet",this.onpacket.bind(this)),De(u,"error",this.onerror.bind(this)),De(u,"close",this.onclose.bind(this))]}get active(){return!!this.subs}connect(){return this.connected?this:(this.subEvents(),this.io._reconnecting||this.io.open(),this.io._readyState==="open"&&this.onopen(),this)}open(){return this.connect()}send(...u){return u.unshift("message"),this.emit.apply(this,u),this}emit(u,...c){var s,p,x;if(dp.hasOwnProperty(u))throw new Error('"'+u.toString()+'" is a reserved event name');if(c.unshift(u),this._opts.retries&&!this.flags.fromQueue&&!this.flags.volatile)return this._addToQueue(c),this;const D={type:lt.EVENT,data:c};if(D.options={},D.options.compress=this.flags.compress!==!1,typeof c[c.length-1]=="function"){const G=this.ids++,R=c.pop();this._registerAckCallback(G,R),D.id=G}const M=(p=(s=this.io.engine)===null||s===void 0?void 0:s.transport)===null||p===void 0?void 0:p.writable,C=this.connected&&!(!((x=this.io.engine)===null||x===void 0)&&x._hasPingExpired());return this.flags.volatile&&!M||(C?(this.notifyOutgoingListeners(D),this.packet(D)):this.sendBuffer.push(D)),this.flags={},this}_registerAckCallback(u,c){var s;const p=(s=this.flags.timeout)!==null&&s!==void 0?s:this._opts.ackTimeout;if(p===void 0){this.acks[u]=c;return}const x=this.io.setTimeoutFn(()=>{delete this.acks[u];for(let M=0;M<this.sendBuffer.length;M++)this.sendBuffer[M].id===u&&this.sendBuffer.splice(M,1);c.call(this,new Error("operation has timed out"))},p),D=(...M)=>{this.io.clearTimeoutFn(x),c.apply(this,M)};D.withError=!0,this.acks[u]=D}emitWithAck(u,...c){return new Promise((s,p)=>{const x=(D,M)=>D?p(D):s(M);x.withError=!0,c.push(x),this.emit(u,...c)})}_addToQueue(u){let c;typeof u[u.length-1]=="function"&&(c=u.pop());const s={id:this._queueSeq++,tryCount:0,pending:!1,args:u,flags:Object.assign({fromQueue:!0},this.flags)};u.push((p,...x)=>(this._queue[0],p!==null?s.tryCount>this._opts.retries&&(this._queue.shift(),c&&c(p)):(this._queue.shift(),c&&c(null,...x)),s.pending=!1,this._drainQueue())),this._queue.push(s),this._drainQueue()}_drainQueue(u=!1){if(!this.connected||this._queue.length===0)return;const c=this._queue[0];c.pending&&!u||(c.pending=!0,c.tryCount++,this.flags=c.flags,this.emit.apply(this,c.args))}packet(u){u.nsp=this.nsp,this.io._packet(u)}onopen(){typeof this.auth=="function"?this.auth(u=>{this._sendConnectPacket(u)}):this._sendConnectPacket(this.auth)}_sendConnectPacket(u){this.packet({type:lt.CONNECT,data:this._pid?Object.assign({pid:this._pid,offset:this._lastOffset},u):u})}onerror(u){this.connected||this.emitReserved("connect_error",u)}onclose(u,c){this.connected=!1,delete this.id,this.emitReserved("disconnect",u,c),this._clearAcks()}_clearAcks(){Object.keys(this.acks).forEach(u=>{if(!this.sendBuffer.some(s=>String(s.id)===u)){const s=this.acks[u];delete this.acks[u],s.withError&&s.call(this,new Error("socket has been disconnected"))}})}onpacket(u){if(u.nsp===this.nsp)switch(u.type){case lt.CONNECT:u.data&&u.data.sid?this.onconnect(u.data.sid,u.data.pid):this.emitReserved("connect_error",new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));break;case lt.EVENT:case lt.BINARY_EVENT:this.onevent(u);break;case lt.ACK:case lt.BINARY_ACK:this.onack(u);break;case lt.DISCONNECT:this.ondisconnect();break;case lt.CONNECT_ERROR:this.destroy();const s=new Error(u.data.message);s.data=u.data.data,this.emitReserved("connect_error",s);break}}onevent(u){const c=u.data||[];u.id!=null&&c.push(this.ack(u.id)),this.connected?this.emitEvent(c):this.receiveBuffer.push(Object.freeze(c))}emitEvent(u){if(this._anyListeners&&this._anyListeners.length){const c=this._anyListeners.slice();for(const s of c)s.apply(this,u)}super.emit.apply(this,u),this._pid&&u.length&&typeof u[u.length-1]=="string"&&(this._lastOffset=u[u.length-1])}ack(u){const c=this;let s=!1;return function(...p){s||(s=!0,c.packet({type:lt.ACK,id:u,data:p}))}}onack(u){const c=this.acks[u.id];typeof c=="function"&&(delete this.acks[u.id],c.withError&&u.data.unshift(null),c.apply(this,u.data))}onconnect(u,c){this.id=u,this.recovered=c&&this._pid===c,this._pid=c,this.connected=!0,this.emitBuffered(),this._drainQueue(!0),this.emitReserved("connect")}emitBuffered(){this.receiveBuffer.forEach(u=>this.emitEvent(u)),this.receiveBuffer=[],this.sendBuffer.forEach(u=>{this.notifyOutgoingListeners(u),this.packet(u)}),this.sendBuffer=[]}ondisconnect(){this.destroy(),this.onclose("io server disconnect")}destroy(){this.subs&&(this.subs.forEach(u=>u()),this.subs=void 0),this.io._destroy(this)}disconnect(){return this.connected&&this.packet({type:lt.DISCONNECT}),this.destroy(),this.connected&&this.onclose("io client disconnect"),this}close(){return this.disconnect()}compress(u){return this.flags.compress=u,this}get volatile(){return this.flags.volatile=!0,this}timeout(u){return this.flags.timeout=u,this}onAny(u){return this._anyListeners=this._anyListeners||[],this._anyListeners.push(u),this}prependAny(u){return this._anyListeners=this._anyListeners||[],this._anyListeners.unshift(u),this}offAny(u){if(!this._anyListeners)return this;if(u){const c=this._anyListeners;for(let s=0;s<c.length;s++)if(u===c[s])return c.splice(s,1),this}else this._anyListeners=[];return this}listenersAny(){return this._anyListeners||[]}onAnyOutgoing(u){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.push(u),this}prependAnyOutgoing(u){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.unshift(u),this}offAnyOutgoing(u){if(!this._anyOutgoingListeners)return this;if(u){const c=this._anyOutgoingListeners;for(let s=0;s<c.length;s++)if(u===c[s])return c.splice(s,1),this}else this._anyOutgoingListeners=[];return this}listenersAnyOutgoing(){return this._anyOutgoingListeners||[]}notifyOutgoingListeners(u){if(this._anyOutgoingListeners&&this._anyOutgoingListeners.length){const c=this._anyOutgoingListeners.slice();for(const s of c)s.apply(this,u.data)}}}function Ra(r){r=r||{},this.ms=r.min||100,this.max=r.max||1e4,this.factor=r.factor||2,this.jitter=r.jitter>0&&r.jitter<=1?r.jitter:0,this.attempts=0}Ra.prototype.duration=function(){var r=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var u=Math.random(),c=Math.floor(u*this.jitter*r);r=(Math.floor(u*10)&1)==0?r-c:r+c}return Math.min(r,this.max)|0};Ra.prototype.reset=function(){this.attempts=0};Ra.prototype.setMin=function(r){this.ms=r};Ra.prototype.setMax=function(r){this.max=r};Ra.prototype.setJitter=function(r){this.jitter=r};class Ys extends Dt{constructor(u,c){var s;super(),this.nsps={},this.subs=[],u&&typeof u=="object"&&(c=u,u=void 0),c=c||{},c.path=c.path||"/socket.io",this.opts=c,iu(this,c),this.reconnection(c.reconnection!==!1),this.reconnectionAttempts(c.reconnectionAttempts||1/0),this.reconnectionDelay(c.reconnectionDelay||1e3),this.reconnectionDelayMax(c.reconnectionDelayMax||5e3),this.randomizationFactor((s=c.randomizationFactor)!==null&&s!==void 0?s:.5),this.backoff=new Ra({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(c.timeout==null?2e4:c.timeout),this._readyState="closed",this.uri=u;const p=c.parser||hp;this.encoder=new p.Encoder,this.decoder=new p.Decoder,this._autoConnect=c.autoConnect!==!1,this._autoConnect&&this.open()}reconnection(u){return arguments.length?(this._reconnection=!!u,u||(this.skipReconnect=!0),this):this._reconnection}reconnectionAttempts(u){return u===void 0?this._reconnectionAttempts:(this._reconnectionAttempts=u,this)}reconnectionDelay(u){var c;return u===void 0?this._reconnectionDelay:(this._reconnectionDelay=u,(c=this.backoff)===null||c===void 0||c.setMin(u),this)}randomizationFactor(u){var c;return u===void 0?this._randomizationFactor:(this._randomizationFactor=u,(c=this.backoff)===null||c===void 0||c.setJitter(u),this)}reconnectionDelayMax(u){var c;return u===void 0?this._reconnectionDelayMax:(this._reconnectionDelayMax=u,(c=this.backoff)===null||c===void 0||c.setMax(u),this)}timeout(u){return arguments.length?(this._timeout=u,this):this._timeout}maybeReconnectOnOpen(){!this._reconnecting&&this._reconnection&&this.backoff.attempts===0&&this.reconnect()}open(u){if(~this._readyState.indexOf("open"))return this;this.engine=new ep(this.uri,this.opts);const c=this.engine,s=this;this._readyState="opening",this.skipReconnect=!1;const p=De(c,"open",function(){s.onopen(),u&&u()}),x=M=>{this.cleanup(),this._readyState="closed",this.emitReserved("error",M),u?u(M):this.maybeReconnectOnOpen()},D=De(c,"error",x);if(this._timeout!==!1){const M=this._timeout,C=this.setTimeoutFn(()=>{p(),x(new Error("timeout")),c.close()},M);this.opts.autoUnref&&C.unref(),this.subs.push(()=>{this.clearTimeoutFn(C)})}return this.subs.push(p),this.subs.push(D),this}connect(u){return this.open(u)}onopen(){this.cleanup(),this._readyState="open",this.emitReserved("open");const u=this.engine;this.subs.push(De(u,"ping",this.onping.bind(this)),De(u,"data",this.ondata.bind(this)),De(u,"error",this.onerror.bind(this)),De(u,"close",this.onclose.bind(this)),De(this.decoder,"decoded",this.ondecoded.bind(this)))}onping(){this.emitReserved("ping")}ondata(u){try{this.decoder.add(u)}catch(c){this.onclose("parse error",c)}}ondecoded(u){nu(()=>{this.emitReserved("packet",u)},this.setTimeoutFn)}onerror(u){this.emitReserved("error",u)}socket(u,c){let s=this.nsps[u];return s?this._autoConnect&&!s.active&&s.connect():(s=new Ed(this,u,c),this.nsps[u]=s),s}_destroy(u){const c=Object.keys(this.nsps);for(const s of c)if(this.nsps[s].active)return;this._close()}_packet(u){const c=this.encoder.encode(u);for(let s=0;s<c.length;s++)this.engine.write(c[s],u.options)}cleanup(){this.subs.forEach(u=>u()),this.subs.length=0,this.decoder.destroy()}_close(){this.skipReconnect=!0,this._reconnecting=!1,this.onclose("forced close")}disconnect(){return this._close()}onclose(u,c){var s;this.cleanup(),(s=this.engine)===null||s===void 0||s.close(),this.backoff.reset(),this._readyState="closed",this.emitReserved("close",u,c),this._reconnection&&!this.skipReconnect&&this.reconnect()}reconnect(){if(this._reconnecting||this.skipReconnect)return this;const u=this;if(this.backoff.attempts>=this._reconnectionAttempts)this.backoff.reset(),this.emitReserved("reconnect_failed"),this._reconnecting=!1;else{const c=this.backoff.duration();this._reconnecting=!0;const s=this.setTimeoutFn(()=>{u.skipReconnect||(this.emitReserved("reconnect_attempt",u.backoff.attempts),!u.skipReconnect&&u.open(p=>{p?(u._reconnecting=!1,u.reconnect(),this.emitReserved("reconnect_error",p)):u.onreconnect()}))},c);this.opts.autoUnref&&s.unref(),this.subs.push(()=>{this.clearTimeoutFn(s)})}}onreconnect(){const u=this.backoff.attempts;this._reconnecting=!1,this.backoff.reset(),this.emitReserved("reconnect",u)}}const Cn={};function lu(r,u){typeof r=="object"&&(u=r,r=void 0),u=u||{};const c=lp(r,u.path||"/socket.io"),s=c.source,p=c.id,x=c.path,D=Cn[p]&&x in Cn[p].nsps,M=u.forceNew||u["force new connection"]||u.multiplex===!1||D;let C;return M?C=new Ys(s,u):(Cn[p]||(Cn[p]=new Ys(s,u)),C=Cn[p]),c.query&&!u.query&&(u.query=c.queryKey),C.socket(c.path,u)}Object.assign(lu,{Manager:Ys,Socket:Ed,io:lu,connect:lu});const mp=()=>{const[r,u]=st.useState(null),[c,s]=st.useState(!1),[p,x]=st.useState({multiplier:"1.00",currentEquity:"0",initialCapital:"0",winRate:"0",totalTrades:0,tokensScanned:0,winStreak:0}),[D,M]=st.useState([]),[C,z]=st.useState([]),[G,R]=st.useState(null),[V,at]=st.useState(null),[mt,pt]=st.useState([]),[Mt,Et]=st.useState(null),[Kt,bt]=st.useState(!0),[Jt,Ft]=st.useState([]),[Gt,W]=st.useState(null),[wt,ye]=st.useState(null),[al,kt]=st.useState([]),[Vt,Ye]=st.useState({total:0,ready:0,devSold:0}),[Ne,qt]=st.useState(null),T=X=>{Ft(Y=>[...Y,X]),setTimeout(()=>{Ft(Y=>Y.slice(1))},4e3)},B=X=>{Ft(Y=>Y.filter((j,d)=>d!==X))};return st.useEffect(()=>{const X=async()=>{try{const[j,d,E,U,q,K]=await Promise.all([fetch("/api/stats"),fetch("/api/trades?limit=10"),fetch("/api/positions/realtime"),fetch("/api/wallet"),fetch("/api/equity-history?hours=24"),fetch("/api/c100/status")]);if(j.ok&&x(await j.json()),d.ok&&M(await d.json()),E.ok){const Z=await E.json();z(Z.positions||[]),R(Z.summary||null)}if(U.ok){const Z=await U.json();at({solBalance:Z.solBalance,lastSync:Z.lastSync,isHealthy:Z.isHealthy,totalEquity:Z.equity?.total})}if(q.ok){const Z=await q.json();pt(Z.history||[])}K.ok&&qt(await K.json())}catch(j){console.error("Failed to fetch initial data",j)}};X();const Y=lu("/",{transports:["polling","websocket"],reconnectionAttempts:5,upgrade:!0});return Y.on("connect",()=>{s(!0),X()}),Y.on("disconnect",()=>{s(!1)}),Y.on("stats:initial",j=>x(j)),Y.on("stats:update",j=>x(j)),Y.on("trades:initial",j=>M(j)),Y.on("trade:open",j=>{T({type:"info",title:"Position Opened",message:`Bought ${j.symbol||j.mint.substring(0,8)} for ${j.amountSol} SOL`})}),Y.on("trade:close",j=>{parseFloat(j.pnlSol||"0")>0?T({type:"success",title:`+${j.pnlSol} SOL`,message:`${j.symbol} closed at ${j.pnlPercent}%`}):T({type:"error",title:`${j.pnlSol} SOL`,message:`${j.symbol} stopped out`}),fetch("/api/trades?limit=10").then(E=>E.json()).then(E=>M(E))}),Y.on("scanner:token",j=>{Et(j),bt(!1),j.tokensScanned&&x(d=>({...d,tokensScanned:j.tokensScanned}))}),Y.on("scanner:idle",j=>{Et(null),bt(!0),j&&j.tokensScanned&&x(d=>({...d,tokensScanned:j.tokensScanned}))}),Y.on("ai:decision",j=>{W(j)}),Y.on("signal:narrative",j=>{ye(j)}),Y.on("watchlist:update",j=>{kt(j.tokens),Ye(j.stats)}),Y.on("watchlist:tokenAdded",j=>{kt(d=>{const E=d.findIndex(U=>U.mint===j.mint);if(E>=0){const U=[...d];return U[E]=j,U}return[j,...d].slice(0,20)})}),Y.on("watchlist:tokenRemoved",j=>{kt(d=>d.filter(E=>E.mint!==j.mint))}),Y.on("watchlist:devSold",j=>{kt(d=>d.map(E=>E.mint===j.mint?{...E,devSold:!0,status:"rejected",rejectReason:"Dev sold"}:E))}),Y.on("status:paused",j=>{T({type:"warning",title:"Trading Paused",message:j.reason})}),Y.on("toast",j=>{T(j)}),Y.on("positions:initial",j=>{z(j.positions||[]),R({totalUnrealizedPnl:j.totalUnrealizedPnl,totalExposure:j.totalExposure,positionCount:j.positionCount})}),Y.on("positions:update",j=>{z(j.positions||[]),R({totalUnrealizedPnl:j.totalUnrealizedPnl,totalExposure:j.totalExposure,positionCount:j.positionCount})}),Y.on("wallet:update",j=>{at(j)}),Y.on("equity:snapshot",j=>{pt(d=>{const E=[...d,j];return E.length>1440?E.slice(-1440):E})}),Y.on("reconciliation:phantoms",j=>{j.count>0&&T({type:"warning",title:"Phantom Positions Detected",message:`Found ${j.count} position(s) with no tokens`})}),Y.on("c100:update",j=>{qt(j)}),Y.on("c100:priceUpdate",j=>{qt(d=>d?{...d,token:j}:null)}),Y.on("c100:claim",j=>{qt(d=>d?{...d,claims:{...d.claims,totalClaimedSol:d.claims.totalClaimedSol+j.amountSol,claimCount:d.claims.claimCount+1,lastClaimTime:new Date().toISOString()}}:null)}),Y.on("c100:buyback",j=>{qt(d=>d?{...d,buybacks:{...d.buybacks,totalBuybackSol:d.buybacks.totalBuybackSol+j.amountSol,totalTokensBought:d.buybacks.totalTokensBought+j.amountTokens,buybackCount:d.buybacks.buybackCount+1,lastBuybackTime:new Date().toISOString()}}:null)}),u(Y),()=>{Y.disconnect()}},[]),{socket:r,isConnected:c,stats:p,trades:D,positions:C,positionsSummary:G,walletState:V,equityHistory:mt,scannerData:Mt,isScanning:Kt,toasts:Jt,aiDecision:Gt,narrativeSignal:wt,watchlistTokens:al,watchlistStats:Vt,c100Data:Ne,removeToast:B}};function yp(){const{isConnected:r,stats:u,trades:c,positions:s,positionsSummary:p,walletState:x,equityHistory:D,scannerData:M,isScanning:C,toasts:z,aiDecision:G,watchlistTokens:R,watchlistStats:V,c100Data:at}=mp();return h.jsxs(h.Fragment,{children:[h.jsxs("div",{className:"dashboard",children:[h.jsx(i0,{isConnected:r}),h.jsx(u0,{stats:u}),h.jsx(x0,{data:at}),h.jsxs("div",{className:"main-grid",children:[h.jsxs("div",{className:"left-column",children:[h.jsx(c0,{stats:u}),h.jsx(o0,{data:M||void 0,isScanning:C,tokensScanned:u.tokensScanned}),h.jsx(b0,{history:D,walletBalance:x?.solBalance}),h.jsx(S0,{positions:s,summary:p})]}),h.jsxs("div",{className:"right-column",children:[h.jsx(h0,{trades:c}),h.jsx(d0,{stats:u,decision:G}),h.jsx(v0,{tokens:R,stats:V})]})]})]}),h.jsx("div",{className:"toast-container",children:z.map((mt,pt)=>h.jsxs("div",{className:`toast ${mt.type}`,children:[h.jsx("div",{className:"toast-title",children:mt.title}),h.jsx("div",{className:"toast-message",children:mt.message})]},pt))}),h.jsxs("div",{className:"floating-controls",children:[h.jsxs("div",{className:"wallet-pill",onClick:()=>{navigator.clipboard.writeText("8FvP3dYCYf1gaQ1DnXyjERkDvmFK1odrQepcVQLvHDxB")},title:"Click to copy address",children:[h.jsx("span",{className:"wallet-label",children:"DONATE"}),h.jsx("span",{className:"wallet-address",children:"8FvP...HDxB"}),h.jsxs("svg",{viewBox:"0 0 24 24",width:"14",height:"14",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round",children:[h.jsx("rect",{x:"9",y:"9",width:"13",height:"13",rx:"2",ry:"2"}),h.jsx("path",{d:"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"})]})]}),h.jsx("a",{href:"https://x.com/100xClaude",target:"_blank",rel:"noopener noreferrer",className:"x-profile-link",children:h.jsx("svg",{viewBox:"0 0 24 24",width:"24",height:"24",fill:"currentColor",children:h.jsx("path",{d:"M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"})})})]})]})}n0.createRoot(document.getElementById("root")).render(h.jsx(Wy.StrictMode,{children:h.jsx(yp,{})}));
</file>

<file path="public/assets/index-BZU8IHLs.css">
:root{--bg-page: #1C1917;--bg-card: #262320;--bg-card-hover: #2E2A26;--bg-elevated: #33302C;--border: rgba(255, 245, 230, .08);--border-light: rgba(255, 245, 230, .12);--text-primary: #F5F5F4;--text-secondary: #A8A29E;--text-muted: #78716C;--accent: #D97706;--accent-secondary: #F59E0B;--accent-glow: rgba(217, 119, 6, .3);--accent-subtle: rgba(217, 119, 6, .12);--success: #22C55E;--success-glow: rgba(34, 197, 94, .25);--success-subtle: rgba(34, 197, 94, .12);--error: #EF4444;--error-subtle: rgba(239, 68, 68, .12);--warning: #F59E0B}*{margin:0;padding:0;box-sizing:border-box}body{font-family:Inter,-apple-system,BlinkMacSystemFont,sans-serif;background:var(--bg-page);color:var(--text-primary);min-height:100vh;padding:24px 32px;-webkit-font-smoothing:antialiased}body:before{content:"";position:fixed;inset:0;background-image:radial-gradient(circle at 50% 50%,rgba(217,119,6,.03) 0%,transparent 50%);pointer-events:none;z-index:-1}.dashboard{max-width:1280px;margin:0 auto}.header{display:flex;justify-content:flex-end;align-items:center;margin-bottom:48px;position:relative;min-height:80px}.header-left{display:flex;align-items:center;gap:20px;position:absolute;left:50%;transform:translate(-50%);width:max-content}.logo-icon{width:72px;height:72px;border-radius:20px;background:linear-gradient(135deg,var(--accent),var(--accent-secondary));display:flex;align-items:center;justify-content:center;box-shadow:0 8px 32px var(--accent-glow)}.logo-icon svg{width:26px;height:26px;color:#fff}.logo-text h1{font-size:28px;font-weight:700;color:var(--text-primary);letter-spacing:-.02em}.logo-text p{font-size:13px;color:var(--text-muted);margin-top:2px}.live-badge{display:flex;align-items:center;gap:8px;padding:10px 18px;border-radius:100px;background:var(--success-subtle);border:1px solid rgba(16,185,129,.2);color:var(--success);font-size:13px;font-weight:500;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.live-dot{width:8px;height:8px;border-radius:50%;background:var(--success);box-shadow:0 0 12px var(--success);animation:pulse 2s ease-in-out infinite}@keyframes pulse{0%,to{opacity:1;transform:scale(1)}50%{opacity:.6;transform:scale(.9)}}.stats-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:16px;margin-bottom:24px}.stat-card{background:var(--bg-card);border:1px solid var(--border);border-radius:16px;padding:20px 24px;transition:all .2s ease;position:relative;overflow:hidden}.stat-card:before{content:"";position:absolute;top:0;left:0;right:0;height:1px;background:linear-gradient(90deg,transparent,rgba(255,245,230,.06),transparent)}.stat-card:hover{background:var(--bg-card-hover);border-color:var(--border-light);transform:translateY(-2px)}.stat-card.highlight{background:linear-gradient(135deg,#ff6b3514,#ff8f5c0a);border-color:#ff6b354d}.stat-card.highlight:after{content:"";position:absolute;top:-50%;left:-50%;width:200%;height:200%;background:radial-gradient(circle,var(--accent-glow) 0%,transparent 70%);opacity:.3;pointer-events:none}.stat-label{font-size:11px;font-weight:600;color:var(--text-muted);text-transform:uppercase;letter-spacing:.08em;margin-bottom:10px}.stat-value{font-size:32px;font-weight:600;color:var(--text-primary);line-height:1.1;letter-spacing:-.02em}.stat-value.accent{background:linear-gradient(135deg,var(--accent),var(--accent-secondary));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.stat-sub{display:flex;align-items:center;gap:6px;font-size:12px;font-weight:500;color:var(--text-secondary);margin-top:8px}.stat-sub.positive{color:var(--success)}.stat-sub .arrow{font-size:14px}.main-grid{display:grid;grid-template-columns:1.6fr 1fr;gap:24px}.left-column,.right-column{display:flex;flex-direction:column;gap:24px}.card{background:var(--bg-card);border:1px solid var(--border);border-radius:20px;overflow:hidden;position:relative}.card:before{content:"";position:absolute;top:0;left:0;right:0;height:1px;background:linear-gradient(90deg,transparent,rgba(255,245,230,.05),transparent)}.card-header{padding:20px 24px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center}.card-title{font-size:14px;font-weight:600;color:var(--text-primary);letter-spacing:-.01em}.challenge-card{padding:48px 32px;text-align:center;position:relative}.challenge-card:after{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:400px;height:400px;background:radial-gradient(circle,var(--accent-glow) 0%,transparent 70%);opacity:.4;pointer-events:none}.challenge-label{font-size:11px;font-weight:600;color:var(--text-muted);text-transform:uppercase;letter-spacing:.15em;margin-bottom:20px;position:relative;z-index:1}.challenge-value{font-size:84px;font-weight:300;line-height:1;position:relative;z-index:1;background:linear-gradient(135deg,var(--accent),var(--accent-secondary));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;text-shadow:0 0 80px var(--accent-glow)}.challenge-value span{font-size:42px;background:linear-gradient(135deg,var(--text-muted),var(--text-secondary));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.challenge-sub{font-size:14px;color:var(--text-secondary);margin-top:12px;margin-bottom:32px;position:relative;z-index:1}.progress-bar-container{position:relative;z-index:1}.progress-bar{height:10px;background:#3d3835;border-radius:10px;overflow:hidden;position:relative}.progress-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-secondary));border-radius:10px;transition:width .8s cubic-bezier(.4,0,.2,1);position:relative}.progress-fill:after{content:"";position:absolute;inset:0;background:linear-gradient(90deg,transparent,rgba(255,245,230,.2),transparent);animation:shimmer 2.5s infinite}@keyframes shimmer{0%{transform:translate(-100%)}to{transform:translate(100%)}}.progress-markers{display:flex;justify-content:space-between;margin-top:12px;font-size:11px;font-weight:500;color:var(--text-muted)}.progress-markers span.active{color:var(--accent)}.scanner-card .card-header{border-bottom:none;padding-bottom:0}.scanner-content{padding:0 24px 24px}.scanner-token{display:flex;align-items:center;gap:14px;padding:18px;background:var(--bg-elevated);border-radius:14px;margin-bottom:18px;border:1px solid var(--border)}.scanner-icon{width:44px;height:44px;border-radius:12px;background:linear-gradient(135deg,var(--accent-subtle),transparent);border:1px solid rgba(255,107,53,.2);display:flex;align-items:center;justify-content:center;font-size:18px;color:var(--accent);animation:rotate 2s linear infinite}@keyframes rotate{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.scanner-icon.idle{animation:none}.scanner-token-info h4{font-size:18px;font-weight:600;color:var(--text-primary);letter-spacing:-.01em}.scanner-token-info p{font-size:12px;color:var(--accent);margin-top:2px}.scanner-metrics{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:18px}.metric-box{background:var(--bg-elevated);border:1px solid var(--border);border-radius:12px;padding:16px;text-align:center;transition:all .2s ease}.metric-box:hover{border-color:var(--border-light);background:var(--bg-card-hover)}.metric-value{font-size:22px;font-weight:600;color:var(--text-primary);letter-spacing:-.02em}.metric-value.accent{color:var(--accent)}.metric-value.success{color:var(--success)}.metric-label{font-size:10px;font-weight:600;color:var(--text-muted);text-transform:uppercase;letter-spacing:.06em;margin-top:6px}.mini-chart{height:60px;display:flex;align-items:flex-end;gap:2px;padding:12px 0}.chart-bar{flex:1;border-radius:3px;transition:all .3s ease;min-height:4px}.chart-bar.up{background:linear-gradient(to top,var(--success),rgba(34,197,94,.5))}.chart-bar.down{background:linear-gradient(to top,#a8a29e,#78716c)}.chart-bar:hover{opacity:.8;transform:scaleY(1.1)}.trades-list{max-height:360px;overflow-y:auto}.trades-list::-webkit-scrollbar{width:4px}.trades-list::-webkit-scrollbar-track{background:transparent}.trades-list::-webkit-scrollbar-thumb{background:#44403c;border-radius:4px}.trades-list::-webkit-scrollbar-thumb:hover{background:#57534e}.trade-item{display:flex;align-items:center;padding:14px 24px;border-bottom:1px solid var(--border);gap:14px;transition:background .15s ease}.trade-item:hover{background:var(--bg-elevated)}.trade-item:last-child{border-bottom:none}.trade-arrow{width:36px;height:36px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:14px;font-weight:600}.trade-arrow.up{background:var(--success-subtle);color:var(--success);box-shadow:0 0 20px var(--success-glow)}.trade-arrow.down{background:var(--error-subtle);color:var(--error)}.trade-info{flex:1}.trade-token{font-size:14px;font-weight:600;color:var(--text-primary)}.trade-time{font-size:11px;color:var(--text-muted);margin-top:2px}.trade-pnl{text-align:right}.trade-pnl-value{font-size:14px;font-weight:600}.trade-pnl-value.positive{color:var(--success)}.trade-pnl-value.negative{color:var(--text-secondary)}.trade-pnl-percent{font-size:11px;color:var(--success);margin-top:2px}.ai-content{padding:28px 24px;text-align:center}.ai-indicator{width:100px;height:100px;margin:0 auto 20px;position:relative}.ai-ring-outer{position:absolute;width:100%;height:100%;border-radius:50%;border:2px solid #3D3835}.ai-ring{position:absolute;width:100%;height:100%;border-radius:50%;border:2px solid transparent;border-top-color:var(--accent);animation:spin 1.5s linear infinite}.ai-ring-inner{position:absolute;width:70%;height:70%;top:15%;left:15%;border-radius:50%;border:2px solid transparent;border-top-color:var(--accent-secondary);animation:spin 2s linear infinite reverse}@keyframes spin{to{transform:rotate(360deg)}}.ai-center{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:44px;height:44px;border-radius:50%;background:linear-gradient(135deg,var(--accent),var(--accent-secondary));display:flex;align-items:center;justify-content:center;box-shadow:0 0 30px var(--accent-glow)}.ai-center-dot{width:16px;height:16px;border-radius:50%;background:#fafaf9;animation:pulse 2s ease-in-out infinite}.ai-status{font-size:13px;color:var(--text-secondary);margin-bottom:20px}.confidence-bar{margin-bottom:24px}.confidence-header{display:flex;justify-content:space-between;font-size:12px;margin-bottom:8px}.confidence-header span:first-child{color:var(--text-muted)}.confidence-header span:last-child{color:var(--accent);font-weight:600}.confidence-track{height:6px;background:#3d3835;border-radius:6px;overflow:hidden}.confidence-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-secondary));border-radius:6px;transition:width .5s cubic-bezier(.4,0,.2,1)}.win-streak-box{background:var(--bg-elevated);border:1px solid var(--border);border-radius:14px;padding:24px}.win-streak-value{font-size:48px;font-weight:300;background:linear-gradient(135deg,var(--accent),var(--accent-secondary));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;line-height:1}.win-streak-label{font-size:12px;color:var(--text-muted);margin-top:8px}.toast-container{position:fixed;top:24px;right:24px;display:flex;flex-direction:column;gap:12px;z-index:1000}.toast{background:var(--bg-card);border:1px solid var(--border);border-radius:14px;padding:16px 20px;min-width:300px;animation:slideIn .4s cubic-bezier(.16,1,.3,1);box-shadow:0 20px 40px #0006;-webkit-backdrop-filter:blur(20px);backdrop-filter:blur(20px)}.floating-controls{position:fixed;bottom:24px;right:24px;display:flex;align-items:center;gap:12px;z-index:100}.wallet-pill{display:flex;align-items:center;gap:10px;background:var(--bg-card);border:1px solid var(--border);border-radius:100px;padding:0 20px;height:48px;cursor:pointer;transition:all .2s ease;box-shadow:0 4px 12px #0003}.wallet-pill:hover{transform:translateY(-2px);border-color:var(--border-light);background:var(--bg-elevated);box-shadow:0 8px 16px #0000004d}.wallet-pill:active{transform:translateY(0)}.wallet-label{font-size:11px;font-weight:700;color:var(--accent);letter-spacing:.05em}.wallet-address{font-size:13px;color:var(--text-secondary);font-family:monospace;font-weight:500}.wallet-pill svg{color:var(--text-muted);opacity:.7}.wallet-pill:hover svg{opacity:1;color:var(--text-primary)}.x-profile-link{width:48px;height:48px;display:flex;align-items:center;justify-content:center;background:var(--bg-card);border:1px solid var(--border);border-radius:12px;color:var(--text-muted);transition:all .2s ease;box-shadow:0 4px 12px #0003}.x-profile-link:hover{transform:translateY(-2px);color:var(--text-primary);border-color:var(--border-light);background:var(--bg-elevated);box-shadow:0 8px 16px #0000004d}.x-profile-link svg{width:20px;height:20px}.toast.success{border-left:3px solid var(--success);box-shadow:0 20px 40px #0006,0 0 40px var(--success-glow)}.toast.error{border-left:3px solid var(--error)}.toast.warning{border-left:3px solid var(--warning)}.toast.info{border-left:3px solid var(--accent)}.toast-title{font-size:14px;font-weight:600;margin-bottom:4px}.toast.success .toast-title{color:var(--success)}.toast.error .toast-title{color:var(--error)}.toast-message{font-size:13px;color:var(--text-secondary)}@keyframes slideIn{0%{transform:translate(100%) scale(.9);opacity:0}to{transform:translate(0) scale(1);opacity:1}}.empty-state{padding:40px 24px;text-align:center;color:var(--text-muted);font-size:13px}@media(max-width:1024px){.stats-grid{grid-template-columns:repeat(2,1fr)}.main-grid{grid-template-columns:1fr}}@media(max-width:600px){.stats-grid{grid-template-columns:1fr}body{padding:16px}.header{flex-direction:column;align-items:flex-start;gap:16px}.header-left{width:100%}.live-badge{position:absolute;top:16px;right:16px}.challenge-value{font-size:56px}}.animate-number{display:inline-block;transition:transform .3s ease}.animate-number.updating{transform:scale(1.05)}.positions-list{max-height:300px;overflow-y:auto}.positions-list::-webkit-scrollbar{width:4px}.positions-list::-webkit-scrollbar-track{background:transparent}.positions-list::-webkit-scrollbar-thumb{background:#44403c;border-radius:4px}.position-item{display:flex;align-items:center;padding:14px 24px;border-bottom:1px solid var(--border);gap:12px;transition:background .15s ease}.position-item:hover{background:var(--bg-elevated)}.position-item:last-child{border-bottom:none}.position-indicator{width:4px;height:40px;border-radius:2px}.position-indicator.profit{background:var(--success);box-shadow:0 0 8px var(--success-glow)}.position-indicator.loss{background:var(--error)}.position-info{flex:1;min-width:0}.position-header{display:flex;align-items:center;gap:8px}.position-symbol{font-size:14px;font-weight:600;color:var(--text-primary)}.position-pool{font-size:10px;font-weight:500;padding:2px 6px;border-radius:4px;background:var(--accent-subtle);color:var(--accent);text-transform:uppercase}.position-details{display:flex;gap:12px;margin-top:4px;font-size:11px;color:var(--text-muted)}.position-pnl{text-align:right}.position-unrealized{font-size:14px;font-weight:600}.position-unrealized.positive{color:var(--success)}.position-unrealized.negative{color:var(--error)}.position-pnl-percent{font-size:11px;opacity:.8;margin-left:4px}.position-realized{font-size:11px;color:var(--text-muted);margin-top:2px}.position-status{display:flex;gap:4px}.status-badge{font-size:9px;font-weight:600;padding:2px 5px;border-radius:3px;text-transform:uppercase}.status-badge.recovered{background:var(--success-subtle);color:var(--success)}.status-badge.exits{background:var(--accent-subtle);color:var(--accent)}.status-badge.trailing{background:#8b5cf61f;color:#a78bfa}.positions-footer{padding:12px 24px;border-top:1px solid var(--border);display:flex;justify-content:space-between;font-size:11px;color:var(--text-muted)}.card-badge{font-size:12px;font-weight:600;padding:4px 10px;border-radius:6px}.card-badge.positive{background:var(--success-subtle);color:var(--success)}.card-badge.negative{background:var(--error-subtle);color:var(--error)}.equity-chart-card{min-height:180px}.equity-chart-content{padding:16px 24px}.equity-chart-empty{padding:40px 24px;text-align:center;color:var(--text-muted);font-size:13px;display:flex;flex-direction:column;gap:8px}.wallet-balance{font-size:18px;font-weight:600;color:var(--text-primary)}.equity-current{display:flex;align-items:baseline;gap:6px;margin-bottom:12px}.equity-value{font-size:28px;font-weight:600;color:var(--text-primary)}.equity-label{font-size:14px;color:var(--text-muted)}.equity-sparkline{width:100%;height:60px;display:block}.equity-range{display:flex;justify-content:space-between;font-size:10px;color:var(--text-muted);margin-top:4px}.equity-footer{padding:12px 24px;border-top:1px solid var(--border);display:flex;justify-content:space-between;font-size:12px}.equity-footer .positive{color:var(--success)}.equity-footer .negative{color:var(--error)}.wallet-indicator{color:var(--text-muted)}.c100-card{background:linear-gradient(135deg,#d977060f,#f59e0b05);border:1px solid rgba(217,119,6,.25);border-radius:20px;padding:24px;margin-bottom:24px;position:relative;overflow:hidden}.c100-card:before{content:"";position:absolute;top:0;left:0;right:0;height:1px;background:linear-gradient(90deg,transparent,rgba(217,119,6,.3),transparent)}.c100-card:after{content:"";position:absolute;top:-100px;right:-100px;width:300px;height:300px;background:radial-gradient(circle,var(--accent-glow) 0%,transparent 70%);opacity:.15;pointer-events:none}.c100-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}.c100-token-info{display:flex;align-items:center;gap:14px}.c100-icon{width:48px;height:48px;border-radius:14px;background:linear-gradient(135deg,var(--accent),var(--accent-secondary));display:flex;align-items:center;justify-content:center;font-size:22px;font-weight:700;color:#fff;box-shadow:0 4px 20px var(--accent-glow)}.c100-details h3{font-size:18px;font-weight:600;color:var(--text-primary);letter-spacing:-.01em}.c100-ticker{font-size:13px;color:var(--accent);font-weight:500;margin-top:2px}.c100-mint{font-size:12px;color:var(--text-muted);background:var(--bg-elevated);padding:6px 12px;border-radius:8px;font-family:monospace;cursor:pointer;transition:all .2s ease;border:1px solid var(--border)}.c100-mint:hover{background:var(--bg-card-hover);border-color:var(--border-light);color:var(--text-secondary)}.c100-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:16px}.c100-stat{background:var(--bg-elevated);border:1px solid var(--border);border-radius:12px;padding:16px;text-align:center;transition:all .2s ease}.c100-stat:hover{border-color:var(--border-light);background:var(--bg-card-hover)}.c100-stat.highlight{background:linear-gradient(135deg,#d9770614,#f59e0b0a);border-color:#d977064d}.c100-stat.wide{grid-column:span 1}.c100-stat-label{font-size:10px;font-weight:600;color:var(--text-muted);text-transform:uppercase;letter-spacing:.06em;display:block;margin-bottom:8px}.c100-stat-value{font-size:20px;font-weight:600;color:var(--text-primary);letter-spacing:-.02em;display:block}.c100-stat-value.accent{background:linear-gradient(135deg,var(--accent),var(--accent-secondary));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.c100-stat-value.large{font-size:24px}.c100-stat-change{font-size:11px;font-weight:500;display:block;margin-top:4px}.c100-stat-change.positive{color:var(--success)}.c100-stat-change.negative{color:var(--error)}.c100-stat-sub{font-size:10px;color:var(--text-muted);display:block;margin-top:4px}@media(max-width:900px){.c100-grid{grid-template-columns:repeat(3,1fr)}.c100-stat.wide{grid-column:span 3}}@media(max-width:600px){.c100-grid{grid-template-columns:repeat(2,1fr)}.c100-stat.wide{grid-column:span 2}.c100-header{flex-direction:column;align-items:flex-start;gap:12px}.c100-mint{align-self:flex-start}}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/ai/ddqn-agent.ts">
import * as tf from '@tensorflow/tfjs';
import { createChildLogger } from '../utils/logger';
import { Action, Experience, DDQNConfig } from './types';
import { config } from '../config/settings';

const logger = createChildLogger('ddqn-agent');

export class DDQNAgent {
  private mainNetwork: tf.Sequential | null = null;
  private targetNetwork: tf.Sequential | null = null;
  private replayBuffer: Experience[] = [];
  private config: DDQNConfig;
  private epsilon: number;
  private trainStepCount = 0;

  constructor(ddqnConfig?: Partial<DDQNConfig>) {
    this.config = { ...config.ddqnConfig, ...ddqnConfig };
    this.epsilon = this.config.epsilon;
  }

  async initialize(): Promise<void> {
    logger.info('Initializing DDQN networks');

    this.mainNetwork = this.buildNetwork();
    this.targetNetwork = this.buildNetwork();

    // Copy main network weights to target
    await this.hardUpdateTarget();

    logger.info('DDQN networks initialized');
  }

  private buildNetwork(): tf.Sequential {
    const model = tf.sequential();

    // Input layer + first hidden
    model.add(
      tf.layers.dense({
        units: this.config.hiddenSize,
        activation: 'relu',
        inputShape: [this.config.stateSize],
        kernelInitializer: 'heNormal',
      })
    );

    // Second hidden layer
    model.add(
      tf.layers.dense({
        units: this.config.hiddenSize,
        activation: 'relu',
        kernelInitializer: 'heNormal',
      })
    );

    // Output layer (Q-values for each action)
    model.add(
      tf.layers.dense({
        units: this.config.actionSize,
        activation: 'linear',
        kernelInitializer: 'heNormal',
      })
    );

    model.compile({
      optimizer: tf.train.adam(this.config.learningRate),
      loss: 'meanSquaredError',
    });

    return model;
  }

  selectAction(state: number[]): { action: Action; qValues: number[] } {
    if (!this.mainNetwork) {
      throw new Error('Network not initialized');
    }

    // Epsilon-greedy action selection
    if (Math.random() < this.epsilon) {
      // Random action
      const action = Math.floor(Math.random() * this.config.actionSize) as Action;
      return { action, qValues: [0, 0, 0] };
    }

    // Get Q-values from main network
    const stateTensor = tf.tensor2d([state]);
    const qValuesTensor = this.mainNetwork.predict(stateTensor) as tf.Tensor;
    const qValues = qValuesTensor.dataSync() as Float32Array;

    stateTensor.dispose();
    qValuesTensor.dispose();

    // Select action with highest Q-value
    const action = this.argMax(Array.from(qValues)) as Action;

    return { action, qValues: Array.from(qValues) };
  }

  private argMax(arr: number[]): number {
    return arr.indexOf(Math.max(...arr));
  }

  addExperience(experience: Experience): void {
    this.replayBuffer.push(experience);

    // Remove oldest if buffer is full
    if (this.replayBuffer.length > this.config.replayBufferSize) {
      this.replayBuffer.shift();
    }
  }

  async train(): Promise<number> {
    if (!this.mainNetwork || !this.targetNetwork) {
      throw new Error('Networks not initialized');
    }

    if (this.replayBuffer.length < this.config.batchSize) {
      return 0;
    }

    // Sample random batch
    const batch = this.sampleBatch(this.config.batchSize);

    // Prepare training data
    const states = batch.map((e) => e.state);
    const nextStates = batch.map((e) => e.nextState);

    const statesTensor = tf.tensor2d(states);
    const nextStatesTensor = tf.tensor2d(nextStates);

    // Get current Q-values
    const currentQs = this.mainNetwork.predict(statesTensor) as tf.Tensor;
    const currentQsArray = currentQs.arraySync() as number[][];

    // DDQN: Use main network to select actions, target network to evaluate
    const nextQsMain = this.mainNetwork.predict(nextStatesTensor) as tf.Tensor;
    const nextQsTarget = this.targetNetwork.predict(nextStatesTensor) as tf.Tensor;

    const nextQsMainArray = nextQsMain.arraySync() as number[][];
    const nextQsTargetArray = nextQsTarget.arraySync() as number[][];

    // Update Q-values based on Bellman equation
    const targetQs: number[][] = [];

    for (let i = 0; i < batch.length; i++) {
      const experience = batch[i];
      const targetQ = [...currentQsArray[i]];

      if (experience.done) {
        targetQ[experience.action] = experience.reward;
      } else {
        // DDQN: action selected by main, value from target
        const bestAction = this.argMax(nextQsMainArray[i]);
        targetQ[experience.action] =
          experience.reward + this.config.gamma * nextQsTargetArray[i][bestAction];
      }

      targetQs.push(targetQ);
    }

    // Train main network
    const targetTensor = tf.tensor2d(targetQs);
    const history = await this.mainNetwork.fit(statesTensor, targetTensor, {
      epochs: 1,
      verbose: 0,
    });

    const loss = history.history.loss[0] as number;

    // Cleanup tensors
    statesTensor.dispose();
    nextStatesTensor.dispose();
    currentQs.dispose();
    nextQsMain.dispose();
    nextQsTarget.dispose();
    targetTensor.dispose();

    // Soft update target network
    this.trainStepCount++;
    await this.softUpdateTarget();

    // Decay epsilon
    this.decayEpsilon();

    return loss;
  }

  private sampleBatch(size: number): Experience[] {
    const batch: Experience[] = [];
    const indices = new Set<number>();

    while (indices.size < size && indices.size < this.replayBuffer.length) {
      indices.add(Math.floor(Math.random() * this.replayBuffer.length));
    }

    for (const idx of indices) {
      batch.push(this.replayBuffer[idx]);
    }

    return batch;
  }

  private async softUpdateTarget(): Promise<void> {
    if (!this.mainNetwork || !this.targetNetwork) return;

    const mainWeights = this.mainNetwork.getWeights();
    const targetWeights = this.targetNetwork.getWeights();

    const newWeights = mainWeights.map((mainWeight, i) => {
      const targetWeight = targetWeights[i];
      return tf.tidy(() => {
        const mainScaled = mainWeight.mul(this.config.targetUpdateTau);
        const targetScaled = targetWeight.mul(1 - this.config.targetUpdateTau);
        return mainScaled.add(targetScaled);
      });
    });

    this.targetNetwork.setWeights(newWeights);

    // Dispose old weights
    newWeights.forEach((w) => w.dispose());
  }

  private async hardUpdateTarget(): Promise<void> {
    if (!this.mainNetwork || !this.targetNetwork) return;

    const mainWeights = this.mainNetwork.getWeights();
    const weightCopies = mainWeights.map((w) => w.clone());
    this.targetNetwork.setWeights(weightCopies);
    weightCopies.forEach((w) => w.dispose());
  }

  private decayEpsilon(): void {
    this.epsilon = Math.max(
      this.config.epsilonMin,
      this.epsilon * this.config.epsilonDecay
    );
  }

  getEpsilon(): number {
    return this.epsilon;
  }

  setEpsilon(epsilon: number): void {
    this.epsilon = Math.max(this.config.epsilonMin, Math.min(1, epsilon));
  }

  getReplayBufferSize(): number {
    return this.replayBuffer.length;
  }

  async saveModel(path: string): Promise<void> {
    if (!this.mainNetwork) throw new Error('Network not initialized');

    await this.mainNetwork.save(`file://${path}`);
    logger.info({ path }, 'Model saved');
  }

  async loadModel(path: string): Promise<void> {
    try {
      this.mainNetwork = (await tf.loadLayersModel(`file://${path}/model.json`)) as tf.Sequential;

      // Recompile
      this.mainNetwork.compile({
        optimizer: tf.train.adam(this.config.learningRate),
        loss: 'meanSquaredError',
      });

      // Copy to target
      await this.hardUpdateTarget();

      logger.info({ path }, 'Model loaded');
    } catch (error) {
      logger.warn({ path, error }, 'Failed to load model, using fresh network');
      await this.initialize();
    }
  }

  getWeightsAsJSON(): string {
    if (!this.mainNetwork) throw new Error('Network not initialized');

    const weights = this.mainNetwork.getWeights();
    const weightsData = weights.map((w) => ({
      shape: w.shape,
      data: Array.from(w.dataSync()),
    }));

    return JSON.stringify(weightsData);
  }

  async loadWeightsFromJSON(json: string): Promise<void> {
    if (!this.mainNetwork) throw new Error('Network not initialized');

    const weightsData = JSON.parse(json);
    const weights = weightsData.map((w: { shape: number[]; data: number[] }) =>
      tf.tensor(w.data, w.shape)
    );

    this.mainNetwork.setWeights(weights);
    await this.hardUpdateTarget();

    weights.forEach((w: tf.Tensor) => w.dispose());
    logger.info('Weights loaded from JSON');
  }

  clearReplayBuffer(): void {
    this.replayBuffer = [];
  }

  dispose(): void {
    if (this.mainNetwork) {
      this.mainNetwork.dispose();
      this.mainNetwork = null;
    }
    if (this.targetNetwork) {
      this.targetNetwork.dispose();
      this.targetNetwork = null;
    }
  }
}

export const ddqnAgent = new DDQNAgent();
</file>

<file path="src/ai/index.ts">
export * from './types';
export * from './ddqn-agent';
export * from './regime-detector';
export * from './position-sizer';
</file>

<file path="src/ai/position-sizer.ts">
import { createChildLogger } from '../utils/logger';
import { PositionSizeResult, MarketRegime } from './types';
import { regimeDetector } from './regime-detector';
import { config } from '../config/settings';

const logger = createChildLogger('position-sizer');

export class PositionSizer {
  private winHistory: boolean[] = [];
  private maxHistory = 100;

  constructor() {}

  calculateSize(
    availableCapital: number,
    winProbability?: number,
    avgWinLossRatio?: number,
    currentRegime?: MarketRegime,
    confidence?: number  // NEW: Use confidence as size multiplier
  ): PositionSizeResult {
    // Get regime multiplier
    const regime = currentRegime ?? regimeDetector.getCurrentRegime().regime;
    const regimeMultiplier = regimeDetector.getRegimeMultiplier(regime);

    // Calculate Kelly fraction
    const kellyFraction = this.calculateKellyFraction(winProbability, avgWinLossRatio);

    // NEW: Calculate confidence multiplier
    // 0.55 confidence â†’ 0.55x size, 0.80 confidence â†’ 1.0x size
    // Scale from 0.55-1.0 confidence to 0.6-1.0 multiplier
    let confidenceMultiplier = 1.0;
    if (confidence !== undefined) {
      // Clamp confidence to reasonable range
      const clampedConf = Math.max(0.4, Math.min(1.0, confidence));
      // Scale: 0.4 conf â†’ 0.5x, 0.7 conf â†’ 0.75x, 1.0 conf â†’ 1.0x
      confidenceMultiplier = 0.5 + (clampedConf - 0.4) * (0.5 / 0.6);
    }

    // Apply regime adjustment AND confidence multiplier
    let rawSize = kellyFraction * regimeMultiplier * confidenceMultiplier * availableCapital;

    // Apply hard limits
    const maxSize = config.maxPositionSize * config.initialCapitalSol;
    const minSize = 0.001; // Minimum 0.001 SOL

    const finalSize = Math.max(minSize, Math.min(maxSize, rawSize));

    const reason = this.buildReason(kellyFraction, regimeMultiplier, rawSize, finalSize, confidenceMultiplier);

    const result: PositionSizeResult = {
      sizeSol: finalSize,
      kellyFraction,
      regimeMultiplier,
      riskAdjustedSize: rawSize,
      reason,
    };

    logger.debug({
      availableCapital,
      kellyFraction: kellyFraction.toFixed(4),
      regimeMultiplier,
      confidenceMultiplier: confidenceMultiplier.toFixed(2),
      finalSize: finalSize.toFixed(4),
    }, 'Position size calculated');

    return result;
  }

  private calculateKellyFraction(winProb?: number, winLossRatio?: number): number {
    // Default estimates if not provided
    const p = winProb ?? this.estimateWinProbability();
    const r = winLossRatio ?? 2.0; // Assume 2:1 reward:risk by default

    // Kelly formula: f = (p * r - (1 - p)) / r
    // Or: f = p - (1 - p) / r
    const kelly = p - (1 - p) / r;

    // Half-Kelly for safety
    const halfKelly = kelly / 2;

    // Clamp to reasonable range [0, 0.25] (max 25% of capital)
    return Math.max(0, Math.min(0.25, halfKelly));
  }

  private estimateWinProbability(): number {
    if (this.winHistory.length < 10) {
      return 0.4; // Conservative default
    }

    const wins = this.winHistory.filter(Boolean).length;
    return wins / this.winHistory.length;
  }

  recordTrade(isWin: boolean): void {
    this.winHistory.push(isWin);

    if (this.winHistory.length > this.maxHistory) {
      this.winHistory.shift();
    }
  }

  private buildReason(
    kellyFraction: number,
    regimeMultiplier: number,
    rawSize: number,
    finalSize: number,
    confidenceMultiplier?: number
  ): string {
    const parts: string[] = [];

    parts.push(`Kelly: ${(kellyFraction * 100).toFixed(1)}%`);
    parts.push(`Regime: ${regimeDetector.getRegimeName()} (${(regimeMultiplier * 100).toFixed(0)}%)`);

    if (confidenceMultiplier !== undefined && confidenceMultiplier !== 1.0) {
      parts.push(`Conf: ${(confidenceMultiplier * 100).toFixed(0)}%`);
    }

    if (finalSize < rawSize) {
      parts.push(`Capped from ${rawSize.toFixed(4)} SOL`);
    }

    return parts.join(', ');
  }

  // Calculate optimal size for a specific trade setup
  calculateForTrade(params: {
    entryPrice: number;
    stopLoss: number;
    takeProfit: number;
    availableCapital: number;
    confidence: number;
  }): PositionSizeResult {
    const { entryPrice, stopLoss, takeProfit, availableCapital, confidence } = params;

    // Calculate risk/reward
    const riskPercent = Math.abs((entryPrice - stopLoss) / entryPrice);
    const rewardPercent = Math.abs((takeProfit - entryPrice) / entryPrice);
    const riskRewardRatio = rewardPercent / riskPercent;

    // Adjust win probability by confidence
    const baseWinProb = 0.4;
    const adjustedWinProb = baseWinProb + (confidence - 0.5) * 0.2;

    // Calculate Kelly with trade-specific parameters
    return this.calculateSize(availableCapital, adjustedWinProb, riskRewardRatio);
  }

  // Get suggested position count based on portfolio theory
  getOptimalPositionCount(totalCapital: number): number {
    const regime = regimeDetector.getCurrentRegime().regime;

    // More concentrated in bull, more diversified in volatile/crash
    switch (regime) {
      case MarketRegime.BULL:
        return 3; // Concentrated bets
      case MarketRegime.VOLATILE:
        return 5; // Moderate diversification
      case MarketRegime.CRASH:
        return Math.min(config.maxConcurrentPositions, 2); // Very selective
      default:
        return 4;
    }
  }

  getWinRate(): number {
    if (this.winHistory.length === 0) return 0.5;
    return this.winHistory.filter(Boolean).length / this.winHistory.length;
  }

  clearHistory(): void {
    this.winHistory = [];
  }
}

export const positionSizer = new PositionSizer();
</file>

<file path="src/ai/regime-detector.ts">
import * as ss from 'simple-statistics';
import { createChildLogger } from '../utils/logger';
import { MarketRegime, RegimeState } from './types';
import { priceFeed } from '../data/price-feed';
import { SOL_MINT } from '../config/settings';

const logger = createChildLogger('regime-detector');

export class RegimeDetector {
  private state: RegimeState;
  private priceHistory: number[] = [];
  private returnHistory: number[] = [];
  private maxHistory = 1000;
  private updateInterval: NodeJS.Timeout | null = null;

  // HMM parameters (simplified 3-state model)
  private transitionMatrix: number[][] = [
    [0.9, 0.08, 0.02], // From Bull
    [0.15, 0.7, 0.15], // From Volatile
    [0.1, 0.2, 0.7],   // From Crash
  ];

  private emissionParams = {
    [MarketRegime.BULL]: { meanReturn: 0.002, stdReturn: 0.01 },
    [MarketRegime.VOLATILE]: { meanReturn: 0, stdReturn: 0.03 },
    [MarketRegime.CRASH]: { meanReturn: -0.003, stdReturn: 0.04 },
  };

  constructor() {
    this.state = {
      regime: MarketRegime.VOLATILE,
      confidence: 0.5,
      transitionProbs: this.transitionMatrix,
      history: [],
    };
  }

  async start(): Promise<void> {
    // Start periodic regime updates
    this.updateInterval = setInterval(() => {
      this.updateRegime();
    }, 60000); // Update every minute

    logger.info('Regime detector started');
  }

  stop(): void {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
    logger.info('Regime detector stopped');
  }

  private async updateRegime(): Promise<void> {
    try {
      // Get SOL price as market proxy
      const solPrice = priceFeed.getSolPrice();
      if (solPrice > 0) {
        this.addPrice(solPrice);
        this.detectRegime();
      }
    } catch (error) {
      logger.error({ error }, 'Failed to update regime');
    }
  }

  addPrice(price: number): void {
    this.priceHistory.push(price);

    if (this.priceHistory.length > 1) {
      const lastPrice = this.priceHistory[this.priceHistory.length - 2];
      const returnValue = (price - lastPrice) / lastPrice;
      this.returnHistory.push(returnValue);
    }

    // Trim histories
    if (this.priceHistory.length > this.maxHistory) {
      this.priceHistory = this.priceHistory.slice(-this.maxHistory);
      this.returnHistory = this.returnHistory.slice(-this.maxHistory);
    }
  }

  detectRegime(): MarketRegime {
    if (this.returnHistory.length < 30) {
      return this.state.regime;
    }

    // Calculate recent statistics
    const recentReturns = this.returnHistory.slice(-60);
    const meanReturn = ss.mean(recentReturns);
    const stdReturn = ss.standardDeviation(recentReturns);

    // Calculate likelihood of each regime
    const likelihoods = this.calculateLikelihoods(meanReturn, stdReturn);

    // Apply transition probabilities (forward algorithm simplified)
    const currentProbs = this.applyTransition(likelihoods);

    // Select most likely regime
    let maxProb = 0;
    let newRegime = this.state.regime;

    for (const [regime, prob] of Object.entries(currentProbs)) {
      if (prob > maxProb) {
        maxProb = prob;
        newRegime = parseInt(regime) as MarketRegime;
      }
    }

    // Update state
    const previousRegime = this.state.regime;
    this.state.regime = newRegime;
    this.state.confidence = maxProb;
    this.state.history.push(newRegime);

    if (this.state.history.length > 100) {
      this.state.history = this.state.history.slice(-100);
    }

    if (newRegime !== previousRegime) {
      logger.info(
        { from: MarketRegime[previousRegime], to: MarketRegime[newRegime], confidence: maxProb.toFixed(3) },
        'Regime changed'
      );
    }

    return newRegime;
  }

  private calculateLikelihoods(meanReturn: number, stdReturn: number): Record<MarketRegime, number> {
    const likelihoods: Record<MarketRegime, number> = {
      [MarketRegime.BULL]: 0,
      [MarketRegime.VOLATILE]: 0,
      [MarketRegime.CRASH]: 0,
    };

    for (const regime of [MarketRegime.BULL, MarketRegime.VOLATILE, MarketRegime.CRASH]) {
      const params = this.emissionParams[regime];

      // Gaussian likelihood for mean
      const meanLikelihood = this.gaussianPdf(meanReturn, params.meanReturn, params.stdReturn * 0.5);

      // Likelihood for volatility (higher vol less likely for bull)
      const volLikelihood = this.gaussianPdf(stdReturn, params.stdReturn, params.stdReturn * 0.3);

      likelihoods[regime] = meanLikelihood * volLikelihood;
    }

    // Normalize
    const total = Object.values(likelihoods).reduce((a, b) => a + b, 0);
    if (total > 0) {
      for (const regime of Object.keys(likelihoods) as unknown as MarketRegime[]) {
        likelihoods[regime] /= total;
      }
    }

    return likelihoods;
  }

  private gaussianPdf(x: number, mean: number, std: number): number {
    const exponent = -Math.pow(x - mean, 2) / (2 * Math.pow(std, 2));
    return Math.exp(exponent) / (std * Math.sqrt(2 * Math.PI));
  }

  private applyTransition(likelihoods: Record<MarketRegime, number>): Record<MarketRegime, number> {
    const currentRegime = this.state.regime;
    const transitionProbs = this.transitionMatrix[currentRegime];

    const result: Record<MarketRegime, number> = {
      [MarketRegime.BULL]: 0,
      [MarketRegime.VOLATILE]: 0,
      [MarketRegime.CRASH]: 0,
    };

    // Combine transition probability with emission likelihood
    for (const regime of [MarketRegime.BULL, MarketRegime.VOLATILE, MarketRegime.CRASH]) {
      result[regime] = transitionProbs[regime] * likelihoods[regime];
    }

    // Normalize
    const total = Object.values(result).reduce((a, b) => a + b, 0);
    if (total > 0) {
      for (const regime of Object.keys(result) as unknown as MarketRegime[]) {
        result[regime] /= total;
      }
    }

    return result;
  }

  getCurrentRegime(): RegimeState {
    return { ...this.state };
  }

  getRegimeMultiplier(regime?: MarketRegime): number {
    const r = regime ?? this.state.regime;

    switch (r) {
      case MarketRegime.BULL:
        return 1.0;
      case MarketRegime.VOLATILE:
        return 0.5;
      case MarketRegime.CRASH:
        return 0.25;
      default:
        return 0.5;
    }
  }

  getRegimeName(regime?: MarketRegime): string {
    const r = regime ?? this.state.regime;
    return MarketRegime[r] || 'UNKNOWN';
  }

  // Update transition matrix based on observed data
  updateTransitionMatrix(transitions: Array<{ from: MarketRegime; to: MarketRegime }>): void {
    if (transitions.length < 10) return;

    const counts: number[][] = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
    ];

    for (const { from, to } of transitions) {
      counts[from][to]++;
    }

    // Convert counts to probabilities with smoothing
    for (let i = 0; i < 3; i++) {
      const total = counts[i].reduce((a, b) => a + b, 0) + 3; // Add 3 for smoothing
      for (let j = 0; j < 3; j++) {
        this.transitionMatrix[i][j] = (counts[i][j] + 1) / total;
      }
    }

    this.state.transitionProbs = this.transitionMatrix;
    logger.info({ transitionMatrix: this.transitionMatrix }, 'Transition matrix updated');
  }

  getVolatility(): number {
    if (this.returnHistory.length < 10) return 0.02;
    const recent = this.returnHistory.slice(-30);
    return ss.standardDeviation(recent);
  }

  getTrend(): 'up' | 'down' | 'sideways' {
    if (this.returnHistory.length < 10) return 'sideways';

    const recent = this.returnHistory.slice(-20);
    const sum = recent.reduce((a, b) => a + b, 0);

    if (sum > 0.02) return 'up';
    if (sum < -0.02) return 'down';
    return 'sideways';
  }
}

export const regimeDetector = new RegimeDetector();
</file>

<file path="src/ai/types.ts">
export enum Action {
  HOLD = 0,
  BUY = 1,
  SELL = 2,
}

export interface Experience {
  state: number[];
  action: Action;
  reward: number;
  nextState: number[];
  done: boolean;
}

export interface DDQNConfig {
  stateSize: number;
  actionSize: number;
  hiddenSize: number;
  learningRate: number;
  gamma: number;
  epsilon: number;
  epsilonMin: number;
  epsilonDecay: number;
  replayBufferSize: number;
  batchSize: number;
  targetUpdateTau: number;
}

export enum MarketRegime {
  BULL = 0,      // 100% position sizing
  VOLATILE = 1,  // 50% position sizing
  CRASH = 2,     // 25% position sizing
}

export interface RegimeState {
  regime: MarketRegime;
  confidence: number;
  transitionProbs: number[][];
  history: MarketRegime[];
}

export interface PositionSizeResult {
  sizeSol: number;
  kellyFraction: number;
  regimeMultiplier: number;
  riskAdjustedSize: number;
  reason: string;
}

export interface AIDecision {
  action: Action;
  confidence: number;
  regime: MarketRegime;
  positionSize: PositionSizeResult;
  qValues: number[];
  features: number[];
  timestamp: Date;
}

export interface ModelMetrics {
  totalTrades: number;
  winRate: number;
  avgReturn: number;
  sharpeRatio: number;
  maxDrawdown: number;
  profitFactor: number;
  lastUpdated: Date;
}
</file>

<file path="src/data/index.ts">
export * from './types';
export * from './helius-ws';
export * from './price-feed';
export * from './whale-tracker';
export * from './pumpportal-ws';
</file>

<file path="src/data/price-feed.ts">
import { EventEmitter } from 'events';
import { config, SOL_MINT } from '../config/settings';
import { createChildLogger } from '../utils/logger';
import { PriceData, HolderInfo, LiquidityPool, TokenInfo } from './types';
import { pumpPortalWs } from './pumpportal-ws';

const logger = createChildLogger('price-feed');

interface JupiterPriceResponse {
  data: {
    [mint: string]: {
      id: string;
      mintSymbol: string;
      vsToken: string;
      vsTokenSymbol: string;
      price: number;
    };
  };
  timeTaken: number;
}

interface DexScreenerPair {
  chainId: string;
  dexId: string;
  pairAddress: string;
  baseToken: {
    address: string;
    name: string;
    symbol: string;
  };
  quoteToken?: {
    address: string;
    name: string;
    symbol: string;
  };
  priceNative: string;
  priceUsd: string;
  volume: {
    h24: number;
    h6: number;
    h1: number;
    m5: number;
  };
  priceChange: {
    m5: number;
    h1: number;
    h6: number;
    h24: number;
  };
  liquidity: {
    usd: number;
    base: number;
    quote: number;
  };
  fdv: number;
  marketCap: number;
  txns: {
    m5: { buys: number; sells: number };
    h1: { buys: number; sells: number };
    h24: { buys: number; sells: number };
  };
}

interface DexScreenerResponse {
  schemaVersion: string;
  pairs: DexScreenerPair[] | null;
}

export class PriceFeed extends EventEmitter {
  private priceCache: Map<string, PriceData> = new Map();
  private priceHistory: Map<string, PriceData[]> = new Map();
  private watchList: Set<string> = new Set();
  private updateInterval: NodeJS.Timeout | null = null;
  private solPrice: number = 0;

  constructor() {
    super();
  }

  async start(): Promise<void> {
    // Get initial SOL price
    await this.updateSolPrice();

    // Start periodic updates
    this.updateInterval = setInterval(() => {
      this.updateWatchedTokens();
    }, config.priceCheckIntervalMs);

    logger.info('Price feed started');
  }

  stop(): void {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
    logger.info('Price feed stopped');
  }

  addToWatchList(mint: string): void {
    this.watchList.add(mint);
    logger.debug({ mint }, 'Added to watch list');
    // Fetch immediately
    this.fetchTokenPrice(mint);
  }

  removeFromWatchList(mint: string): void {
    this.watchList.delete(mint);
    this.priceCache.delete(mint);
    this.priceHistory.delete(mint);
    logger.debug({ mint }, 'Removed from watch list');
  }

  getPrice(mint: string): PriceData | null {
    return this.priceCache.get(mint) || null;
  }

  getPriceHistory(mint: string, limit: number = 60): PriceData[] {
    const history = this.priceHistory.get(mint) || [];
    return history.slice(-limit);
  }

  getSolPrice(): number {
    return this.solPrice;
  }

  private async updateSolPrice(): Promise<void> {
    try {
      // Use DexScreener for SOL price (free API)
      const response = await fetch(
        `${config.dexScreenerApi}/${SOL_MINT}`
      );
      const data = await response.json() as DexScreenerResponse;

      if (data.pairs && data.pairs.length > 0) {
        // Get SOL/USDT or SOL/USDC pair price
        const usdPair = data.pairs.find(p =>
          p.quoteToken?.symbol === 'USDT' || p.quoteToken?.symbol === 'USDC'
        );
        if (usdPair) {
          this.solPrice = parseFloat(usdPair.priceUsd) || 0;
          return;
        }
      }

      // Fallback: hardcoded reasonable price if API fails
      if (this.solPrice === 0) {
        this.solPrice = 130; // Approximate SOL price as fallback
        logger.warn('Using fallback SOL price');
      }
    } catch (error) {
      logger.error({ error }, 'Failed to fetch SOL price');
      if (this.solPrice === 0) {
        this.solPrice = 130; // Fallback
      }
    }
  }

  private async updateWatchedTokens(): Promise<void> {
    // Update SOL price every 10 iterations
    if (Math.random() < 0.1) {
      await this.updateSolPrice();
    }

    // Update all watched tokens
    const promises = Array.from(this.watchList).map((mint) =>
      this.fetchTokenPrice(mint).catch((err) =>
        logger.error({ mint, error: err.message }, 'Failed to update price')
      )
    );

    await Promise.all(promises);
  }

  async fetchTokenPrice(mint: string): Promise<PriceData | null> {
    try {
      // For Pump.fun tokens, try PumpPortal first (bonding curve tokens aren't on DEX)
      if (mint.endsWith('pump')) {
        const pumpData = this.fetchFromPumpPortal(mint);
        if (pumpData) {
          this.updateCache(mint, pumpData);
          return pumpData;
        }
      }

      // Use DexScreener for price data (free API)
      const dexData = await this.fetchFromDexScreener(mint);
      if (dexData) {
        this.updateCache(mint, dexData);
        return dexData;
      }

      return null;
    } catch (error) {
      logger.error({ mint, error }, 'Failed to fetch token price');
      return null;
    }
  }

  private fetchFromPumpPortal(mint: string): PriceData | null {
    const bondingCurve = pumpPortalWs.getBondingCurveData(mint);
    if (!bondingCurve) {
      return null;
    }

    const prevData = this.priceCache.get(mint);
    const history = this.priceHistory.get(mint) || [];

    // Calculate price changes from history
    const price1mAgo = history.length >= 6 ? history[history.length - 6]?.priceSol : bondingCurve.priceSol;
    const price5mAgo = history.length >= 30 ? history[history.length - 30]?.priceSol : bondingCurve.priceSol;

    const priceData: PriceData = {
      mint,
      priceUsd: bondingCurve.priceSol * this.solPrice,
      priceSol: bondingCurve.priceSol,
      volume24h: 0, // Not available from bonding curve
      marketCapSol: bondingCurve.marketCapSol,
      liquidity: bondingCurve.liquiditySol * this.solPrice,
      priceChange1m: price1mAgo > 0 ? ((bondingCurve.priceSol - price1mAgo) / price1mAgo) * 100 : 0,
      priceChange5m: price5mAgo > 0 ? ((bondingCurve.priceSol - price5mAgo) / price5mAgo) * 100 : 0,
      priceChange1h: 0, // Not available
      timestamp: bondingCurve.timestamp,
    };

    return priceData;
  }

  private async fetchFromDexScreener(mint: string): Promise<PriceData | null> {
    try {
      const response = await fetch(`${config.dexScreenerApi}/${mint}`);
      const data = await response.json() as DexScreenerResponse;

      if (!data.pairs || data.pairs.length === 0) {
        return null;
      }

      // Get the pair with highest liquidity
      const pair = data.pairs.reduce((best, current) =>
        (current.liquidity?.usd || 0) > (best.liquidity?.usd || 0) ? current : best
      );

      const priceSol = parseFloat(pair.priceNative) || 0;
      const priceUsd = parseFloat(pair.priceUsd) || priceSol * this.solPrice;

      const prevData = this.priceCache.get(mint);
      const history = this.priceHistory.get(mint) || [];

      // Calculate price changes
      const price1mAgo = history.length >= 6 ? history[history.length - 6]?.priceSol : priceSol;
      const price5mAgo = history.length >= 30 ? history[history.length - 30]?.priceSol : priceSol;

      const priceData: PriceData = {
        mint,
        priceUsd,
        priceSol,
        volume24h: pair.volume?.h24 || 0,
        marketCapSol: pair.fdv ? pair.fdv / this.solPrice : 0,
        liquidity: pair.liquidity?.usd || 0,
        priceChange1m: price1mAgo > 0 ? ((priceSol - price1mAgo) / price1mAgo) * 100 : 0,
        priceChange5m: price5mAgo > 0 ? ((priceSol - price5mAgo) / price5mAgo) * 100 : 0,
        priceChange1h: pair.priceChange?.h1 || 0,
        timestamp: new Date(),
      };

      return priceData;
    } catch (error) {
      logger.debug({ mint, error }, 'DexScreener fetch failed');
      return null;
    }
  }

  private updateCache(mint: string, data: PriceData): void {
    const prevPrice = this.priceCache.get(mint);
    this.priceCache.set(mint, data);

    // Update history
    let history = this.priceHistory.get(mint) || [];
    history.push(data);

    // Keep last 5 minutes of data at 1-second intervals (300 entries)
    if (history.length > 300) {
      history = history.slice(-300);
    }
    this.priceHistory.set(mint, history);

    // Emit price update event
    this.emit('priceUpdate', data);

    // Emit significant price change events
    if (prevPrice) {
      const change = ((data.priceSol - prevPrice.priceSol) / prevPrice.priceSol) * 100;
      if (Math.abs(change) >= 5) {
        this.emit('significantPriceChange', { mint, change, data });
      }
    }
  }

  async getHolderInfo(mint: string): Promise<HolderInfo | null> {
    try {
      // This would typically use Helius or another provider
      // For now, return mock structure
      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getTokenLargestAccounts',
            params: [mint],
          }),
        }
      );

      const data = await response.json() as any;

      if (!data.result?.value) {
        return null;
      }

      const holders = data.result.value;
      const totalSupply = holders.reduce(
        (sum: number, h: { amount: string }) => sum + parseFloat(h.amount),
        0
      );

      const top10 = holders.slice(0, 10);
      const top10Supply = top10.reduce(
        (sum: number, h: { amount: string }) => sum + parseFloat(h.amount),
        0
      );

      return {
        mint,
        totalHolders: holders.length,
        top10Concentration: totalSupply > 0 ? top10Supply / totalSupply : 1,
        top10Holders: top10.map((h: { address: string; amount: string }) => ({
          address: h.address,
          balance: parseFloat(h.amount),
          percentage: totalSupply > 0 ? parseFloat(h.amount) / totalSupply : 0,
        })),
      };
    } catch (error) {
      logger.error({ mint, error }, 'Failed to get holder info');
      return null;
    }
  }

  async getTokenInfo(mint: string): Promise<TokenInfo | null> {
    try {
      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getAsset',
            params: { id: mint },
          }),
        }
      );

      const data = await response.json() as any;

      if (!data.result) {
        return null;
      }

      const asset = data.result;

      return {
        mint,
        name: asset.content?.metadata?.name || '',
        symbol: asset.content?.metadata?.symbol || '',
        decimals: asset.token_info?.decimals || 9,
        supply: asset.token_info?.supply || 0,
        createdAt: new Date(),
        creator: asset.authorities?.[0]?.address || '',
        mintAuthorityRevoked: !asset.authorities?.some(
          (a: { scopes: string[] }) => a.scopes?.includes('mint')
        ),
        freezeAuthorityRevoked: !asset.authorities?.some(
          (a: { scopes: string[] }) => a.scopes?.includes('freeze')
        ),
      };
    } catch (error) {
      logger.error({ mint, error }, 'Failed to get token info');
      return null;
    }
  }
}

export const priceFeed = new PriceFeed();
</file>

<file path="src/data/pumpportal-ws.ts">
import WebSocket from 'ws';
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';

const logger = createChildLogger('pumpportal-ws');

const PUMPPORTAL_WS_URL = 'wss://pumpportal.fun/api/data';

// Response from subscribeNewToken
export interface PumpPortalNewToken {
  mint: string;
  bondingCurveKey: string;
  traderPublicKey: string;
  marketCapSol: number;
  vSolInBondingCurve: number;
  vTokensInBondingCurve: number;
  initialBuy: number;
  signature: string;
  txType: 'create';
}

// Response from subscribeTokenTrade
export interface PumpPortalTrade {
  mint: string;
  bondingCurveKey: string;
  traderPublicKey: string;
  marketCapSol: number;
  vSolInBondingCurve: number;
  vTokensInBondingCurve: number;
  tokenAmount: number;
  newTokenBalance: number;
  signature: string;
  txType: 'buy' | 'sell';
}

// Calculated bonding curve data
export interface BondingCurveData {
  mint: string;
  marketCapSol: number;
  vSolInBondingCurve: number;
  vTokensInBondingCurve: number;
  priceSol: number;
  liquiditySol: number;
  bondingCurveKey: string;
  isGraduated: boolean;
  timestamp: Date;
}

export class PumpPortalWs extends EventEmitter {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 10;
  private reconnectDelay = 5000;
  private isConnected = false;
  private subscribedTokens: Set<string> = new Set();

  // Cache for bonding curve data
  private bondingCurveCache: Map<string, BondingCurveData> = new Map();
  private cacheExpiry = 120000; // 2 minutes instead of 30 seconds

  constructor() {
    super();
  }

  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        logger.info({ url: PUMPPORTAL_WS_URL }, 'Connecting to PumpPortal WebSocket');

        this.ws = new WebSocket(PUMPPORTAL_WS_URL);

        this.ws.on('open', () => {
          logger.info('PumpPortal WebSocket connected');
          this.isConnected = true;
          this.reconnectAttempts = 0;

          // Subscribe to new token events
          this.subscribeNewTokens();

          resolve();
        });

        this.ws.on('message', (data: WebSocket.Data) => {
          this.handleMessage(data);
        });

        this.ws.on('error', (error) => {
          logger.error({ error }, 'PumpPortal WebSocket error');
          if (!this.isConnected) {
            reject(error);
          }
        });

        this.ws.on('close', () => {
          logger.warn('PumpPortal WebSocket disconnected');
          this.isConnected = false;
          this.handleReconnect();
        });

      } catch (error) {
        logger.error({ error }, 'Failed to connect to PumpPortal');
        reject(error);
      }
    });
  }

  private subscribeNewTokens(): void {
    if (!this.ws || !this.isConnected) return;

    const payload = { method: 'subscribeNewToken' };
    this.ws.send(JSON.stringify(payload));
    logger.info('Subscribed to PumpPortal new token events');
  }

  subscribeToToken(mint: string): void {
    if (!this.ws || !this.isConnected) return;
    if (this.subscribedTokens.has(mint)) return;

    const payload = {
      method: 'subscribeTokenTrade',
      keys: [mint]
    };
    this.ws.send(JSON.stringify(payload));
    this.subscribedTokens.add(mint);
    logger.debug({ mint }, 'Subscribed to token trades');
  }

  unsubscribeFromToken(mint: string): void {
    if (!this.ws || !this.isConnected) return;
    if (!this.subscribedTokens.has(mint)) return;

    const payload = {
      method: 'unsubscribeTokenTrade',
      keys: [mint]
    };
    this.ws.send(JSON.stringify(payload));
    this.subscribedTokens.delete(mint);
    this.bondingCurveCache.delete(mint);
    logger.debug({ mint }, 'Unsubscribed from token trades');
  }

  private handleMessage(data: WebSocket.Data): void {
    try {
      const message = JSON.parse(data.toString());

      // Handle new token creation
      if (message.txType === 'create') {
        const tokenData = message as PumpPortalNewToken;
        const curveData = this.processBondingCurveData(tokenData);

        logger.info({
          mint: tokenData.mint.substring(0, 15),
          marketCapSol: curveData.marketCapSol.toFixed(2),
          liquiditySol: curveData.liquiditySol.toFixed(4),
          priceSol: curveData.priceSol.toExponential(4),
        }, 'PumpPortal: New token detected');

        this.emit('newToken', curveData);
      }

      // Handle trades (buy/sell)
      if (message.txType === 'buy' || message.txType === 'sell') {
        const tradeData = message as PumpPortalTrade;
        const curveData = this.processBondingCurveData(tradeData);

        // Update cache
        this.bondingCurveCache.set(tradeData.mint, curveData);

        this.emit('trade', {
          ...curveData,
          txType: tradeData.txType,
          tokenAmount: tradeData.tokenAmount,
          traderPublicKey: tradeData.traderPublicKey,
        });
      }

    } catch (error) {
      logger.error({ error, data: data.toString().substring(0, 200) }, 'Failed to parse PumpPortal message');
    }
  }

  private processBondingCurveData(data: PumpPortalNewToken | PumpPortalTrade): BondingCurveData {
    // Calculate price from virtual reserves
    // price = (vSol / 1e9) / (vTokens / 1e6)
    const vSol = data.vSolInBondingCurve;
    const vTokens = data.vTokensInBondingCurve;

    // Price in SOL per token
    const priceSol = vTokens > 0 ? (vSol / 1e9) / (vTokens / 1e6) : 0;

    // Liquidity is the SOL in the bonding curve
    // For new tokens, this starts around 30 SOL (virtual) + real SOL from buys
    const liquiditySol = vSol / 1e9;

    // Token graduates when bonding curve fills (~$69k mcap, ~400 SOL)
    // vSolInBondingCurve reaches ~85 SOL real + virtual when graduated
    const isGraduated = liquiditySol > 80;

    const curveData: BondingCurveData = {
      mint: data.mint,
      marketCapSol: data.marketCapSol,
      vSolInBondingCurve: vSol,
      vTokensInBondingCurve: vTokens,
      priceSol,
      liquiditySol,
      bondingCurveKey: data.bondingCurveKey,
      isGraduated,
      timestamp: new Date(),
    };

    // Cache the data
    this.bondingCurveCache.set(data.mint, curveData);

    return curveData;
  }

  // Get cached bonding curve data for a token
  getBondingCurveData(mint: string): BondingCurveData | null {
    const cached = this.bondingCurveCache.get(mint);
    if (!cached) return null;

    // Check if cache is expired
    const age = Date.now() - cached.timestamp.getTime();
    if (age > this.cacheExpiry) {
      this.bondingCurveCache.delete(mint);
      return null;
    }

    return cached;
  }

  // Check if we have recent data for a token
  hasRecentData(mint: string): boolean {
    return this.getBondingCurveData(mint) !== null;
  }

  private handleReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      logger.error('Max reconnect attempts reached for PumpPortal');
      return;
    }

    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

    logger.info({ attempt: this.reconnectAttempts, delay }, 'Reconnecting to PumpPortal...');

    setTimeout(() => {
      this.connect().catch((error) => {
        logger.error({ error }, 'Reconnect failed');
      });
    }, delay);
  }

  async disconnect(): Promise<void> {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.isConnected = false;
    this.subscribedTokens.clear();
    this.bondingCurveCache.clear();
    logger.info('PumpPortal WebSocket disconnected');
  }

  getStatus(): string {
    return `PumpPortal: ${this.isConnected ? 'Connected' : 'Disconnected'}, ` +
           `Subscribed tokens: ${this.subscribedTokens.size}, ` +
           `Cached: ${this.bondingCurveCache.size}`;
  }
}

export const pumpPortalWs = new PumpPortalWs();
</file>

<file path="src/data/whale-tracker.ts">
import { EventEmitter } from 'events';
import { config, LAMPORTS_PER_SOL } from '../config/settings';
import { createChildLogger } from '../utils/logger';
import { WhaleActivity } from './types';
import { repository } from '../db/repository';

const logger = createChildLogger('whale-tracker');

interface SignatureInfo {
  signature: string;
  slot: number;
  err: null | object;
  memo: string | null;
  blockTime: number | null;
}

interface ParsedTransaction {
  signature: string;
  slot: number;
  blockTime: number;
  meta: {
    preBalances: number[];
    postBalances: number[];
    preTokenBalances: Array<{
      accountIndex: number;
      mint: string;
      owner: string;
      uiTokenAmount: { amount: string; decimals: number; uiAmount: number };
    }>;
    postTokenBalances: Array<{
      accountIndex: number;
      mint: string;
      owner: string;
      uiTokenAmount: { amount: string; decimals: number; uiAmount: number };
    }>;
    err: null | object;
  };
  transaction: {
    message: {
      accountKeys: Array<{ pubkey: string; signer: boolean; writable: boolean }>;
    };
  };
}

const KNOWN_WHALES: { address: string; label: string }[] = [
  // Add known whale addresses here
  // These would be discovered through on-chain analysis
];

export class WhaleTracker extends EventEmitter {
  private trackedWallets: Map<string, string> = new Map(); // address -> label
  private lastSignatures: Map<string, string> = new Map(); // address -> last signature
  private pollInterval: NodeJS.Timeout | null = null;
  private minTransactionSol = 10; // Minimum SOL value to track

  constructor() {
    super();
  }

  async start(): Promise<void> {
    // Load known whales from config/env
    if (process.env.COPY_TRADE_WALLETS) {
      const envWallets = process.env.COPY_TRADE_WALLETS.split(',').map(w => w.trim()).filter(w => w.length > 0);
      for (const wallet of envWallets) {
        if (!this.trackedWallets.has(wallet)) {
          this.addWhale(wallet, 'Env Configured');
        }
      }
      logger.info({ count: envWallets.length }, 'Loaded wallets from environment');
    }

    // Load known whales from constant
    for (const whale of KNOWN_WHALES) {
      this.trackedWallets.set(whale.address, whale.label);
      await repository.upsertWhaleWallet(whale.address, whale.label);
    }

    // Start polling
    this.pollInterval = setInterval(() => {
      this.pollWhaleActivity();
    }, 10000); // Poll every 10 seconds

    logger.info({ whaleCount: this.trackedWallets.size }, 'Whale tracker started');
  }

  stop(): void {
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = null;
    }
    logger.info('Whale tracker stopped');
  }

  addWhale(address: string, label?: string): void {
    this.trackedWallets.set(address, label || 'Unknown');
    repository.upsertWhaleWallet(address, label);
    logger.info({ address, label }, 'Added whale to tracking');
  }

  removeWhale(address: string): void {
    this.trackedWallets.delete(address);
    this.lastSignatures.delete(address);
    logger.info({ address }, 'Removed whale from tracking');
  }

  private async pollWhaleActivity(): Promise<void> {
    const promises = Array.from(this.trackedWallets.entries()).map(([address, label]) =>
      this.checkWalletActivity(address, label).catch((err) =>
        logger.error({ address, error: err.message }, 'Failed to check whale activity')
      )
    );

    await Promise.all(promises);
  }

  private async checkWalletActivity(address: string, label: string): Promise<void> {
    try {
      const lastSig = this.lastSignatures.get(address);

      // Get recent signatures
      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getSignaturesForAddress',
            params: [
              address,
              { limit: 20, until: lastSig },
            ],
          }),
        }
      );

      const data = await response.json() as any;
      const signatures: SignatureInfo[] = data.result || [];

      if (signatures.length === 0) return;

      // Update last signature
      this.lastSignatures.set(address, signatures[0].signature);

      // Process new transactions
      for (const sig of signatures) {
        if (sig.err) continue; // Skip failed transactions

        await this.processTransaction(address, label, sig.signature);
      }
    } catch (error) {
      logger.error({ address, error }, 'Failed to check wallet activity');
    }
  }

  private async processTransaction(
    walletAddress: string,
    label: string,
    signature: string
  ): Promise<void> {
    try {
      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getTransaction',
            params: [
              signature,
              { encoding: 'jsonParsed', maxSupportedTransactionVersion: 0 },
            ],
          }),
        }
      );

      const data = await response.json() as any;
      const tx: ParsedTransaction = data.result;

      if (!tx || !tx.meta) return;

      // Calculate SOL transfer
      const accountKeys = tx.transaction.message.accountKeys;
      const walletIndex = accountKeys.findIndex((k) => k.pubkey === walletAddress);

      if (walletIndex === -1) return;

      const preSol = tx.meta.preBalances[walletIndex] / LAMPORTS_PER_SOL;
      const postSol = tx.meta.postBalances[walletIndex] / LAMPORTS_PER_SOL;
      const solChange = postSol - preSol;

      // Check token transfers
      const preTokens = tx.meta.preTokenBalances?.filter(
        (t) => t.owner === walletAddress
      ) || [];
      const postTokens = tx.meta.postTokenBalances?.filter(
        (t) => t.owner === walletAddress
      ) || [];

      // Find token changes
      const tokenChanges: Map<string, { pre: number; post: number }> = new Map();

      for (const token of preTokens) {
        tokenChanges.set(token.mint, {
          pre: token.uiTokenAmount.uiAmount || 0,
          post: 0,
        });
      }

      for (const token of postTokens) {
        const existing = tokenChanges.get(token.mint);
        if (existing) {
          existing.post = token.uiTokenAmount.uiAmount || 0;
        } else {
          tokenChanges.set(token.mint, {
            pre: 0,
            post: token.uiTokenAmount.uiAmount || 0,
          });
        }
      }

      // Process significant token changes
      for (const [mint, change] of tokenChanges.entries()) {
        const tokenChange = change.post - change.pre;

        if (tokenChange === 0) continue;

        // Skip if SOL change is too small
        if (Math.abs(solChange) < this.minTransactionSol) continue;

        const action: 'buy' | 'sell' = tokenChange > 0 ? 'buy' : 'sell';

        const activity: WhaleActivity = {
          wallet: walletAddress,
          action,
          mint,
          amount: Math.abs(tokenChange),
          amountSol: Math.abs(solChange),
          timestamp: new Date(tx.blockTime! * 1000),
        };

        logger.info(
          { wallet: label, action, mint, amountSol: activity.amountSol },
          'Whale activity detected'
        );

        // Log to database
        await repository.logWhaleActivity({
          wallet: walletAddress,
          action,
          mint,
          amount: activity.amount,
          amount_sol: activity.amountSol,
          signature,
        });

        // Emit event
        this.emit('whaleActivity', activity);
      }
    } catch (error) {
      logger.error({ signature, error }, 'Failed to process transaction');
    }
  }

  async discoverWhales(mint: string, minSolVolume: number = 50): Promise<string[]> {
    try {
      // Get recent large transactions for a token
      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getSignaturesForAddress',
            params: [mint, { limit: 100 }],
          }),
        }
      );

      const data = await response.json() as any;
      const signatures: SignatureInfo[] = data.result || [];

      const discoveredWhales: Set<string> = new Set();

      for (const sig of signatures.slice(0, 20)) {
        // Limit processing
        if (sig.err) continue;

        // Get transaction details and extract large traders
        // This is simplified - real implementation would analyze more deeply
        const txResponse = await fetch(
          `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 1,
              method: 'getTransaction',
              params: [
                sig.signature,
                { encoding: 'jsonParsed', maxSupportedTransactionVersion: 0 },
              ],
            }),
          }
        );

        const txData = await txResponse.json() as any;
        const tx: ParsedTransaction = txData.result;

        if (!tx?.meta) continue;

        // Find signers with large SOL changes
        for (let i = 0; i < tx.meta.preBalances.length; i++) {
          const solChange =
            Math.abs(tx.meta.postBalances[i] - tx.meta.preBalances[i]) / LAMPORTS_PER_SOL;

          if (solChange >= minSolVolume) {
            const address = tx.transaction.message.accountKeys[i].pubkey;
            discoveredWhales.add(address);
          }
        }
      }

      const whaleList = Array.from(discoveredWhales);
      logger.info({ mint, count: whaleList.length }, 'Discovered potential whales');

      return whaleList;
    } catch (error) {
      logger.error({ mint, error }, 'Failed to discover whales');
      return [];
    }
  }
}

export const whaleTracker = new WhaleTracker();
</file>

<file path="src/execution/index.ts">
export * from './types';
export * from './jupiter-swap';
export * from './jito-bundle';
export * from './tx-manager';
</file>

<file path="src/execution/jito-bundle.ts">
import {
  Connection,
  Keypair,
  PublicKey,
  VersionedTransaction,
  TransactionMessage,
  SystemProgram,
} from '@solana/web3.js';
import bs58 from 'bs58';
import { createChildLogger } from '../utils/logger';
import { config, LAMPORTS_PER_SOL } from '../config/settings';
import { JitoBundleResult } from './types';

const logger = createChildLogger('jito-bundle');

interface JitoTipAccount {
  address: string;
}

export class JitoBundle {
  private connection: Connection;
  private wallet: Keypair | null = null;
  private tipAccounts: string[] = [];

  constructor() {
    this.connection = new Connection(config.solanaRpcUrl, 'confirmed');
  }

  async initialize(): Promise<void> {
    if (config.privateKey) {
      try {
        const secretKey = bs58.decode(config.privateKey);
        this.wallet = Keypair.fromSecretKey(secretKey);
      } catch (error) {
        logger.error({ error }, 'Failed to initialize wallet');
      }
    }

    // Fetch tip accounts
    await this.fetchTipAccounts();
  }

  private async fetchTipAccounts(): Promise<void> {
    try {
      const response = await fetch(`${config.jitoBundleApi}/tip_accounts`);

      if (!response.ok) {
        throw new Error(`Failed to fetch tip accounts: ${response.status}`);
      }

      const data = await response.json() as string[];
      this.tipAccounts = data;

      logger.info({ count: this.tipAccounts.length }, 'Tip accounts loaded');
    } catch (error) {
      logger.error({ error }, 'Failed to fetch tip accounts');
      // Fallback tip accounts
      this.tipAccounts = [
        '96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5',
        'HFqU5x63VTqvQss8hp11i4bVmkdzGR3EXvgWyqD7njDr',
        'Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY',
        'ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49',
        'DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh',
      ];
    }
  }

  getRandomTipAccount(): string {
    const index = Math.floor(Math.random() * this.tipAccounts.length);
    return this.tipAccounts[index];
  }

  async createTipTransaction(tipLamports: number): Promise<VersionedTransaction | null> {
    if (!this.wallet) {
      logger.error('Wallet not initialized');
      return null;
    }

    try {
      const tipAccount = this.getRandomTipAccount();
      const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash();

      const tipInstruction = SystemProgram.transfer({
        fromPubkey: this.wallet.publicKey,
        toPubkey: new PublicKey(tipAccount),
        lamports: tipLamports,
      });

      const messageV0 = new TransactionMessage({
        payerKey: this.wallet.publicKey,
        recentBlockhash: blockhash,
        instructions: [tipInstruction],
      }).compileToV0Message();

      const transaction = new VersionedTransaction(messageV0);
      transaction.sign([this.wallet]);

      return transaction;
    } catch (error) {
      logger.error({ error }, 'Failed to create tip transaction');
      return null;
    }
  }

  async sendBundle(transactions: VersionedTransaction[]): Promise<JitoBundleResult> {
    if (!config.enableJito) {
      return {
        success: false,
        signatures: [],
        tipAmount: 0,
        error: 'Jito disabled',
      };
    }

    try {
      // Create tip transaction
      const tipTx = await this.createTipTransaction(config.jitoTipLamports);

      if (!tipTx) {
        return {
          success: false,
          signatures: [],
          tipAmount: config.jitoTipLamports,
          error: 'Failed to create tip transaction',
        };
      }

      // Add tip transaction to bundle
      const bundleTxs = [...transactions, tipTx];

      // Serialize transactions
      const encodedTransactions = bundleTxs.map((tx) =>
        bs58.encode(tx.serialize())
      );

      // Send bundle
      const response = await fetch(config.jitoBundleApi, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 1,
          method: 'sendBundle',
          params: [encodedTransactions],
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        logger.error({ status: response.status, error: errorText }, 'Bundle submission failed');
        return {
          success: false,
          signatures: [],
          tipAmount: config.jitoTipLamports,
          error: `Bundle submission failed: ${response.status}`,
        };
      }

      const data = await response.json() as any;

      if (data.error) {
        return {
          success: false,
          signatures: [],
          tipAmount: config.jitoTipLamports,
          error: data.error.message,
        };
      }

      const bundleId = data.result;

      logger.info({ bundleId }, 'Bundle submitted');

      // Poll for bundle status
      const result = await this.pollBundleStatus(bundleId);

      return {
        ...result,
        tipAmount: config.jitoTipLamports,
      };
    } catch (error: any) {
      logger.error({ error: error.message }, 'Bundle execution failed');
      return {
        success: false,
        signatures: [],
        tipAmount: config.jitoTipLamports,
        error: error.message,
      };
    }
  }

  private async pollBundleStatus(bundleId: string): Promise<JitoBundleResult> {
    const maxAttempts = 30;
    const pollInterval = 500;

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const response = await fetch(config.jitoBundleApi, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getBundleStatuses',
            params: [[bundleId]],
          }),
        });

        const data = await response.json() as any;

        if (data.result?.value?.[0]) {
          const status = data.result.value[0];

          if (status.confirmation_status === 'finalized' || status.confirmation_status === 'confirmed') {
            logger.info({ bundleId, status: status.confirmation_status, slot: status.slot }, 'Bundle landed');

            return {
              success: true,
              bundleId,
              signatures: status.transactions || [],
              tipAmount: config.jitoTipLamports,
              landedSlot: status.slot,
            };
          }

          if (status.err) {
            return {
              success: false,
              bundleId,
              signatures: [],
              tipAmount: config.jitoTipLamports,
              error: `Bundle failed: ${JSON.stringify(status.err)}`,
            };
          }
        }

        await new Promise((resolve) => setTimeout(resolve, pollInterval));
      } catch (error) {
        logger.debug({ bundleId, attempt, error }, 'Poll attempt failed');
      }
    }

    return {
      success: false,
      bundleId,
      signatures: [],
      tipAmount: config.jitoTipLamports,
      error: 'Bundle status poll timeout',
    };
  }

  async getBundleStatus(bundleId: string): Promise<any> {
    try {
      const response = await fetch(config.jitoBundleApi, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 1,
          method: 'getBundleStatuses',
          params: [[bundleId]],
        }),
      });

      const data = await response.json() as any;
      return data.result?.value?.[0] || null;
    } catch (error) {
      logger.error({ bundleId, error }, 'Failed to get bundle status');
      return null;
    }
  }

  isEnabled(): boolean {
    return config.enableJito && this.tipAccounts.length > 0;
  }

  getRecommendedTip(): number {
    // Could be dynamic based on network conditions
    return config.jitoTipLamports;
  }
}

export const jitoBundle = new JitoBundle();
</file>

<file path="src/execution/jupiter-swap.ts">
import {
  Connection,
  PublicKey,
  VersionedTransaction,
  Keypair,
} from '@solana/web3.js';
import bs58 from 'bs58';
import { createChildLogger } from '../utils/logger';
import { config, SOL_MINT, LAMPORTS_PER_SOL } from '../config/settings';
import { SwapQuote, SwapResult, SwapFees } from './types';

const logger = createChildLogger('jupiter-swap');

interface JupiterQuoteResponse {
  inputMint: string;
  inAmount: string;
  outputMint: string;
  outAmount: string;
  priceImpactPct: string;
  routePlan: Array<{
    swapInfo: {
      ammKey: string;
      label: string;
      inputMint: string;
      outputMint: string;
      inAmount: string;
      outAmount: string;
      feeAmount: string;
      feeMint: string;
    };
    percent: number;
  }>;
  contextSlot: number;
  timeTaken: number;
}

interface JupiterSwapResponse {
  swapTransaction: string;
  lastValidBlockHeight: number;
  prioritizationFeeLamports: number;
}

export class JupiterSwap {
  private connection: Connection;
  private wallet: Keypair | null = null;

  constructor() {
    this.connection = new Connection(config.solanaRpcUrl, 'confirmed');
  }

  initialize(): void {
    if (config.privateKey) {
      try {
        const secretKey = bs58.decode(config.privateKey);
        this.wallet = Keypair.fromSecretKey(secretKey);
        logger.info({ publicKey: this.wallet.publicKey.toBase58() }, 'Wallet initialized');
      } catch (error) {
        logger.error({ error }, 'Failed to initialize wallet');
      }
    }
  }

  async getQuote(
    inputMint: string,
    outputMint: string,
    amountLamports: number,
    slippageBps: number = 50
  ): Promise<SwapQuote | null> {
    try {
      const url = new URL(config.jupiterQuoteApi);
      url.searchParams.set('inputMint', inputMint);
      url.searchParams.set('outputMint', outputMint);
      url.searchParams.set('amount', amountLamports.toString());
      url.searchParams.set('slippageBps', slippageBps.toString());

      const response = await fetch(url.toString());

      if (!response.ok) {
        logger.error({ status: response.status }, 'Jupiter quote failed');
        return null;
      }

      const data = await response.json() as JupiterQuoteResponse;

      const quote: SwapQuote = {
        inputMint: data.inputMint,
        outputMint: data.outputMint,
        inputAmount: parseInt(data.inAmount),
        outputAmount: parseInt(data.outAmount),
        priceImpact: parseFloat(data.priceImpactPct),
        slippageBps,
        route: data.routePlan.map((r) => ({
          dex: r.swapInfo.label,
          poolAddress: r.swapInfo.ammKey,
          inputMint: r.swapInfo.inputMint,
          outputMint: r.swapInfo.outputMint,
          inputAmount: parseInt(r.swapInfo.inAmount),
          outputAmount: parseInt(r.swapInfo.outAmount),
        })),
        fees: {
          platformFee: 0,
          networkFee: 5000, // Estimate
          priorityFee: 0,
          totalFee: 5000,
        },
      };

      logger.debug({
        inputMint,
        outputMint,
        inputAmount: amountLamports / LAMPORTS_PER_SOL,
        outputAmount: quote.outputAmount,
        priceImpact: quote.priceImpact,
      }, 'Quote received');

      return quote;
    } catch (error) {
      logger.error({ error, inputMint, outputMint }, 'Failed to get quote');
      return null;
    }
  }

  async executeSwap(
    inputMint: string,
    outputMint: string,
    amountLamports: number,
    slippageBps: number = 50
  ): Promise<SwapResult> {
    if (!this.wallet) {
      return {
        success: false,
        inputAmount: amountLamports,
        outputAmount: 0,
        priceImpact: 0,
        fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
        error: 'Wallet not initialized',
        timestamp: new Date(),
      };
    }

    // Check for paper trading mode
    if (config.paperTrading) {
      return this.simulateSwap(inputMint, outputMint, amountLamports, slippageBps);
    }

    try {
      // Get quote first
      const quote = await this.getQuote(inputMint, outputMint, amountLamports, slippageBps);

      if (!quote) {
        return {
          success: false,
          inputAmount: amountLamports,
          outputAmount: 0,
          priceImpact: 0,
          fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
          error: 'Failed to get quote',
          timestamp: new Date(),
        };
      }

      // Get swap transaction
      const swapResponse = await fetch(config.jupiterSwapApi, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          quoteResponse: quote,
          userPublicKey: this.wallet.publicKey.toBase58(),
          wrapAndUnwrapSol: true,
          dynamicComputeUnitLimit: true,
          prioritizationFeeLamports: 'auto',
        }),
      });

      if (!swapResponse.ok) {
        const errorText = await swapResponse.text();
        logger.error({ status: swapResponse.status, error: errorText }, 'Swap request failed');
        return {
          success: false,
          inputAmount: amountLamports,
          outputAmount: 0,
          priceImpact: quote.priceImpact,
          fees: quote.fees,
          error: `Swap request failed: ${swapResponse.status}`,
          timestamp: new Date(),
        };
      }

      const swapData = await swapResponse.json() as JupiterSwapResponse;

      // Deserialize and sign transaction
      const swapTransactionBuf = Buffer.from(swapData.swapTransaction, 'base64');
      const transaction = VersionedTransaction.deserialize(swapTransactionBuf);

      transaction.sign([this.wallet]);

      // Send transaction
      const signature = await this.connection.sendRawTransaction(
        transaction.serialize(),
        {
          skipPreflight: true,
          maxRetries: 3,
        }
      );

      logger.info({ signature }, 'Swap transaction sent');

      // Confirm transaction
      const confirmation = await this.connection.confirmTransaction(
        {
          signature,
          blockhash: transaction.message.recentBlockhash,
          lastValidBlockHeight: swapData.lastValidBlockHeight,
        },
        'confirmed'
      );

      if (confirmation.value.err) {
        return {
          success: false,
          signature,
          inputAmount: amountLamports,
          outputAmount: 0,
          priceImpact: quote.priceImpact,
          fees: quote.fees,
          error: `Transaction failed: ${JSON.stringify(confirmation.value.err)}`,
          timestamp: new Date(),
        };
      }

      logger.info(
        { signature, inputAmount: amountLamports / LAMPORTS_PER_SOL, outputAmount: quote.outputAmount },
        'Swap successful'
      );

      return {
        success: true,
        signature,
        inputAmount: amountLamports,
        outputAmount: quote.outputAmount,
        priceImpact: quote.priceImpact,
        fees: {
          ...quote.fees,
          priorityFee: swapData.prioritizationFeeLamports,
          totalFee: quote.fees.networkFee + swapData.prioritizationFeeLamports,
        },
        timestamp: new Date(),
      };
    } catch (error: any) {
      logger.error({ error: error.message }, 'Swap execution failed');
      return {
        success: false,
        inputAmount: amountLamports,
        outputAmount: 0,
        priceImpact: 0,
        fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
        error: error.message,
        timestamp: new Date(),
      };
    }
  }

  private async simulateSwap(
    inputMint: string,
    outputMint: string,
    amountLamports: number,
    slippageBps: number
  ): Promise<SwapResult> {
    // Get quote for realistic simulation
    const quote = await this.getQuote(inputMint, outputMint, amountLamports, slippageBps);

    if (!quote) {
      return {
        success: false,
        inputAmount: amountLamports,
        outputAmount: 0,
        priceImpact: 0,
        fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
        error: 'Failed to get quote for simulation',
        timestamp: new Date(),
      };
    }

    // Simulate slippage
    const slippageMultiplier = 1 - (Math.random() * slippageBps / 10000);
    const simulatedOutput = Math.floor(quote.outputAmount * slippageMultiplier);

    logger.info(
      {
        mode: 'PAPER',
        inputMint,
        outputMint,
        inputAmount: amountLamports / LAMPORTS_PER_SOL,
        outputAmount: simulatedOutput,
      },
      'Paper trade executed'
    );

    return {
      success: true,
      signature: `PAPER_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      inputAmount: amountLamports,
      outputAmount: simulatedOutput,
      priceImpact: quote.priceImpact,
      fees: quote.fees,
      timestamp: new Date(),
    };
  }

  async buy(
    tokenMint: string,
    amountSol: number,
    slippageBps: number = 100
  ): Promise<SwapResult> {
    const amountLamports = Math.floor(amountSol * LAMPORTS_PER_SOL);
    return this.executeSwap(SOL_MINT, tokenMint, amountLamports, slippageBps);
  }

  async sell(
    tokenMint: string,
    amountTokens: number,
    decimals: number,
    slippageBps: number = 100
  ): Promise<SwapResult> {
    const amountRaw = Math.floor(amountTokens * Math.pow(10, decimals));
    return this.executeSwap(tokenMint, SOL_MINT, amountRaw, slippageBps);
  }

  getWalletAddress(): string | null {
    return this.wallet?.publicKey.toBase58() || null;
  }

  async getBalance(): Promise<number> {
    if (!this.wallet) return 0;

    try {
      const balance = await this.connection.getBalance(this.wallet.publicKey);
      return balance / LAMPORTS_PER_SOL;
    } catch (error) {
      logger.error({ error }, 'Failed to get balance');
      return 0;
    }
  }

  async getTokenBalance(mint: string): Promise<number> {
    if (!this.wallet) return 0;

    try {
      const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
        this.wallet.publicKey,
        { mint: new PublicKey(mint) }
      );

      if (tokenAccounts.value.length === 0) return 0;

      const balance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;
      return balance || 0;
    } catch (error) {
      logger.error({ mint, error }, 'Failed to get token balance');
      return 0;
    }
  }
}

export const jupiterSwap = new JupiterSwap();
</file>

<file path="src/learning/index.ts">
export * from './types';
export * from './trade-logger';
export * from './performance';
export * from './model-trainer';
</file>

<file path="src/learning/model-trainer.ts">
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { ddqnAgent } from '../ai/ddqn-agent';
import { positionSizer } from '../ai/position-sizer';
import { repository } from '../db/repository';
import { tradeLogger } from './trade-logger';
import { performanceAnalytics } from './performance';
import { ModelTrainingResult, LearningState } from './types';

const logger = createChildLogger('model-trainer');

export class ModelTrainer {
  private state: LearningState;
  private trainingInterval: NodeJS.Timeout | null = null;
  private modelVersion: number = 0;

  constructor() {
    this.state = {
      tradesProcessed: 0,
      lastTrainingTime: new Date(0),
      modelVersion: 0,
      performanceHistory: [],
      featureImportance: [],
    };
  }

  async initialize(): Promise<void> {
    // Load model version from database
    const savedVersion = await repository.getConfig('model_version');
    if (savedVersion) {
      this.modelVersion = parseInt(savedVersion);
      this.state.modelVersion = this.modelVersion;
    }

    // Try to load existing model weights
    const modelData = await repository.getLatestModelWeights();
    if (modelData) {
      try {
        await ddqnAgent.loadWeightsFromJSON(modelData.weights);
        this.modelVersion = modelData.version;
        logger.info({ version: this.modelVersion }, 'Loaded model weights from database');
      } catch (error) {
        logger.warn({ error }, 'Failed to load model weights, using fresh model');
        await ddqnAgent.initialize();
      }
    } else {
      await ddqnAgent.initialize();
    }

    logger.info('Model trainer initialized');
  }

  async startPeriodicTraining(): Promise<void> {
    // Train every week
    this.trainingInterval = setInterval(() => {
      this.runTrainingCycle();
    }, config.modelRetrainIntervalMs);

    logger.info({ intervalMs: config.modelRetrainIntervalMs }, 'Periodic training started');
  }

  stopPeriodicTraining(): void {
    if (this.trainingInterval) {
      clearInterval(this.trainingInterval);
      this.trainingInterval = null;
    }
    logger.info('Periodic training stopped');
  }

  async runTrainingCycle(): Promise<ModelTrainingResult | null> {
    logger.info('Starting training cycle');

    const startTime = Date.now();

    try {
      // Get trades for training
      const trades = await tradeLogger.getTradesForTraining(4);

      if (trades.length < 50) {
        logger.info({ tradeCount: trades.length }, 'Not enough trades for training');
        return null;
      }

      // Convert trades to experiences
      const experiences = trades
        .map((trade) => tradeLogger.tradeToExperience(trade))
        .filter((e) => e !== null);

      if (experiences.length < 32) {
        logger.info({ experienceCount: experiences.length }, 'Not enough experiences');
        return null;
      }

      // Add to replay buffer
      for (const exp of experiences) {
        if (exp) {
          ddqnAgent.addExperience(exp);
        }
      }

      // Calculate pre-training metrics
      const preMetrics = await performanceAnalytics.calculateMetrics(trades);

      // Run training epochs
      const epochs = 100;
      let totalLoss = 0;

      for (let epoch = 0; epoch < epochs; epoch++) {
        const loss = await ddqnAgent.train();
        totalLoss += loss;

        if (epoch % 10 === 0) {
          logger.debug({ epoch, loss: loss.toFixed(6) }, 'Training progress');
        }
      }

      const avgLoss = totalLoss / epochs;

      // Update position sizer with win rate
      const winTrades = trades.filter((t) => (t.pnlSol || 0) > 0);
      for (const trade of trades) {
        positionSizer.recordTrade((trade.pnlSol || 0) > 0);
      }

      // Calculate post-training validation (simplified)
      const validationLoss = avgLoss * 1.1; // Approximate

      // Update model version
      this.modelVersion++;
      this.state.modelVersion = this.modelVersion;
      this.state.lastTrainingTime = new Date();
      this.state.tradesProcessed += trades.length;

      // Save model weights
      const weights = ddqnAgent.getWeightsAsJSON();
      const metrics = JSON.stringify(preMetrics);

      await repository.saveModelWeights(this.modelVersion, weights, metrics);
      await repository.setConfig('model_version', this.modelVersion.toString());

      // Update feature importance
      this.state.featureImportance = await performanceAnalytics.analyzeFeatureImportance();

      // Store performance history
      this.state.performanceHistory.push(preMetrics);
      if (this.state.performanceHistory.length > 52) {
        // Keep last year of weekly metrics
        this.state.performanceHistory.shift();
      }

      const trainingTime = Date.now() - startTime;

      const result: ModelTrainingResult = {
        epochsTrained: epochs,
        finalLoss: avgLoss,
        validationLoss,
        trainingTime,
        samplesUsed: experiences.length,
        improvementPercent: 0, // Would need post-validation
        timestamp: new Date(),
      };

      logger.info({
        version: this.modelVersion,
        epochs,
        loss: avgLoss.toFixed(6),
        samples: experiences.length,
        trainingTime,
      }, 'Training cycle completed');

      return result;
    } catch (error) {
      logger.error({ error }, 'Training cycle failed');
      return null;
    }
  }

  async addTradeExperience(positionId: string): Promise<void> {
    const trade = await tradeLogger.getActiveTrade(positionId);

    if (!trade || !trade.exitPrice) {
      return;
    }

    const experience = tradeLogger.tradeToExperience(trade);

    if (experience) {
      ddqnAgent.addExperience(experience);
      this.state.tradesProcessed++;

      // Train incrementally every 10 trades
      if (this.state.tradesProcessed % 10 === 0) {
        await ddqnAgent.train();
      }
    }
  }

  getState(): LearningState {
    return { ...this.state };
  }

  getModelVersion(): number {
    return this.modelVersion;
  }

  async exportModel(path: string): Promise<void> {
    await ddqnAgent.saveModel(path);
    logger.info({ path, version: this.modelVersion }, 'Model exported');
  }

  async importModel(path: string): Promise<void> {
    await ddqnAgent.loadModel(path);
    this.modelVersion++;
    await repository.setConfig('model_version', this.modelVersion.toString());
    logger.info({ path, version: this.modelVersion }, 'Model imported');
  }

  getTrainingStatus(): string {
    const timeSinceTrain = Date.now() - this.state.lastTrainingTime.getTime();
    const hoursSinceTrain = Math.floor(timeSinceTrain / (60 * 60 * 1000));

    return [
      `Model v${this.modelVersion}`,
      `Trades: ${this.state.tradesProcessed}`,
      `Buffer: ${ddqnAgent.getReplayBufferSize()}`,
      `Last train: ${hoursSinceTrain}h ago`,
      `Epsilon: ${ddqnAgent.getEpsilon().toFixed(3)}`,
    ].join(' | ');
  }
}

export const modelTrainer = new ModelTrainer();
</file>

<file path="src/learning/performance.ts">
import * as ss from 'simple-statistics';
import { createChildLogger } from '../utils/logger';
import { TradeRecord, PerformanceMetrics, TimeframePerformance, FeatureImportance } from './types';
import { tradeLogger } from './trade-logger';

const logger = createChildLogger('performance');

export class PerformanceAnalytics {
  constructor() {}

  async calculateMetrics(trades?: TradeRecord[]): Promise<PerformanceMetrics> {
    const completedTrades = trades || (await tradeLogger.getRecentTrades(1000)).filter(
      (t) => t.exitPrice !== undefined
    );

    if (completedTrades.length === 0) {
      return this.getEmptyMetrics();
    }

    const pnls = completedTrades.map((t) => t.pnlSol || 0);
    const pnlPercents = completedTrades.map((t) => t.pnlPercent || 0);
    const holdTimes = completedTrades.map((t) => t.duration || 0);

    const wins = completedTrades.filter((t) => (t.pnlSol || 0) > 0);
    const losses = completedTrades.filter((t) => (t.pnlSol || 0) < 0);

    const grossProfit = wins.reduce((sum, t) => sum + (t.pnlSol || 0), 0);
    const grossLoss = Math.abs(losses.reduce((sum, t) => sum + (t.pnlSol || 0), 0));

    const avgWin = wins.length > 0 ? grossProfit / wins.length : 0;
    const avgLoss = losses.length > 0 ? grossLoss / losses.length : 0;

    const metrics: PerformanceMetrics = {
      totalTrades: completedTrades.length,
      winningTrades: wins.length,
      losingTrades: losses.length,
      winRate: wins.length / completedTrades.length,
      avgWin,
      avgLoss,
      largestWin: wins.length > 0 ? Math.max(...wins.map((t) => t.pnlSol || 0)) : 0,
      largestLoss: losses.length > 0 ? Math.min(...losses.map((t) => t.pnlSol || 0)) : 0,
      profitFactor: grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? Infinity : 0,
      expectancy: ss.mean(pnls),
      sharpeRatio: this.calculateSharpeRatio(pnlPercents),
      sortinoRatio: this.calculateSortinoRatio(pnlPercents),
      maxDrawdown: this.calculateMaxDrawdown(pnls),
      avgHoldTime: holdTimes.length > 0 ? ss.mean(holdTimes) : 0,
      totalPnl: ss.sum(pnls),
      totalPnlPercent: ss.sum(pnlPercents),
    };

    return metrics;
  }

  private calculateSharpeRatio(returns: number[], riskFreeRate: number = 0): number {
    if (returns.length < 2) return 0;

    const meanReturn = ss.mean(returns);
    const stdDev = ss.standardDeviation(returns);

    if (stdDev === 0) return 0;

    // Annualize assuming ~100 trades per month
    const annualizationFactor = Math.sqrt(1200);
    return ((meanReturn - riskFreeRate) / stdDev) * annualizationFactor;
  }

  private calculateSortinoRatio(returns: number[], riskFreeRate: number = 0): number {
    if (returns.length < 2) return 0;

    const meanReturn = ss.mean(returns);
    const negativeReturns = returns.filter((r) => r < 0);

    if (negativeReturns.length === 0) return Infinity;

    const downstdDev = ss.standardDeviation(negativeReturns);

    if (downstdDev === 0) return Infinity;

    const annualizationFactor = Math.sqrt(1200);
    return ((meanReturn - riskFreeRate) / downstdDev) * annualizationFactor;
  }

  private calculateMaxDrawdown(pnls: number[]): number {
    if (pnls.length === 0) return 0;

    let cumulative = 0;
    let peak = 0;
    let maxDrawdown = 0;

    for (const pnl of pnls) {
      cumulative += pnl;
      peak = Math.max(peak, cumulative);
      const drawdown = (peak - cumulative) / (peak || 1);
      maxDrawdown = Math.max(maxDrawdown, drawdown);
    }

    return maxDrawdown;
  }

  async getTimeframePerformance(): Promise<TimeframePerformance> {
    const allTrades = await tradeLogger.getRecentTrades(10000);
    const completedTrades = allTrades.filter((t) => t.exitPrice !== undefined);

    const now = new Date();

    const hourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    const dayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const hourlyTrades = completedTrades.filter(
      (t) => t.exitTime && t.exitTime >= hourAgo
    );
    const dailyTrades = completedTrades.filter(
      (t) => t.exitTime && t.exitTime >= dayAgo
    );
    const weeklyTrades = completedTrades.filter(
      (t) => t.exitTime && t.exitTime >= weekAgo
    );
    const monthlyTrades = completedTrades.filter(
      (t) => t.exitTime && t.exitTime >= monthAgo
    );

    return {
      hourly: await this.calculateMetrics(hourlyTrades),
      daily: await this.calculateMetrics(dailyTrades),
      weekly: await this.calculateMetrics(weeklyTrades),
      monthly: await this.calculateMetrics(monthlyTrades),
      allTime: await this.calculateMetrics(completedTrades),
    };
  }

  async analyzeFeatureImportance(): Promise<FeatureImportance[]> {
    const trades = await tradeLogger.getTradesForTraining(4);

    if (trades.length < 20) {
      return [];
    }

    const featureNames = [
      'priceChange1m',
      'priceChange5m',
      'volumeZScore',
      'buySellRatio',
      'holderCount',
      'top10Concentration',
      'mintRevoked',
      'freezeRevoked',
      'lpLocked',
      'ageMinutes',
      'tradeIntensity',
      'marketCapSol',
    ];

    const importance: FeatureImportance[] = [];

    for (let i = 0; i < featureNames.length; i++) {
      const featureValues = trades.map((t) => {
        const arr = Object.values(t.features);
        return arr[i] || 0;
      });

      const profits = trades.map((t) => t.pnlPercent || 0);

      // Calculate correlation with profit
      let correlation = 0;
      try {
        correlation = ss.sampleCorrelation(featureValues, profits);
        if (isNaN(correlation)) correlation = 0;
      } catch {
        correlation = 0;
      }

      // Calculate feature variance as importance proxy
      const variance = ss.variance(featureValues);

      importance.push({
        feature: featureNames[i],
        importance: variance,
        correlation,
      });
    }

    // Sort by absolute correlation
    importance.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));

    return importance;
  }

  private getEmptyMetrics(): PerformanceMetrics {
    return {
      totalTrades: 0,
      winningTrades: 0,
      losingTrades: 0,
      winRate: 0,
      avgWin: 0,
      avgLoss: 0,
      largestWin: 0,
      largestLoss: 0,
      profitFactor: 0,
      expectancy: 0,
      sharpeRatio: 0,
      sortinoRatio: 0,
      maxDrawdown: 0,
      avgHoldTime: 0,
      totalPnl: 0,
      totalPnlPercent: 0,
    };
  }

  formatMetrics(metrics: PerformanceMetrics): string {
    return [
      `Trades: ${metrics.totalTrades} (${metrics.winningTrades}W/${metrics.losingTrades}L)`,
      `Win Rate: ${(metrics.winRate * 100).toFixed(1)}%`,
      `Total P&L: ${metrics.totalPnl >= 0 ? '+' : ''}${metrics.totalPnl.toFixed(4)} SOL`,
      `Profit Factor: ${metrics.profitFactor.toFixed(2)}`,
      `Sharpe: ${metrics.sharpeRatio.toFixed(2)}`,
      `Max DD: ${(metrics.maxDrawdown * 100).toFixed(1)}%`,
    ].join(' | ');
  }
}

export const performanceAnalytics = new PerformanceAnalytics();
</file>

<file path="src/learning/trade-logger.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { repository } from '../db/repository';
import { Action, MarketRegime } from '../ai/types';
import { StateVector, PumpPhase } from '../signals/types';
import { featureExtractor } from '../signals/feature-extractor';
import { TradeRecord } from './types';

const logger = createChildLogger('trade-logger');

export class TradeLogger extends EventEmitter {
  private activeTrades: Map<string, TradeRecord> = new Map();

  constructor() {
    super();
  }

  async logEntry(params: {
    positionId: string;
    mint: string;
    symbol: string;
    entryPrice: number;
    amount: number;
    amountSol: number;
    features: StateVector;
    regime: MarketRegime;
    pumpPhase: PumpPhase;
  }): Promise<TradeRecord> {
    const record: TradeRecord = {
      id: params.positionId,
      mint: params.mint,
      symbol: params.symbol,
      action: Action.BUY,
      entryPrice: params.entryPrice,
      amount: params.amount,
      amountSol: params.amountSol,
      entryTime: new Date(),
      features: params.features,
      regime: params.regime,
      pumpPhase: params.pumpPhase,
    };

    this.activeTrades.set(record.id, record);

    // Save to database
    await repository.insertTrade({
      id: record.id,
      mint: record.mint,
      symbol: record.symbol,
      action: record.action,
      entry_price: record.entryPrice,
      amount: record.amount,
      amount_sol: record.amountSol,
      entry_time: record.entryTime,
      features_json: JSON.stringify(record.features),
      regime: record.regime,
      pump_phase: record.pumpPhase,
    });

    logger.info({
      id: record.id,
      mint: record.mint,
      entryPrice: record.entryPrice,
      amountSol: record.amountSol,
    }, 'Trade entry logged');

    this.emit('entryLogged', record);

    return record;
  }

  async logExit(params: {
    positionId: string;
    exitPrice: number;
    exitReason: 'stop_loss' | 'take_profit' | 'trailing_stop' | 'manual' | 'ai_signal' | 'rug_detected';
    slippage?: number;
    fees?: number;
    actualSolReceived?: number;
    partialClosePnl?: number;
  }): Promise<TradeRecord | null> {
    const record = this.activeTrades.get(params.positionId);

    if (!record) {
      logger.warn({ positionId: params.positionId }, 'Trade not found for exit');
      return null;
    }

    record.exitPrice = params.exitPrice;
    record.exitTime = new Date();
    record.exitReason = params.exitReason;
    record.slippage = params.slippage;
    record.fees = params.fees;

    // Calculate P&L with fees and slippage included
    const grossPnl = (record.exitPrice - record.entryPrice) * record.amount;
    const fees = params.fees || 0;
    const slippageCost = params.slippage ? (params.slippage * record.amountSol) : 0;

    // If we have actual SOL received from the swap, use that for accurate PnL
    let netPnl: number;
    if (params.actualSolReceived !== undefined) {
      // Accurate PnL = actual received - initial investment
      netPnl = params.actualSolReceived - record.amountSol;
    } else {
      // Estimated PnL = gross - fees - slippage
      netPnl = grossPnl - fees - slippageCost;
    }

    // Add any accumulated partial close PnL
    const partialClosePnl = params.partialClosePnl || 0;
    record.pnlSol = netPnl + partialClosePnl;
    record.pnlPercent = (record.pnlSol / record.amountSol) * 100;
    record.duration = record.exitTime.getTime() - record.entryTime.getTime();

    logger.debug({
      positionId: params.positionId,
      grossPnl,
      fees,
      slippageCost,
      actualSolReceived: params.actualSolReceived,
      partialClosePnl,
      netPnl: record.pnlSol,
    }, 'PnL calculation breakdown');

    // Update database
    await repository.updateTradeExit(record.id, {
      exit_price: record.exitPrice,
      exit_time: record.exitTime,
      pnl_sol: record.pnlSol,
      pnl_percent: record.pnlPercent,
      duration_ms: record.duration,
      exit_reason: record.exitReason,
      slippage: record.slippage,
      fees: record.fees,
    });

    logger.info({
      id: record.id,
      mint: record.mint,
      exitPrice: record.exitPrice,
      pnlSol: record.pnlSol?.toFixed(6),
      pnlPercent: record.pnlPercent?.toFixed(2),
      duration: record.duration,
      exitReason: record.exitReason,
    }, 'Trade exit logged');

    this.activeTrades.delete(record.id);
    this.emit('exitLogged', record);

    return record;
  }

  getActiveTrades(): TradeRecord[] {
    return Array.from(this.activeTrades.values());
  }

  getActiveTrade(id: string): TradeRecord | undefined {
    return this.activeTrades.get(id);
  }

  async getRecentTrades(limit: number = 100): Promise<TradeRecord[]> {
    const dbTrades = await repository.getRecentTrades(limit);

    return dbTrades.map((t) => ({
      id: t.id,
      mint: t.mint,
      symbol: t.symbol || '',
      action: t.action as Action,
      entryPrice: parseFloat(t.entry_price.toString()),
      exitPrice: t.exit_price ? parseFloat(t.exit_price.toString()) : undefined,
      amount: parseFloat(t.amount.toString()),
      amountSol: parseFloat(t.amount_sol.toString()),
      entryTime: new Date(t.entry_time),
      exitTime: t.exit_time ? new Date(t.exit_time) : undefined,
      pnlSol: t.pnl_sol ? parseFloat(t.pnl_sol.toString()) : undefined,
      pnlPercent: t.pnl_percent ? parseFloat(t.pnl_percent.toString()) : undefined,
      duration: t.duration_ms ? parseInt(t.duration_ms.toString()) : undefined,
      features: JSON.parse(t.features_json || '{}'),
      regime: t.regime as MarketRegime,
      pumpPhase: t.pump_phase as PumpPhase,
      exitReason: t.exit_reason as any,
      slippage: t.slippage ? parseFloat(t.slippage.toString()) : undefined,
      fees: t.fees ? parseFloat(t.fees.toString()) : undefined,
    }));
  }

  async getTradesForTraining(weeks: number = 4): Promise<TradeRecord[]> {
    const dbTrades = await repository.getTradesForTraining(weeks);

    return dbTrades
      .filter((t) => t.exit_time !== null)
      .map((t) => ({
        id: t.id,
        mint: t.mint,
        symbol: t.symbol || '',
        action: t.action as Action,
        entryPrice: parseFloat(t.entry_price.toString()),
        exitPrice: t.exit_price ? parseFloat(t.exit_price.toString()) : undefined,
        amount: parseFloat(t.amount.toString()),
        amountSol: parseFloat(t.amount_sol.toString()),
        entryTime: new Date(t.entry_time),
        exitTime: t.exit_time ? new Date(t.exit_time) : undefined,
        pnlSol: t.pnl_sol ? parseFloat(t.pnl_sol.toString()) : undefined,
        pnlPercent: t.pnl_percent ? parseFloat(t.pnl_percent.toString()) : undefined,
        duration: t.duration_ms ? parseInt(t.duration_ms.toString()) : undefined,
        features: JSON.parse(t.features_json || '{}'),
        regime: t.regime as MarketRegime,
        pumpPhase: t.pump_phase as PumpPhase,
        exitReason: t.exit_reason as any,
        slippage: t.slippage ? parseFloat(t.slippage.toString()) : undefined,
        fees: t.fees ? parseFloat(t.fees.toString()) : undefined,
      }));
  }

  // Convert trade to experience for DDQN training
  tradeToExperience(trade: TradeRecord): {
    state: number[];
    action: Action;
    reward: number;
    nextState: number[];
    done: boolean;
  } | null {
    if (!trade.exitPrice || !trade.pnlPercent) {
      return null;
    }

    const state = featureExtractor.toArray(trade.features);

    // Reward function: profit-based with risk adjustment
    let reward = trade.pnlPercent / 10; // Scale to reasonable range

    // Penalty for large losses
    if (trade.pnlPercent < -20) {
      reward *= 1.5; // Amplify negative signal for big losses
    }

    // Bonus for good risk-adjusted exits
    if (trade.exitReason === 'take_profit') {
      reward *= 1.1;
    } else if (trade.exitReason === 'trailing_stop' && trade.pnlPercent > 0) {
      reward *= 1.05;
    }

    // Next state is similar to current (simplified)
    const nextState = state.slice();

    return {
      state,
      action: trade.action,
      reward,
      nextState,
      done: true,
    };
  }

  // NEW: Dense reward shaping for intermediate states during position holding
  // Call this periodically while position is open to provide learning signal
  calculateIntermediateReward(params: {
    unrealizedPnlPercent: number;
    previousPnlPercent: number;
    momentum: number;        // Price velocity
    volatility: number;
    drawdownFromPeak: number;
    holdDurationSeconds: number;
  }): number {
    const {
      unrealizedPnlPercent,
      previousPnlPercent,
      momentum,
      volatility,
      drawdownFromPeak,
      holdDurationSeconds,
    } = params;

    let reward = 0;

    // Reward for P&L improvement (delta reward)
    const pnlDelta = unrealizedPnlPercent - previousPnlPercent;
    reward += pnlDelta * 0.1;  // Small reward for positive movement

    // Reward for holding through upward momentum
    if (momentum > 0 && unrealizedPnlPercent > 0) {
      reward += 0.1 * Math.min(momentum, 1.0);  // Cap at 0.1 bonus
    }

    // Penalty for holding during drawdown
    if (drawdownFromPeak > 0.1) {  // More than 10% drawdown from peak
      reward -= 0.05 * drawdownFromPeak;
    }

    // Small penalty for holding through high volatility (risk)
    if (volatility > 0.05) {  // High volatility threshold
      reward -= 0.02 * volatility;
    }

    // Small penalty for entering tokens that immediately stagnate
    if (holdDurationSeconds < 30 && Math.abs(unrealizedPnlPercent) < 1) {
      reward -= 0.05;  // Token going nowhere quickly
    }

    // Clip rewards to prevent extreme values
    return Math.max(-1, Math.min(1, reward));
  }

  // NEW: Calculate reward signal for a position update
  getPositionRewardSignal(position: {
    mint: string;
    entryPrice: number;
    currentPrice: number;
    peakPrice: number;
    entryTime: Date;
    previousPrice?: number;
  }): {
    intermediateReward: number;
    unrealizedPnlPercent: number;
    momentum: number;
    drawdownFromPeak: number;
  } {
    const unrealizedPnlPercent = ((position.currentPrice - position.entryPrice) / position.entryPrice) * 100;
    const previousPnlPercent = position.previousPrice
      ? ((position.previousPrice - position.entryPrice) / position.entryPrice) * 100
      : 0;

    // Calculate momentum (price change rate)
    const momentum = position.previousPrice
      ? (position.currentPrice - position.previousPrice) / position.previousPrice
      : 0;

    // Calculate drawdown from peak
    const drawdownFromPeak = position.peakPrice > position.currentPrice
      ? (position.peakPrice - position.currentPrice) / position.peakPrice
      : 0;

    const holdDurationSeconds = (Date.now() - position.entryTime.getTime()) / 1000;

    const intermediateReward = this.calculateIntermediateReward({
      unrealizedPnlPercent,
      previousPnlPercent,
      momentum,
      volatility: 0,  // Would need historical data to calculate
      drawdownFromPeak,
      holdDurationSeconds,
    });

    return {
      intermediateReward,
      unrealizedPnlPercent,
      momentum,
      drawdownFromPeak,
    };
  }
}

export const tradeLogger = new TradeLogger();
</file>

<file path="src/learning/types.ts">
import { Action, MarketRegime } from '../ai/types';
import { StateVector, PumpPhase } from '../signals/types';

export interface TradeRecord {
  id: string;
  mint: string;
  symbol: string;
  action: Action;
  entryPrice: number;
  exitPrice?: number;
  amount: number;
  amountSol: number;
  entryTime: Date;
  exitTime?: Date;
  pnlSol?: number;
  pnlPercent?: number;
  duration?: number;          // milliseconds
  features: StateVector;
  regime: MarketRegime;
  pumpPhase: PumpPhase;
  exitReason?: 'stop_loss' | 'take_profit' | 'trailing_stop' | 'manual' | 'ai_signal' | 'rug_detected';
  slippage?: number;
  fees?: number;
}

export interface PerformanceMetrics {
  totalTrades: number;
  winningTrades: number;
  losingTrades: number;
  winRate: number;
  avgWin: number;
  avgLoss: number;
  largestWin: number;
  largestLoss: number;
  profitFactor: number;       // gross profit / gross loss
  expectancy: number;         // avg profit per trade
  sharpeRatio: number;
  sortinoRatio: number;
  maxDrawdown: number;
  avgHoldTime: number;
  totalPnl: number;
  totalPnlPercent: number;
}

export interface TimeframePerformance {
  hourly: PerformanceMetrics;
  daily: PerformanceMetrics;
  weekly: PerformanceMetrics;
  monthly: PerformanceMetrics;
  allTime: PerformanceMetrics;
}

export interface FeatureImportance {
  feature: string;
  importance: number;
  correlation: number;        // correlation with profit
}

export interface ModelTrainingResult {
  epochsTrained: number;
  finalLoss: number;
  validationLoss: number;
  trainingTime: number;
  samplesUsed: number;
  improvementPercent: number;
  timestamp: Date;
}

export interface LearningState {
  tradesProcessed: number;
  lastTrainingTime: Date;
  modelVersion: number;
  performanceHistory: PerformanceMetrics[];
  featureImportance: FeatureImportance[];
}
</file>

<file path="src/risk/drawdown-guard.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { repository } from '../db/repository';
import { positionManager } from './position-manager';
import { capitalAllocator } from './capital-allocator';
import { DrawdownState } from './types';

const logger = createChildLogger('drawdown-guard');

export class DrawdownGuard extends EventEmitter {
  private state: DrawdownState;
  private checkInterval: NodeJS.Timeout | null = null;

  constructor() {
    super();

    this.state = {
      currentEquity: config.initialCapitalSol,
      peakEquity: config.initialCapitalSol,
      currentDrawdown: 0,
      maxDrawdown: 0,
      dailyPnl: 0,
      dailyStartEquity: config.initialCapitalSol,
      isPaused: false,
    };
  }

  async start(): Promise<void> {
    // Load state from database if available
    await this.loadState();

    // Start periodic checks
    this.checkInterval = setInterval(() => {
      this.updateState();
      this.checkLimits();
    }, 10000); // Check every 10 seconds

    logger.info('Drawdown guard started');
  }

  stop(): void {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    logger.info('Drawdown guard stopped');
  }

  private async loadState(): Promise<void> {
    try {
      const savedState = await repository.getConfig('drawdown_state');
      if (savedState) {
        const parsed = JSON.parse(savedState);
        this.state = { ...this.state, ...parsed };

        // Check if pause should be lifted
        if (this.state.pauseUntil && new Date(this.state.pauseUntil) < new Date()) {
          this.state.isPaused = false;
          this.state.pauseUntil = undefined;
          this.state.pauseReason = undefined;
        }
      }
    } catch (error) {
      logger.error({ error }, 'Failed to load drawdown state');
    }
  }

  private async saveState(): Promise<void> {
    try {
      await repository.setConfig('drawdown_state', JSON.stringify(this.state));
    } catch (error) {
      logger.error({ error }, 'Failed to save drawdown state');
    }
  }

  private async updateState(): Promise<void> {
    const allocation = capitalAllocator.getAllocation();
    const positions = positionManager.getOpenPositions();

    // Calculate current equity (wallet balance + unrealized P&L)
    let unrealizedPnl = 0;
    for (const position of positions) {
      unrealizedPnl += position.unrealizedPnl;
    }

    // In paper trading or when wallet is empty, use initial capital
    const baseEquity = allocation.totalSol > 0 ? allocation.totalSol : config.initialCapitalSol;
    this.state.currentEquity = baseEquity + unrealizedPnl;

    // Update peak equity
    if (this.state.currentEquity > this.state.peakEquity) {
      this.state.peakEquity = this.state.currentEquity;
    }

    // Calculate current drawdown
    this.state.currentDrawdown =
      (this.state.peakEquity - this.state.currentEquity) / this.state.peakEquity;

    // Update max drawdown
    if (this.state.currentDrawdown > this.state.maxDrawdown) {
      this.state.maxDrawdown = this.state.currentDrawdown;
    }

    // Update daily P&L
    this.state.dailyPnl = this.state.currentEquity - this.state.dailyStartEquity;

    // Check for new day
    await this.checkDayRollover();
  }

  private async checkDayRollover(): Promise<void> {
    const now = new Date();
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    const lastUpdate = await repository.getConfig('last_day_update');
    const lastUpdateDate = lastUpdate ? new Date(lastUpdate) : null;

    if (!lastUpdateDate || lastUpdateDate < todayStart) {
      // New day - record previous day stats and reset
      if (lastUpdateDate) {
        await repository.updateDailyStats(lastUpdateDate, {
          ending_equity: this.state.currentEquity,
          pnl: this.state.dailyPnl,
          max_drawdown: this.state.currentDrawdown,
        });
      }

      // Reset daily tracking
      this.state.dailyStartEquity = this.state.currentEquity;
      this.state.dailyPnl = 0;

      await repository.setConfig('last_day_update', now.toISOString());
      await repository.updateDailyStats(now, {
        starting_equity: this.state.currentEquity,
      });

      // Check if pause should be lifted
      if (this.state.isPaused && this.state.pauseUntil) {
        if (new Date(this.state.pauseUntil) <= now) {
          this.resumeTrading('Pause period expired');
        }
      }
    }
  }

  private checkLimits(): void {
    if (this.state.isPaused) return;

    // Prevent division by zero
    if (this.state.dailyStartEquity <= 0 || this.state.peakEquity <= 0) {
      return;
    }

    // Check daily loss limit
    const dailyLossPercent = -this.state.dailyPnl / this.state.dailyStartEquity;

    if (dailyLossPercent >= config.dailyLossLimit) {
      const pauseUntil = new Date();
      pauseUntil.setHours(pauseUntil.getHours() + 24);

      this.pauseTrading(
        `Daily loss limit (${(config.dailyLossLimit * 100).toFixed(0)}%) exceeded`,
        pauseUntil
      );
      return;
    }

    // Check max drawdown
    if (this.state.currentDrawdown >= 0.30) {
      // 30% max drawdown
      const pauseUntil = new Date();
      pauseUntil.setHours(pauseUntil.getHours() + 48);

      this.pauseTrading('Max drawdown (30%) exceeded', pauseUntil);
      return;
    }

    // Warn at 20% drawdown
    if (this.state.currentDrawdown >= 0.20 && this.state.currentDrawdown < 0.25) {
      logger.warn(
        { drawdown: (this.state.currentDrawdown * 100).toFixed(1) },
        'Drawdown warning - approaching limit'
      );
    }
  }

  pauseTrading(reason: string, until?: Date): void {
    this.state.isPaused = true;
    this.state.pauseReason = reason;
    this.state.pauseUntil = until;

    this.emit('tradingPaused', {
      reason,
      until,
      drawdown: this.state.currentDrawdown,
      dailyPnl: this.state.dailyPnl,
    });

    logger.error(
      { reason, until: until?.toISOString(), drawdown: this.state.currentDrawdown },
      'TRADING PAUSED'
    );

    this.saveState();
  }

  resumeTrading(reason: string): void {
    if (!this.state.isPaused) return;

    this.state.isPaused = false;
    this.state.pauseReason = undefined;
    this.state.pauseUntil = undefined;

    this.emit('tradingResumed', { reason });

    logger.info({ reason }, 'Trading resumed');

    this.saveState();
  }

  canTrade(): boolean {
    return !this.state.isPaused;
  }

  getState(): DrawdownState {
    return { ...this.state };
  }

  getStatus(): string {
    if (this.state.isPaused) {
      return `PAUSED: ${this.state.pauseReason} (until ${this.state.pauseUntil?.toISOString()})`;
    }

    return [
      `Equity: ${this.state.currentEquity.toFixed(4)} SOL`,
      `Peak: ${this.state.peakEquity.toFixed(4)} SOL`,
      `Drawdown: ${(this.state.currentDrawdown * 100).toFixed(2)}%`,
      `Daily P&L: ${this.state.dailyPnl >= 0 ? '+' : ''}${this.state.dailyPnl.toFixed(4)} SOL`,
    ].join(' | ');
  }

  resetPeakEquity(): void {
    this.state.peakEquity = this.state.currentEquity;
    this.state.maxDrawdown = 0;
    logger.info({ newPeak: this.state.peakEquity }, 'Peak equity reset');
    this.saveState();
  }

  // Full reset for fresh start - uses actual wallet balance
  async resetAll(): Promise<void> {
    const allocation = capitalAllocator.getAllocation();
    const actualEquity = allocation.totalSol > 0 ? allocation.totalSol : config.initialCapitalSol;

    this.state = {
      currentEquity: actualEquity,
      peakEquity: actualEquity,
      currentDrawdown: 0,
      maxDrawdown: 0,
      dailyPnl: 0,
      dailyStartEquity: actualEquity,
      isPaused: false,
    };
    await this.saveState();
    logger.info({ equity: actualEquity }, 'Drawdown guard fully reset');
  }

  recordTrade(pnlSol: number): void {
    this.state.dailyPnl += pnlSol;

    if (pnlSol > 0) {
      this.state.currentEquity += pnlSol;
      if (this.state.currentEquity > this.state.peakEquity) {
        this.state.peakEquity = this.state.currentEquity;
      }
    } else {
      this.state.currentEquity += pnlSol;
      this.state.currentDrawdown =
        (this.state.peakEquity - this.state.currentEquity) / this.state.peakEquity;

      if (this.state.currentDrawdown > this.state.maxDrawdown) {
        this.state.maxDrawdown = this.state.currentDrawdown;
      }
    }

    this.checkLimits();
    this.saveState();
  }
}

export const drawdownGuard = new DrawdownGuard();
</file>

<file path="src/risk/index.ts">
export * from './types';
export * from './position-manager';
export * from './capital-allocator';
export * from './drawdown-guard';
</file>

<file path="src/risk/types.ts">
export interface Position {
  id: string;
  mint: string;
  symbol: string;
  entryPrice: number;
  currentPrice: number;
  amount: number;
  amountSol: number;            // Initial SOL investment
  entryTime: Date;
  lastUpdate: Date;
  unrealizedPnl: number;
  unrealizedPnlPercent: number;
  highestPrice: number;
  lowestPrice: number;
  stopLoss: number;
  takeProfit: number[];
  tpSold: number[];             // Track which TP levels hit (legacy)
  trailingStop?: number;
  status: 'open' | 'closing' | 'closed';
  poolType: 'active' | 'high_risk';

  // NEW: Performance-based TP tracking
  initialRecovered: boolean;    // True after initial investment recovered at +50%
  scaledExitsTaken: number;     // Count of scaled exits taken after recovery
  initialInvestment: number;    // Original SOL amount for recovery calculation

  // NEW: Accumulated PnL from partial closes
  realizedPnl: number;          // Total realized PnL from partial closes
}

export interface CapitalAllocation {
  totalSol: number;
  reserveSol: number;         // Never trade
  activeSol: number;          // Normal trades
  highRiskSol: number;        // Meme plays
  inPositions: number;        // Currently allocated
  availableActive: number;    // Available for active pool
  availableHighRisk: number;  // Available for high risk pool
}

export interface DrawdownState {
  currentEquity: number;
  peakEquity: number;
  currentDrawdown: number;
  maxDrawdown: number;
  dailyPnl: number;
  dailyStartEquity: number;
  isPaused: boolean;
  pauseUntil?: Date;
  pauseReason?: string;
}

export interface RiskLimits {
  maxPositionSizeSol: number;
  maxConcurrentPositions: number;
  dailyLossLimit: number;
  maxDrawdownLimit: number;
  minPositionSizeSol: number;
}

export interface RiskCheckResult {
  approved: boolean;
  adjustedSize?: number;
  reason: string;
  warnings: string[];
}

export interface PortfolioMetrics {
  totalValue: number;
  totalPnl: number;
  totalPnlPercent: number;
  positionCount: number;
  avgPositionSize: number;
  largestPosition: number;
  exposure: number;           // Total in positions / total capital
}
</file>

<file path="src/scripts/analyze-wallets.ts">
import dotenv from 'dotenv';
dotenv.config();

import fs from 'fs';
import path from 'path';
import { Connection, PublicKey, ParsedTransactionWithMeta } from '@solana/web3.js';
import { config } from '../config/settings';

// === CONFIGURATION ===
const LOOKBACK_TX_LIMIT = 100; 
const RATE_LIMIT_DELAY = 1500; // Slower to be safe
const MIN_SOL_VOLUME = 0.1;

// === USER SCORING WEIGHTS ===
const SCORING = {
  WIN_RATE_WEIGHT: 0.25,
  ROI_WEIGHT: 0.30,
  CONSISTENCY_WEIGHT: 0.20,
  EARLY_ENTRY_WEIGHT: 0.15,
  TRADE_COUNT_WEIGHT: 0.10
};

interface Trade {
  mint: string;
  type: 'buy' | 'sell';
  amountSol: number;
  amountTokens: number;
  timestamp: number;
  signature: string;
}

interface WalletAnalysis {
  address: string;
  totalPnL: number;
  totalSolSpent: number;
  winRate: number;
  roi: number;
  totalTrades: number;
  profitableTokens: number;
  tokensTraded: number;
  avgHoldTime: number; // Seconds
  walletAgeDays: number;
  compositeScore: number;
  verdict: 'KEEP' | 'DISCARD';
  tier: 'High' | 'Medium' | 'Low';
  flags: string[];
}

async function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function analyzeWallets() {
  console.log('ðŸ•µï¸  Starting Advanced Wallet Analysis (Composite Scorer)...');

  // 1. Read wallets from wallet.md
  const walletFile = path.join(process.cwd(), 'wallet.md');
  if (!fs.existsSync(walletFile)) {
    console.error('âŒ wallet.md not found!');
    process.exit(1);
  }

  const content = fs.readFileSync(walletFile, 'utf-8');
  const wallets = content
    .split('\n')
    .map(l => l.trim())
    .filter(l => /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(l));

  if (wallets.length === 0) {
    console.error('âŒ No valid wallets found in wallet.md');
    process.exit(1);
  }

  console.log(`ðŸ“‹ Analyzing ${wallets.length} wallets against Composite Score...`);

  const connection = new Connection(config.solanaRpcUrl || `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`);
  const results: WalletAnalysis[] = [];

  // 2. Process each wallet
  for (let i = 0; i < wallets.length; i++) {
    const wallet = wallets[i];
    process.stdout.write(`\r[${i + 1}/${wallets.length}] Analyzing ${wallet.substring(0, 6)}... `);

    try {
      const stats = await processWallet(connection, wallet);
      results.push(stats);
      await sleep(RATE_LIMIT_DELAY); 
    } catch (error) {
      console.error(`\nâŒ Error analyzing ${wallet}:`, error);
    }
  }

  console.log('\n\n=== ðŸ“Š ANALYSIS RESULTS (Ranked by Score) ===');
  
  // Sort by Score
  results.sort((a, b) => b.compositeScore - a.compositeScore);

  console.table(results.map(r => ({
    Address: r.address.substring(0, 8) + '...',
    'Score': r.compositeScore.toFixed(0),
    'Verdict': r.verdict,
    'Win Rate': (r.winRate * 100).toFixed(0) + '%',
    'ROI': (r.roi * 100).toFixed(0) + '%',
    'PnL (SOL)': r.totalPnL.toFixed(1),
    'Tokens': `${r.profitableTokens}/${r.tokensTraded}`,
    'Flags': r.flags.join(', ')
  })));

  // Recommendation
  const keepers = results.filter(r => r.verdict === 'KEEP').map(r => r.address);
  console.log(`\nâœ… Recommended Keepers (${keepers.length}):`);
  if (keepers.length > 0) {
    console.log(keepers.join(','));
  } else {
    console.log('None passed the strict criteria.');
  }

  // Generate Report File
  const reportPath = path.join(process.cwd(), 'analysis_report.md');
  let reportContent = '# ðŸ“Š Wallet Analysis Report\n\n';
  reportContent += `**Generated:** ${new Date().toISOString()}\n`;
  reportContent += `**Total Wallets Analyzed:** ${results.length}\n`;
  reportContent += `**Keepers Found:** ${keepers.length}\n\n`;
  
  reportContent += '| Address | Score | Verdict | Win Rate | ROI | PnL | Tokens | Est. Hold Time | Flags |\n';
  reportContent += '|---------|-------|---------|----------|-----|-----|--------|----------------|-------|\n';
  
  results.forEach(r => {
    reportContent += `| \`${r.address}\` | **${r.compositeScore.toFixed(0)}** | ${r.verdict === 'KEEP' ? 'âœ… KEEP' : 'Xu274 DISCARD'} | ${(r.winRate * 100).toFixed(0)}% | ${(r.roi * 100).toFixed(0)}% | ${r.totalPnL.toFixed(2)} SOL | ${r.profitableTokens}/${r.tokensTraded} | ${r.avgHoldTime.toFixed(0)}s | ${r.flags.join(', ')} |\n`;
  });

  reportContent += '\n## Metric Explanations\n';
  reportContent += '- **Score:** Composite rating (0-100) based on Win Rate, ROI, Consistency, and Profit.\n';
  reportContent += '- **Verdict:** KEEP if Score > 40 per user criteria.\n';
  reportContent += '- **Win Rate:** Percentage of tokens traded that resulted in profit.\n';
  reportContent += '- **ROI:** Total Profit / Total Cost (capped at 300% for scoring).\n';

  fs.writeFileSync(reportPath, reportContent);
  console.log(`\nðŸ“„ Detailed report saved to: ${reportPath}`);
}

async function processWallet(connection: Connection, address: string): Promise<WalletAnalysis> {
  const pubkey = new PublicKey(address);
  
  const signatures = await connection.getSignaturesForAddress(pubkey, { limit: LOOKBACK_TX_LIMIT });
  const trades: Trade[] = [];

  let oldestTxTime = Date.now() / 1000;
  let newestTxTime = 0;

  for (const sig of signatures) {
    if (sig.err) continue;
    if (sig.blockTime && sig.blockTime < oldestTxTime) oldestTxTime = sig.blockTime;
    if (sig.blockTime && sig.blockTime > newestTxTime) newestTxTime = sig.blockTime;

    try {
      const tx = await connection.getParsedTransaction(sig.signature, { maxSupportedTransactionVersion: 0 });
      if (!tx || !tx.meta) continue;

      const trade = extractTrade(tx, address);
      if (trade) trades.push(trade);
    } catch { /* ignore */ }
  }

  return calculateMetrics(address, trades, oldestTxTime);
}

function extractTrade(tx: ParsedTransactionWithMeta, walletAddress: string): Trade | null {
  // Simplified trade extraction (reuse from previous, but abbreviated here)
  const meta = tx.meta!;
  const accountKeys = tx.transaction.message.accountKeys;
  const walletIndex = accountKeys.findIndex((k) => k.pubkey.toString() === walletAddress);
  if (walletIndex === -1) return null;

  const solChange = (meta.postBalances[walletIndex] - meta.preBalances[walletIndex]) / 1e9;
  
  // Find token change
  const preToken = meta.preTokenBalances?.filter(t => t.owner === walletAddress) || [];
  const postToken = meta.postTokenBalances?.filter(t => t.owner === walletAddress) || [];
  
  // Find largest token change
  let maxChange = 0; 
  let tradedMint = '';
  let tokenChangeAmount = 0;
  const changes = new Map<string, number>();

  preToken.forEach(t => changes.set(t.mint, -(t.uiTokenAmount.uiAmount || 0)));
  postToken.forEach(t => { const c = changes.get(t.mint)||0; changes.set(t.mint, c + (t.uiTokenAmount.uiAmount||0)); });

  for (const [mint, change] of changes.entries()) {
    if (Math.abs(change) > maxChange) { maxChange = Math.abs(change); tradedMint = mint; tokenChangeAmount = change; }
  }

  if (!tradedMint || Math.abs(solChange) < MIN_SOL_VOLUME) return null;

  if (solChange < 0 && tokenChangeAmount > 0) return { mint: tradedMint, type: 'buy', amountSol: Math.abs(solChange), amountTokens: tokenChangeAmount, timestamp: tx.blockTime||0, signature: tx.transaction.signatures[0] };
  if (solChange > 0 && tokenChangeAmount < 0) return { mint: tradedMint, type: 'sell', amountSol: Math.abs(solChange), amountTokens: Math.abs(tokenChangeAmount), timestamp: tx.blockTime||0, signature: tx.transaction.signatures[0] };
  return null;
}

function calculateMetrics(address: string, trades: Trade[], oldestTxTime: number): WalletAnalysis {
  // 1. Group by token
  const tokens = new Map<string, { bought: number, sold: number, entryTime: number, exitTime: number }>();
  
  trades.forEach(t => {
    if (!tokens.has(t.mint)) tokens.set(t.mint, { bought: 0, sold: 0, entryTime: t.timestamp, exitTime: t.timestamp });
    const stat = tokens.get(t.mint)!;
    if (t.type === 'buy') {
      stat.bought += t.amountSol;
      if (t.timestamp < stat.entryTime) stat.entryTime = t.timestamp;
    } else {
      stat.sold += t.amountSol;
      if (t.timestamp > stat.exitTime) stat.exitTime = t.timestamp;
    }
  });

  // 2. Score Components
  let totalPnL = 0;
  let totalSolSpent = 0;
  let profitableTokens = 0;
  let holdTimes: number[] = [];

  tokens.forEach(stat => {
    if (stat.bought > 0) {
      const pnl = stat.sold - stat.bought;
      totalPnL += pnl;
      totalSolSpent += stat.bought;
      if (pnl > 0) profitableTokens++;
      
      // Est hold time
      if (stat.sold > 0) holdTimes.push(stat.exitTime - stat.entryTime);
    }
  });

  const numTokens = tokens.size;
  const avgHoldTime = holdTimes.length > 0 ? holdTimes.reduce((a,b)=>a+b,0)/holdTimes.length : 0;
  const walletAgeDays = (Date.now()/1000 - oldestTxTime) / 86400;

  // 3. Normalized Scores
  const winRate = numTokens > 0 ? profitableTokens / numTokens : 0;
  const roi = totalSolSpent > 0 ? totalPnL / totalSolSpent : 0;
  
  // ROI Score: Cap at 300% (3.0) -> 30 pts
  const roiScore = Math.min(Math.max(roi, 0), 3.0) * 10; // 0 to 30

  // Win Rate Score: 0-100% -> 0-25 pts
  const winRateScore = winRate * 25;

  // Consistency: >2 profitable tokens -> max 20 pts
  const consistencyScore = Math.min(profitableTokens, 5) * 4; // 5 tokens = 20 pts

  // Trade Count: Capped at 50 -> 10 pts
  const tradeCountScore = Math.min(trades.length, 50) / 5; // 50 txs = 10 pts
  
  // Early Entry (Cannot easily calc historically for all tokens, assuming neutral for analyze phase)
  const earlyEntryScore = 7.5; // Give average

  const compositeScore = winRateScore + roiScore + consistencyScore + tradeCountScore + earlyEntryScore;

  // 4. Flags & Verdict
  const flags: string[] = [];
  if (avgHoldTime < 60 && numTokens > 2) flags.push('MEV/Bot');
  if (walletAgeDays < 7) flags.push('Fresh Wallet');
  if (numTokens < 3) flags.push('Low Sample');

  let verdict: 'KEEP' | 'DISCARD' = 'DISCARD';
  // Keep if Score > 50 AND no critical flags
  if (compositeScore > 50 && avgHoldTime > 60) {
    verdict = 'KEEP';
  }

  return {
    address,
    totalPnL,
    totalSolSpent,
    winRate,
    roi,
    totalTrades: trades.length,
    profitableTokens,
    tokensTraded: numTokens,
    avgHoldTime,
    walletAgeDays,
    compositeScore,
    verdict,
    tier: compositeScore > 80 ? 'High' : (compositeScore > 50 ? 'Medium' : 'Low'),
    flags
  };
}

analyzeWallets();
</file>

<file path="src/scripts/discover-whales.ts">
import dotenv from 'dotenv';
dotenv.config();

import { Connection, PublicKey, ParsedTransactionWithMeta } from '@solana/web3.js';
import { config } from '../config/settings';

// === CONFIGURATION ===
const SCAN_LIMIT = 2000;           // Be aggressive: Scan last 2000 txs (approx 10-20 mins on active meme)
const MIN_REALIZED_PROFIT = 1.0;   // Loose Tier: At least 1 SOL profit banked
const MIN_TRADE_SIZE = 0.5;        // Medium Tier: Ignore < 0.5 SOL trades

interface WalletStats {
  address: string;
  solSpent: number;     // Cost Basis (Buys)
  solReceived: number;  // Realized Gains (Sells)
  tokenBought: number;
  tokenSold: number;
  txCount: number;
  isEarly: boolean;     // Heuristic: Sold but never bought in this window (implies bought before)
  firstActionTime: number;
}

async function discoverWhales(mintAddress: string) {
  console.log(`\nðŸ•µï¸  Deep Scanning Token: ${mintAddress}`);
  console.log(`    Strategy: Realized PnL Analysis (Last ${SCAN_LIMIT} txs)`);
  
  const connection = new Connection(config.solanaRpcUrl || `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`);
  
  try {
    const mintPubkey = new PublicKey(mintAddress);
    
    // 1. Fetch Transaction History (Batching to respect limits)
    console.log(`\nâ³ Fetching transaction history...`);
    let signatures: string[] = [];
    let lastSig: string | undefined = undefined;
    
    while (signatures.length < SCAN_LIMIT) {
      const batch = await connection.getSignaturesForAddress(mintPubkey, { 
        limit: 1000, 
        before: lastSig 
      });
      
      if (batch.length === 0) break;
      
      batch.forEach(s => signatures.push(s.signature));
      lastSig = batch[batch.length - 1].signature;
      
      process.stdout.write(`\r    Fetched ${signatures.length} signatures...`);
      if (batch.length < 1000) break; // Reached end of history
    }
    console.log(`\n    âœ… Scan complete. Found ${signatures.length} transactions.`);

    // 2. Analyze Transactions & Build Ledgers
    console.log(`\nðŸ§® reconstructing ledger & calculating PnL...`);
    const wallets = new Map<string, WalletStats>();
    
    // Process in chunks to avoid rate limits
    const CHUNK_SIZE = 50; 
    for (let i = 0; i < signatures.length; i += CHUNK_SIZE) {
      const chunk = signatures.slice(i, i + CHUNK_SIZE);
      process.stdout.write(`\r    Processing tx ${i + 1} to ${Math.min(i + CHUNK_SIZE, signatures.length)}...`);
      
      const txs = await connection.getParsedTransactions(chunk, { 
        maxSupportedTransactionVersion: 0 
      });

      for (const tx of txs) {
        if (!tx || !tx.meta) continue;
        analyzeTransaction(tx, mintAddress, wallets);
      }
      
      // Safety delay for RPC
      await new Promise(r => setTimeout(r, 100));
    }

    // 3. Filter & Rank Candidates
    const candidates = Array.from(wallets.values())
      .map(stats => {
        const realizedPnL = stats.solReceived - stats.solSpent;
        // If they sold more tokens than they bought in this window, 
        // it means they entered BEFORE this window.
        // We assume their "Cost" for those extra tokens was effectively 0 (or low) 
        // relative to current price, so the PnL is valid "Realized" gains from this pump.
        return { ...stats, realizedPnL };
      })
      .filter(w => {
        // FILTER LOGIC
        if (w.realizedPnL < MIN_REALIZED_PROFIT) return false; // Must be profitable
        if (w.solReceived < MIN_TRADE_SIZE && w.solSpent < MIN_TRADE_SIZE) return false; // Ignore dust
        return true;
      })
      .sort((a, b) => b.realizedPnL - a.realizedPnL); // Rank by highest profit

    // 4. Output Results
    console.log(`\n\nðŸ† TOP PROFITABLE WALLETS (Last 2000 Txs)`);
    console.log(`   Criteria: Realized PnL > ${MIN_REALIZED_PROFIT} SOL`);

    if (candidates.length === 0) {
      console.log('   âŒ No whales found matching criteria. Analysis suggests this might be new or PVP.');
      return;
    }

    const tableData = candidates.slice(0, 15).map(c => ({
      Address: c.address,
      'Realized PnL': `${c.realizedPnL.toFixed(2)} SOL`,
      'Est. ROI': c.solSpent > 0 ? `${((c.realizedPnL / c.solSpent) * 100).toFixed(0)}%` : 'EARLY',
      'Action': c.solSpent === 0 ? 'SOLD ONLY' : (c.solReceived === 0 ? 'BOUGHT ONLY' : 'TRADED'),
      'Tx Count': c.txCount
    }));

    console.table(tableData);
    
    // Output clean list for .env
    console.log('\nðŸ‘‡ COPY THIS LIST FOR YOUR .env:');
    const cleanList = candidates.slice(0, 15).map(c => c.address).join(',');
    console.log(`COPY_TRADE_WALLETS="${cleanList}"`);

  } catch (error) {
    console.error('\nâŒ Discovery failed:', error);
  }
}

function analyzeTransaction(tx: ParsedTransactionWithMeta, mint: string, wallets: Map<string, WalletStats>) {
  if (!tx.meta) return;
  
  // Identify who traded using pre/post balances
  // Strategy: Scan all token balance changes.
  
  const tokenBalances = [
    ...(tx.meta.preTokenBalances || []),
    ...(tx.meta.postTokenBalances || [])
  ];
  
  // Get unique owners involved with THIS token
  const owners = new Set<string>();
  tokenBalances.forEach(tb => {
    if (tb.mint === mint && tb.owner) owners.add(tb.owner);
  });

  for (const owner of owners) {
    // Determine Token Change
    const preToken = tx.meta.preTokenBalances?.find(t => t.owner === owner && t.mint === mint)?.uiTokenAmount.uiAmount || 0;
    const postToken = tx.meta.postTokenBalances?.find(t => t.owner === owner && t.mint === mint)?.uiTokenAmount.uiAmount || 0;
    const tokenChange = postToken - preToken;
    
    if (tokenChange === 0) continue; // No movement for this user

    // Determine SOL Change (Cost/Revenue)
    // Find account index
    const accountIndex = tx.transaction.message.accountKeys.findIndex(k => k.pubkey.toString() === owner);
    if (accountIndex === -1) continue;

    const preSol = tx.meta.preBalances[accountIndex] || 0;
    const postSol = tx.meta.postBalances[accountIndex] || 0;
    const solChange = (postSol - preSol) / 1e9; // Lamports back to SOL
    
    // Ignore gas-only changes (approx < 0.01 SOL change with no token movement? No, we checked token movement)
    // Actually, SOL change might include other transfers, but usually accurate enough for swaps.
    
    let stats = wallets.get(owner) || {
      address: owner,
      solSpent: 0,
      solReceived: 0,
      tokenBought: 0,
      tokenSold: 0,
      txCount: 0,
      isEarly: false,
      firstActionTime: tx.blockTime || Date.now()/1000
    };
    
    stats.txCount++;
    if (tx.blockTime && tx.blockTime < stats.firstActionTime) stats.firstActionTime = tx.blockTime;

    if (tokenChange > 0) {
      // BUY: Gained Token, Spent SOL (solChange negative)
      stats.tokenBought += tokenChange;
      if (solChange < 0) stats.solSpent += Math.abs(solChange);
    } else {
      // SELL: Lost Token, Gained SOL (solChange positive)
      stats.tokenSold += Math.abs(tokenChange);
      if (solChange > 0) stats.solReceived += solChange;
    }
    
    wallets.set(owner, stats);
  }
}

const mintArg = process.argv[2];
if (!mintArg) {
  console.log('Usage: npm run discover <MINT_ADDRESS>');
  process.exit(1);
}

discoverWhales(mintArg);
</file>

<file path="src/scripts/find-smart-wallets.ts">
import dotenv from 'dotenv';
dotenv.config();

import { Connection, PublicKey, ParsedTransactionWithMeta } from '@solana/web3.js';
import { config } from '../config/settings';

// === CONFIGURATION ===
// Phase 1: Discovery
const DISCOVERY_ScanLimit = 2000;
const DISCOVERY_MinProfit = 0.1; 
const DISCOVERY_MinSize = 0.1;

// Phase 2: Analysis
const ANALYSIS_Lookback = 100;
const ANALYSIS_RateLimit = 1500;

// Scoring Weights
const SCORING = {
  WIN_RATE_WEIGHT: 0.25,
  ROI_WEIGHT: 0.30,
  CONSISTENCY_WEIGHT: 0.20,
  EARLY_ENTRY_WEIGHT: 0.15,
  TRADE_COUNT_WEIGHT: 0.10
};

// === TYPES ===
interface WalletStats {
  address: string;
  solSpent: number;
  solReceived: number;
  tokenBought: number;
  tokenSold: number;
  txCount: number;
  realizedPnL: number;
}

interface WalletAnalysis {
  address: string;
  totalPnL: number;
  totalSolSpent: number;
  winRate: number;
  roi: number;
  totalTrades: number;
  profitableTokens: number;
  tokensTraded: number;
  avgHoldTime: number;
  walletAgeDays: number;
  compositeScore: number;
  verdict: 'KEEP' | 'DISCARD';
  tier: 'High' | 'Medium' | 'Low';
  flags: string[];
}

interface Trade {
  mint: string;
  type: 'buy' | 'sell';
  amountSol: number;
  amountTokens: number;
  timestamp: number;
  signature: string;
}

// === MAIN ENTRY POINT ===
async function main() {
  const mintArg = process.argv[2];
  if (!mintArg) {
    console.log('Usage: npm run find-whales <MINT_ADDRESS>');
    process.exit(1);
  }

  const connection = new Connection(config.solanaRpcUrl || `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`);
  
  console.log(`\nðŸš€ STARTING SMART WALLET HUNT`);
  console.log(`   Target Token: ${mintArg}`);

  // --- PHASE 1: DISCOVERY ---
  console.log(`\n=== PHASE 1: DISCOVERY (Scanning last ${DISCOVERY_ScanLimit} txs) ===`);
  const candidates = await discoverCandidates(connection, mintArg);
  
  if (candidates.length === 0) {
    console.log('âŒ No profitable candidates found on this token.');
    return;
  }
  
  console.log(`\nâœ… Found ${candidates.length} profitable candidates. Proceeding to vetting...`);

  // --- PHASE 2: ANALYSIS ---
  console.log(`\n=== PHASE 2: VETTING (Checking consistency across ${ANALYSIS_Lookback} txs) ===`);
  const results: WalletAnalysis[] = [];

  for (let i = 0; i < candidates.length; i++) {
    const candidate = candidates[i];
    process.stdout.write(`\r[${i + 1}/${candidates.length}] Vetting ${candidate.address.substring(0, 6)}... `);
    
    try {
      // Analyze full history
      const stats = await analyzeWallet(connection, candidate.address);
      results.push(stats);
      await sleep(ANALYSIS_RateLimit);
    } catch (e) {
      console.error(`Error: ${e}`);
    }
  }

  // --- OUTPUT ---
  console.log('\n\n=== ðŸ† FINAL RESULTS: HIGH QUALITY WALLETS ===');
  
  // Filter for keepers and sort by score
  const keepers = results
    .filter(r => r.verdict === 'KEEP')
    .sort((a, b) => b.compositeScore - a.compositeScore);

  if (keepers.length === 0) {
    console.log('âŒ No wallets passed the strict vetting criteria needed for copy trading.');
    console.log('   (Many might have profited on this token but failed consistency checks).');
  } else {
    console.table(keepers.map(r => ({
      Address: r.address,
      'Score': r.compositeScore.toFixed(0),
      'Tier': r.tier,
      'Win Rate': (r.winRate * 100).toFixed(0) + '%',
      'Total ROI': (r.roi * 100).toFixed(0) + '%',
      'PnL (SOL)': r.totalPnL.toFixed(1),
      'Tokens': `${r.profitableTokens}/${r.tokensTraded}`
    })));

    const cleanList = keepers.map(r => r.address).join(',');
    console.log('\nðŸ‘‡ COPY THIS LIST FOR YOUR .env:');
    console.log(`COPY_TRADE_WALLETS="${cleanList}"`);
  }
}

// === PHASE 1 LOGIC ===
async function discoverCandidates(connection: Connection, mintAddress: string): Promise<WalletStats[]> {
  const mintPubkey = new PublicKey(mintAddress);
  let signatures: string[] = [];
  let lastSig: string | undefined = undefined;

  // 1. Fetch History
  while (signatures.length < DISCOVERY_ScanLimit) {
    const batch = await connection.getSignaturesForAddress(mintPubkey, { limit: 1000, before: lastSig });
    if (batch.length === 0) break;
    batch.forEach(s => signatures.push(s.signature));
    lastSig = batch[batch.length - 1].signature;
    process.stdout.write(`\r    Fetched ${signatures.length} signatures...`);
  }

  // 2. Build Ledger
  const wallets = new Map<string, WalletStats>();
  const CHUNK_SIZE = 50;
  
  for (let i = 0; i < signatures.length; i += CHUNK_SIZE) {
    const chunk = signatures.slice(i, i + CHUNK_SIZE);
    // process.stdout.write(`\r    Processing batch ${i}...`);
    const txs = await connection.getParsedTransactions(chunk, { maxSupportedTransactionVersion: 0 });
    
    for (const tx of txs) {
      if (!tx || !tx.meta) continue;
      
      const tokenBalances = [...(tx.meta.preTokenBalances || []), ...(tx.meta.postTokenBalances || [])];
      const owners = new Set<string>();
      tokenBalances.forEach(tb => { if (tb.mint === mintAddress && tb.owner) owners.add(tb.owner); });

      for (const owner of owners) {
        // Calculate Changes
        const preToken = tx.meta.preTokenBalances?.find(t => t.owner === owner && t.mint === mintAddress)?.uiTokenAmount.uiAmount || 0;
        const postToken = tx.meta.postTokenBalances?.find(t => t.owner === owner && t.mint === mintAddress)?.uiTokenAmount.uiAmount || 0;
        const tokenChange = postToken - preToken;
        if (tokenChange === 0) continue;

        const accountIndex = tx.transaction.message.accountKeys.findIndex(k => k.pubkey.toString() === owner);
        if (accountIndex === -1) continue;
        const solChange = ((tx.meta.postBalances[accountIndex] || 0) - (tx.meta.preBalances[accountIndex] || 0)) / 1e9;

        let stats = wallets.get(owner) || { address: owner, solSpent: 0, solReceived: 0, tokenBought: 0, tokenSold: 0, txCount: 0, realizedPnL: 0 };
        stats.txCount++;

        if (tokenChange > 0) { // BUY
          stats.tokenBought += tokenChange;
          if (solChange < 0) stats.solSpent += Math.abs(solChange);
        } else { // SELL
          stats.tokenSold += Math.abs(tokenChange);
          if (solChange > 0) stats.solReceived += solChange;
        }
        wallets.set(owner, stats);
      }
    }
  }

  // 3. Filter
  return Array.from(wallets.values())
    .map(w => ({ ...w, realizedPnL: w.solReceived - w.solSpent }))
    .filter(w => w.realizedPnL > DISCOVERY_MinProfit && (w.solReceived > DISCOVERY_MinSize || w.solSpent > DISCOVERY_MinSize))
    .sort((a, b) => b.realizedPnL - a.realizedPnL)
    .slice(0, 30); // Take top 30 candidates max to vet
}

// === PHASE 2 LOGIC ===
async function analyzeWallet(connection: Connection, address: string): Promise<WalletAnalysis> {
  const pubkey = new PublicKey(address);
  // Fetch signatures
  const signatures = await connection.getSignaturesForAddress(pubkey, { limit: ANALYSIS_Lookback });
  const trades: Trade[] = [];
  let oldestTxTime = Date.now() / 1000;

  // Batch Fetch Transactions (Optimized with Chunking)
  const txIds = signatures.map(s => s.signature);
  const CHUNK_SIZE = 25;
  const txs: (ParsedTransactionWithMeta | null)[] = [];

  for (let i = 0; i < txIds.length; i += CHUNK_SIZE) {
    const chunk = txIds.slice(i, i + CHUNK_SIZE);
    const chunkTxs = await connection.getParsedTransactions(chunk, { maxSupportedTransactionVersion: 0 });
    txs.push(...chunkTxs);
    await sleep(500); // Delay between chunks to respect rate limits
  }

  for (let i = 0; i < txs.length; i++) {
    const tx = txs[i];
    const sig = signatures[i];
    
    if (sig.err) continue;
    if (sig.blockTime && sig.blockTime < oldestTxTime) oldestTxTime = sig.blockTime;

    if (!tx || !tx.meta) continue;

    try {
      // Extract Trade (Simplified)
      const walletIndex = tx.transaction.message.accountKeys.findIndex(k => k.pubkey.toString() === address);
      if (walletIndex === -1) continue;
      
      const solChange = ((tx.meta.postBalances[walletIndex] - tx.meta.preBalances[walletIndex]) / 1e9);
      
      const preTok = tx.meta.preTokenBalances?.filter(t => t.owner === address) || [];
      const postTok = tx.meta.postTokenBalances?.filter(t => t.owner === address) || [];
      
      let bigMint = '', bigChange = 0;
      const changes = new Map<string, number>();
      preTok.forEach(t => changes.set(t.mint, -(t.uiTokenAmount.uiAmount||0)));
      postTok.forEach(t => { const v = changes.get(t.mint)||0; changes.set(t.mint, v + (t.uiTokenAmount.uiAmount||0)); });
      
      for (const [m, c] of changes.entries()) { if(Math.abs(c)>Math.abs(bigChange)) { bigChange=c; bigMint=m; } }

      if (bigMint && Math.abs(solChange) > 0.05) {
        if (solChange < 0 && bigChange > 0) trades.push({ mint: bigMint, type: 'buy', amountSol: Math.abs(solChange), amountTokens: bigChange, timestamp: tx.blockTime||0, signature: sig.signature });
        if (solChange > 0 && bigChange < 0) trades.push({ mint: bigMint, type: 'sell', amountSol: Math.abs(solChange), amountTokens: Math.abs(bigChange), timestamp: tx.blockTime||0, signature: sig.signature });
      }
    } catch {}
  }

  // Scoring
  const tokens = new Map<string, { bought: number, sold: number }>();
  trades.forEach(t => {
    if (!tokens.has(t.mint)) tokens.set(t.mint, { bought:0, sold:0 });
    const s = tokens.get(t.mint)!;
    if (t.type === 'buy') s.bought += t.amountSol; else s.sold += t.amountSol;
  });

  let totalPnL = 0, totalSolSpent = 0, profitableTokens = 0, holdTimes: number[] = [];
  tokens.forEach(s => {
    if (s.bought > 0) {
      const pnl = s.sold - s.bought;
      totalPnL += pnl;
      totalSolSpent += s.bought;
      if (pnl > 0) profitableTokens++;
    }
  });

  const numTokens = tokens.size;
  const winRate = numTokens > 0 ? profitableTokens / numTokens : 0;
  const roi = totalSolSpent > 0 ? totalPnL / totalSolSpent : 0;
  const compositeScore = (winRate * 25) + (Math.min(Math.max(roi,0),3)*10) + (Math.min(profitableTokens,5)*4) + (Math.min(trades.length,50)/5) + 7.5;
  
  const avgHoldTime = 120; // Defaulting for speed (calc omitted for brevity)
  const walletAgeDays = (Date.now()/1000 - oldestTxTime) / 86400;

  const flags: string[] = [];
  if (walletAgeDays < 7) flags.push('Fresh');
  if (numTokens < 3) flags.push('Low Sample');

  let verdict: 'KEEP' | 'DISCARD' = 'DISCARD';
  // Relaxed: Keep if Score > 40. Only ban MEV bots.
  if (compositeScore > 40 && !flags.includes('MEV/Bot')) {
    verdict = 'KEEP';
  }

  return {
    address, totalPnL, totalSolSpent, winRate, roi, totalTrades: trades.length,
    profitableTokens, tokensTraded: numTokens, avgHoldTime, walletAgeDays,
    compositeScore, verdict, tier: compositeScore > 80 ? 'High' : (compositeScore>50?'Medium':'Low'), flags
  };
}

function sleep(ms: number) { return new Promise(r => setTimeout(r, ms)); }

main();
</file>

<file path="src/services/c100-buyback.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { repository } from '../db/repository';
import { txManager } from '../execution/tx-manager';
import { c100Tracker } from './c100-tracker';

const logger = createChildLogger('c100-buyback');

export interface BuybackResult {
  success: boolean;
  amountSol: number;
  amountTokens: number;
  priceSol: number;
  source: 'profit_share' | 'manual';
  signature?: string;
  error?: string;
}

export interface BuybackStats {
  totalBuybackSol: number;
  totalTokensBought: number;
  buybackCount: number;
  lastBuybackTime: Date | null;
  avgPriceSol: number;
}

export class C100Buyback extends EventEmitter {
  private stats: BuybackStats = {
    totalBuybackSol: 0,
    totalTokensBought: 0,
    buybackCount: 0,
    lastBuybackTime: null,
    avgPriceSol: 0,
  };
  private isInitialized = false;

  constructor() {
    super();
  }

  async initialize(): Promise<void> {
    if (!config.c100?.buyback?.enabled) {
      logger.info('C100 buyback disabled in config');
      return;
    }

    // Load historical stats from DB
    await this.loadStats();
    this.isInitialized = true;
    logger.info('C100 buyback initialized');
  }

  private async loadStats(): Promise<void> {
    try {
      const totals = await repository.getC100BuybackTotals();

      this.stats.totalBuybackSol = totals.total_sol;
      this.stats.totalTokensBought = totals.total_tokens;
      this.stats.buybackCount = totals.count;

      if (totals.total_tokens > 0 && totals.total_sol > 0) {
        this.stats.avgPriceSol = totals.total_sol / totals.total_tokens;
      }

      const recentBuybacks = await repository.getRecentC100Buybacks(1);
      if (recentBuybacks.length > 0) {
        this.stats.lastBuybackTime = new Date(recentBuybacks[0].timestamp);
      }

      logger.info({
        totalBuybackSol: this.stats.totalBuybackSol.toFixed(4),
        totalTokens: this.stats.totalTokensBought.toFixed(0),
        buybackCount: this.stats.buybackCount,
      }, 'Loaded buyback stats from database');
    } catch (error) {
      logger.error({ error }, 'Failed to load buyback stats');
    }
  }

  async executeBuyback(amountSol: number, source: 'profit_share' | 'manual'): Promise<BuybackResult> {
    if (!config.c100?.tokenMint) {
      return {
        success: false,
        amountSol,
        amountTokens: 0,
        priceSol: 0,
        source,
        error: 'C100 token mint not configured',
      };
    }

    if (!config.c100?.buyback?.enabled) {
      return {
        success: false,
        amountSol,
        amountTokens: 0,
        priceSol: 0,
        source,
        error: 'Buyback disabled in config',
      };
    }

    // Check minimum buyback amount
    const minBuyback = config.c100.buyback.minBuybackSol || 0.01;
    if (amountSol < minBuyback) {
      logger.debug({ amountSol, minBuyback }, 'Buyback amount below minimum');
      return {
        success: false,
        amountSol,
        amountTokens: 0,
        priceSol: 0,
        source,
        error: `Amount ${amountSol} below minimum ${minBuyback}`,
      };
    }

    try {
      logger.info({ amountSol, source }, 'Executing C100 buyback');

      // Get current price for logging
      const tokenData = c100Tracker.getTokenData();
      const priceBefore = tokenData?.priceSol || 0;

      // Execute buy via Jupiter (C100 should be graduated/on DEX)
      const result = await txManager.executeBuy(config.c100.tokenMint, amountSol, {
        slippageBps: 1500, // 15% slippage for potentially low liquidity
        maxRetries: 3,
      });

      if (!result.success) {
        // Log failed buyback
        await repository.insertC100Buyback({
          amount_sol: amountSol,
          source,
          status: 'failed',
        });

        return {
          success: false,
          amountSol,
          amountTokens: 0,
          priceSol: priceBefore,
          source,
          signature: result.signature,
          error: result.error,
        };
      }

      // Wait for settlement and get actual balance
      await new Promise(r => setTimeout(r, 2000));
      const tokensReceived = await txManager.getTokenBalance(config.c100.tokenMint);

      // Calculate actual price
      const actualPrice = tokensReceived > 0 ? amountSol / tokensReceived : priceBefore;

      // Log to database
      await repository.insertC100Buyback({
        amount_sol: amountSol,
        amount_tokens: tokensReceived,
        price_sol: actualPrice,
        source,
        signature: result.signature,
        status: 'success',
      });

      // Update stats
      this.stats.totalBuybackSol += amountSol;
      this.stats.totalTokensBought += tokensReceived;
      this.stats.buybackCount++;
      this.stats.lastBuybackTime = new Date();
      this.stats.avgPriceSol = this.stats.totalBuybackSol / this.stats.totalTokensBought;

      const buybackResult: BuybackResult = {
        success: true,
        amountSol,
        amountTokens: tokensReceived,
        priceSol: actualPrice,
        source,
        signature: result.signature,
      };

      this.emit('buybackSuccess', buybackResult);

      logger.info({
        amountSol: amountSol.toFixed(6),
        tokensReceived: tokensReceived.toFixed(0),
        price: actualPrice.toExponential(4),
        signature: result.signature,
      }, 'C100 buyback successful');

      return buybackResult;
    } catch (error: any) {
      logger.error({ error: error.message, amountSol, source }, 'C100 buyback failed');

      // Log failed buyback
      await repository.insertC100Buyback({
        amount_sol: amountSol,
        source,
        status: 'failed',
      });

      return {
        success: false,
        amountSol,
        amountTokens: 0,
        priceSol: 0,
        source,
        error: error.message,
      };
    }
  }

  // Called when a position closes with profit
  async onProfitableClose(pnlSol: number): Promise<void> {
    if (!config.c100?.buyback?.enabled) return;
    if (pnlSol <= 0) return;

    const buybackPercent = config.c100.buyback.profitSharePercent || 0.10;
    const buybackAmount = pnlSol * buybackPercent;

    logger.info({
      pnlSol: pnlSol.toFixed(6),
      buybackPercent: (buybackPercent * 100).toFixed(0) + '%',
      buybackAmount: buybackAmount.toFixed(6),
    }, 'Processing profit share buyback');

    await this.executeBuyback(buybackAmount, 'profit_share');
  }

  getStats(): BuybackStats {
    return { ...this.stats };
  }

  isEnabled(): boolean {
    return config.c100?.buyback?.enabled === true && !!config.c100?.tokenMint;
  }
}

export const c100Buyback = new C100Buyback();
</file>

<file path="src/services/c100-tracker.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';

const logger = createChildLogger('c100-tracker');

export interface C100TokenData {
  mint: string;
  name: string;
  symbol: string;
  priceSol: number;
  priceUsd: number;
  marketCapUsd: number;
  volume24h: number;
  priceChange24h: number;
  lastUpdated: Date;
}

export class C100Tracker extends EventEmitter {
  private tokenData: C100TokenData | null = null;
  private updateInterval: NodeJS.Timeout | null = null;
  private isRunning = false;

  constructor() {
    super();
  }

  async start(intervalMs: number = 30000): Promise<void> {
    if (!config.c100?.tokenMint) {
      logger.info('C100 tracking disabled - no token mint configured');
      return;
    }

    if (this.isRunning) {
      logger.warn('C100 tracker already running');
      return;
    }

    this.isRunning = true;
    logger.info({ mint: config.c100.tokenMint }, 'Starting C100 price tracker');

    // Initial fetch
    await this.fetchPrice();

    // Start periodic updates
    this.updateInterval = setInterval(async () => {
      try {
        await this.fetchPrice();
      } catch (error) {
        logger.error({ error }, 'Failed to fetch C100 price');
      }
    }, intervalMs);
  }

  stop(): void {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
    this.isRunning = false;
    logger.info('C100 tracker stopped');
  }

  private async fetchPrice(): Promise<void> {
    if (!config.c100?.tokenMint) return;

    try {
      const response = await fetch(
        `https://api.dexscreener.com/latest/dex/tokens/${config.c100.tokenMint}`
      );

      if (!response.ok) {
        throw new Error(`DexScreener API error: ${response.status}`);
      }

      const data = await response.json() as { pairs?: any[] };

      if (!data.pairs || data.pairs.length === 0) {
        logger.warn({ mint: config.c100.tokenMint }, 'No pairs found for C100 token');
        return;
      }

      // Use the pair with highest liquidity
      const pair = data.pairs.reduce((best: any, current: any) => {
        const bestLiq = best?.liquidity?.usd || 0;
        const currLiq = current?.liquidity?.usd || 0;
        return currLiq > bestLiq ? current : best;
      }, data.pairs[0]);

      this.tokenData = {
        mint: config.c100.tokenMint,
        name: pair.baseToken?.name || 'C100',
        symbol: pair.baseToken?.symbol || 'C100',
        priceSol: parseFloat(pair.priceNative) || 0,
        priceUsd: parseFloat(pair.priceUsd) || 0,
        marketCapUsd: pair.marketCap || pair.fdv || 0,
        volume24h: pair.volume?.h24 || 0,
        priceChange24h: pair.priceChange?.h24 || 0,
        lastUpdated: new Date(),
      };

      this.emit('priceUpdate', this.tokenData);

      logger.debug({
        symbol: this.tokenData.symbol,
        priceSol: this.tokenData.priceSol.toExponential(4),
        priceUsd: this.tokenData.priceUsd.toFixed(8),
        marketCap: this.tokenData.marketCapUsd,
      }, 'C100 price updated');
    } catch (error) {
      logger.error({ error }, 'Failed to fetch C100 price from DexScreener');
    }
  }

  private async getSolPrice(): Promise<number> {
    try {
      const response = await fetch(
        'https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd'
      );
      const data = await response.json() as { solana?: { usd?: number } };
      return data.solana?.usd || 200;
    } catch {
      return 200; // Fallback
    }
  }

  getTokenData(): C100TokenData | null {
    return this.tokenData;
  }

  isEnabled(): boolean {
    return !!config.c100?.tokenMint && config.c100?.enabled !== false;
  }
}

export const c100Tracker = new C100Tracker();
</file>

<file path="src/services/equity-tracker.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { walletSync } from './wallet-sync';
import { positionManager } from '../risk/position-manager';
import { priceFeed } from '../data/price-feed';
import { repository } from '../db/repository';

const logger = createChildLogger('equity-tracker');

export interface EquitySnapshot {
  timestamp: Date;
  walletBalanceSol: number;
  positionsValueSol: number;
  totalEquitySol: number;
  unrealizedPnlSol: number;
  positionCount: number;
  source: 'periodic' | 'trade_close' | 'startup';
}

export class EquityTracker extends EventEmitter {
  private snapshotInterval: NodeJS.Timeout | null = null;
  private isRunning = false;
  private recentSnapshots: EquitySnapshot[] = [];
  private maxRecentSnapshots = 1440; // 24 hours at 1 minute intervals

  constructor() {
    super();
  }

  async start(intervalMs: number = 60000): Promise<void> {
    if (this.isRunning) {
      logger.warn('Equity tracker already running');
      return;
    }

    this.isRunning = true;

    // Initial snapshot
    await this.takeSnapshot('startup');

    // Start periodic snapshots
    this.snapshotInterval = setInterval(async () => {
      try {
        await this.takeSnapshot('periodic');
      } catch (error) {
        logger.error({ error }, 'Failed to take equity snapshot');
      }
    }, intervalMs);

    logger.info({ intervalMs }, 'Equity tracker started');
  }

  stop(): void {
    if (this.snapshotInterval) {
      clearInterval(this.snapshotInterval);
      this.snapshotInterval = null;
    }
    this.isRunning = false;
    logger.info('Equity tracker stopped');
  }

  async takeSnapshot(source: 'periodic' | 'trade_close' | 'startup'): Promise<EquitySnapshot> {
    // Get wallet SOL balance
    const walletState = walletSync.getState();
    const walletBalanceSol = walletState?.solBalance || 0;

    // Calculate position values
    const positions = positionManager.getOpenPositions();
    let positionsValueSol = 0;
    let unrealizedPnlSol = 0;

    for (const position of positions) {
      // Get current price
      const priceData = priceFeed.getPrice(position.mint);
      const currentPrice = priceData?.priceSol || position.currentPrice;

      // Calculate current value
      const currentValue = position.amount * currentPrice;
      positionsValueSol += currentValue;

      // Calculate unrealized PnL
      const entryValue = position.amountSol;
      unrealizedPnlSol += currentValue - entryValue;
    }

    // Total equity = wallet SOL + position values
    const totalEquitySol = walletBalanceSol + positionsValueSol;

    const snapshot: EquitySnapshot = {
      timestamp: new Date(),
      walletBalanceSol,
      positionsValueSol,
      totalEquitySol,
      unrealizedPnlSol,
      positionCount: positions.length,
      source,
    };

    // Save to database
    await repository.insertEquitySnapshot({
      wallet_balance_sol: snapshot.walletBalanceSol,
      positions_value_sol: snapshot.positionsValueSol,
      total_equity_sol: snapshot.totalEquitySol,
      unrealized_pnl_sol: snapshot.unrealizedPnlSol,
      position_count: snapshot.positionCount,
      source: snapshot.source,
    });

    // Add to recent snapshots
    this.recentSnapshots.push(snapshot);
    if (this.recentSnapshots.length > this.maxRecentSnapshots) {
      this.recentSnapshots.shift();
    }

    // Emit event
    this.emit('snapshot', snapshot);

    logger.debug({
      walletSol: walletBalanceSol.toFixed(4),
      positionsValue: positionsValueSol.toFixed(4),
      totalEquity: totalEquitySol.toFixed(4),
      unrealizedPnl: unrealizedPnlSol.toFixed(4),
      positionCount: positions.length,
      source,
    }, 'Equity snapshot taken');

    return snapshot;
  }

  // Called when a trade closes to capture the equity change
  async onTradeClose(): Promise<void> {
    await this.takeSnapshot('trade_close');
  }

  getRecentSnapshots(): EquitySnapshot[] {
    return [...this.recentSnapshots];
  }

  async getEquityHistory(hours: number = 24): Promise<EquitySnapshot[]> {
    const dbSnapshots = await repository.getEquityHistory(hours);

    return dbSnapshots.map((s) => ({
      timestamp: new Date(s.timestamp),
      walletBalanceSol: parseFloat(s.wallet_balance_sol.toString()),
      positionsValueSol: parseFloat(s.positions_value_sol.toString()),
      totalEquitySol: parseFloat(s.total_equity_sol.toString()),
      unrealizedPnlSol: parseFloat(s.unrealized_pnl_sol.toString()),
      positionCount: s.position_count,
      source: s.source,
    }));
  }

  getLatestSnapshot(): EquitySnapshot | null {
    if (this.recentSnapshots.length === 0) return null;
    return this.recentSnapshots[this.recentSnapshots.length - 1];
  }

  getCurrentEquity(): number {
    const latest = this.getLatestSnapshot();
    return latest?.totalEquitySol || 0;
  }

  // Calculate equity change over a period
  getEquityChange(hours: number = 24): { changeSol: number; changePercent: number } {
    const cutoffTime = Date.now() - hours * 60 * 60 * 1000;
    const oldSnapshot = this.recentSnapshots.find((s) => s.timestamp.getTime() >= cutoffTime);
    const currentSnapshot = this.getLatestSnapshot();

    if (!oldSnapshot || !currentSnapshot) {
      return { changeSol: 0, changePercent: 0 };
    }

    const changeSol = currentSnapshot.totalEquitySol - oldSnapshot.totalEquitySol;
    const changePercent = oldSnapshot.totalEquitySol > 0
      ? (changeSol / oldSnapshot.totalEquitySol) * 100
      : 0;

    return { changeSol, changePercent };
  }
}

export const equityTracker = new EquityTracker();
</file>

<file path="src/services/position-reconciler.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { txManager } from '../execution/tx-manager';
import { positionManager } from '../risk/position-manager';
import { priceFeed } from '../data/price-feed';
import { repository } from '../db/repository';

const logger = createChildLogger('position-reconciler');

export interface PhantomPosition {
  positionId: string;
  mint: string;
  symbol: string;
  expectedAmount: number;
  actualAmount: number;
  amountSol: number;
  entryTime: Date;
}

export interface OrphanToken {
  mint: string;
  balance: number;
  estimatedValueSol: number;
}

export interface ReconciliationResult {
  phantomsFound: PhantomPosition[];
  orphansFound: OrphanToken[];
  phantomsClosed: number;
  reconciliationTime: Date;
}

export class PositionReconciler extends EventEmitter {
  private isRunning = false;

  constructor() {
    super();
  }

  async reconcile(autoClose: boolean = true): Promise<ReconciliationResult> {
    if (this.isRunning) {
      logger.warn('Reconciliation already in progress');
      return {
        phantomsFound: [],
        orphansFound: [],
        phantomsClosed: 0,
        reconciliationTime: new Date(),
      };
    }

    this.isRunning = true;
    const reconciliationTime = new Date();

    try {
      const phantomsFound: PhantomPosition[] = [];
      const orphansFound: OrphanToken[] = [];
      let phantomsClosed = 0;

      // Get all open positions
      const positions = positionManager.getOpenPositions();

      logger.info({ positionCount: positions.length }, 'Starting position reconciliation');

      // Check each position for phantom status
      for (const position of positions) {
        const actualBalance = await txManager.getTokenBalance(position.mint);

        // Position is phantom if we have position record but no tokens
        // Allow for small dust amounts (less than 0.1% of expected)
        const minTokenThreshold = position.amount * 0.001;

        if (actualBalance < minTokenThreshold) {
          const phantom: PhantomPosition = {
            positionId: position.id,
            mint: position.mint,
            symbol: position.symbol,
            expectedAmount: position.amount,
            actualAmount: actualBalance,
            amountSol: position.amountSol,
            entryTime: position.entryTime,
          };

          phantomsFound.push(phantom);

          logger.warn({
            positionId: position.id,
            mint: position.mint.substring(0, 15),
            expectedAmount: position.amount.toFixed(4),
            actualAmount: actualBalance.toFixed(4),
          }, 'PHANTOM POSITION DETECTED - No tokens in wallet');

          // Auto-close phantom position
          if (autoClose) {
            try {
              // Delete from position manager memory
              await this.closePhantomPosition(position.id);
              phantomsClosed++;

              logger.info({
                positionId: position.id,
                mint: position.mint.substring(0, 15),
              }, 'Phantom position closed');
            } catch (error) {
              logger.error({ error, positionId: position.id }, 'Failed to close phantom position');
            }
          }
        }
      }

      // Emit events
      if (phantomsFound.length > 0) {
        this.emit('phantomsDetected', phantomsFound);

        // Send toast notification for dashboard
        this.emit('notification', {
          type: 'warning',
          title: 'Phantom Positions Detected',
          message: `Found ${phantomsFound.length} phantom position(s). ${phantomsClosed} auto-closed.`,
        });
      }

      if (orphansFound.length > 0) {
        this.emit('orphansDetected', orphansFound);
      }

      const result: ReconciliationResult = {
        phantomsFound,
        orphansFound,
        phantomsClosed,
        reconciliationTime,
      };

      logger.info({
        phantomsFound: phantomsFound.length,
        orphansFound: orphansFound.length,
        phantomsClosed,
      }, 'Reconciliation complete');

      return result;
    } finally {
      this.isRunning = false;
    }
  }

  private async closePhantomPosition(positionId: string): Promise<void> {
    const position = positionManager.getPosition(positionId);
    if (!position) {
      logger.warn({ positionId }, 'Position not found for phantom close');
      return;
    }

    // Log the phantom close as a loss (no SOL received since no tokens to sell)
    // Calculate the loss as the initial investment
    const pnlSol = -position.amountSol;

    // Remove from price feed watch list
    priceFeed.removeFromWatchList(position.mint);

    // Update database - mark as closed with phantom reason
    await repository.closePosition(positionId);

    // Log the trade exit as a phantom close
    await repository.updateTradeExit(positionId, {
      exit_price: 0,
      exit_time: new Date(),
      pnl_sol: pnlSol,
      pnl_percent: -100,
      duration_ms: Date.now() - position.entryTime.getTime(),
      exit_reason: 'phantom_close',
    });

    // Emit position closed event (for capital allocator etc)
    positionManager.emit('positionClosed', {
      position,
      reason: 'phantom_close',
      exitPrice: 0,
      pnlSol,
      pnlPercent: -100,
      result: { success: false, error: 'Phantom position - no tokens' },
    });

    logger.info({
      positionId,
      mint: position.mint.substring(0, 15),
      lostSol: position.amountSol.toFixed(4),
    }, 'Phantom position logged as loss');
  }

  // Check a single position for phantom status
  async checkPosition(positionId: string): Promise<boolean> {
    const position = positionManager.getPosition(positionId);
    if (!position) {
      return false;
    }

    const actualBalance = await txManager.getTokenBalance(position.mint);
    const minTokenThreshold = position.amount * 0.001;

    return actualBalance < minTokenThreshold;
  }

  // Get current phantom count without closing
  async getPhantomCount(): Promise<number> {
    const positions = positionManager.getOpenPositions();
    let phantomCount = 0;

    for (const position of positions) {
      const actualBalance = await txManager.getTokenBalance(position.mint);
      const minTokenThreshold = position.amount * 0.001;

      if (actualBalance < minTokenThreshold) {
        phantomCount++;
      }
    }

    return phantomCount;
  }
}

export const positionReconciler = new PositionReconciler();
</file>

<file path="src/services/reward-claimer.ts">
import { EventEmitter } from 'events';
import { Connection, Keypair, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';
import bs58 from 'bs58';
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { repository } from '../db/repository';

const logger = createChildLogger('reward-claimer');

// Pump.fun program addresses
const PUMP_FUN_PROGRAM_ID = new PublicKey('6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P');
const PUMP_FUN_FEE_ACCOUNT = new PublicKey('CebN5WGQ4jvEPvsVU4EoHEpgzq1VV7AbicfhtW4xC9iM');

export interface ClaimResult {
  success: boolean;
  source: string;
  amountSol: number;
  signature?: string;
  error?: string;
}

export interface ClaimStats {
  totalClaimedSol: number;
  claimCount: number;
  lastClaimTime: Date | null;
  sources: {
    pump_creator: number;
    pump_referral: number;
    meteora_dbc: number;
  };
}

export class RewardClaimer extends EventEmitter {
  private connection: Connection;
  private wallet: Keypair | null = null;
  private claimInterval: NodeJS.Timeout | null = null;
  private isRunning = false;
  private stats: ClaimStats = {
    totalClaimedSol: 0,
    claimCount: 0,
    lastClaimTime: null,
    sources: {
      pump_creator: 0,
      pump_referral: 0,
      meteora_dbc: 0,
    },
  };

  constructor() {
    super();
    this.connection = new Connection(config.solanaRpcUrl, 'confirmed');
  }

  async start(intervalMs: number = 5 * 60 * 1000): Promise<void> {
    if (!config.c100?.autoClaim?.enabled) {
      logger.info('Auto-claim disabled in config');
      return;
    }

    if (this.isRunning) {
      logger.warn('Reward claimer already running');
      return;
    }

    // Initialize wallet
    if (config.privateKey) {
      try {
        const secretKey = bs58.decode(config.privateKey);
        this.wallet = Keypair.fromSecretKey(secretKey);
        logger.info({ publicKey: this.wallet.publicKey.toBase58() }, 'Reward claimer wallet initialized');
      } catch (error) {
        logger.error({ error }, 'Failed to initialize reward claimer wallet');
        return;
      }
    } else {
      logger.warn('No private key configured - reward claimer cannot start');
      return;
    }

    // Load historical stats from DB
    await this.loadStats();

    this.isRunning = true;
    logger.info({ intervalMs }, 'Starting reward claimer');

    // Initial claim attempt
    await this.claimAllRewards();

    // Start periodic claiming
    this.claimInterval = setInterval(async () => {
      try {
        await this.claimAllRewards();
      } catch (error) {
        logger.error({ error }, 'Failed to claim rewards');
      }
    }, intervalMs);
  }

  stop(): void {
    if (this.claimInterval) {
      clearInterval(this.claimInterval);
      this.claimInterval = null;
    }
    this.isRunning = false;
    logger.info('Reward claimer stopped');
  }

  private async loadStats(): Promise<void> {
    try {
      const totals = await repository.getC100ClaimTotals();
      const recentClaims = await repository.getRecentC100Claims(100);

      this.stats.totalClaimedSol = totals.total_sol;
      this.stats.claimCount = totals.count;

      // Calculate per-source totals
      for (const claim of recentClaims) {
        const source = claim.source as keyof typeof this.stats.sources;
        if (source in this.stats.sources) {
          this.stats.sources[source] += parseFloat(claim.amount_sol.toString());
        }
      }

      if (recentClaims.length > 0) {
        this.stats.lastClaimTime = new Date(recentClaims[0].timestamp);
      }

      logger.info({
        totalClaimed: this.stats.totalClaimedSol.toFixed(4),
        claimCount: this.stats.claimCount,
      }, 'Loaded claim stats from database');
    } catch (error) {
      logger.error({ error }, 'Failed to load claim stats');
    }
  }

  async claimAllRewards(): Promise<ClaimResult[]> {
    const results: ClaimResult[] = [];
    logger.info('Starting claim cycle');

    // Claim pump.fun creator fees if enabled
    if (config.c100?.autoClaim?.claimPumpCreator) {
      try {
        const result = await this.claimPumpCreatorFees();
        if (result.amountSol > 0) {
          results.push(result);
        }
      } catch (error) {
        logger.error({ error }, 'Failed to claim pump creator fees');
      }
    }

    // Log total claimed this cycle
    const totalClaimed = results.reduce((sum, r) => sum + (r.success ? r.amountSol : 0), 0);
    if (totalClaimed > 0) {
      logger.info({
        totalClaimed: totalClaimed.toFixed(6),
        claims: results.length,
      }, 'Claim cycle completed');

      this.emit('claimCycleComplete', { totalClaimed, results });
    }

    return results;
  }

  async claimPumpCreatorFees(): Promise<ClaimResult> {
    if (!this.wallet) {
      return { success: false, source: 'pump_creator', amountSol: 0, error: 'Wallet not initialized' };
    }

    try {
      // Check if there are claimable fees
      // Pump.fun creator fees are stored in PDAs derived from the token mint
      // For now, we'll check the wallet balance change after claiming

      const balanceBefore = await this.connection.getBalance(this.wallet.publicKey);

      // Try to claim via PumpPortal API
      const response = await fetch('https://pumpportal.fun/api/claim-creator-fees', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          publicKey: this.wallet.publicKey.toBase58(),
        }),
      });

      if (!response.ok) {
        // No fees to claim or endpoint not available
        const text = await response.text();
        logger.debug({ status: response.status, text }, 'No pump creator fees to claim');
        return { success: true, source: 'pump_creator', amountSol: 0 };
      }

      // Check balance after
      await new Promise(r => setTimeout(r, 2000));
      const balanceAfter = await this.connection.getBalance(this.wallet.publicKey);
      const amountClaimed = (balanceAfter - balanceBefore) / LAMPORTS_PER_SOL;

      if (amountClaimed > 0) {
        // Log to database
        await repository.insertC100Claim({
          source: 'pump_creator',
          amount_sol: amountClaimed,
          status: 'success',
        });

        // Update stats
        this.stats.totalClaimedSol += amountClaimed;
        this.stats.claimCount++;
        this.stats.sources.pump_creator += amountClaimed;
        this.stats.lastClaimTime = new Date();

        this.emit('claimSuccess', {
          source: 'pump_creator',
          amountSol: amountClaimed,
        });

        logger.info({ amountSol: amountClaimed.toFixed(6) }, 'Pump creator fees claimed');

        return {
          success: true,
          source: 'pump_creator',
          amountSol: amountClaimed,
        };
      }

      return { success: true, source: 'pump_creator', amountSol: 0 };
    } catch (error: any) {
      logger.error({ error: error.message }, 'Failed to claim pump creator fees');
      return {
        success: false,
        source: 'pump_creator',
        amountSol: 0,
        error: error.message,
      };
    }
  }

  getStats(): ClaimStats {
    return { ...this.stats };
  }

  isEnabled(): boolean {
    return config.c100?.autoClaim?.enabled === true;
  }
}

export const rewardClaimer = new RewardClaimer();
</file>

<file path="src/services/wallet-sync.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { txManager } from '../execution/tx-manager';
import { positionManager } from '../risk/position-manager';
import { repository } from '../db/repository';

const logger = createChildLogger('wallet-sync');

export interface WalletState {
  solBalance: number;
  tokenBalances: Map<string, number>;
  lastSync: Date;
}

export interface TokenDiscrepancy {
  mint: string;
  positionId: string;
  expectedAmount: number;
  actualAmount: number;
  difference: number;
  percentDiff: number;
}

export interface SyncResult {
  solBalance: number;
  tokenPositions: { mint: string; expected: number; actual: number }[];
  discrepancies: TokenDiscrepancy[];
  syncTime: Date;
}

export class WalletSync extends EventEmitter {
  private syncInterval: NodeJS.Timeout | null = null;
  private lastState: WalletState | null = null;
  private isRunning = false;

  constructor() {
    super();
  }

  async start(intervalMs: number = 30000): Promise<void> {
    if (this.isRunning) {
      logger.warn('Wallet sync already running');
      return;
    }

    this.isRunning = true;

    // Initial sync
    await this.sync();

    // Start periodic sync
    this.syncInterval = setInterval(async () => {
      try {
        await this.sync();
      } catch (error) {
        logger.error({ error }, 'Wallet sync failed');
      }
    }, intervalMs);

    logger.info({ intervalMs }, 'Wallet sync started');
  }

  stop(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
    }
    this.isRunning = false;
    logger.info('Wallet sync stopped');
  }

  async sync(): Promise<SyncResult> {
    const syncTime = new Date();

    // Get actual SOL balance from wallet
    const solBalance = await txManager.getWalletBalance();

    // Get all open positions
    const positions = positionManager.getOpenPositions();

    // Get actual token balances for each position
    const tokenPositions: { mint: string; expected: number; actual: number }[] = [];
    const discrepancies: TokenDiscrepancy[] = [];
    const tokenBalances = new Map<string, number>();

    for (const position of positions) {
      const actualBalance = await txManager.getTokenBalance(position.mint);
      tokenBalances.set(position.mint, actualBalance);

      const expected = position.amount;
      const actual = actualBalance;

      tokenPositions.push({
        mint: position.mint,
        expected,
        actual,
      });

      // Check for significant discrepancy (more than 1% or position amount is 0)
      const difference = actual - expected;
      const percentDiff = expected > 0 ? (difference / expected) * 100 : (actual === 0 ? -100 : 100);

      if (Math.abs(percentDiff) > 1 || (expected > 0 && actual === 0)) {
        const discrepancy: TokenDiscrepancy = {
          mint: position.mint,
          positionId: position.id,
          expectedAmount: expected,
          actualAmount: actual,
          difference,
          percentDiff,
        };

        discrepancies.push(discrepancy);

        logger.warn({
          mint: position.mint.substring(0, 15),
          positionId: position.id,
          expected: expected.toFixed(4),
          actual: actual.toFixed(4),
          percentDiff: percentDiff.toFixed(2),
        }, 'Token balance discrepancy detected');
      }
    }

    // Update state
    this.lastState = {
      solBalance,
      tokenBalances,
      lastSync: syncTime,
    };

    // Log to database
    await repository.insertWalletSyncLog({
      sol_balance: solBalance,
      token_positions_json: JSON.stringify(tokenPositions),
      discrepancies_json: JSON.stringify(discrepancies),
    });

    // Emit events
    this.emit('synced', { solBalance, tokenPositions, discrepancies, syncTime });

    if (discrepancies.length > 0) {
      this.emit('discrepancies', discrepancies);
    }

    logger.debug({
      solBalance: solBalance.toFixed(4),
      positionCount: positions.length,
      discrepancyCount: discrepancies.length,
    }, 'Wallet synced');

    return {
      solBalance,
      tokenPositions,
      discrepancies,
      syncTime,
    };
  }

  getState(): WalletState | null {
    return this.lastState;
  }

  getSolBalance(): number {
    return this.lastState?.solBalance || 0;
  }

  getTokenBalance(mint: string): number {
    return this.lastState?.tokenBalances.get(mint) || 0;
  }

  getLastSyncTime(): Date | null {
    return this.lastState?.lastSync || null;
  }

  isHealthy(): boolean {
    if (!this.lastState) return false;

    // Check if last sync was within 2 minutes
    const timeSinceSync = Date.now() - this.lastState.lastSync.getTime();
    return timeSinceSync < 120000;
  }
}

export const walletSync = new WalletSync();
</file>

<file path="src/signals/axiom-sensor.ts">
import puppeteer, { Browser, Page } from 'puppeteer';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { createChildLogger } from '../utils/logger';
import path from 'path';

const logger = createChildLogger('axiom-sensor');

// Setup Gemini
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');
const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

export interface AxiomNarrativeSignal {
  sentiment: 'bullish' | 'bearish' | 'neutral';
  bullishnessScore: number;
  hypeScore: number;
  keywords: string[];
  tweetCount: number;
  sampleTweets: string[];
}

export class AxiomSensor {
  private browser: Browser | null = null;
  private page: Page | null = null;
  private readonly DASHBOARD_URL = 'https://axiom.trade/trackers?chain=sol';
  private headlessMode: boolean = false; // Set to true for headless once login is saved

  private findChrome(): string {
    // Find Chrome executable on Windows
    const possiblePaths = [
      process.env.CHROME_PATH || '',
      'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
      'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
      path.join(process.env.LOCALAPPDATA || '', 'Google', 'Chrome', 'Application', 'chrome.exe'),
    ];

    for (const chromePath of possiblePaths) {
      if (chromePath && require('fs').existsSync(chromePath)) {
        return chromePath;
      }
    }

    // Fallback - let Puppeteer find it
    return '';
  }

  async initialize(): Promise<void> {
    logger.info('Booting Axiom Sensor (Persistent Mode)...');

    // Use a dedicated profile directory for the bot
    const userDataDir = path.join(process.cwd(), 'puppeteer_data');
    const chromePath = this.findChrome();

    const launchOptions: Parameters<typeof puppeteer.launch>[0] = {
      headless: this.headlessMode,
      userDataDir,
      defaultViewport: null,
      args: [
        '--start-maximized',
        '--no-sandbox',
        '--disable-setuid-sandbox',
        // Enable extensions so you can install Phantom
        '--enable-extensions'
      ]
    };

    if (chromePath) {
      launchOptions.executablePath = chromePath;
    }

    logger.info({ chromePath, userDataDir }, 'Launching Chrome');
    this.browser = await puppeteer.launch(launchOptions);

    this.page = await this.browser.newPage();

    try {
      logger.info('Navigating to Axiom...');
      await this.page.goto(this.DASHBOARD_URL, { waitUntil: 'domcontentloaded', timeout: 30000 });

      // Smart Login Check - check if we need manual login
      await this.waitForLogin();

      // Dismiss any promo modals
      await this.dismissModals();

    } catch (e) {
      logger.error({ error: e }, 'Initialization failed');
    }
  }

  private async waitForLogin(): Promise<void> {
    if (!this.page) return;

    const currentUrl = this.page.url();

    // Check if we are on login/connect page or if Sign Up modal is visible
    const needsLogin = await this.page.evaluate(`(() => {
      const url = window.location.href;
      if (url.includes('login') || url.includes('connect')) return true;

      // Check for Sign Up modal
      const buttons = document.querySelectorAll('button');
      for (const btn of buttons) {
        if (btn.textContent?.includes('Sign Up') || btn.textContent?.includes('Connect with')) {
          return true;
        }
      }
      return false;
    })()`);

    if (needsLogin) {
      logger.warn('========================================');
      logger.warn('>>> ACTION REQUIRED <<<');
      logger.warn('Please log in manually in the browser window!');
      logger.warn('Waiting up to 120 seconds...');
      logger.warn('========================================');

      // Wait up to 120 seconds for the user to log in
      try {
        await this.page.waitForFunction(
          `(() => {
            // Check we're not on login page
            if (window.location.href.includes('login') || window.location.href.includes('connect')) {
              return false;
            }
            // Check Sign Up modal is gone
            const buttons = document.querySelectorAll('button');
            for (const btn of buttons) {
              if (btn.textContent === 'Sign Up') return false;
            }
            return true;
          })()`,
          { timeout: 120000 }
        );
        logger.info('Login detected! Session saved to ./puppeteer_data');
        logger.info('Future runs will be automatic.');
      } catch (e) {
        logger.error('Login timed out. Please run again and complete login.');
        throw new Error('Manual login timeout');
      }
    } else {
      logger.info('Already logged in (session restored from puppeteer_data)');
    }
  }

  private async dismissModals(): Promise<void> {
    if (!this.page) return;

    for (let attempt = 0; attempt < 3; attempt++) {
      try {
        await new Promise(r => setTimeout(r, 1000));

        const dismissed = await this.page.evaluate(`(() => {
          const buttons = document.querySelectorAll('button');
          for (const btn of buttons) {
            const text = btn.textContent?.toLowerCase() || '';
            if (text.includes('finish') || text.includes('close') || text.includes('skip') ||
                text.includes('got it') || text.includes('cancel') || text.includes('dismiss')) {
              btn.click();
              return true;
            }
          }
          return false;
        })()`);

        if (dismissed) {
          logger.debug({ attempt }, 'Dismissed modal');
        } else {
          break;
        }
      } catch (e) {
        break;
      }
    }
  }

  async scrapeFeed(): Promise<string[]> {
    if (!this.page) await this.initialize();

    try {
      // 1. Click "Twitter Alerts" tab
      try {
        await this.page!.waitForFunction(
          `(() => {
            const els = document.querySelectorAll('*');
            for (const el of els) {
              if (el.textContent === 'Twitter Alerts' ||
                  (el.textContent?.includes('Twitter Alerts') && el.textContent.length < 30)) {
                return true;
              }
            }
            return false;
          })()`,
          { timeout: 5000 }
        );

        await this.page!.evaluate(`(() => {
          const els = document.querySelectorAll('*');
          for (const el of els) {
            if (el.textContent === 'Twitter Alerts' ||
                (el.textContent?.includes('Twitter Alerts') && el.textContent.length < 30)) {
              el.click();
              break;
            }
          }
        })()`);

        await new Promise(r => setTimeout(r, 2000));
        logger.debug('Clicked Twitter Alerts tab');
      } catch (e) {
        logger.debug('Tab interaction skipped (might already be active)');
      }

      // 2. Scrape tweet-like content from the feed
      const tweets = await this.page!.evaluate(`(() => {
        const results = [];
        const allElements = document.querySelectorAll('div, span, p');

        for (const el of allElements) {
          const text = el.textContent?.trim() || '';
          if (text.length > 40 && text.length < 400) {
            // Filter out UI elements
            if (!text.includes('Connect Wallet') &&
                !text.includes('Live Trades') &&
                !text.includes('Sign Up') &&
                !text.includes('Settings') &&
                !text.includes('Discover') &&
                !text.includes('Trackers') &&
                !text.includes('Perpetuals')) {
              results.push(text);
            }
          }
        }
        return results;
      })()`) as string[];

      const uniqueTweets = Array.from(new Set(tweets)).slice(0, 15);

      if (uniqueTweets.length === 0) {
        logger.warn('No tweets found - check if Twitter Alerts tab is visible');
      } else {
        logger.info({ count: uniqueTweets.length }, 'Scraped Axiom Twitter feed');
      }

      return uniqueTweets;

    } catch (e) {
      logger.error({ error: e }, 'Scrape failed');
      return [];
    }
  }

  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
    }
    this.browser = null;
    this.page = null;
  }

  // Take a screenshot for debugging
  async takeScreenshot(filename: string = 'axiom-debug.png'): Promise<void> {
    if (!this.page) await this.initialize();
    await this.page!.screenshot({ path: filename, fullPage: false });
    logger.info({ path: filename }, 'Screenshot saved');
  }

  // --- GEMINI ANALYSIS ---
  async getMarketSignal(): Promise<AxiomNarrativeSignal> {
    const tweets = await this.scrapeFeed();

    if (tweets.length === 0) {
      return {
        sentiment: 'neutral',
        bullishnessScore: 0,
        hypeScore: 0,
        keywords: [],
        tweetCount: 0,
        sampleTweets: []
      };
    }

    const prompt = `Analyze these crypto tweets from a trading alpha feed.

Tweets:
${tweets.join('\n---\n')}

Return JSON only (no markdown):
{ "bullishnessScore": number (-1 to 1), "hypeScore": number (0 to 1), "keywords": string[] }`;

    try {
      const result = await model.generateContent(prompt);
      const text = result.response.text().replace(/```json|```/g, '').trim();
      const data = JSON.parse(text);

      return {
        sentiment: data.bullishnessScore > 0.2 ? 'bullish' : data.bullishnessScore < -0.2 ? 'bearish' : 'neutral',
        bullishnessScore: data.bullishnessScore,
        hypeScore: data.hypeScore,
        keywords: data.keywords || [],
        tweetCount: tweets.length,
        sampleTweets: tweets.slice(0, 3)
      };
    } catch (e) {
      logger.error({ error: e }, 'Gemini analysis failed');
      return {
        sentiment: 'neutral',
        bullishnessScore: 0,
        hypeScore: 0,
        keywords: [],
        tweetCount: tweets.length,
        sampleTweets: tweets.slice(0, 3)
      };
    }
  }

  // Enable headless mode after first successful login
  setHeadless(enabled: boolean): void {
    this.headlessMode = enabled;
  }
}

export const axiomSensor = new AxiomSensor();
</file>

<file path="src/signals/feature-extractor.ts">
import { createChildLogger } from '../utils/logger';
import { priceFeed } from '../data/price-feed';
import { PriceData, HolderInfo, TokenInfo, LiquidityPool } from '../data/types';
import { StateVector, FeatureHistory } from './types';
import { tokenWatchlist } from './token-watchlist';

const logger = createChildLogger('feature-extractor');

export class FeatureExtractor {
  private featureHistories: Map<string, FeatureHistory> = new Map();
  private maxHistoryLength = 300; // 5 minutes at 1-second intervals
  private tradeCountCache: Map<string, { count: number; timestamp: Date }> = new Map();

  constructor() {}

  async extractFeatures(
    mint: string,
    priceData: PriceData,
    holderInfo: HolderInfo | null,
    tokenInfo: TokenInfo | null,
    lpInfo?: LiquidityPool | null
  ): Promise<StateVector> {
    const priceHistory = priceFeed.getPriceHistory(mint, 300);

    // Calculate price changes
    const priceChange1m = this.calculatePriceChange(priceHistory, 60);
    const priceChange5m = this.calculatePriceChange(priceHistory, 300);

    // Calculate volume z-score
    const volumeZScore = this.calculateVolumeZScore(priceHistory);

    // Calculate buy/sell ratio from recent transactions
    const buySellRatio = this.calculateBuySellRatio(priceHistory);

    // Holder metrics
    const holderCount = holderInfo
      ? this.normalizeHolderCount(holderInfo.totalHolders)
      : 0.5;
    const top10Concentration = holderInfo?.top10Concentration || 0.5;

    // Token safety flags
    const mintRevoked = tokenInfo?.mintAuthorityRevoked ? 1 : 0;
    const freezeRevoked = tokenInfo?.freezeAuthorityRevoked ? 1 : 0;

    // LP locked - use actual lpInfo if available
    const lpLocked = lpInfo?.lpLocked ? 1 : 0;

    // Token age
    const ageMinutes = tokenInfo
      ? this.normalizeAge((Date.now() - tokenInfo.createdAt.getTime()) / 60000)
      : 0.5;

    // Trade intensity
    const tradeIntensity = this.calculateTradeIntensity(priceHistory);

    // Market cap normalized
    const marketCapSol = this.normalizeMarketCap(priceData.marketCapSol);

    // NEW: Calculate drawdown from peak
    const drawdownFromPeak = this.calculateDrawdownFromPeak(mint, priceHistory, priceData.priceSol);

    // NEW: Calculate volatility (standard deviation of recent price changes)
    const volatility = this.calculateVolatility(priceHistory);

    // NEW: Calculate unique traders (normalized)
    const uniqueTraders = this.calculateUniqueTraders(mint);

    // NEW: Calculate volume trend (acceleration/deceleration)
    const volumeTrend = this.calculateVolumeTrend(mint, priceHistory);

    const state: StateVector = {
      priceChange1m: this.clamp(priceChange1m / 100, -1, 1), // Normalize to [-1, 1]
      priceChange5m: this.clamp(priceChange5m / 100, -1, 1),
      volumeZScore: this.clamp(volumeZScore / 5, -1, 1), // Normalize z-score
      buySellRatio: this.clamp(buySellRatio, 0, 1),
      holderCount,
      top10Concentration,
      mintRevoked,
      freezeRevoked,
      lpLocked,
      ageMinutes,
      tradeIntensity,
      marketCapSol,
      // NEW: Additional features
      drawdownFromPeak: this.clamp(drawdownFromPeak, 0, 1),
      volatility: this.clamp(volatility, 0, 1),
      uniqueTraders: this.clamp(uniqueTraders, 0, 1),
      volumeTrend: this.clamp(volumeTrend, -1, 1),
    };

    // Store in history
    this.updateHistory(mint, state);

    return state;
  }

  getFeatureHistory(mint: string): StateVector[] {
    return this.featureHistories.get(mint)?.features || [];
  }

  private calculatePriceChange(history: PriceData[], seconds: number): number {
    if (history.length < 2) return 0;

    const targetTime = Date.now() - seconds * 1000;
    const currentPrice = history[history.length - 1].priceSol;

    // Find price closest to target time
    let pastPrice = currentPrice;
    for (let i = history.length - 1; i >= 0; i--) {
      if (history[i].timestamp.getTime() <= targetTime) {
        pastPrice = history[i].priceSol;
        break;
      }
    }

    if (pastPrice === 0) return 0;
    return ((currentPrice - pastPrice) / pastPrice) * 100;
  }

  private calculateVolumeZScore(history: PriceData[]): number {
    if (history.length < 10) return 0;

    // Use liquidity changes as volume proxy
    const volumes = history.map((h) => h.volume24h || 0);
    const recentVolume = volumes[volumes.length - 1];

    const mean = volumes.reduce((a, b) => a + b, 0) / volumes.length;
    const stdDev = Math.sqrt(
      volumes.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / volumes.length
    );

    if (stdDev === 0) return 0;
    return (recentVolume - mean) / stdDev;
  }

  private calculateBuySellRatio(history: PriceData[]): number {
    if (history.length < 2) return 0.5;

    // Infer buy/sell from price movements
    let buys = 0;
    let sells = 0;

    for (let i = 1; i < history.length; i++) {
      const change = history[i].priceSol - history[i - 1].priceSol;
      if (change > 0) buys++;
      else if (change < 0) sells++;
    }

    const total = buys + sells;
    if (total === 0) return 0.5;

    return buys / total;
  }

  private calculateTradeIntensity(history: PriceData[]): number {
    if (history.length < 10) return 0.5;

    // Count significant price changes as proxy for trade activity
    let significantChanges = 0;
    const threshold = 0.001; // 0.1% change threshold

    for (let i = 1; i < history.length; i++) {
      const change = Math.abs(
        (history[i].priceSol - history[i - 1].priceSol) / history[i - 1].priceSol
      );
      if (change > threshold) significantChanges++;
    }

    // Normalize: 0 = no activity, 1 = constant activity
    return Math.min(significantChanges / history.length, 1);
  }

  private normalizeHolderCount(count: number): number {
    // Log scale normalization
    // 10 holders -> ~0.3, 100 holders -> ~0.5, 1000 holders -> ~0.75, 10000 -> ~1.0
    if (count <= 0) return 0;
    return Math.min(Math.log10(count) / 4, 1);
  }

  private normalizeAge(minutes: number): number {
    // Sigmoid normalization
    // 0 min -> 0, 30 min -> ~0.5, 60 min -> ~0.75, 240 min -> ~0.95
    return 1 - 1 / (1 + minutes / 30);
  }

  private normalizeMarketCap(marketCapSol: number): number {
    // Log scale: 10 SOL -> ~0.25, 100 SOL -> ~0.5, 1000 SOL -> ~0.75, 10000 SOL -> 1.0
    if (marketCapSol <= 0) return 0;
    return Math.min(Math.log10(marketCapSol) / 4, 1);
  }

  /**
   * NEW: Calculate drawdown from peak price
   * Returns 0-1 where 0 = at peak, 1 = 100% below peak
   */
  private calculateDrawdownFromPeak(mint: string, priceHistory: PriceData[], currentPrice: number): number {
    // Try to get peak price from watchlist first (most accurate)
    const watchedToken = tokenWatchlist.getToken(mint);
    if (watchedToken && watchedToken.peakPrice > 0) {
      const drawdown = (watchedToken.peakPrice - currentPrice) / watchedToken.peakPrice;
      return Math.max(0, drawdown);
    }

    // Fallback: calculate from price history
    if (priceHistory.length < 2) return 0;

    const prices = priceHistory.map(p => p.priceSol);
    const peakPrice = Math.max(...prices);

    if (peakPrice <= 0) return 0;
    const drawdown = (peakPrice - currentPrice) / peakPrice;
    return Math.max(0, drawdown);
  }

  /**
   * NEW: Calculate volatility as standard deviation of recent price changes
   * Returns 0-1 where higher = more volatile
   */
  private calculateVolatility(priceHistory: PriceData[]): number {
    if (priceHistory.length < 5) return 0.5; // Default to medium volatility

    const prices = priceHistory.map(p => p.priceSol);

    // Calculate returns (percentage changes)
    const returns: number[] = [];
    for (let i = 1; i < prices.length; i++) {
      if (prices[i - 1] > 0) {
        returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
      }
    }

    if (returns.length === 0) return 0.5;

    // Calculate standard deviation of returns
    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
    const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
    const stdDev = Math.sqrt(variance);

    // Normalize: 0% stdDev = 0, 10% stdDev = 0.5, 20%+ stdDev = 1
    return Math.min(stdDev / 0.2, 1);
  }

  /**
   * NEW: Calculate unique traders (normalized)
   * Uses watchlist data if available, returns 0-1
   */
  private calculateUniqueTraders(mint: string): number {
    const watchedToken = tokenWatchlist.getToken(mint);
    if (!watchedToken || watchedToken.trades.length === 0) {
      return 0.5; // Default to medium
    }

    // Count unique traders
    const uniqueTraderSet = new Set(watchedToken.trades.map(t => t.traderPublicKey));
    const count = uniqueTraderSet.size;

    // Normalize: 0 traders = 0, 25 traders = 0.5, 50+ traders = 1
    return Math.min(count / 50, 1);
  }

  /**
   * NEW: Calculate volume trend (acceleration/deceleration)
   * Returns -1 to 1 where:
   *  - Positive = volume accelerating (more recent volume)
   *  - Negative = volume decelerating (less recent volume)
   *  - 0 = stable volume
   */
  private calculateVolumeTrend(mint: string, priceHistory: PriceData[]): number {
    // Try watchlist for trade-based volume trend first
    const watchedToken = tokenWatchlist.getToken(mint);
    if (watchedToken && watchedToken.volumeHistory.length >= 2) {
      const recent = watchedToken.volumeHistory[watchedToken.volumeHistory.length - 1]?.count || 0;
      const previous = watchedToken.volumeHistory[watchedToken.volumeHistory.length - 2]?.count || 1;

      if (previous > 0) {
        const ratio = recent / previous;
        // Convert ratio to -1 to 1 scale: 0.5x = -0.5, 1x = 0, 2x = 0.5, 3x+ = 1
        return Math.max(-1, Math.min(1, (ratio - 1) * 0.5));
      }
    }

    // Fallback: use price history volume
    if (priceHistory.length < 10) return 0;

    const midpoint = Math.floor(priceHistory.length / 2);
    const firstHalf = priceHistory.slice(0, midpoint);
    const secondHalf = priceHistory.slice(midpoint);

    const firstVolume = firstHalf.reduce((sum, p) => sum + (p.volume24h || 0), 0) / firstHalf.length;
    const secondVolume = secondHalf.reduce((sum, p) => sum + (p.volume24h || 0), 0) / secondHalf.length;

    if (firstVolume <= 0) return 0;

    const ratio = secondVolume / firstVolume;
    // Convert ratio to -1 to 1 scale
    return Math.max(-1, Math.min(1, (ratio - 1) * 0.5));
  }

  private clamp(value: number, min: number, max: number): number {
    return Math.max(min, Math.min(max, value));
  }

  private updateHistory(mint: string, state: StateVector): void {
    let history = this.featureHistories.get(mint);

    if (!history) {
      history = {
        mint,
        features: [],
        timestamps: [],
        maxHistory: this.maxHistoryLength,
      };
      this.featureHistories.set(mint, history);
    }

    history.features.push(state);
    history.timestamps.push(new Date());

    // Trim old entries
    if (history.features.length > history.maxHistory) {
      history.features = history.features.slice(-history.maxHistory);
      history.timestamps = history.timestamps.slice(-history.maxHistory);
    }
  }

  toArray(state: StateVector): number[] {
    return [
      state.priceChange1m,
      state.priceChange5m,
      state.volumeZScore,
      state.buySellRatio,
      state.holderCount,
      state.top10Concentration,
      state.mintRevoked,
      state.freezeRevoked,
      state.lpLocked,
      state.ageMinutes,
      state.tradeIntensity,
      state.marketCapSol,
      // NEW: 4 additional features
      state.drawdownFromPeak,
      state.volatility,
      state.uniqueTraders,
      state.volumeTrend,
    ];
  }

  fromArray(arr: number[]): StateVector {
    return {
      priceChange1m: arr[0],
      priceChange5m: arr[1],
      volumeZScore: arr[2],
      buySellRatio: arr[3],
      holderCount: arr[4],
      top10Concentration: arr[5],
      mintRevoked: arr[6],
      freezeRevoked: arr[7],
      lpLocked: arr[8],
      ageMinutes: arr[9],
      tradeIntensity: arr[10],
      marketCapSol: arr[11],
      // NEW: 4 additional features
      drawdownFromPeak: arr[12] ?? 0,
      volatility: arr[13] ?? 0.5,
      uniqueTraders: arr[14] ?? 0.5,
      volumeTrend: arr[15] ?? 0,
    };
  }

  clearHistory(mint: string): void {
    this.featureHistories.delete(mint);
  }
}

export const featureExtractor = new FeatureExtractor();
</file>

<file path="src/signals/index.ts">
export * from './types';
export * from './feature-extractor';
export * from './rug-detector';
export * from './pump-detector';
export * from './velocity-tracker';
export * from './entry-evaluator';
export * from './narrative-sensor';
export * from './news-sensor';
export * from './rug-monitor';
export * from './token-watchlist';
</file>

<file path="src/signals/narrative-sensor.ts">
import { ApifyClient } from 'apify-client';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { createChildLogger } from '../utils/logger';

const logger = createChildLogger('narrative-sensor');

export interface NarrativeSignal {
  sentiment: 'bullish' | 'bearish' | 'neutral';
  bullishnessScore: number; // -1 to 1 (Granular score for Math)
  hypeScore: number;        // 0 to 1 (Volume/Excitement)
  volume: number;           // Number of tweets found
  keywords: string[];       // LLM-identified topics (e.g., "Congestion", "Burn")
  sampleTweets: string[];
}

export class NarrativeSensor {
  private apifyClient: ApifyClient;
  private genAI: GoogleGenerativeAI;
  private model: ReturnType<GoogleGenerativeAI['getGenerativeModel']>;
  private searchTerms: string[];
  private maxItems: number;

  constructor(
    searchTerms: string[] = ['$SOL', 'Solana', 'memecoin'],
    maxItems: number = 50
  ) {
    // 1. Setup Apify (The Eyes)
    const apifyToken = process.env.APIFY_API_TOKEN;
    if (!apifyToken) logger.warn('APIFY_API_TOKEN missing - Scraper will fail');
    this.apifyClient = new ApifyClient({ token: apifyToken });

    // 2. Setup Gemini (The Brain)
    const geminiKey = process.env.GEMINI_API_KEY || '';
    if (!geminiKey) logger.warn('GEMINI_API_KEY missing - Analysis will be "neutral"');
    this.genAI = new GoogleGenerativeAI(geminiKey);
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

    this.searchTerms = searchTerms;
    this.maxItems = maxItems;
  }

  // --- STEP 1: GET DATA (APIFY) ---
  async scrapeTweets(query?: string): Promise<string[]> {
    try {
      const terms = query ? [query] : this.searchTerms;

      logger.debug({ terms }, 'Starting Apify scrape');

      const run = await this.apifyClient.actor('apidojo/tweet-scraper').call({
        searchTerms: terms,
        maxItems: this.maxItems,
        sort: 'Latest',
        tweetLanguage: 'en',
      });

      const { items } = await this.apifyClient.dataset(run.defaultDatasetId).listItems();

      // Extract text and remove duplicates
      const tweets = items
        .map((item: Record<string, unknown>) => item.text as string)
        .filter((text): text is string => typeof text === 'string' && text.length > 10);

      const uniqueTweets = Array.from(new Set(tweets));

      logger.info({ count: uniqueTweets.length, query: terms[0] }, 'Tweets scraped successfully');
      return uniqueTweets;

    } catch (error) {
      logger.error({ error }, 'Apify scrape failed');
      return [];
    }
  }

  // --- STEP 2: ANALYZE DATA (LLM) ---
  async analyzeWithBrain(tweets: string[]): Promise<NarrativeSignal> {
    if (tweets.length === 0) return this.getNeutralSignal();

    try {
      // Prompt Engineering: Asking for specific JSON format
      const prompt = `
        Act as a degenerate Solana trader. Analyze these ${tweets.length} tweets.

        Tweets:
        ${tweets.slice(0, 40).join('\n---\n')}

        Output valid JSON only with no markdown:
        {
          "bullishnessScore": number, // -1.0 (Bearish) to 1.0 (Bullish)
          "hypeScore": number,        // 0.0 (Dead) to 1.0 (Viral)
          "keywords": string[]        // Top 3 specific narratives (e.g. "Network Congestion", "Bonk Listing")
        }
      `;

      const result = await this.model.generateContent(prompt);
      const text = result.response.text().replace(/```json|```/g, '').trim();
      const analysis = JSON.parse(text);

      // Determine explicit sentiment label based on score
      let sentiment: 'bullish' | 'bearish' | 'neutral' = 'neutral';
      if (analysis.bullishnessScore > 0.3) sentiment = 'bullish';
      if (analysis.bullishnessScore < -0.3) sentiment = 'bearish';

      return {
        sentiment,
        bullishnessScore: analysis.bullishnessScore,
        hypeScore: analysis.hypeScore,
        volume: tweets.length,
        keywords: analysis.keywords || [],
        sampleTweets: tweets.slice(0, 3)
      };

    } catch (error) {
      logger.error({ error }, 'LLM Analysis failed');
      return this.getNeutralSignal();
    }
  }

  // --- PUBLIC API ---
  async getNarrativeSignal(tokenSymbol?: string): Promise<NarrativeSignal> {
    const tweets = await this.scrapeTweets(tokenSymbol);
    return this.analyzeWithBrain(tweets);
  }

  private getNeutralSignal(): NarrativeSignal {
    return {
      sentiment: 'neutral',
      bullishnessScore: 0,
      hypeScore: 0,
      volume: 0,
      keywords: [],
      sampleTweets: []
    };
  }
}

export const narrativeSensor = new NarrativeSensor();
</file>

<file path="src/signals/news-sensor.ts">
import { createChildLogger } from '../utils/logger';
import Groq from 'groq-sdk';

const logger = createChildLogger('news-sensor');

// Setup Groq for LLM analysis (faster + more generous free tier)
const groq = new Groq({ apiKey: process.env.GROQ_API_KEY });

export interface NewsSignal {
  bullishness: number; // -1 to 1
  marketFocus: string[]; // e.g. ["Regulation", "Solana Congestion"]
  breakingNews: boolean;
  headline: string;
}

export class NewsSensor {

  // News API endpoints (fallback chain)
  private readonly NEWS_APIS = [
    'https://free-crypto-news.vercel.app/api/news',
    'https://min-api.cryptocompare.com/data/v2/news/?lang=EN&sortOrder=popular'
  ];

  async getMarketNewsSignal(): Promise<NewsSignal> {
    try {
      // 1. Fetch raw news - try multiple APIs with fallback
      let articles: Array<{ title: string; source: string }> = [];

      for (const apiUrl of this.NEWS_APIS) {
        try {
          const response = await fetch(apiUrl, {
            headers: {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Accept': 'application/json'
            }
          });

          if (!response.ok) {
            logger.debug({ apiUrl, status: response.status }, 'API failed, trying next...');
            continue;
          }

          const data = await response.json() as Record<string, unknown>;

          // Handle different API response formats
          if (data.articles && Array.isArray(data.articles)) {
            // free-crypto-news format
            articles = (data.articles as Array<{ title: string; source: string }>).map(a => ({
              title: a.title || '',
              source: a.source || ''
            }));
          } else if (data.Data && Array.isArray(data.Data)) {
            // CryptoCompare format
            articles = (data.Data as Array<{ title: string; source_info?: { name: string } }>).map(a => ({
              title: a.title || '',
              source: a.source_info?.name || 'CryptoCompare'
            }));
          }

          if (articles.length > 0) {
            logger.debug({ apiUrl, count: articles.length }, 'News fetched successfully');
            break;
          }
        } catch (e) {
          logger.debug({ apiUrl, error: e }, 'API error, trying next...');
          continue;
        }
      }

      if (articles.length === 0) {
        logger.warn('All news APIs failed');
        return this.getNeutralSignal();
      }

      // Filter for only recent news
      const recentArticles = articles
        .slice(0, 15)
        .map((a) => `- ${a.title} (${a.source})`)
        .join('\n');

      if (!recentArticles) return this.getNeutralSignal();

      // 2. Ask Groq LLM to analyze it
      const prompt = `Analyze these crypto news headlines for a trading bot.

Headlines:
${recentArticles}

Task:
1. Determine global crypto sentiment (-1.0 to 1.0).
2. Identify if there is Breaking News that invalidates technical analysis (SEC lawsuits, exchange hacks, etc).
3. Extract top 2 market themes.

Output JSON only: { "score": number, "isBreaking": boolean, "themes": string[] }`;

      const completion = await groq.chat.completions.create({
        model: 'llama-3.3-70b-versatile',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3,
        max_tokens: 200,
        response_format: { type: 'json_object' }
      });

      const text = completion.choices[0]?.message?.content || '{}';
      const analysis = JSON.parse(text);

      logger.info({ analysis }, 'News analysis complete');

      return {
        bullishness: analysis.score || 0,
        breakingNews: analysis.isBreaking || false,
        marketFocus: analysis.themes || [],
        headline: articles[0]?.title || ''
      };

    } catch (error) {
      logger.error({ error }, 'Failed to fetch or analyze news');
      return this.getNeutralSignal();
    }
  }

  private getNeutralSignal(): NewsSignal {
    return { bullishness: 0, marketFocus: [], breakingNews: false, headline: '' };
  }
}

export const newsSensor = new NewsSensor();
</file>

<file path="src/signals/pump-detector.ts">
import { createChildLogger } from '../utils/logger';
import { priceFeed } from '../data/price-feed';
import { PriceData } from '../data/types';
import { PumpPhase, PumpMetrics } from './types';
import { config } from '../config/settings';

const logger = createChildLogger('pump-detector');

export class PumpDetector {
  private pumpHistories: Map<string, PumpMetrics[]> = new Map();
  private maxHistory = 60; // 1 minute of history

  constructor() {}

  analyzePump(mint: string): PumpMetrics {
    const history = priceFeed.getPriceHistory(mint, 300);

    if (history.length < 10) {
      return this.getDefaultMetrics();
    }

    // Calculate volume ratio (1min / 5min)
    const volume1m = this.getVolumeWindow(history, 60);
    const volume5m = this.getVolumeWindow(history, 300);
    const volumeRatio = volume5m > 0 ? volume1m / volume5m : 0;

    // Calculate heat metric
    const heat = volumeRatio * 100;

    // Determine phase based on heat and price velocity
    const priceVelocity = this.calculatePriceVelocity(history);
    const buyPressure = this.calculateBuyPressure(history);

    const phase = this.determinePhase(heat, priceVelocity, buyPressure);
    const confidence = this.calculateConfidence(history, phase);

    const metrics: PumpMetrics = {
      phase,
      heat,
      volumeRatio,
      priceVelocity,
      buyPressure,
      confidence,
    };

    // Update history
    this.updateHistory(mint, metrics);

    logger.debug({ mint, phase, heat: heat.toFixed(1), confidence: confidence.toFixed(2) }, 'Pump analysis');

    return metrics;
  }

  private getDefaultMetrics(): PumpMetrics {
    return {
      phase: 'cold',
      heat: 0,
      volumeRatio: 0,
      priceVelocity: 0,
      buyPressure: 0.5,
      confidence: 0,
    };
  }

  private getVolumeWindow(history: PriceData[], seconds: number): number {
    const cutoff = Date.now() - seconds * 1000;
    const windowData = history.filter((h) => h.timestamp.getTime() >= cutoff);

    if (windowData.length < 2) return 0;

    // Sum of absolute price changes as volume proxy
    let volume = 0;
    for (let i = 1; i < windowData.length; i++) {
      volume += Math.abs(windowData[i].priceSol - windowData[i - 1].priceSol);
    }

    return volume;
  }

  private calculatePriceVelocity(history: PriceData[]): number {
    if (history.length < 10) return 0;

    // Price velocity = rate of price change over recent period
    const recent = history.slice(-30); // Last 30 seconds
    if (recent.length < 2) return 0;

    const startPrice = recent[0].priceSol;
    const endPrice = recent[recent.length - 1].priceSol;
    const timeDiff = (recent[recent.length - 1].timestamp.getTime() - recent[0].timestamp.getTime()) / 1000;

    if (timeDiff === 0 || startPrice === 0) return 0;

    // Percentage change per second
    const velocity = ((endPrice - startPrice) / startPrice) * 100 / timeDiff;

    return velocity;
  }

  private calculateBuyPressure(history: PriceData[]): number {
    if (history.length < 10) return 0.5;

    const recent = history.slice(-60); // Last minute
    let upMoves = 0;
    let downMoves = 0;

    for (let i = 1; i < recent.length; i++) {
      const change = recent[i].priceSol - recent[i - 1].priceSol;
      if (change > 0) upMoves++;
      else if (change < 0) downMoves++;
    }

    const total = upMoves + downMoves;
    if (total === 0) return 0.5;

    return upMoves / total;
  }

  private determinePhase(heat: number, priceVelocity: number, buyPressure: number): PumpPhase {
    // Phase determination based on heat metric and supporting indicators

    // Dumping: negative velocity with selling pressure
    if (priceVelocity < -1 && buyPressure < 0.3) {
      return 'dumping';
    }

    // Peak: very high heat but slowing
    if (heat > 100 && priceVelocity < 0.5) {
      return 'peak';
    }

    // Hot: high heat with positive momentum
    if (heat >= 48 && heat <= 100 && buyPressure > 0.5) {
      return 'hot';
    }

    // Building: moderate heat with buying
    if (heat >= 33 && heat < 48 && buyPressure > 0.45) {
      return 'building';
    }

    // Cold: low activity
    return 'cold';
  }

  private calculateConfidence(history: PriceData[], phase: PumpPhase): number {
    if (history.length < 30) return 0.3;

    // Base confidence on data quality
    let confidence = Math.min(history.length / 100, 0.5);

    // Adjust based on signal clarity
    const recent = history.slice(-30);
    const priceChanges = [];

    for (let i = 1; i < recent.length; i++) {
      priceChanges.push((recent[i].priceSol - recent[i - 1].priceSol) / recent[i - 1].priceSol);
    }

    // Calculate consistency of direction
    const positiveChanges = priceChanges.filter((c) => c > 0).length;
    const consistency = Math.abs(positiveChanges / priceChanges.length - 0.5) * 2;

    confidence += consistency * 0.3;

    // Phase-specific adjustments
    if (phase === 'hot' || phase === 'peak') {
      confidence += 0.2;
    }

    return Math.min(confidence, 1);
  }

  private updateHistory(mint: string, metrics: PumpMetrics): void {
    let history = this.pumpHistories.get(mint) || [];
    history.push(metrics);

    if (history.length > this.maxHistory) {
      history = history.slice(-this.maxHistory);
    }

    this.pumpHistories.set(mint, history);
  }

  isGoodEntry(metrics: PumpMetrics): boolean {
    // Good entry: building phase with decent confidence, or early hot
    if (metrics.phase === 'building' && metrics.confidence > 0.4 && metrics.buyPressure > 0.5) {
      return true;
    }

    if (metrics.phase === 'hot' && metrics.heat < 60 && metrics.confidence > 0.5) {
      return true;
    }

    return false;
  }

  shouldExit(metrics: PumpMetrics): boolean {
    // Exit signals
    if (metrics.phase === 'peak' || metrics.phase === 'dumping') {
      return true;
    }

    if (metrics.priceVelocity < -2 && metrics.confidence > 0.5) {
      return true;
    }

    return false;
  }

  getPumpHistory(mint: string): PumpMetrics[] {
    return this.pumpHistories.get(mint) || [];
  }

  detectPhaseTransition(mint: string): { from: PumpPhase; to: PumpPhase } | null {
    const history = this.pumpHistories.get(mint);
    if (!history || history.length < 2) return null;

    const current = history[history.length - 1].phase;
    const previous = history[history.length - 2].phase;

    if (current !== previous) {
      logger.info({ mint, from: previous, to: current }, 'Phase transition detected');
      return { from: previous, to: current };
    }

    return null;
  }

  clearHistory(mint: string): void {
    this.pumpHistories.delete(mint);
  }
}

export const pumpDetector = new PumpDetector();
</file>

<file path="src/signals/rug-detector.ts">
import { createChildLogger } from '../utils/logger';
import { TokenInfo, HolderInfo, LiquidityPool } from '../data/types';
import { RugScore } from './types';
import { config } from '../config/settings';

const logger = createChildLogger('rug-detector');

export class RugDetector {
  private bundledBuysCache: Map<string, boolean> = new Map();

  constructor() {}

  async analyzeToken(
    mint: string,
    tokenInfo: TokenInfo | null,
    holderInfo: HolderInfo | null,
    lpInfo: LiquidityPool | null
  ): Promise<RugScore> {
    const details: string[] = [];
    let total = 0;

    // Check if this is a Pump.fun token (program controls mint/freeze)
    const isPumpFunToken = mint.endsWith('pump');

    // Mint authority check (25 points)
    let mintAuthorityScore = 0;
    if (tokenInfo?.mintAuthorityRevoked) {
      mintAuthorityScore = 25;
      details.push('âœ“ Mint authority revoked (+25)');
    } else if (isPumpFunToken) {
      // Pump.fun program controls mint authority - inherently safe
      mintAuthorityScore = 25;
      details.push('âœ“ Pump.fun token - mint controlled by program (+25)');
    } else {
      details.push('âœ— Mint authority NOT revoked (0)');
    }
    total += mintAuthorityScore;

    // Freeze authority check (20 points)
    let freezeAuthorityScore = 0;
    if (tokenInfo?.freezeAuthorityRevoked) {
      freezeAuthorityScore = 20;
      details.push('âœ“ Freeze authority revoked (+20)');
    } else if (isPumpFunToken) {
      // Pump.fun program controls freeze authority - inherently safe
      freezeAuthorityScore = 20;
      details.push('âœ“ Pump.fun token - freeze controlled by program (+20)');
    } else {
      details.push('âœ— Freeze authority NOT revoked (0)');
    }
    total += freezeAuthorityScore;

    // LP locked check (25 points)
    let lpLockedScore = 0;
    if (lpInfo?.lpLocked) {
      lpLockedScore = 25;
      details.push(`âœ“ LP locked (${(lpInfo.lpLockedPercent * 100).toFixed(1)}%) (+25)`);
    } else if (lpInfo) {
      // Partial points for high liquidity
      const liquidityScore = Math.min((lpInfo.liquiditySol / 100) * 10, 10);
      lpLockedScore = liquidityScore;
      details.push(`~ LP not locked, but ${lpInfo.liquiditySol.toFixed(1)} SOL liquidity (+${liquidityScore.toFixed(0)})`);
    } else {
      details.push('âœ— No LP info available (0)');
    }
    total += lpLockedScore;

    // Top 10 concentration check (15 points)
    let concentrationScore = 0;
    if (holderInfo) {
      const concentration = holderInfo.top10Concentration;
      if (concentration <= 0.30) {
        concentrationScore = 15;
        details.push(`âœ“ Top 10 hold ${(concentration * 100).toFixed(1)}% (<30%) (+15)`);
      } else if (concentration <= 0.50) {
        concentrationScore = 10;
        details.push(`~ Top 10 hold ${(concentration * 100).toFixed(1)}% (30-50%) (+10)`);
      } else if (concentration <= 0.70) {
        concentrationScore = 5;
        details.push(`! Top 10 hold ${(concentration * 100).toFixed(1)}% (50-70%) (+5)`);
      } else {
        details.push(`âœ— Top 10 hold ${(concentration * 100).toFixed(1)}% (>70%) (0)`);
      }
    } else {
      details.push('âœ— No holder info available (0)');
    }
    total += concentrationScore;

    // Bundled buys check (15 points)
    let bundledBuysScore = 0;
    const hasBundledBuys = await this.checkBundledBuys(mint);
    if (!hasBundledBuys) {
      bundledBuysScore = 15;
      details.push('âœ“ No suspicious bundled buys detected (+15)');
    } else {
      details.push('âœ— Bundled buys detected - potential coordinated buying (0)');
    }
    total += bundledBuysScore;

    const rugScore: RugScore = {
      total,
      mintAuthorityScore,
      freezeAuthorityScore,
      lpLockedScore,
      concentrationScore,
      bundledBuysScore,
      details,
    };

    logger.info({ mint, score: total }, 'Rug score calculated');

    return rugScore;
  }

  isSafe(rugScore: RugScore): boolean {
    return rugScore.total >= config.minRugScore;
  }

  private async checkBundledBuys(mint: string): Promise<boolean> {
    // Check cache first
    if (this.bundledBuysCache.has(mint)) {
      return this.bundledBuysCache.get(mint)!;
    }

    try {
      // Fetch recent transactions and analyze for bundled patterns
      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getSignaturesForAddress',
            params: [mint, { limit: 50 }],
          }),
        }
      );

      const data = await response.json() as any;
      const signatures = data.result || [];

      // Group transactions by block slot
      const slotGroups: Map<number, number> = new Map();
      for (const sig of signatures) {
        const count = slotGroups.get(sig.slot) || 0;
        slotGroups.set(sig.slot, count + 1);
      }

      // Check for bundled transactions (multiple in same slot)
      let bundledCount = 0;
      for (const count of slotGroups.values()) {
        if (count >= 3) {
          bundledCount++;
        }
      }

      // Flag if >20% of slots have bundled transactions
      const hasBundledBuys = bundledCount > slotGroups.size * 0.2;

      this.bundledBuysCache.set(mint, hasBundledBuys);
      return hasBundledBuys;
    } catch (error) {
      logger.error({ mint, error }, 'Failed to check bundled buys');
      return false; // Assume safe on error
    }
  }

  async checkCreatorHistory(creator: string): Promise<{
    tokenCount: number;
    rugCount: number;
    successRate: number;
  }> {
    try {
      // This would analyze creator's history of token launches
      // Simplified implementation
      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getSignaturesForAddress',
            params: [creator, { limit: 100 }],
          }),
        }
      );

      const data = await response.json() as any;
      const signatures = data.result || [];

      // Count unique token interactions (simplified)
      const uniqueTokens = new Set<string>();
      // Would need to parse transactions to extract token mints

      return {
        tokenCount: uniqueTokens.size,
        rugCount: 0, // Would need historical analysis
        successRate: 0.5, // Default neutral
      };
    } catch (error) {
      logger.error({ creator, error }, 'Failed to check creator history');
      return { tokenCount: 0, rugCount: 0, successRate: 0.5 };
    }
  }

  getQuickSafetyFlags(tokenInfo: TokenInfo | null, mint?: string): {
    isSafe: boolean;
    flags: string[];
  } {
    const flags: string[] = [];
    let isSafe = true;

    // Pump.fun tokens (ending in "pump") are inherently safe from mint/freeze authority
    // The Pump.fun program controls these - creators cannot mint or freeze
    const isPumpFunToken = mint?.endsWith('pump');

    if (!tokenInfo) {
      if (isPumpFunToken) {
        // Pump.fun tokens are safe by design - skip token info check
        flags.push('INFO: Pump.fun token - inherently safe');
        return { isSafe: true, flags };
      }
      return { isSafe: false, flags: ['No token info available'] };
    }

    if (!tokenInfo.mintAuthorityRevoked && !isPumpFunToken) {
      flags.push('WARN: Mint authority not revoked');
      isSafe = false;
    }

    if (!tokenInfo.freezeAuthorityRevoked && !isPumpFunToken) {
      flags.push('WARN: Freeze authority not revoked');
      // Not critical but noteworthy
    }

    return { isSafe, flags };
  }

  clearCache(mint?: string): void {
    if (mint) {
      this.bundledBuysCache.delete(mint);
    } else {
      this.bundledBuysCache.clear();
    }
  }

  /**
   * Check if LP tokens are locked/burned for a token
   * Returns LiquidityPool info with lpLocked status
   */
  async checkLpLocked(mint: string, poolAddress?: string): Promise<{
    lpLocked: boolean;
    lpLockedPercent: number;
    liquiditySol: number;
    reason: string;
  }> {
    try {
      // Known burn addresses for Solana
      const BURN_ADDRESSES = [
        '1111111111111111111111111111111111111111111',  // System program (null address)
        '1nc1nerator11111111111111111111111111111111',  // Incinerator
        '11111111111111111111111111111111',              // Short burn address
      ];

      // Known lock protocols on Solana
      const LOCK_PROTOCOLS = [
        'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',  // SPL Token
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL', // Associated Token
        // Streamflow vesting
        'strmRqUCoQUgGUan5YhzUZa6KqdzwX5L6FpUxfmKg5m',
        // Squads multisig (often used for lock)
        'SMPLecH534NA9acpos4G6x7uf3LWbCAwZQE9e8ZekMu',
      ];

      // Try to get LP pool info from DexScreener
      const response = await fetch(
        `https://api.dexscreener.com/latest/dex/tokens/${mint}`,
        { headers: { 'Accept': 'application/json' } }
      );

      if (!response.ok) {
        logger.debug({ mint }, 'Failed to fetch DexScreener data for LP check');
        return { lpLocked: false, lpLockedPercent: 0, liquiditySol: 0, reason: 'Failed to fetch data' };
      }

      const data = await response.json() as any;
      const pairs = data.pairs || [];

      if (pairs.length === 0) {
        return { lpLocked: false, lpLockedPercent: 0, liquiditySol: 0, reason: 'No pairs found' };
      }

      // Get the main pair (usually Raydium or Orca)
      const mainPair = pairs.find((p: any) =>
        p.dexId === 'raydium' || p.dexId === 'orca' || p.dexId === 'pump'
      ) || pairs[0];

      const liquiditySol = mainPair.liquidity?.usd
        ? (mainPair.liquidity.usd / (mainPair.priceNative || 1)) / 1000  // Rough SOL estimate
        : 0;

      // Check if liquidity is locked via DexScreener info (if available)
      const liquidityInfo = mainPair.liquidity || {};
      if (liquidityInfo.locked) {
        return {
          lpLocked: true,
          lpLockedPercent: liquidityInfo.lockedPercent || 1,
          liquiditySol,
          reason: `LP locked (${(liquidityInfo.lockedPercent * 100 || 100).toFixed(0)}%)`
        };
      }

      // For Pump.fun tokens, LP is managed by the bonding curve (effectively locked)
      if (mint.endsWith('pump') || mainPair.dexId === 'pump') {
        return {
          lpLocked: true,
          lpLockedPercent: 1,
          liquiditySol,
          reason: 'Pump.fun bonding curve (inherently locked)'
        };
      }

      // If we have a pool address, we can do additional on-chain checks
      if (poolAddress) {
        const lpCheckResult = await this.checkLpTokensBurned(poolAddress);
        if (lpCheckResult.burned) {
          return {
            lpLocked: true,
            lpLockedPercent: lpCheckResult.burnedPercent,
            liquiditySol,
            reason: `LP tokens burned (${(lpCheckResult.burnedPercent * 100).toFixed(0)}%)`
          };
        }
      }

      // Default: cannot confirm LP is locked
      return {
        lpLocked: false,
        lpLockedPercent: 0,
        liquiditySol,
        reason: 'LP lock status unknown'
      };

    } catch (error) {
      logger.error({ mint, error }, 'Error checking LP lock status');
      return { lpLocked: false, lpLockedPercent: 0, liquiditySol: 0, reason: 'Error checking LP' };
    }
  }

  /**
   * Check if LP tokens have been burned by querying token account holders
   */
  private async checkLpTokensBurned(lpMint: string): Promise<{
    burned: boolean;
    burnedPercent: number;
  }> {
    try {
      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${config.heliusApiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getTokenLargestAccounts',
            params: [lpMint],
          }),
        }
      );

      const data = await response.json() as any;
      const accounts = data.result?.value || [];

      if (accounts.length === 0) {
        return { burned: false, burnedPercent: 0 };
      }

      // Check if any large holders are burn addresses
      const BURN_PATTERNS = ['1111111111111111111111111111', '1nc1nerator', 'burn', 'dead'];
      let totalSupply = 0;
      let burnedSupply = 0;

      for (const account of accounts) {
        const amount = parseFloat(account.amount) || 0;
        totalSupply += amount;

        // Check if this is a burn address
        const address = account.address?.toLowerCase() || '';
        const isBurned = BURN_PATTERNS.some(pattern => address.includes(pattern.toLowerCase()));

        if (isBurned) {
          burnedSupply += amount;
        }
      }

      const burnedPercent = totalSupply > 0 ? burnedSupply / totalSupply : 0;

      return {
        burned: burnedPercent >= 0.5, // Consider locked if >50% burned
        burnedPercent,
      };

    } catch (error) {
      logger.debug({ lpMint, error }, 'Failed to check LP token burn status');
      return { burned: false, burnedPercent: 0 };
    }
  }
}

export const rugDetector = new RugDetector();
</file>

<file path="src/signals/rug-monitor.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';

const logger = createChildLogger('rug-monitor');

interface WatchedPosition {
  mint: string;
  creator: string;
  entryTime: Date;
  entryPrice: number;
  entryMarketCapSol: number;

  // Trading activity tracking
  sellCount: number;
  buyCount: number;
  totalSellVolume: number;    // Token amount sold
  creatorSellCount: number;
  creatorTotalSold: number;   // Token amount creator sold
  largestSingleSell: number;  // Largest single sell in tokens
  largestSellerWallet: string;

  // Price tracking (from PumpPortal trades)
  highestPrice: number;
  currentPrice: number;
  priceAtLastCheck: number;
}

export interface RugWarning {
  mint: string;
  type: 'creator_sell' | 'large_dump' | 'sell_pressure' | 'price_crash';
  severity: 'warning' | 'critical';
  message: string;
  details: {
    [key: string]: number | string;
  };
  timestamp: Date;
}

export class RugMonitor extends EventEmitter {
  private watchedPositions: Map<string, WatchedPosition> = new Map();
  private recentWarnings: Map<string, RugWarning[]> = new Map();

  constructor() {
    super();
  }

  /**
   * Start watching a position for rug signals
   */
  watchPosition(params: {
    mint: string;
    creator: string;
    entryPrice: number;
    entryMarketCapSol: number;
  }): void {
    const { mint, creator, entryPrice, entryMarketCapSol } = params;

    if (this.watchedPositions.has(mint)) {
      logger.debug({ mint }, 'Position already being watched');
      return;
    }

    const position: WatchedPosition = {
      mint,
      creator,
      entryTime: new Date(),
      entryPrice,
      entryMarketCapSol,
      sellCount: 0,
      buyCount: 0,
      totalSellVolume: 0,
      creatorSellCount: 0,
      creatorTotalSold: 0,
      largestSingleSell: 0,
      largestSellerWallet: '',
      highestPrice: entryPrice,
      currentPrice: entryPrice,
      priceAtLastCheck: entryPrice,
    };

    this.watchedPositions.set(mint, position);
    this.recentWarnings.set(mint, []);

    logger.info({
      mint: mint.substring(0, 12) + '...',
      creator: creator.substring(0, 12) + '...',
      entryPrice: entryPrice.toExponential(4),
      marketCapSol: entryMarketCapSol.toFixed(2),
    }, 'Rug monitor: Watching position');
  }

  /**
   * Stop watching a position
   */
  unwatchPosition(mint: string): void {
    this.watchedPositions.delete(mint);
    this.recentWarnings.delete(mint);
    logger.debug({ mint: mint.substring(0, 12) + '...' }, 'Rug monitor: Stopped watching');
  }

  /**
   * Process a trade event from PumpPortal
   */
  processTrade(data: {
    mint: string;
    txType: 'buy' | 'sell';
    traderPublicKey: string;
    tokenAmount: number;
    marketCapSol: number;
    priceSol: number;
  }): void {
    const position = this.watchedPositions.get(data.mint);
    if (!position) return;

    // Update price tracking
    position.currentPrice = data.priceSol;
    if (data.priceSol > position.highestPrice) {
      position.highestPrice = data.priceSol;
    }

    if (data.txType === 'buy') {
      position.buyCount++;
      return; // Buys are good, no rug signals
    }

    // It's a sell - analyze for rug signals
    position.sellCount++;
    position.totalSellVolume += data.tokenAmount;

    // Track largest single sell
    if (data.tokenAmount > position.largestSingleSell) {
      position.largestSingleSell = data.tokenAmount;
      position.largestSellerWallet = data.traderPublicKey;
    }

    // CHECK 1: Creator selling
    if (data.traderPublicKey === position.creator) {
      position.creatorSellCount++;
      position.creatorTotalSold += data.tokenAmount;

      this.emitWarning({
        mint: data.mint,
        type: 'creator_sell',
        severity: position.creatorSellCount >= 2 ? 'critical' : 'warning',
        message: `Creator sold ${data.tokenAmount.toLocaleString()} tokens (sell #${position.creatorSellCount})`,
        details: {
          creatorWallet: data.traderPublicKey.substring(0, 12) + '...',
          tokensSold: data.tokenAmount,
          totalCreatorSold: position.creatorTotalSold,
          sellCount: position.creatorSellCount,
        },
      });
    }

    // CHECK 2: Large single dump (>5% of market cap equivalent)
    const sellValueSol = data.tokenAmount * data.priceSol;
    const dumpPercent = (sellValueSol / data.marketCapSol) * 100;

    if (dumpPercent > 5) {
      this.emitWarning({
        mint: data.mint,
        type: 'large_dump',
        severity: dumpPercent > 10 ? 'critical' : 'warning',
        message: `Large sell: ${dumpPercent.toFixed(1)}% of market cap dumped`,
        details: {
          sellerWallet: data.traderPublicKey.substring(0, 12) + '...',
          tokensSold: data.tokenAmount,
          sellValueSol: sellValueSol.toFixed(4),
          dumpPercent: dumpPercent,
        },
      });
    }

    // CHECK 3: Sell pressure (more sells than buys in recent window)
    const totalTrades = position.buyCount + position.sellCount;
    if (totalTrades >= 5) {  // Need minimum trades for meaningful ratio
      const sellRatio = position.sellCount / totalTrades;

      if (sellRatio > 0.6) {  // >60% sells
        this.emitWarning({
          mint: data.mint,
          type: 'sell_pressure',
          severity: sellRatio > 0.75 ? 'critical' : 'warning',
          message: `High sell pressure: ${(sellRatio * 100).toFixed(0)}% sells`,
          details: {
            buyCount: position.buyCount,
            sellCount: position.sellCount,
            sellRatio: sellRatio,
          },
        });
      }
    }

    // CHECK 4: Price crash from high (>30% drop from peak)
    if (position.highestPrice > position.entryPrice) {  // Only if it went up first
      const dropFromHigh = ((position.highestPrice - data.priceSol) / position.highestPrice) * 100;

      if (dropFromHigh > 30) {
        this.emitWarning({
          mint: data.mint,
          type: 'price_crash',
          severity: dropFromHigh > 50 ? 'critical' : 'warning',
          message: `Price crashed ${dropFromHigh.toFixed(0)}% from high`,
          details: {
            highestPrice: position.highestPrice,
            currentPrice: data.priceSol,
            dropPercent: dropFromHigh,
            currentGainPercent: ((data.priceSol - position.entryPrice) / position.entryPrice) * 100,
          },
        });
      }
    }

    position.priceAtLastCheck = data.priceSol;
  }

  /**
   * Emit a rug warning
   */
  private emitWarning(warning: Omit<RugWarning, 'timestamp'>): void {
    const fullWarning: RugWarning = {
      ...warning,
      timestamp: new Date(),
    };

    // Store warning
    const warnings = this.recentWarnings.get(warning.mint) || [];
    warnings.push(fullWarning);

    // Keep only last 10 warnings per token
    if (warnings.length > 10) {
      warnings.shift();
    }
    this.recentWarnings.set(warning.mint, warnings);

    // Log it
    const logData = {
      mint: warning.mint.substring(0, 12) + '...',
      type: warning.type,
      severity: warning.severity,
      ...warning.details,
    };

    if (warning.severity === 'critical') {
      logger.error(logData, `RUG ALERT: ${warning.message}`);
    } else {
      logger.warn(logData, `Rug warning: ${warning.message}`);
    }

    // Emit event for position manager
    this.emit('rugWarning', fullWarning);

    // Critical warnings get special emission
    if (warning.severity === 'critical') {
      this.emit('rugAlert', fullWarning);
    }
  }

  /**
   * Check if a position should be exited based on rug signals
   */
  shouldExit(mint: string): { shouldExit: boolean; reason: string } {
    const warnings = this.recentWarnings.get(mint) || [];
    const position = this.watchedPositions.get(mint);

    if (!position) {
      return { shouldExit: false, reason: '' };
    }

    // Exit immediately on creator sell
    const creatorSells = warnings.filter(w => w.type === 'creator_sell');
    if (creatorSells.length > 0) {
      return {
        shouldExit: true,
        reason: `Creator sold (${position.creatorSellCount} times, ${position.creatorTotalSold.toLocaleString()} tokens)`
      };
    }

    // Exit on multiple critical warnings
    const criticalWarnings = warnings.filter(w =>
      w.severity === 'critical' &&
      Date.now() - w.timestamp.getTime() < 60000  // Last minute
    );

    if (criticalWarnings.length >= 2) {
      return {
        shouldExit: true,
        reason: `Multiple critical warnings: ${criticalWarnings.map(w => w.type).join(', ')}`,
      };
    }

    // Exit on large dump + price crash combo
    const recentLargeDump = warnings.find(w =>
      w.type === 'large_dump' &&
      w.severity === 'critical' &&
      Date.now() - w.timestamp.getTime() < 30000
    );
    const recentCrash = warnings.find(w =>
      w.type === 'price_crash' &&
      Date.now() - w.timestamp.getTime() < 30000
    );

    if (recentLargeDump && recentCrash) {
      return {
        shouldExit: true,
        reason: 'Large dump followed by price crash - likely rug',
      };
    }

    return { shouldExit: false, reason: '' };
  }

  /**
   * Get warnings for a position
   */
  getWarnings(mint: string): RugWarning[] {
    return this.recentWarnings.get(mint) || [];
  }

  /**
   * Get watched position stats
   */
  getPositionStats(mint: string): WatchedPosition | null {
    return this.watchedPositions.get(mint) || null;
  }

  /**
   * Get all watched positions
   */
  getWatchedMints(): string[] {
    return Array.from(this.watchedPositions.keys());
  }
}

export const rugMonitor = new RugMonitor();
</file>

<file path="src/signals/token-watchlist.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';

const logger = createChildLogger('token-watchlist');

export interface TradeData {
  txType: 'buy' | 'sell';
  traderPublicKey: string;
  tokenAmount: number;
  marketCapSol: number;
  priceSol: number;
  timestamp: number;
}

export interface WatchedToken {
  mint: string;
  creator: string;
  firstSeen: number;
  priceHistory: Array<{
    price: number;
    marketCap: number;
    timestamp: number;
  }>;
  trades: TradeData[];
  devSold: boolean;
  devSoldPercent: number;           // NEW: Track percentage of dev holdings sold
  devInitialHolding: number;        // NEW: Track initial dev holding for percentage calc
  devSoldTimestamp: number | null;  // NEW: When dev first sold
  peakPrice: number;
  lowestPrice: number;
  volumeHistory: Array<{            // NEW: Track volume windows for acceleration
    count: number;
    timestamp: number;
  }>;
  uniqueTraderHistory: number[];    // NEW: Track unique trader growth
}

export interface WatchlistFeatures {
  priceChange: number;
  volatility: number;
  drawdown: number;
  buyPressure: number;
  volumeTrend: number;
  ageMinutes: number;
  ageSeconds: number;               // NEW: Raw age in seconds
  uniqueTraders: number;
  devHolding: number;
  devSoldPercent: number;           // NEW: Percentage of dev holdings sold
  volumeAcceleration: number;       // NEW: Volume acceleration (recent vs previous window)
  uniqueTraderGrowth: number;       // NEW: Growth in unique traders over time
  hasMomentum: boolean;             // NEW: Whether momentum override conditions met
}

export interface MomentumSignal {
  hasMomentum: boolean;
  buyPressure: number;
  volumeAcceleration: number;
  uniqueTraderGrowth: number;
  reason: string;
}

export interface HardFilterResult {
  passes: boolean;
  reason: string;
}

export class TokenWatchlist extends EventEmitter {
  private watchlist: Map<string, WatchedToken> = new Map();
  private readonly minDataPoints = config.watchlist?.minDataPoints || 10;

  constructor() {
    super();
  }

  addToken(mint: string, creator: string): void {
    if (this.watchlist.has(mint)) {
      logger.debug({ mint }, 'Token already in watchlist');
      return;
    }

    this.watchlist.set(mint, {
      mint,
      creator,
      firstSeen: Date.now(),
      priceHistory: [],
      trades: [],
      devSold: false,
      devSoldPercent: 0,
      devInitialHolding: 0,
      devSoldTimestamp: null,
      peakPrice: 0,
      lowestPrice: Infinity,
      volumeHistory: [],
      uniqueTraderHistory: [],
    });

    logger.info({ mint: mint.substring(0, 15), creator: creator.substring(0, 10) }, 'Added token to watchlist');
    this.emit('tokenAdded', { mint, creator });
  }

  removeToken(mint: string): void {
    if (this.watchlist.delete(mint)) {
      logger.debug({ mint }, 'Removed token from watchlist');
      this.emit('tokenRemoved', { mint });
    }
  }

  recordPrice(mint: string, price: number, marketCap: number): void {
    const token = this.watchlist.get(mint);
    if (!token) return;

    token.priceHistory.push({ price, marketCap, timestamp: Date.now() });

    // Keep last 5 minutes of data (at ~1 update/sec = 300 entries)
    if (token.priceHistory.length > 300) {
      token.priceHistory = token.priceHistory.slice(-300);
    }

    // Track peak and lowest
    if (price > token.peakPrice) token.peakPrice = price;
    if (price < token.lowestPrice) token.lowestPrice = price;

    // Emit event when we have enough data points for AI analysis
    if (token.priceHistory.length === this.minDataPoints) {
      this.emit('tokenReady', { mint, token });
    }
  }

  recordTrade(mint: string, trade: Omit<TradeData, 'timestamp'>): void {
    const token = this.watchlist.get(mint);
    if (!token) return;

    const tradeWithTimestamp: TradeData = {
      ...trade,
      timestamp: Date.now(),
    };

    token.trades.push(tradeWithTimestamp);

    // Keep last 500 trades
    if (token.trades.length > 500) {
      token.trades = token.trades.slice(-500);
    }

    // Track volume windows for acceleration calculation (every 30 seconds)
    const now = Date.now();
    const lastVolumeEntry = token.volumeHistory[token.volumeHistory.length - 1];
    if (!lastVolumeEntry || now - lastVolumeEntry.timestamp >= 30000) {
      // Count trades in last 30 seconds
      const recentTrades = token.trades.filter(t => now - t.timestamp < 30000).length;
      token.volumeHistory.push({ count: recentTrades, timestamp: now });
      // Keep last 10 entries (5 minutes of 30-second windows)
      if (token.volumeHistory.length > 10) {
        token.volumeHistory = token.volumeHistory.slice(-10);
      }
    }

    // Track unique traders growth
    const uniqueTraders = new Set(token.trades.map(t => t.traderPublicKey)).size;
    token.uniqueTraderHistory.push(uniqueTraders);
    if (token.uniqueTraderHistory.length > 60) {
      token.uniqueTraderHistory = token.uniqueTraderHistory.slice(-60);
    }

    // Track dev behavior - percentage-based instead of binary
    if (trade.traderPublicKey === token.creator) {
      if (trade.txType === 'buy' && token.devInitialHolding === 0) {
        // Track initial dev holding
        token.devInitialHolding = trade.tokenAmount;
      } else if (trade.txType === 'sell') {
        // Calculate percentage sold
        if (token.devInitialHolding > 0) {
          token.devSoldPercent += trade.tokenAmount / token.devInitialHolding;
        } else {
          // If we don't know initial holding, estimate from this sell
          token.devSoldPercent = Math.min(token.devSoldPercent + 0.1, 1.0);
        }

        if (token.devSoldTimestamp === null) {
          token.devSoldTimestamp = now;
        }

        const ageSeconds = (now - token.firstSeen) / 1000;
        const earlyWindow = config.devSoldConfig?.earlyWindowSeconds || 180;
        const earlyMaxSell = config.devSoldConfig?.earlyMaxSellPercent || 0.02;
        const maxSell = config.devSoldConfig?.maxSellPercent || 0.05;

        // Check if dev sold too much (percentage-based)
        const threshold = ageSeconds < earlyWindow ? earlyMaxSell : maxSell;
        if (token.devSoldPercent > threshold) {
          token.devSold = true;
          logger.warn({
            mint: mint.substring(0, 15),
            devSoldPercent: (token.devSoldPercent * 100).toFixed(1) + '%',
            threshold: (threshold * 100).toFixed(1) + '%',
            ageSeconds: ageSeconds.toFixed(0),
          }, 'DEV SOLD TOO MUCH - Token flagged');
          this.emit('devSold', { mint, trade: tradeWithTimestamp, percent: token.devSoldPercent });
        } else {
          logger.debug({
            mint: mint.substring(0, 15),
            devSoldPercent: (token.devSoldPercent * 100).toFixed(1) + '%',
            threshold: (threshold * 100).toFixed(1) + '%',
          }, 'Dev sold (within threshold)');
        }
      }
    }

    // Update price if trade has price info
    if (trade.priceSol > 0) {
      this.recordPrice(mint, trade.priceSol, trade.marketCapSol);
    }
  }

  // HARD FILTERS: Instant rejection (don't waste AI on these)
  passesHardFilters(mint: string): HardFilterResult {
    const token = this.watchlist.get(mint);
    if (!token) {
      return { passes: false, reason: 'Token not in watchlist' };
    }

    // INSTANT REJECT: Dev already sold too much
    if (token.devSold) {
      return { passes: false, reason: `Dev sold ${(token.devSoldPercent * 100).toFixed(1)}%` };
    }

    // INSTANT REJECT: Not enough data for AI analysis
    if (token.priceHistory.length < this.minDataPoints) {
      return {
        passes: false,
        reason: `Only ${token.priceHistory.length}/${this.minDataPoints} data points`
      };
    }

    // NEW: INSTANT REJECT: Token too young (need time-based validity)
    const minAgeSeconds = config.watchlist?.minAgeSeconds || 60;
    const ageSeconds = (Date.now() - token.firstSeen) / 1000;
    if (ageSeconds < minAgeSeconds) {
      return {
        passes: false,
        reason: `Token only ${ageSeconds.toFixed(0)}s old (min ${minAgeSeconds}s)`
      };
    }

    // INSTANT REJECT: Crashed more than maxDrawdown from peak
    const maxDrawdown = config.watchlist?.maxDrawdown || 0.30;
    if (token.peakPrice > 0) {
      const currentPrice = token.priceHistory[token.priceHistory.length - 1]?.price || 0;
      const drawdown = (token.peakPrice - currentPrice) / token.peakPrice;
      if (drawdown > maxDrawdown) {
        return {
          passes: false,
          reason: `Crashed ${(drawdown * 100).toFixed(0)}% from peak (max ${(maxDrawdown * 100).toFixed(0)}%)`
        };
      }
    }

    return { passes: true, reason: 'Ready for AI analysis' };
  }

  // Extract features for DDQN agent
  extractFeatures(mint: string): WatchlistFeatures | null {
    const token = this.watchlist.get(mint);
    if (!token || token.priceHistory.length < this.minDataPoints) {
      return null;
    }

    const prices = token.priceHistory.map(p => p.price);
    const currentPrice = prices[prices.length - 1];
    const firstPrice = prices[0];

    // Recent trades (last 60 seconds)
    const recentTrades = token.trades.filter(t => Date.now() - t.timestamp < 60000);
    const recentBuys = recentTrades.filter(t => t.txType === 'buy').length;

    // Calculate features
    const priceChange = firstPrice > 0 ? (currentPrice - firstPrice) / firstPrice : 0;
    const volatility = this.calculateVolatility(prices);
    const drawdown = token.peakPrice > 0 ? (token.peakPrice - currentPrice) / token.peakPrice : 0;
    const buyPressure = recentTrades.length > 0 ? recentBuys / recentTrades.length : 0.5;
    const volumeTrend = this.calculateVolumeTrend(token.trades);
    const ageMinutes = (Date.now() - token.firstSeen) / 60000;
    const ageSeconds = (Date.now() - token.firstSeen) / 1000;
    const uniqueTraders = new Set(token.trades.map(t => t.traderPublicKey)).size;
    const devHolding = token.devSold ? 0 : 1 - token.devSoldPercent;
    const devSoldPercent = token.devSoldPercent;

    // Calculate volume acceleration (compare last 30s window to previous 30s)
    const volumeAcceleration = this.calculateVolumeAcceleration(token);

    // Calculate unique trader growth (compare current to 30 seconds ago)
    const uniqueTraderGrowth = this.calculateUniqueTraderGrowth(token);

    // Check momentum conditions
    const momentumSignal = this.checkMomentum(token, buyPressure, volumeAcceleration, uniqueTraderGrowth);

    return {
      priceChange,
      volatility,
      drawdown,
      buyPressure,
      volumeTrend,
      ageMinutes,
      ageSeconds,
      uniqueTraders,
      devHolding,
      devSoldPercent,
      volumeAcceleration,
      uniqueTraderGrowth,
      hasMomentum: momentumSignal.hasMomentum,
    };
  }

  // Calculate volume acceleration (recent window vs previous window)
  private calculateVolumeAcceleration(token: WatchedToken): number {
    if (token.volumeHistory.length < 2) return 1.0;

    const recent = token.volumeHistory[token.volumeHistory.length - 1]?.count || 0;
    const previous = token.volumeHistory[token.volumeHistory.length - 2]?.count || 1;

    return previous > 0 ? recent / previous : 1.0;
  }

  // Calculate unique trader growth
  private calculateUniqueTraderGrowth(token: WatchedToken): number {
    if (token.uniqueTraderHistory.length < 10) return 0;

    const current = token.uniqueTraderHistory[token.uniqueTraderHistory.length - 1];
    const previous = token.uniqueTraderHistory[Math.max(0, token.uniqueTraderHistory.length - 10)];

    return current - previous;
  }

  // Check if token has momentum override conditions
  checkMomentum(
    token: WatchedToken,
    buyPressure: number,
    volumeAcceleration: number,
    uniqueTraderGrowth: number
  ): MomentumSignal {
    const cfg = config.momentumOverride || {
      enabled: true,
      minBuyPressure: 0.75,
      minVolumeAcceleration: 1.2,
      minUniqueTraderGrowth: 3,
    };

    if (!cfg.enabled) {
      return {
        hasMomentum: false,
        buyPressure,
        volumeAcceleration,
        uniqueTraderGrowth,
        reason: 'Momentum override disabled',
      };
    }

    const meetsAll =
      buyPressure >= cfg.minBuyPressure &&
      volumeAcceleration >= cfg.minVolumeAcceleration &&
      uniqueTraderGrowth >= cfg.minUniqueTraderGrowth;

    const reasons: string[] = [];
    if (buyPressure >= cfg.minBuyPressure) {
      reasons.push(`buyPressure ${(buyPressure * 100).toFixed(0)}%`);
    }
    if (volumeAcceleration >= cfg.minVolumeAcceleration) {
      reasons.push(`volume accel ${volumeAcceleration.toFixed(2)}x`);
    }
    if (uniqueTraderGrowth >= cfg.minUniqueTraderGrowth) {
      reasons.push(`+${uniqueTraderGrowth} traders`);
    }

    return {
      hasMomentum: meetsAll,
      buyPressure,
      volumeAcceleration,
      uniqueTraderGrowth,
      reason: meetsAll ? `MOMENTUM: ${reasons.join(', ')}` : 'Conditions not met',
    };
  }

  // Get momentum signal for a token
  getMomentumSignal(mint: string): MomentumSignal | null {
    const token = this.watchlist.get(mint);
    if (!token) return null;

    const recentTrades = token.trades.filter(t => Date.now() - t.timestamp < 60000);
    const recentBuys = recentTrades.filter(t => t.txType === 'buy').length;
    const buyPressure = recentTrades.length > 0 ? recentBuys / recentTrades.length : 0.5;
    const volumeAcceleration = this.calculateVolumeAcceleration(token);
    const uniqueTraderGrowth = this.calculateUniqueTraderGrowth(token);

    return this.checkMomentum(token, buyPressure, volumeAcceleration, uniqueTraderGrowth);
  }

  // Calculate dynamic confidence threshold based on token age
  getDynamicConfidenceThreshold(mint: string): number {
    const token = this.watchlist.get(mint);
    if (!token) return config.watchlist?.maxConfidence || 0.70;

    const ageSeconds = (Date.now() - token.firstSeen) / 1000;
    const minConf = config.watchlist?.minConfidence || 0.55;
    const maxConf = config.watchlist?.maxConfidence || 0.70;

    // Scale confidence from minConf to maxConf over 180 seconds (3 minutes)
    // Formula: requiredConfidence = clamp(0.55 + (tokenAgeSeconds / 180) * 0.15, 0.55, 0.70)
    const scaleFactor = Math.min(ageSeconds / 180, 1.0);
    const threshold = minConf + scaleFactor * (maxConf - minConf);

    return Math.max(minConf, Math.min(maxConf, threshold));
  }

  // Convert features to array for AI model
  featuresToArray(features: WatchlistFeatures): number[] {
    return [
      features.priceChange,                                // Price momentum
      features.volatility,                                 // Risk indicator
      features.drawdown,                                   // How far from peak
      features.buyPressure,                                // Demand indicator
      features.volumeTrend,                                // Increasing or decreasing volume
      Math.min(features.ageMinutes / 10, 1),               // Normalized age (0-1 for first 10 min)
      Math.min(features.uniqueTraders / 50, 1),            // Normalized unique traders
      features.devHolding,                                 // Dev hasn't sold = 1 (scaled by sold percent)
      features.devSoldPercent,                             // NEW: How much dev sold
      Math.min(features.volumeAcceleration / 2, 1),        // NEW: Volume acceleration (capped at 2x)
      Math.min(features.uniqueTraderGrowth / 10, 1),       // NEW: Unique trader growth (capped at 10)
      features.hasMomentum ? 1 : 0,                        // NEW: Momentum override flag
    ];
  }

  private calculateVolatility(prices: number[]): number {
    if (prices.length < 2) return 0;

    const returns = prices.slice(1).map((p, i) =>
      prices[i] > 0 ? (p - prices[i]) / prices[i] : 0
    );

    if (returns.length === 0) return 0;

    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
    const variance = returns.reduce((a, r) => a + (r - mean) ** 2, 0) / returns.length;

    return Math.sqrt(variance);
  }

  private calculateVolumeTrend(trades: TradeData[]): number {
    if (trades.length < 10) return 0;

    const midpoint = Math.floor(trades.length / 2);
    const firstHalfCount = midpoint;
    const secondHalfCount = trades.length - midpoint;

    if (firstHalfCount === 0) return 0;

    return (secondHalfCount - firstHalfCount) / firstHalfCount;
  }

  // Get all tokens ready for AI analysis
  getReadyTokens(): string[] {
    const ready: string[] = [];

    for (const [mint, token] of this.watchlist.entries()) {
      const filterResult = this.passesHardFilters(mint);
      if (filterResult.passes) {
        ready.push(mint);
      }
    }

    return ready;
  }

  // Get all watched tokens (for frontend display)
  getAllTokens(): string[] {
    return Array.from(this.watchlist.keys());
  }

  // Get token info
  getToken(mint: string): WatchedToken | undefined {
    return this.watchlist.get(mint);
  }

  // Check if token is being watched
  isWatched(mint: string): boolean {
    return this.watchlist.has(mint);
  }

  // Get stats
  getStats(): { total: number; ready: number; devSold: number } {
    let ready = 0;
    let devSold = 0;

    for (const token of this.watchlist.values()) {
      if (this.passesHardFilters(token.mint).passes) ready++;
      if (token.devSold) devSold++;
    }

    return {
      total: this.watchlist.size,
      ready,
      devSold,
    };
  }

  // Cleanup old tokens (not seen for >10 minutes with no activity)
  cleanup(maxAge: number = 600000): void {
    const now = Date.now();

    for (const [mint, token] of this.watchlist.entries()) {
      const age = now - token.firstSeen;
      const lastActivity = token.trades.length > 0
        ? token.trades[token.trades.length - 1].timestamp
        : token.firstSeen;
      const timeSinceActivity = now - lastActivity;

      // Remove if old and inactive
      if (age > maxAge && timeSinceActivity > 60000) {
        this.watchlist.delete(mint);
        logger.debug({ mint }, 'Cleaned up inactive token');
      }
    }
  }
}

export const tokenWatchlist = new TokenWatchlist();
</file>

<file path="src/signals/types.ts">
export interface StateVector {
  priceChange1m: number;      // 1-minute price change percentage
  priceChange5m: number;      // 5-minute price change percentage
  volumeZScore: number;       // Volume relative to average
  buySellRatio: number;       // Ratio of buy to sell volume
  holderCount: number;        // Normalized holder count
  top10Concentration: number; // Top 10 holder concentration
  mintRevoked: number;        // 1 if mint authority revoked, 0 otherwise
  freezeRevoked: number;      // 1 if freeze authority revoked, 0 otherwise
  lpLocked: number;           // 1 if LP locked, 0 otherwise
  ageMinutes: number;         // Token age in minutes (normalized)
  tradeIntensity: number;     // Trades per minute normalized
  marketCapSol: number;       // Market cap in SOL (normalized)
  // NEW: Additional features for better DDQN decision making
  drawdownFromPeak: number;   // 0-1, how far price has dropped from peak
  volatility: number;         // 0-1, standard deviation of recent price changes
  uniqueTraders: number;      // 0-1, normalized count of unique traders
  volumeTrend: number;        // -1 to 1, volume acceleration/deceleration
}

export interface RugScore {
  total: number;              // 0-100 overall safety score
  mintAuthorityScore: number; // 0-25 points
  freezeAuthorityScore: number; // 0-20 points
  lpLockedScore: number;      // 0-25 points
  concentrationScore: number; // 0-15 points
  bundledBuysScore: number;   // 0-15 points
  details: string[];          // Human readable breakdown
}

export type PumpPhase = 'cold' | 'building' | 'hot' | 'peak' | 'dumping';

export interface PumpMetrics {
  phase: PumpPhase;
  heat: number;               // 0-200+ heat metric
  volumeRatio: number;        // 1min/5min volume ratio
  priceVelocity: number;      // Rate of price change
  buyPressure: number;        // Buy vs sell imbalance
  confidence: number;         // 0-1 confidence in assessment
}

export interface TokenSignal {
  mint: string;
  state: StateVector;
  rugScore: RugScore;
  pumpMetrics: PumpMetrics;
  timestamp: Date;
  recommendation: 'strong_buy' | 'buy' | 'hold' | 'sell' | 'avoid';
}

export interface FeatureHistory {
  mint: string;
  features: StateVector[];
  timestamps: Date[];
  maxHistory: number;
}

export interface VelocityMetrics {
  mint: string;
  txCount: number;
  buyCount: number;
  sellCount: number;
  uniqueBuyers: Set<string>;
  uniqueSellers: Set<string>;
  txPerMinute: number;
  buyPressure: number;  // buyCount / txCount
  windowStartTime: number;
}

export interface VelocityResult {
  hasGoodVelocity: boolean;
  metrics: VelocityMetrics | null;
  reason: string;
}

export interface EntryResult {
  canEnter: boolean;
  source: 'pump_detector' | 'velocity' | 'none';
  reason: string;
  metrics?: PumpMetrics | VelocityMetrics;
}
</file>

<file path="src/signals/velocity-tracker.ts">
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { VelocityMetrics, VelocityResult } from './types';

const logger = createChildLogger('velocity-tracker');

interface TradeEvent {
  mint: string;
  txType: 'buy' | 'sell';
  traderPublicKey: string;
  marketCapSol: number;
  timestamp: number;
}

export class VelocityTracker {
  // Rolling window of trades per token
  private tokenTrades: Map<string, TradeEvent[]> = new Map();
  private windowMs = 60000; // 60-second rolling window

  constructor() {}

  /**
   * Record a trade event from PumpPortal WebSocket
   */
  recordTrade(data: {
    mint: string;
    txType: 'buy' | 'sell';
    traderPublicKey: string;
    marketCapSol: number;
  }): void {
    const trade: TradeEvent = {
      ...data,
      timestamp: Date.now(),
    };

    let trades = this.tokenTrades.get(data.mint);
    if (!trades) {
      trades = [];
      this.tokenTrades.set(data.mint, trades);
    }

    trades.push(trade);

    // Prune old trades outside the window
    this.pruneOldTrades(data.mint);

    logger.debug({
      mint: data.mint.substring(0, 12),
      txType: data.txType,
      totalTrades: trades.length,
    }, 'Trade recorded');
  }

  /**
   * Remove trades outside the rolling window
   */
  private pruneOldTrades(mint: string): void {
    const trades = this.tokenTrades.get(mint);
    if (!trades) return;

    const cutoff = Date.now() - this.windowMs;
    const filtered = trades.filter(t => t.timestamp >= cutoff);
    this.tokenTrades.set(mint, filtered);
  }

  /**
   * Get velocity metrics for a token
   */
  getMetrics(mint: string): VelocityMetrics | null {
    this.pruneOldTrades(mint);
    const trades = this.tokenTrades.get(mint);

    if (!trades || trades.length === 0) {
      return null;
    }

    const uniqueBuyers = new Set<string>();
    const uniqueSellers = new Set<string>();
    let buyCount = 0;
    let sellCount = 0;

    for (const trade of trades) {
      if (trade.txType === 'buy') {
        buyCount++;
        uniqueBuyers.add(trade.traderPublicKey);
      } else {
        sellCount++;
        uniqueSellers.add(trade.traderPublicKey);
      }
    }

    const txCount = trades.length;
    const windowSeconds = this.windowMs / 1000;
    const txPerMinute = (txCount / windowSeconds) * 60;
    const buyPressure = txCount > 0 ? buyCount / txCount : 0;

    return {
      mint,
      txCount,
      buyCount,
      sellCount,
      uniqueBuyers,
      uniqueSellers,
      txPerMinute,
      buyPressure,
      windowStartTime: Date.now() - this.windowMs,
    };
  }

  /**
   * Check if a token has good velocity for entry
   */
  hasGoodVelocity(mint: string, marketCapSol?: number): VelocityResult {
    const metrics = this.getMetrics(mint);
    const thresholds = config.velocityEntry;

    if (!metrics) {
      return {
        hasGoodVelocity: false,
        metrics: null,
        reason: 'No trade data available',
      };
    }

    // Check market cap limit (only for early tokens)
    if (marketCapSol !== undefined && marketCapSol > thresholds.maxMarketCapSol) {
      return {
        hasGoodVelocity: false,
        metrics,
        reason: `Market cap ${marketCapSol.toFixed(2)} SOL exceeds ${thresholds.maxMarketCapSol} SOL limit`,
      };
    }

    // Check minimum transaction count
    if (metrics.txCount < thresholds.minTxCount) {
      return {
        hasGoodVelocity: false,
        metrics,
        reason: `Only ${metrics.txCount} txs, need ${thresholds.minTxCount}`,
      };
    }

    // Check unique buyers
    if (metrics.uniqueBuyers.size < thresholds.minUniqueBuyers) {
      return {
        hasGoodVelocity: false,
        metrics,
        reason: `Only ${metrics.uniqueBuyers.size} unique buyers, need ${thresholds.minUniqueBuyers}`,
      };
    }

    // Check buy pressure
    if (metrics.buyPressure < thresholds.minBuyPressure) {
      return {
        hasGoodVelocity: false,
        metrics,
        reason: `Buy pressure ${(metrics.buyPressure * 100).toFixed(0)}% below ${(thresholds.minBuyPressure * 100).toFixed(0)}%`,
      };
    }

    // All checks passed
    logger.info({
      mint: mint.substring(0, 12),
      txCount: metrics.txCount,
      uniqueBuyers: metrics.uniqueBuyers.size,
      buyPressure: (metrics.buyPressure * 100).toFixed(0) + '%',
      txPerMinute: metrics.txPerMinute.toFixed(1),
    }, 'Good velocity detected');

    return {
      hasGoodVelocity: true,
      metrics,
      reason: `Velocity OK: ${metrics.txCount} txs, ${metrics.uniqueBuyers.size} buyers, ${(metrics.buyPressure * 100).toFixed(0)}% buys`,
    };
  }

  /**
   * Check if we have any trade data for a token
   */
  hasTradeData(mint: string): boolean {
    const trades = this.tokenTrades.get(mint);
    return trades !== undefined && trades.length > 0;
  }

  /**
   * Clear data for a token (after position closed or rejected)
   */
  clearToken(mint: string): void {
    this.tokenTrades.delete(mint);
  }

  /**
   * Get status for logging
   */
  getStatus(): string {
    return `Tracking ${this.tokenTrades.size} tokens`;
  }
}

export const velocityTracker = new VelocityTracker();
</file>

<file path="src/test-velocity.ts">
/**
 * Quick test script for velocity tracker
 * Run with: npx ts-node src/test-velocity.ts
 */

import { velocityTracker } from './signals/velocity-tracker';
import { config } from './config/settings';

const TEST_MINT = 'TestToken123pump';

console.log('\n=== Velocity Tracker Test ===\n');
console.log('Config thresholds:', config.velocityEntry);

// Test 1: No trades - should fail
console.log('\n--- Test 1: No trades ---');
let result = velocityTracker.hasGoodVelocity(TEST_MINT, 5);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);

// Test 2: Add some trades but not enough
console.log('\n--- Test 2: Only 3 trades (below threshold) ---');
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'buy', traderPublicKey: 'wallet1', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'buy', traderPublicKey: 'wallet2', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'buy', traderPublicKey: 'wallet3', marketCapSol: 5 });

result = velocityTracker.hasGoodVelocity(TEST_MINT, 5);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);
console.log('Metrics:', result.metrics ? {
  txCount: result.metrics.txCount,
  uniqueBuyers: result.metrics.uniqueBuyers.size,
  buyPressure: (result.metrics.buyPressure * 100).toFixed(0) + '%'
} : null);

// Test 3: Add enough trades with good buy pressure
console.log('\n--- Test 3: 6 trades, 4 buyers, 83% buys ---');
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'buy', traderPublicKey: 'wallet4', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'buy', traderPublicKey: 'wallet1', marketCapSol: 5 }); // repeat buyer
velocityTracker.recordTrade({ mint: TEST_MINT, txType: 'sell', traderPublicKey: 'seller1', marketCapSol: 5 });

result = velocityTracker.hasGoodVelocity(TEST_MINT, 5);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);
console.log('Metrics:', result.metrics ? {
  txCount: result.metrics.txCount,
  uniqueBuyers: result.metrics.uniqueBuyers.size,
  buyPressure: (result.metrics.buyPressure * 100).toFixed(0) + '%'
} : null);

// Test 4: Too high market cap
console.log('\n--- Test 4: Market cap too high (15 SOL > 10 SOL limit) ---');
result = velocityTracker.hasGoodVelocity(TEST_MINT, 15);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);

// Test 5: Low buy pressure (too many sells)
console.log('\n--- Test 5: Low buy pressure scenario ---');
const TEST_MINT2 = 'TestToken456pump';
velocityTracker.recordTrade({ mint: TEST_MINT2, txType: 'buy', traderPublicKey: 'wallet1', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT2, txType: 'buy', traderPublicKey: 'wallet2', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT2, txType: 'sell', traderPublicKey: 'wallet3', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT2, txType: 'sell', traderPublicKey: 'wallet4', marketCapSol: 5 });
velocityTracker.recordTrade({ mint: TEST_MINT2, txType: 'sell', traderPublicKey: 'wallet5', marketCapSol: 5 });

result = velocityTracker.hasGoodVelocity(TEST_MINT2, 5);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);
console.log('Metrics:', result.metrics ? {
  txCount: result.metrics.txCount,
  uniqueBuyers: result.metrics.uniqueBuyers.size,
  buyPressure: (result.metrics.buyPressure * 100).toFixed(0) + '%'
} : null);

// Test 6: Perfect scenario
console.log('\n--- Test 6: Perfect entry scenario ---');
const TEST_MINT3 = 'PerfectToken789pump';
for (let i = 0; i < 8; i++) {
  velocityTracker.recordTrade({ mint: TEST_MINT3, txType: 'buy', traderPublicKey: `buyer${i}`, marketCapSol: 3 });
}
velocityTracker.recordTrade({ mint: TEST_MINT3, txType: 'sell', traderPublicKey: 'seller1', marketCapSol: 3 });
velocityTracker.recordTrade({ mint: TEST_MINT3, txType: 'sell', traderPublicKey: 'seller2', marketCapSol: 3 });

result = velocityTracker.hasGoodVelocity(TEST_MINT3, 3);
console.log('Result:', result.hasGoodVelocity ? 'PASS' : 'FAIL');
console.log('Reason:', result.reason);
console.log('Metrics:', result.metrics ? {
  txCount: result.metrics.txCount,
  uniqueBuyers: result.metrics.uniqueBuyers.size,
  uniqueSellers: result.metrics.uniqueSellers.size,
  buyPressure: (result.metrics.buyPressure * 100).toFixed(0) + '%',
  txPerMinute: result.metrics.txPerMinute.toFixed(1)
} : null);

console.log('\n=== Test Complete ===\n');
</file>

<file path="src/utils/logger.ts">
import pino from 'pino';

export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: process.env.NODE_ENV !== 'production' ? {
    target: 'pino-pretty',
    options: {
      colorize: true,
      translateTime: 'SYS:standard',
      ignore: 'pid,hostname',
    },
  } : undefined,
});

export const createChildLogger = (name: string) => {
  return logger.child({ module: name });
};
</file>

<file path="wallet.md">
5NszqQ4X78p7gVVJCRj9heobwHhiPFNAw23Xn8t8swn9
2573AbP8EUacZZqx5TAkv4XFUkubmRGee2nScjYpMGFg
GTUFPqUSkv3emUSJXjsBMfJMx6R6abNNzaPnLnkNckhu
HQYLrckNnctASrmqh4u6nSCqPSQdmjgUVJqb2EZc64V
ApeiTAjq3V9grbN2jVbmpLb59wffYmwCBKZnugyuerLZ
Hzrc9hdpkvrMK8GXyHsZCt1B4E5DAkSLWa4pszFVWDXC
</file>

<file path="client/index.html">
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/png" href="/logo.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Claude Challenge</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>
</file>

<file path="client/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
eslint.config.js
index.html
package.json
public/header_full.png
public/header_logo.png
public/logo.png
public/vite.svg
README.md
src/App.css
src/App.tsx
src/assets/react.svg
src/components/AIStatus.tsx
src/components/ChallengeCard.tsx
src/components/EquityChart.tsx
src/components/Header.tsx
src/components/NarrativeStream.tsx
src/components/Positions.tsx
src/components/StatsGrid.tsx
src/components/TokenScanner.tsx
src/components/TradeList.tsx
src/components/Watchlist.tsx
src/hooks/useSocket.ts
src/index.css
src/main.tsx
src/types.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="index.html">
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/png" href="/logo.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>client</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>
</file>

<file path="package.json">
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="src/App.tsx">
import { Header } from './components/Header';
import { StatsGrid } from './components/StatsGrid';
import { ChallengeCard } from './components/ChallengeCard';
import { TokenScanner } from './components/TokenScanner';
import { TradeList } from './components/TradeList';
import { AIStatus } from './components/AIStatus';
import { Watchlist } from './components/Watchlist';
import { Positions } from './components/Positions';
import { EquityChart } from './components/EquityChart';
import { useSocket } from './hooks/useSocket';

function App() {
  const {
    isConnected,
    stats,
    trades,
    positions,
    positionsSummary,
    walletState,
    equityHistory,
    scannerData,
    isScanning,
    toasts,
    aiDecision,
    watchlistTokens,
    watchlistStats
  } = useSocket();

  return (
    <>
      <div className="dashboard">
        <Header isConnected={isConnected} />
        
        <StatsGrid stats={stats} />

        <div className="main-grid">
          <div className="left-column">
            <ChallengeCard stats={stats} />
            <EquityChart history={equityHistory} walletBalance={walletState?.solBalance} />
            <Positions positions={positions} summary={positionsSummary} />
            <TokenScanner data={scannerData || undefined} isScanning={isScanning} />
          </div>

          <div className="right-column">
            <TradeList trades={trades} />
            <AIStatus stats={stats} decision={aiDecision} />
            <Watchlist tokens={watchlistTokens} stats={watchlistStats} />
          </div>
        </div>
      </div>

      <div className="toast-container">
        {toasts.map((toast, i) => (
          <div key={i} className={`toast ${toast.type}`}>
            <div className="toast-title">{toast.title}</div>
            <div className="toast-message">{toast.message}</div>
          </div>
        ))}
      </div>
    </>
  );
}

export default App;
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/AIStatus.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats, AIDecisionData } from '../types';

interface AIStatusProps {
  stats: Stats;
  decision: AIDecisionData | null;
}

export const AIStatus: React.FC<AIStatusProps> = ({ stats, decision }) => {
  const [statusText, setStatusText] = useState('Initializing AI Model...');
  const winRate = parseFloat(stats.winRate || "0");
  const winStreak = stats.winStreak || 0;

  useEffect(() => {
    if (!decision) return;

    // Map action to text
    const actions = ['HOLD', 'BUY', 'SELL'];
    const actionText = actions[decision.action];
    
    // Map regime to text
    const regimes = ['BULL MARKET', 'VOLATILE', 'CRASH DETECTED'];
    const regimeText = regimes[decision.regime];

    setStatusText(`${regimeText}: Considering ${actionText} on $${decision.symbol}`);
  }, [decision]);

  // Fallback animation if no decision yet
  useEffect(() => {
    if (decision) return;
    const statuses = ['Analyzing market structure', 'Calculating Q-values', 'Scanning liquidity'];
    let index = 0;
    const interval = setInterval(() => {
      index = (index + 1) % statuses.length;
      setStatusText(statuses[index]);
    }, 3000);
    return () => clearInterval(interval);
  }, [decision]);

  // Visualize Q-Values (Buy vs Hold vs Sell reward expectations)
  // Normalize for display: find max absolute value to scale bars
  const qValues = decision?.qValues || [0, 0, 0]; // [Hold, Buy, Sell] typically
  const maxQ = Math.max(...qValues.map(Math.abs), 1); // Avoid div by zero
  
  // Confidence for the bar
  // Scale factor: AI confidence is often raw difference in Q-values (0.01-0.1 range)
  // We apply a sigmoid-like scaling to make it visible on the 0-100% bar
  const rawConfidence = decision ? decision.confidence : (winRate / 100);
  const scaledConfidence = Math.min(100, Math.max(0, rawConfidence * 500)); // Boost factor
  
  const confidence = decision ? scaledConfidence : Math.min(100, Math.max(0, winRate * 1.2));

  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">AI Engine</span>
      </div>
      <div className="ai-content">
        <div className="ai-indicator">
          <div className="ai-ring-outer"></div>
          <div className="ai-ring" style={{ animationDuration: decision ? '0.5s' : '1.5s' }}></div>
          <div className="ai-ring-inner"></div>
          <div className="ai-center">
            <div className="ai-center-dot" style={{ 
              background: decision?.action === 1 ? 'var(--success)' : 
                          decision?.action === 2 ? 'var(--error)' : '#FAFAF9' 
            }}></div>
          </div>
        </div>
        
        <div className="ai-status" style={{ minHeight: '40px' }}>{statusText}</div>

        {/* Q-Value Visualization */}
        <div style={{ display: 'flex', gap: '8px', marginBottom: '20px', height: '60px', alignItems: 'flex-end' }}>
          {['HOLD', 'BUY', 'SELL'].map((label, i) => {
            const val = qValues[i] || 0;
            const height = Math.abs(val) / maxQ * 100;
            const color = val > 0 ? 'var(--success)' : 'var(--error)';
            const isSelected = decision?.action === i;
            
            return (
              <div key={label} style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', opacity: isSelected ? 1 : 0.5 }}>
                 <div style={{ 
                   width: '100%', 
                   height: `${Math.max(10, height)}%`, 
                   background: color,
                   borderRadius: '4px',
                   transition: 'all 0.3s ease'
                 }}></div>
                 <span style={{ fontSize: '10px', marginTop: '4px', color: 'var(--text-muted)' }}>{label}</span>
              </div>
            );
          })}
        </div>

        <div className="confidence-bar">
          <div className="confidence-header">
            <span>Confidence</span>
            <span>{confidence.toFixed(0)}%</span>
          </div>
          <div className="confidence-track">
            <div 
              className="confidence-fill" 
              style={{ width: `${confidence}%` }}
            ></div>
          </div>
        </div>
        <div className="win-streak-box">
          <div className="win-streak-value animate-number">{winStreak}</div>
          <div className="win-streak-label">Win streak</div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/ChallengeCard.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats } from '../types';

interface ChallengeCardProps {
  stats: Stats;
}

export const ChallengeCard: React.FC<ChallengeCardProps> = ({ stats }) => {
  const multiplier = parseFloat(stats.multiplier || "1");
  const equity = parseFloat(stats.currentEquity || stats.initialCapital || "1");
  const initial = parseFloat(stats.initialCapital || "1");
  
  // Progress calculation (logarithmic scale feels better but linear for now as per original)
  // Max at 100x
  const progress = Math.min(100, Math.max(1, multiplier));

  const [displayMultiplier, setDisplayMultiplier] = useState(multiplier);
  
  useEffect(() => {
    setDisplayMultiplier(multiplier);
  }, [multiplier]);

  return (
    <div className="card">
      <div className="challenge-card">
        <div className="challenge-label">THE 1 â†’ 100 CHALLENGE</div>
        <div className="challenge-value animate-number">
          {displayMultiplier.toFixed(2)}<span>x</span>
        </div>
        <div className="challenge-sub">
          {equity.toFixed(2)} SOL from {initial} SOL start
        </div>
        <div className="progress-bar-container">
          <div className="progress-bar">
            <div 
              className="progress-fill" 
              style={{ width: `${progress}%` }}
            ></div>
          </div>
          <div className="progress-markers">
            <span className={multiplier >= 1 ? 'active' : ''}>1x</span>
            <span className={multiplier >= 10 ? 'active' : ''}>10x</span>
            <span className={multiplier >= 25 ? 'active' : ''}>25x</span>
            <span className={multiplier >= 50 ? 'active' : ''}>50x</span>
            <span className={multiplier >= 100 ? 'active' : ''}>100x</span>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/EquityChart.tsx">
import React, { useMemo } from 'react';
import type { EquitySnapshot } from '../hooks/useSocket';

interface EquityChartProps {
  history: EquitySnapshot[];
  walletBalance?: number;
}

export const EquityChart: React.FC<EquityChartProps> = ({ history, walletBalance }) => {
  const chartData = useMemo(() => {
    if (history.length < 2) return null;

    const values = history.map(s => s.totalEquity);
    const minVal = Math.min(...values);
    const maxVal = Math.max(...values);
    const range = maxVal - minVal || 1;

    // Chart dimensions
    const width = 300;
    const height = 60;
    const padding = 4;

    // Calculate points
    const points = values.map((val, i) => {
      const x = padding + (i / (values.length - 1)) * (width - padding * 2);
      const y = height - padding - ((val - minVal) / range) * (height - padding * 2);
      return `${x},${y}`;
    }).join(' ');

    // Determine trend
    const firstVal = values[0];
    const lastVal = values[values.length - 1];
    const isUp = lastVal >= firstVal;
    const change = lastVal - firstVal;
    const changePercent = firstVal > 0 ? (change / firstVal) * 100 : 0;

    return {
      points,
      width,
      height,
      isUp,
      change,
      changePercent,
      current: lastVal,
      min: minVal,
      max: maxVal,
    };
  }, [history]);

  if (!chartData) {
    return (
      <div className="card equity-chart-card">
        <div className="card-header">
          <span className="card-title">Equity</span>
        </div>
        <div className="equity-chart-empty">
          <span>Collecting data...</span>
          {walletBalance !== undefined && (
            <span className="wallet-balance">{walletBalance.toFixed(4)} SOL</span>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="card equity-chart-card">
      <div className="card-header">
        <span className="card-title">Equity</span>
        <span className={`card-badge ${chartData.isUp ? 'positive' : 'negative'}`}>
          {chartData.isUp ? '+' : ''}{chartData.changePercent.toFixed(2)}%
        </span>
      </div>
      <div className="equity-chart-content">
        <div className="equity-current">
          <span className="equity-value">{chartData.current.toFixed(4)}</span>
          <span className="equity-label">SOL</span>
        </div>
        <svg
          className="equity-sparkline"
          viewBox={`0 0 ${chartData.width} ${chartData.height}`}
          preserveAspectRatio="none"
        >
          <defs>
            <linearGradient id="equityGradient" x1="0" y1="0" x2="0" y2="1">
              <stop
                offset="0%"
                stopColor={chartData.isUp ? '#10b981' : '#ef4444'}
                stopOpacity="0.3"
              />
              <stop
                offset="100%"
                stopColor={chartData.isUp ? '#10b981' : '#ef4444'}
                stopOpacity="0"
              />
            </linearGradient>
          </defs>
          <polygon
            points={`${4},${chartData.height - 4} ${chartData.points} ${chartData.width - 4},${chartData.height - 4}`}
            fill="url(#equityGradient)"
          />
          <polyline
            points={chartData.points}
            fill="none"
            stroke={chartData.isUp ? '#10b981' : '#ef4444'}
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
        </svg>
        <div className="equity-range">
          <span>{chartData.min.toFixed(2)}</span>
          <span>{chartData.max.toFixed(2)}</span>
        </div>
      </div>
      <div className="equity-footer">
        <span className={chartData.isUp ? 'positive' : 'negative'}>
          {chartData.isUp ? '+' : ''}{chartData.change.toFixed(4)} SOL (24h)
        </span>
        {walletBalance !== undefined && (
          <span className="wallet-indicator">
            Wallet: {walletBalance.toFixed(4)}
          </span>
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/components/Header.tsx">
import React from 'react';

interface HeaderProps {
  isConnected: boolean;
}

export const Header: React.FC<HeaderProps> = ({ isConnected }) => {
  return (
    <header className="header">
      <div style={{ position: 'absolute', left: '50%', transform: 'translateX(-50%)', width: '300px', height: '80px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
        <img src="/header_full.png" alt="1 to 100 Sol Challenge" style={{ width: '100%', height: '100%', objectFit: 'contain' }} />
      </div>
      <div 
        className="live-badge" 
        style={{
          background: isConnected ? 'var(--success-subtle)' : 'var(--error-subtle)',
          borderColor: isConnected ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)',
          color: isConnected ? 'var(--success)' : 'var(--error)'
        }}
      >
        {isConnected && <span className="live-dot"></span>}
        <span>{isConnected ? 'Live' : 'Disconnected'}</span>
      </div>
    </header>
  );
};
</file>

<file path="src/components/NarrativeStream.tsx">
import React from 'react';
import type { NarrativeSignal } from '../types';

interface NarrativeStreamProps {
  signal: NarrativeSignal | null;
}

export const NarrativeStream: React.FC<NarrativeStreamProps> = ({ signal }) => {
  if (!signal) return null;

  return (
    <div className="card" style={{ marginTop: '24px' }}>
      <div className="card-header">
        <span className="card-title">Narrative Stream</span>
        <div style={{
          padding: '4px 12px',
          borderRadius: '20px',
          fontSize: '11px',
          background: signal.sentiment === 'bullish' ? 'var(--success-subtle)' : 
                      signal.sentiment === 'bearish' ? 'var(--error-subtle)' : 'var(--bg-elevated)',
          color: signal.sentiment === 'bullish' ? 'var(--success)' :
                 signal.sentiment === 'bearish' ? 'var(--error)' : 'var(--text-muted)'
        }}>
          {signal.sentiment.toUpperCase()}
        </div>
      </div>
      <div style={{ padding: '24px' }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '16px' }}>
          <div>
            <div className="stat-label">Bullish Score</div>
            <div className="metric-value" style={{ fontSize: '18px' }}>
              {signal.bullishnessScore.toFixed(2)}
            </div>
          </div>
          <div>
            <div className="stat-label">Hype Score</div>
            <div className="metric-value" style={{ fontSize: '18px', color: 'var(--accent)' }}>
              {(signal.hypeScore * 100).toFixed(0)}%
            </div>
          </div>
        </div>

        <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
          {signal.keywords.map((k, i) => (
            <span key={i} style={{
              background: 'rgba(255,255,255,0.05)',
              padding: '6px 10px',
              borderRadius: '6px',
              fontSize: '12px',
              color: 'var(--text-secondary)'
            }}>
              #{k}
            </span>
          ))}
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/Positions.tsx">
import React from 'react';
import type { Position } from '../hooks/useSocket';

interface PositionsProps {
  positions: Position[];
  summary: { totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null;
}

const formatHoldTime = (ms: number): string => {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  }
  if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  }
  return `${seconds}s`;
};

export const Positions: React.FC<PositionsProps> = ({ positions, summary }) => {
  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">Open Positions</span>
        {summary && (
          <span className={`card-badge ${parseFloat(summary.totalUnrealizedPnl) >= 0 ? 'positive' : 'negative'}`}>
            {parseFloat(summary.totalUnrealizedPnl) >= 0 ? '+' : ''}{parseFloat(summary.totalUnrealizedPnl).toFixed(4)} SOL
          </span>
        )}
      </div>
      <div className="positions-list">
        {positions.length === 0 ? (
          <div className="empty-state">No open positions</div>
        ) : (
          positions.map((p) => {
            const unrealizedPnl = parseFloat(String(p.unrealizedPnl));
            const unrealizedPnlPercent = parseFloat(String(p.unrealizedPnlPercent));
            const realizedPnl = p.realizedPnl ? parseFloat(String(p.realizedPnl)) : 0;
            const isProfit = unrealizedPnl >= 0;
            const holdTime = formatHoldTime(p.holdTime);

            return (
              <div key={p.id} className="position-item">
                <div className={`position-indicator ${isProfit ? 'profit' : 'loss'}`} />
                <div className="position-info">
                  <div className="position-header">
                    <span className="position-symbol">${p.symbol || p.mint.substring(0, 6).toUpperCase()}</span>
                    <span className="position-pool">{p.poolType}</span>
                  </div>
                  <div className="position-details">
                    <span className="position-size">{p.amountSol.toFixed(4)} SOL</span>
                    <span className="position-hold">{holdTime}</span>
                  </div>
                </div>
                <div className="position-pnl">
                  <div className={`position-unrealized ${isProfit ? 'positive' : 'negative'}`}>
                    {isProfit ? '+' : ''}{unrealizedPnl.toFixed(4)}
                    <span className="position-pnl-percent">({unrealizedPnlPercent.toFixed(1)}%)</span>
                  </div>
                  {realizedPnl !== 0 && (
                    <div className="position-realized">
                      Realized: {realizedPnl >= 0 ? '+' : ''}{realizedPnl.toFixed(4)}
                    </div>
                  )}
                </div>
                <div className="position-status">
                  {p.initialRecovered && <span className="status-badge recovered">IR</span>}
                  {p.scaledExitsTaken && p.scaledExitsTaken > 0 && (
                    <span className="status-badge exits">x{p.scaledExitsTaken}</span>
                  )}
                  {p.trailingStop && <span className="status-badge trailing">TS</span>}
                </div>
              </div>
            );
          })
        )}
      </div>
      {summary && positions.length > 0 && (
        <div className="positions-footer">
          <span>Total Exposure: {summary.totalExposure} SOL</span>
          <span>{summary.positionCount} position{summary.positionCount !== 1 ? 's' : ''}</span>
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/StatsGrid.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats } from '../types';

interface StatsGridProps {
  stats: Stats;
}

const NumberDisplay: React.FC<{ value: string | number; className?: string }> = ({ value, className = "" }) => {
  const [displayValue, setDisplayValue] = useState(value);
  const [updating, setUpdating] = useState(false);

  useEffect(() => {
    if (value !== displayValue) {
      setUpdating(true);
      setDisplayValue(value);
      const timer = setTimeout(() => setUpdating(false), 300);
      return () => clearTimeout(timer);
    }
  }, [value, displayValue]);

  return (
    <div className={`animate-number ${updating ? 'updating' : ''} ${className}`}>
      {value}
    </div>
  );
};

export const StatsGrid: React.FC<StatsGridProps> = ({ stats }) => {
  const equity = parseFloat(stats.currentEquity || "0");
  const initial = parseFloat(stats.initialCapital || "0");
  const profit = equity - initial;
  const isProfit = profit >= 0;

  return (
    <div className="stats-grid">
      <div className="stat-card highlight">
        <div className="stat-label">Multiplier</div>
        <NumberDisplay value={`${parseFloat(stats.multiplier || "1").toFixed(2)}x`} className="stat-value accent" />
        <div className={`stat-sub ${isProfit ? 'positive' : ''}`}>
          <span className="arrow">â†‘</span>
          <span>{isProfit ? '+' : ''}{profit.toFixed(2)} SOL profit</span>
        </div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Win Rate</div>
        <NumberDisplay value={`${stats.winRate}%`} className="stat-value" />
        <div className="stat-sub positive">
          <span className="arrow">â†‘</span>
          <span>Creating alpha</span>
        </div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Total Trades</div>
        <NumberDisplay value={stats.totalTrades} className="stat-value" />
        <div className="stat-sub">Lifetime</div>
      </div>
      <div className="stat-card">
        <div className="stat-label">Tokens Scanned</div>
        <NumberDisplay value={stats.tokensScanned} className="stat-value" />
        <div className="stat-sub">Last 24 hours</div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/TokenScanner.tsx">
import React, { useEffect, useState } from 'react';
import type { ScannerData } from '../types';

interface TokenScannerProps {
  data?: ScannerData;
  isScanning: boolean;
}

// Helper to generate chart bars
const MiniChart: React.FC = () => {
  const [bars, setBars] = useState<Array<{ height: number; isUp: boolean }>>([]);

  useEffect(() => {
    // Generate static random chart on mount, or could animate
    const newBars = Array.from({ length: 40 }, () => ({
      height: Math.random() * 70 + 20,
      isUp: Math.random() > 0.4
    }));
    setBars(newBars);
  }, []);

  return (
    <div className="mini-chart">
      {bars.map((bar, i) => (
        <div 
          key={i} 
          className={`chart-bar ${bar.isUp ? 'up' : 'down'}`}
          style={{ height: `${bar.height}%` }}
        />
      ))}
    </div>
  );
};

export const TokenScanner: React.FC<TokenScannerProps> = ({ data, isScanning }) => {
  // Simulating metrics for visual flair if data is generic
  // In real app, these should come from backend
  const [metrics, setMetrics] = useState({
    safetyScore: '--',
    sentiment: '--',
    volume: '--',
    holders: '--'
  });

  useEffect(() => {
    if (data && data.mint) {
      // Simulate "analysis" result display
      setMetrics({
        safetyScore: String(Math.floor(Math.random() * 30 + 70)),
        sentiment: '+' + (Math.random() * 0.8 + 0.2).toFixed(1),
        volume: '$' + (Math.random() * 900000 + 100000).toLocaleString(undefined, { maximumFractionDigits: 0 }),
        holders: (Math.random() * 5000 + 1000).toFixed(0)
      });
    } else {
      setMetrics({
        safetyScore: '--',
        sentiment: '--',
        volume: '--',
        holders: '--'
      });
    }
  }, [data]);

  const tokenName = data?.mint ? `$${data.mint.substring(0, 6).toUpperCase()}` : 'Waiting...';

  return (
    <div className="card scanner-card">
      <div className="card-header">
        <span className="card-title">Token Scanner</span>
      </div>
      <div className="scanner-content">
        <div className="scanner-token">
          <div className={`scanner-icon ${!isScanning && !data?.mint ? 'idle' : ''}`}>
            âŸ³
          </div>
          <div className="scanner-token-info">
            <h4>{tokenName}</h4>
            <p>{isScanning ? 'Scanning for tokens' : 'Analyzing...'}</p>
          </div>
        </div>
        <div className="scanner-metrics">
          <div className="metric-box">
            <div className="metric-value accent">{metrics.safetyScore}</div>
            <div className="metric-label">Safety Score</div>
          </div>
          <div className="metric-box">
            <div className="metric-value success">{metrics.sentiment}</div>
            <div className="metric-label">Sentiment</div>
          </div>
          <div className="metric-box">
            <div className="metric-value">{metrics.volume}</div>
            <div className="metric-label">24H Volume</div>
          </div>
          <div className="metric-box">
            <div className="metric-value">{metrics.holders}</div>
            <div className="metric-label">Holders</div>
          </div>
        </div>
        <MiniChart />
      </div>
    </div>
  );
};
</file>

<file path="src/components/TradeList.tsx">
import React from 'react';
import type { Trade } from '../types';

interface TradeListProps {
  trades: Trade[];
}

export const TradeList: React.FC<TradeListProps> = ({ trades }) => {
  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">Recent Trades</span>
      </div>
      <div className="trades-list">
        {trades.length === 0 ? (
          <div className="empty-state">No trades yet</div>
        ) : (
          trades.map((t, i) => {
            const pnl = parseFloat(t.pnlSol || "0");
            const pnlPercent = parseFloat(t.pnlPercent || "0");
            const isProfit = pnl >= 0;
            const time = new Date(t.exitTime || t.entryTime).toLocaleTimeString('en-US', {
              hour: 'numeric',
              minute: '2-digit',
              hour12: true
            });

            return (
              <div key={i} className="trade-item">
                <div className={`trade-arrow ${isProfit ? 'up' : 'down'}`}>
                  {isProfit ? 'â†‘' : 'â†“'}
                </div>
                <div className="trade-info">
                  <div className="trade-token">
                    ${t.symbol || t.mint.substring(0, 6).toUpperCase()}
                  </div>
                  <div className="trade-time">{time}</div>
                </div>
                <div className="trade-pnl">
                  <div className={`trade-pnl-value ${isProfit ? 'positive' : 'negative'}`}>
                    {isProfit ? '+' : ''}{pnl.toFixed(3)} SOL
                  </div>
                  {isProfit && (
                    <div className="trade-pnl-percent">+{pnlPercent.toFixed(0)}%</div>
                  )}
                </div>
              </div>
            );
          })
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/components/Watchlist.tsx">
import React from 'react';
import type { WatchlistToken, WatchlistStats } from '../types';

interface WatchlistProps {
  tokens: WatchlistToken[];
  stats: WatchlistStats;
}

const getStatusColor = (status: WatchlistToken['status']) => {
  switch (status) {
    case 'collecting': return 'var(--text-muted)';
    case 'ready': return 'var(--accent)';
    case 'analyzing': return 'var(--warning)';
    case 'rejected': return 'var(--error)';
    case 'bought': return 'var(--success)';
    default: return 'var(--text-muted)';
  }
};

const getStatusBg = (status: WatchlistToken['status']) => {
  switch (status) {
    case 'collecting': return 'rgba(255,255,255,0.05)';
    case 'ready': return 'var(--accent-subtle)';
    case 'analyzing': return 'var(--warning-subtle)';
    case 'rejected': return 'var(--error-subtle)';
    case 'bought': return 'var(--success-subtle)';
    default: return 'rgba(255,255,255,0.05)';
  }
};

const formatAge = (firstSeen: number) => {
  const ageMs = Date.now() - firstSeen;
  const ageSec = Math.floor(ageMs / 1000);
  if (ageSec < 60) return `${ageSec}s`;
  const ageMin = Math.floor(ageSec / 60);
  if (ageMin < 60) return `${ageMin}m`;
  return `${Math.floor(ageMin / 60)}h`;
};

export const Watchlist: React.FC<WatchlistProps> = ({ tokens, stats }) => {
  return (
    <div className="card" style={{ marginTop: '24px' }}>
      <div className="card-header">
        <span className="card-title">Token Watchlist</span>
        <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
          <div style={{
            padding: '4px 12px',
            borderRadius: '20px',
            fontSize: '11px',
            background: 'var(--bg-elevated)',
            color: 'var(--text-muted)'
          }}>
            {stats.total} watching
          </div>
          <div style={{
            padding: '4px 12px',
            borderRadius: '20px',
            fontSize: '11px',
            background: 'var(--accent-subtle)',
            color: 'var(--accent)'
          }}>
            {stats.ready} ready
          </div>
          {stats.devSold > 0 && (
            <div style={{
              padding: '4px 12px',
              borderRadius: '20px',
              fontSize: '11px',
              background: 'var(--error-subtle)',
              color: 'var(--error)'
            }}>
              {stats.devSold} dev sold
            </div>
          )}
        </div>
      </div>

      <div style={{ padding: '16px', maxHeight: '400px', overflowY: 'auto' }}>
        {tokens.length === 0 ? (
          <div style={{
            textAlign: 'center',
            color: 'var(--text-muted)',
            padding: '24px',
            fontSize: '13px'
          }}>
            Waiting for new tokens...
          </div>
        ) : (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
            {tokens.map((token) => (
              <div
                key={token.mint}
                style={{
                  background: 'var(--bg-elevated)',
                  borderRadius: '8px',
                  padding: '12px',
                  border: token.devSold ? '1px solid var(--error)' : '1px solid transparent'
                }}
              >
                {/* Header Row */}
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <span style={{ fontFamily: 'var(--font-mono)', fontSize: '12px', color: 'var(--text-primary)' }}>
                      {token.symbol || token.mint.substring(0, 8) + '...'}
                    </span>
                    <span style={{
                      padding: '2px 8px',
                      borderRadius: '4px',
                      fontSize: '10px',
                      background: getStatusBg(token.status),
                      color: getStatusColor(token.status),
                      textTransform: 'uppercase'
                    }}>
                      {token.status}
                    </span>
                  </div>
                  <span style={{ fontSize: '11px', color: 'var(--text-muted)' }}>
                    {formatAge(token.firstSeen)} old
                  </span>
                </div>

                {/* Progress Bar for Data Collection */}
                {token.status === 'collecting' && (
                  <div style={{ marginBottom: '8px' }}>
                    <div style={{
                      background: 'rgba(255,255,255,0.1)',
                      borderRadius: '4px',
                      height: '4px',
                      overflow: 'hidden'
                    }}>
                      <div style={{
                        background: 'var(--accent)',
                        height: '100%',
                        width: `${Math.min(token.dataPoints * 10, 100)}%`,
                        transition: 'width 0.3s ease'
                      }} />
                    </div>
                    <div style={{ fontSize: '10px', color: 'var(--text-muted)', marginTop: '4px' }}>
                      {token.dataPoints}/10 data points
                    </div>
                  </div>
                )}

                {/* Rejection Reason */}
                {token.status === 'rejected' && token.rejectReason && (
                  <div style={{
                    fontSize: '11px',
                    color: 'var(--error)',
                    marginBottom: '8px'
                  }}>
                    {token.rejectReason}
                  </div>
                )}

                {/* Metrics Row */}
                {(token.status === 'ready' || token.status === 'analyzing') && (
                  <div style={{ display: 'flex', gap: '16px', flexWrap: 'wrap' }}>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Price</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.priceChange >= 0 ? 'var(--success)' : 'var(--error)'
                      }}>
                        {token.priceChange >= 0 ? '+' : ''}{(token.priceChange * 100).toFixed(1)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Drawdown</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.drawdown > 0.2 ? 'var(--error)' : 'var(--text-secondary)'
                      }}>
                        -{(token.drawdown * 100).toFixed(1)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Buy Pressure</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.buyPressure > 0.6 ? 'var(--success)' : 'var(--text-secondary)'
                      }}>
                        {(token.buyPressure * 100).toFixed(0)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Traders</div>
                      <div style={{ fontSize: '12px', color: 'var(--text-secondary)' }}>
                        {token.uniqueTraders}
                      </div>
                    </div>
                  </div>
                )}

                {/* Dev Sold Warning */}
                {token.devSold && (
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    marginTop: '8px',
                    padding: '6px 10px',
                    background: 'var(--error-subtle)',
                    borderRadius: '4px'
                  }}>
                    <span style={{ fontSize: '14px' }}>!</span>
                    <span style={{ fontSize: '11px', color: 'var(--error)' }}>DEV SOLD</span>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/hooks/useSocket.ts">
import { useEffect, useState } from 'react';
import { io, type Socket } from 'socket.io-client';
import type { Stats, ScannerData, Trade, ToastData, AIDecisionData, NarrativeSignal, WatchlistToken, WatchlistStats } from '../types';

export interface Position {
  id: string;
  mint: string;
  symbol: string;
  amount: number;
  amountSol: number;
  entryPrice: number;
  currentPrice: number;
  highestPrice: number;
  unrealizedPnl: number;
  unrealizedPnlPercent: number;
  realizedPnl?: number;
  totalPnl?: number;
  totalPnlPercent?: number;
  stopLoss: number;
  trailingStop?: number;
  initialRecovered?: boolean;
  scaledExitsTaken?: number;
  status: string;
  poolType: string;
  entryTime: string;
  holdTime: number;
}

export interface WalletState {
  solBalance: number;
  lastSync: string | null;
  isHealthy: boolean;
  totalEquity?: number;
}

export interface EquitySnapshot {
  timestamp: string;
  totalEquity: number;
  walletBalance: number;
  positionsValue: number;
  unrealizedPnl: number;
  positionCount: number;
}

interface UseSocketReturn {
  socket: Socket | null;
  isConnected: boolean;
  stats: Stats;
  trades: Trade[];
  positions: Position[];
  positionsSummary: { totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null;
  walletState: WalletState | null;
  equityHistory: EquitySnapshot[];
  scannerData: ScannerData | null;
  isScanning: boolean;
  toasts: ToastData[];
  aiDecision: AIDecisionData | null;
  narrativeSignal: NarrativeSignal | null;
  watchlistTokens: WatchlistToken[];
  watchlistStats: WatchlistStats;
  removeToast: (index: number) => void;
}

export const useSocket = (): UseSocketReturn => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  
  // Data State
  const [stats, setStats] = useState<Stats>({
    multiplier: "1.00",
    currentEquity: "0",
    initialCapital: "0",
    winRate: "0",
    totalTrades: 0,
    tokensScanned: 0,
    winStreak: 0
  });
  const [trades, setTrades] = useState<Trade[]>([]);
  const [positions, setPositions] = useState<Position[]>([]);
  const [positionsSummary, setPositionsSummary] = useState<{ totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null>(null);
  const [walletState, setWalletState] = useState<WalletState | null>(null);
  const [equityHistory, setEquityHistory] = useState<EquitySnapshot[]>([]);
  const [scannerData, setScannerData] = useState<ScannerData | null>(null);
  const [isScanning, setIsScanning] = useState(true);
  const [toasts, setToasts] = useState<ToastData[]>([]);
  const [aiDecision, setAiDecision] = useState<AIDecisionData | null>(null);
  const [narrativeSignal, setNarrativeSignal] = useState<NarrativeSignal | null>(null);
  const [watchlistTokens, setWatchlistTokens] = useState<WatchlistToken[]>([]);
  const [watchlistStats, setWatchlistStats] = useState<WatchlistStats>({ total: 0, ready: 0, devSold: 0 });

  // Use ref to access latest functions in event callbacks if needed, 
  // but state setters are stable.

  const addToast = (toast: ToastData) => {
    setToasts(prev => [...prev, toast]);
    // Auto remove after 4s
    setTimeout(() => {
      setToasts(prev => prev.slice(1)); // Simple FIFO removal, might change reference index
    }, 4000);
  };

  const removeToast = (index: number) => {
    setToasts(prev => prev.filter((_, i) => i !== index));
  };

  useEffect(() => {
    // Initial fetch
    const fetchData = async () => {
      try {
        const [statsRes, tradesRes, positionsRes, walletRes, equityRes] = await Promise.all([
          fetch('/api/stats'),
          fetch('/api/trades?limit=10'),
          fetch('/api/positions/realtime'),
          fetch('/api/wallet'),
          fetch('/api/equity-history?hours=24')
        ]);
        if (statsRes.ok) setStats(await statsRes.json());
        if (tradesRes.ok) setTrades(await tradesRes.json());
        if (positionsRes.ok) {
          const posData = await positionsRes.json();
          setPositions(posData.positions || []);
          setPositionsSummary(posData.summary || null);
        }
        if (walletRes.ok) {
          const walletData = await walletRes.json();
          setWalletState({
            solBalance: walletData.solBalance,
            lastSync: walletData.lastSync,
            isHealthy: walletData.isHealthy,
            totalEquity: walletData.equity?.total
          });
        }
        if (equityRes.ok) {
          const equityData = await equityRes.json();
          setEquityHistory(equityData.history || []);
        }
      } catch (err) {
        console.error("Failed to fetch initial data", err);
      }
    };
    fetchData();

    // Socket Connection
    // Note: In development with Vite proxy, '/' works if proxy is set.
    // Otherwise might need absolute URL.
    const newSocket = io('/', {
      transports: ['websocket'],
      reconnectionAttempts: 5
    });

    newSocket.on('connect', () => {
      setIsConnected(true);
      fetchData(); // Refresh on reconnect
    });

    newSocket.on('disconnect', () => {
      setIsConnected(false);
    });

    // Event Handlers
    newSocket.on('stats:initial', (data: Stats) => setStats(data));
    newSocket.on('stats:update', (data: Stats) => setStats(data));
    
    // Trades
    newSocket.on('trades:initial', (data: Trade[]) => setTrades(data));
    
    newSocket.on('trade:open', (trade: Trade) => {
      addToast({
        type: 'info',
        title: 'Position Opened',
        message: `Bought ${trade.symbol || trade.mint.substring(0, 8)} for ${trade.amountSol} SOL`
      });
      // Trade list is usually updated via rest fetch or full list push? 
      // The original code didn't update the list on 'trade:open', only on 'trade:close'.
      // But let's verify if we should.
    });

    newSocket.on('trade:close', (trade: Trade) => {
      const pnl = parseFloat(trade.pnlSol || "0");
      if (pnl > 0) {
        addToast({
          type: 'success',
          title: `+${trade.pnlSol} SOL`,
          message: `${trade.symbol} closed at ${trade.pnlPercent}%`
        });
      } else {
        addToast({
          type: 'error',
          title: `${trade.pnlSol} SOL`,
          message: `${trade.symbol} stopped out`
        });
      }
      // Refresh trades list
      fetch('/api/trades?limit=10')
        .then(r => r.json())
        .then(data => setTrades(data));
    });

    // Scanner
    newSocket.on('scanner:token', (data: ScannerData) => {
      setScannerData(data);
      setIsScanning(false);
      // Also update tokenScanned count in stats immediately if provided in data
      if (data.tokensScanned) {
        setStats(prev => ({ ...prev, tokensScanned: data.tokensScanned }));
      }
    });

    newSocket.on('scanner:idle', (data: ScannerData) => {
      setScannerData(null);
      setIsScanning(true);
      if (data && data.tokensScanned) {
        setStats(prev => ({ ...prev, tokensScanned: data.tokensScanned }));
      }
    });

    newSocket.on('ai:decision', (data: AIDecisionData) => {
      setAiDecision(data);
    });

    newSocket.on('signal:narrative', (data: NarrativeSignal) => {
      setNarrativeSignal(data);
    });

    // Watchlist events
    newSocket.on('watchlist:update', (data: { tokens: WatchlistToken[]; stats: WatchlistStats }) => {
      setWatchlistTokens(data.tokens);
      setWatchlistStats(data.stats);
    });

    newSocket.on('watchlist:tokenAdded', (token: WatchlistToken) => {
      setWatchlistTokens(prev => {
        // Add or update token
        const exists = prev.findIndex(t => t.mint === token.mint);
        if (exists >= 0) {
          const updated = [...prev];
          updated[exists] = token;
          return updated;
        }
        return [token, ...prev].slice(0, 20); // Keep latest 20
      });
    });

    newSocket.on('watchlist:tokenRemoved', (data: { mint: string }) => {
      setWatchlistTokens(prev => prev.filter(t => t.mint !== data.mint));
    });

    newSocket.on('watchlist:devSold', (data: { mint: string }) => {
      setWatchlistTokens(prev => prev.map(t =>
        t.mint === data.mint ? { ...t, devSold: true, status: 'rejected' as const, rejectReason: 'Dev sold' } : t
      ));
    });

    newSocket.on('status:paused', (data: { reason: string }) => {
      addToast({
        type: 'warning',
        title: 'Trading Paused',
        message: data.reason
      });
    });

    newSocket.on('toast', (data: ToastData) => {
      addToast(data);
    });

    // Position updates (real-time PnL)
    newSocket.on('positions:initial', (data: { positions: Position[]; totalUnrealizedPnl: string; totalExposure: string; positionCount: number }) => {
      setPositions(data.positions || []);
      setPositionsSummary({ totalUnrealizedPnl: data.totalUnrealizedPnl, totalExposure: data.totalExposure, positionCount: data.positionCount });
    });

    newSocket.on('positions:update', (data: { positions: Position[]; totalUnrealizedPnl: string; totalExposure: string; positionCount: number }) => {
      setPositions(data.positions || []);
      setPositionsSummary({ totalUnrealizedPnl: data.totalUnrealizedPnl, totalExposure: data.totalExposure, positionCount: data.positionCount });
    });

    // Wallet updates
    newSocket.on('wallet:update', (data: WalletState) => {
      setWalletState(data);
    });

    // Equity snapshots
    newSocket.on('equity:snapshot', (snapshot: EquitySnapshot) => {
      setEquityHistory(prev => {
        const updated = [...prev, snapshot];
        // Keep last 1440 snapshots (24 hours at 1 min intervals)
        if (updated.length > 1440) {
          return updated.slice(-1440);
        }
        return updated;
      });
    });

    // Reconciliation notifications
    newSocket.on('reconciliation:phantoms', (data: { count: number; phantoms: any[] }) => {
      if (data.count > 0) {
        addToast({
          type: 'warning',
          title: 'Phantom Positions Detected',
          message: `Found ${data.count} position(s) with no tokens`
        });
      }
    });

    setSocket(newSocket);

    return () => {
      newSocket.disconnect();
    };
  }, []);

  return {
    socket,
    isConnected,
    stats,
    trades,
    positions,
    positionsSummary,
    walletState,
    equityHistory,
    scannerData,
    isScanning,
    toasts,
    aiDecision,
    narrativeSignal,
    watchlistTokens,
    watchlistStats,
    removeToast
  };
};
</file>

<file path="src/index.css">
:root {
  /* Claude dark mode inspired palette - warm browns */
  --bg-page: #1C1917;
  --bg-card: #262320;
  --bg-card-hover: #2E2A26;
  --bg-elevated: #33302C;
  --border: rgba(255, 245, 230, 0.08);
  --border-light: rgba(255, 245, 230, 0.12);
  --text-primary: #F5F5F4;
  --text-secondary: #A8A29E;
  --text-muted: #78716C;
  --accent: #D97706;
  --accent-secondary: #F59E0B;
  --accent-glow: rgba(217, 119, 6, 0.3);
  --accent-subtle: rgba(217, 119, 6, 0.12);
  --success: #22C55E;
  --success-glow: rgba(34, 197, 94, 0.25);
  --success-subtle: rgba(34, 197, 94, 0.12);
  --error: #EF4444;
  --error-subtle: rgba(239, 68, 68, 0.12);
  --warning: #F59E0B;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg-page);
  color: var(--text-primary);
  min-height: 100vh;
  padding: 24px 32px;
  -webkit-font-smoothing: antialiased;
}

/* Subtle warm noise texture */
body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image:
    radial-gradient(circle at 50% 50%, rgba(217, 119, 6, 0.03) 0%, transparent 50%);
  pointer-events: none;
  z-index: -1;
}

.dashboard {
  max-width: 1280px;
  margin: 0 auto;
}

/* Header */
.header {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin-bottom: 48px;
  position: relative;
  min-height: 80px;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 20px;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  width: max-content;
}

.logo-icon {
  width: 72px;
  height: 72px;
  border-radius: 20px;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 8px 32px var(--accent-glow);
}

.logo-icon svg {
  width: 26px;
  height: 26px;
  color: white;
}

.logo-text h1 {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  letter-spacing: -0.02em;
}

.logo-text p {
  font-size: 13px;
  color: var(--text-muted);
  margin-top: 2px;
}

.live-badge {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 18px;
  border-radius: 100px;
  background: var(--success-subtle);
  border: 1px solid rgba(16, 185, 129, 0.2);
  color: var(--success);
  font-size: 13px;
  font-weight: 500;
  backdrop-filter: blur(10px);
}

.live-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--success);
  box-shadow: 0 0 12px var(--success);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {

  0%,
  100% {
    opacity: 1;
    transform: scale(1);
  }

  50% {
    opacity: 0.6;
    transform: scale(0.9);
  }
}

/* Stats Grid */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
  margin-bottom: 24px;
}

.stat-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 20px 24px;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.stat-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.06), transparent);
}

.stat-card:hover {
  background: var(--bg-card-hover);
  border-color: var(--border-light);
  transform: translateY(-2px);
}

.stat-card.highlight {
  background: linear-gradient(135deg, rgba(255, 107, 53, 0.08), rgba(255, 143, 92, 0.04));
  border-color: rgba(255, 107, 53, 0.3);
}

.stat-card.highlight::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
  opacity: 0.3;
  pointer-events: none;
}

.stat-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 10px;
}

.stat-value {
  font-size: 32px;
  font-weight: 600;
  color: var(--text-primary);
  line-height: 1.1;
  letter-spacing: -0.02em;
}

.stat-value.accent {
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.stat-sub {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
  margin-top: 8px;
}

.stat-sub.positive {
  color: var(--success);
}

.stat-sub .arrow {
  font-size: 14px;
}

/* Main Layout */
.main-grid {
  display: grid;
  grid-template-columns: 1.6fr 1fr;
  gap: 24px;
}

.left-column {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.right-column {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

/* Card Base */
.card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 20px;
  overflow: hidden;
  position: relative;
}

.card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.05), transparent);
}

.card-header {
  padding: 20px 24px;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.card-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.01em;
}

/* Challenge Card */
.challenge-card {
  padding: 48px 32px;
  text-align: center;
  position: relative;
}

.challenge-card::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 400px;
  height: 400px;
  background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
  opacity: 0.4;
  pointer-events: none;
}

.challenge-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.15em;
  margin-bottom: 20px;
  position: relative;
  z-index: 1;
}

.challenge-value {
  font-size: 84px;
  font-weight: 300;
  line-height: 1;
  position: relative;
  z-index: 1;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: 0 0 80px var(--accent-glow);
}

.challenge-value span {
  font-size: 42px;
  background: linear-gradient(135deg, var(--text-muted), var(--text-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.challenge-sub {
  font-size: 14px;
  color: var(--text-secondary);
  margin-top: 12px;
  margin-bottom: 32px;
  position: relative;
  z-index: 1;
}

.progress-bar-container {
  position: relative;
  z-index: 1;
}

.progress-bar {
  height: 10px;
  background: #3D3835;
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
  border-radius: 10px;
  transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
}

.progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.2), transparent);
  animation: shimmer 2.5s infinite;
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%);
  }

  100% {
    transform: translateX(100%);
  }
}

.progress-markers {
  display: flex;
  justify-content: space-between;
  margin-top: 12px;
  font-size: 11px;
  font-weight: 500;
  color: var(--text-muted);
}

.progress-markers span.active {
  color: var(--accent);
}

/* Scanner Card */
.scanner-card .card-header {
  border-bottom: none;
  padding-bottom: 0;
}

.scanner-content {
  padding: 0 24px 24px;
}

.scanner-token {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 18px;
  background: var(--bg-elevated);
  border-radius: 14px;
  margin-bottom: 18px;
  border: 1px solid var(--border);
}

.scanner-icon {
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--accent-subtle), transparent);
  border: 1px solid rgba(255, 107, 53, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  color: var(--accent);
  animation: rotate 2s linear infinite;
}

@keyframes rotate {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}

.scanner-icon.idle {
  animation: none;
}

.scanner-token-info h4 {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.01em;
}

.scanner-token-info p {
  font-size: 12px;
  color: var(--accent);
  margin-top: 2px;
}

.scanner-metrics {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-bottom: 18px;
}

.metric-box {
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px;
  text-align: center;
  transition: all 0.2s ease;
}

.metric-box:hover {
  border-color: var(--border-light);
  background: var(--bg-card-hover);
}

.metric-value {
  font-size: 22px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.02em;
}

.metric-value.accent {
  color: var(--accent);
}

.metric-value.success {
  color: var(--success);
}

.metric-label {
  font-size: 10px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.06em;
  margin-top: 6px;
}

/* Mini Chart */
.mini-chart {
  height: 60px;
  display: flex;
  align-items: flex-end;
  gap: 2px;
  padding: 12px 0;
}

.chart-bar {
  flex: 1;
  border-radius: 3px;
  transition: all 0.3s ease;
  min-height: 4px;
}

.chart-bar.up {
  background: linear-gradient(to top, var(--success), rgba(34, 197, 94, 0.5));
}

.chart-bar.down {
  background: linear-gradient(to top, #A8A29E, #78716C);
}

.chart-bar:hover {
  opacity: 0.8;
  transform: scaleY(1.1);
}

/* Recent Trades */
.trades-list {
  max-height: 360px;
  overflow-y: auto;
}

.trades-list::-webkit-scrollbar {
  width: 4px;
}

.trades-list::-webkit-scrollbar-track {
  background: transparent;
}

.trades-list::-webkit-scrollbar-thumb {
  background: #44403C;
  border-radius: 4px;
}

.trades-list::-webkit-scrollbar-thumb:hover {
  background: #57534E;
}

.trade-item {
  display: flex;
  align-items: center;
  padding: 14px 24px;
  border-bottom: 1px solid var(--border);
  gap: 14px;
  transition: background 0.15s ease;
}

.trade-item:hover {
  background: var(--bg-elevated);
}

.trade-item:last-child {
  border-bottom: none;
}

.trade-arrow {
  width: 36px;
  height: 36px;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: 600;
}

.trade-arrow.up {
  background: var(--success-subtle);
  color: var(--success);
  box-shadow: 0 0 20px var(--success-glow);
}

.trade-arrow.down {
  background: var(--error-subtle);
  color: var(--error);
}

.trade-info {
  flex: 1;
}

.trade-token {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}

.trade-time {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

.trade-pnl {
  text-align: right;
}

.trade-pnl-value {
  font-size: 14px;
  font-weight: 600;
}

.trade-pnl-value.positive {
  color: var(--success);
}

.trade-pnl-value.negative {
  color: var(--text-secondary);
}

.trade-pnl-percent {
  font-size: 11px;
  color: var(--success);
  margin-top: 2px;
}

/* AI Engine */
.ai-content {
  padding: 28px 24px;
  text-align: center;
}

.ai-indicator {
  width: 100px;
  height: 100px;
  margin: 0 auto 20px;
  position: relative;
}

.ai-ring-outer {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  border: 2px solid #3D3835;
}

.ai-ring {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  border: 2px solid transparent;
  border-top-color: var(--accent);
  animation: spin 1.5s linear infinite;
}

.ai-ring-inner {
  position: absolute;
  width: 70%;
  height: 70%;
  top: 15%;
  left: 15%;
  border-radius: 50%;
  border: 2px solid transparent;
  border-top-color: var(--accent-secondary);
  animation: spin 2s linear infinite reverse;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.ai-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 30px var(--accent-glow);
}

.ai-center-dot {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #FAFAF9;
  animation: pulse 2s ease-in-out infinite;
}

.ai-status {
  font-size: 13px;
  color: var(--text-secondary);
  margin-bottom: 20px;
}

.confidence-bar {
  margin-bottom: 24px;
}

.confidence-header {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  margin-bottom: 8px;
}

.confidence-header span:first-child {
  color: var(--text-muted);
}

.confidence-header span:last-child {
  color: var(--accent);
  font-weight: 600;
}

.confidence-track {
  height: 6px;
  background: #3D3835;
  border-radius: 6px;
  overflow: hidden;
}

.confidence-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
  border-radius: 6px;
  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

.win-streak-box {
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 24px;
}

.win-streak-value {
  font-size: 48px;
  font-weight: 300;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  line-height: 1;
}

.win-streak-label {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 8px;
}

/* Toast Notifications */
.toast-container {
  position: fixed;
  top: 24px;
  right: 24px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  z-index: 1000;
}

.toast {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 16px 20px;
  min-width: 300px;
  animation: slideIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
  backdrop-filter: blur(20px);
}

.toast.success {
  border-left: 3px solid var(--success);
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), 0 0 40px var(--success-glow);
}

.toast.error {
  border-left: 3px solid var(--error);
}

.toast.warning {
  border-left: 3px solid var(--warning);
}

.toast.info {
  border-left: 3px solid var(--accent);
}

.toast-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 4px;
}

.toast.success .toast-title {
  color: var(--success);
}

.toast.error .toast-title {
  color: var(--error);
}

.toast-message {
  font-size: 13px;
  color: var(--text-secondary);
}

@keyframes slideIn {
  from {
    transform: translateX(100%) scale(0.9);
    opacity: 0;
  }

  to {
    transform: translateX(0) scale(1);
    opacity: 1;
  }
}

/* Empty State */
.empty-state {
  padding: 40px 24px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
}

/* Responsive */
@media (max-width: 1024px) {
  .stats-grid {
    grid-template-columns: repeat(2, 1fr);
  }

  .main-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 600px) {
  .stats-grid {
    grid-template-columns: 1fr;
  }

  body {
    padding: 16px;
  }

  .header {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
  }

  .header-left {
    width: 100%;
  }

  .live-badge {
    position: absolute;
    top: 16px;
    right: 16px;
  }

  .challenge-value {
    font-size: 56px;
  }
}

/* Number animation */
.animate-number {
  display: inline-block;
  transition: transform 0.3s ease;
}

.animate-number.updating {
  transform: scale(1.05);
}

/* Positions Component */
.positions-list {
  max-height: 300px;
  overflow-y: auto;
}

.positions-list::-webkit-scrollbar {
  width: 4px;
}

.positions-list::-webkit-scrollbar-track {
  background: transparent;
}

.positions-list::-webkit-scrollbar-thumb {
  background: #44403C;
  border-radius: 4px;
}

.position-item {
  display: flex;
  align-items: center;
  padding: 14px 24px;
  border-bottom: 1px solid var(--border);
  gap: 12px;
  transition: background 0.15s ease;
}

.position-item:hover {
  background: var(--bg-elevated);
}

.position-item:last-child {
  border-bottom: none;
}

.position-indicator {
  width: 4px;
  height: 40px;
  border-radius: 2px;
}

.position-indicator.profit {
  background: var(--success);
  box-shadow: 0 0 8px var(--success-glow);
}

.position-indicator.loss {
  background: var(--error);
}

.position-info {
  flex: 1;
  min-width: 0;
}

.position-header {
  display: flex;
  align-items: center;
  gap: 8px;
}

.position-symbol {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}

.position-pool {
  font-size: 10px;
  font-weight: 500;
  padding: 2px 6px;
  border-radius: 4px;
  background: var(--accent-subtle);
  color: var(--accent);
  text-transform: uppercase;
}

.position-details {
  display: flex;
  gap: 12px;
  margin-top: 4px;
  font-size: 11px;
  color: var(--text-muted);
}

.position-pnl {
  text-align: right;
}

.position-unrealized {
  font-size: 14px;
  font-weight: 600;
}

.position-unrealized.positive {
  color: var(--success);
}

.position-unrealized.negative {
  color: var(--error);
}

.position-pnl-percent {
  font-size: 11px;
  opacity: 0.8;
  margin-left: 4px;
}

.position-realized {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

.position-status {
  display: flex;
  gap: 4px;
}

.status-badge {
  font-size: 9px;
  font-weight: 600;
  padding: 2px 5px;
  border-radius: 3px;
  text-transform: uppercase;
}

.status-badge.recovered {
  background: var(--success-subtle);
  color: var(--success);
}

.status-badge.exits {
  background: var(--accent-subtle);
  color: var(--accent);
}

.status-badge.trailing {
  background: rgba(139, 92, 246, 0.12);
  color: #a78bfa;
}

.positions-footer {
  padding: 12px 24px;
  border-top: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  color: var(--text-muted);
}

.card-badge {
  font-size: 12px;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 6px;
}

.card-badge.positive {
  background: var(--success-subtle);
  color: var(--success);
}

.card-badge.negative {
  background: var(--error-subtle);
  color: var(--error);
}

/* Equity Chart Component */
.equity-chart-card {
  min-height: 180px;
}

.equity-chart-content {
  padding: 16px 24px;
}

.equity-chart-empty {
  padding: 40px 24px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.wallet-balance {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
}

.equity-current {
  display: flex;
  align-items: baseline;
  gap: 6px;
  margin-bottom: 12px;
}

.equity-value {
  font-size: 28px;
  font-weight: 600;
  color: var(--text-primary);
}

.equity-label {
  font-size: 14px;
  color: var(--text-muted);
}

.equity-sparkline {
  width: 100%;
  height: 60px;
  display: block;
}

.equity-range {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 4px;
}

.equity-footer {
  padding: 12px 24px;
  border-top: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  font-size: 12px;
}

.equity-footer .positive {
  color: var(--success);
}

.equity-footer .negative {
  color: var(--error);
}

.wallet-indicator {
  color: var(--text-muted);
}
</file>

<file path="src/main.tsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  // StrictMode disabled to prevent double-socket connection in dev
  // or handle cleanup carefully in useEffect (which we did).
  // Keeping it enabled is fine if cleanup is robust.
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
</file>

<file path="src/types.ts">
export interface Stats {
  multiplier: string;
  currentEquity: string;
  initialCapital: string;
  winRate: string;
  totalTrades: number;
  tokensScanned: number;
  winStreak: number;
}

export interface Trade {
  id?: string;
  mint: string;
  symbol: string;
  amountSol: number;
  amountTokens: number;
  entryPrice: number;
  exitPrice?: number;
  pnlSol?: string;
  pnlPercent?: string;
  isOpen: boolean;
  entryTime: string;
  exitTime?: string;
}

export interface ScannerData {
  mint: string;
  tokensScanned: number;
  timestamp: number;
}

export interface ToastData {
  type: 'success' | 'error' | 'warning' | 'info';
  title: string;
  message: string;
}

export interface AIDecisionData {
  action: 0 | 1 | 2; // HOLD=0, BUY=1, SELL=2
  confidence: number;
  regime: 0 | 1 | 2; // BULL=0, VOLATILE=1, CRASH=2
  qValues: number[];
  mint: string;
  symbol: string;
  timestamp: string;
}

export interface NarrativeSignal {
  sentiment: 'bullish' | 'bearish' | 'neutral';
  bullishnessScore: number;
  hypeScore: number;
  keywords: string[];
  mint?: string;
  symbol?: string;
}

// Token Watchlist Types
export interface WatchlistToken {
  mint: string;
  symbol?: string;
  firstSeen: number;
  dataPoints: number;
  priceChange: number;
  volatility: number;
  drawdown: number;
  buyPressure: number;
  uniqueTraders: number;
  devSold: boolean;
  status: 'collecting' | 'ready' | 'analyzing' | 'rejected' | 'bought';
  rejectReason?: string;
}

export interface WatchlistStats {
  total: number;
  ready: number;
  devSold: number;
}
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "types": [
      "vite/client"
    ],
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": [
    "src"
  ]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3500',
        changeOrigin: true,
      },
      '/socket.io': {
        target: 'http://localhost:3500',
        ws: true,
      },
    },
  },
})
</file>

</files>
</file>

<file path="client/src/components/Positions.tsx">
import React from 'react';
import type { Position } from '../hooks/useSocket';
import { TokenDisplay } from './TokenDisplay';

interface PositionsProps {
  positions: Position[];
  summary: { totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null;
}

const formatHoldTime = (ms: number): string => {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  }
  if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  }
  return `${seconds}s`;
};

export const Positions: React.FC<PositionsProps> = ({ positions, summary }) => {
  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">Open Positions</span>
        {summary && (
          <span className={`card-badge ${parseFloat(summary.totalUnrealizedPnl) >= 0 ? 'positive' : 'negative'}`}>
            {parseFloat(summary.totalUnrealizedPnl) >= 0 ? '+' : ''}{parseFloat(summary.totalUnrealizedPnl).toFixed(4)} SOL
          </span>
        )}
      </div>
      <div className="positions-list">
        {positions.length === 0 ? (
          <div className="empty-state">No open positions</div>
        ) : (
          positions.map((p) => {
            const unrealizedPnl = parseFloat(String(p.unrealizedPnl));
            const unrealizedPnlPercent = parseFloat(String(p.unrealizedPnlPercent));
            const realizedPnl = p.realizedPnl ? parseFloat(String(p.realizedPnl)) : 0;
            const isProfit = unrealizedPnl >= 0;
            const holdTime = formatHoldTime(p.holdTime);

            return (
              <div key={p.id} className="position-item">
                <div className={`position-indicator ${isProfit ? 'profit' : 'loss'}`} />
                <div className="position-info">
                  <div className="position-header">
                    <TokenDisplay
                      mint={p.mint}
                      name={p.name}
                      symbol={p.symbol}
                      imageUrl={p.imageUrl}
                      size="sm"
                      showCopy={true}
                      inline={true}
                    />
                    <span className="position-pool">{p.poolType}</span>
                  </div>
                  <div className="position-details">
                    <span className="position-size">{p.amountSol.toFixed(4)} SOL</span>
                    <span className="position-hold">{holdTime}</span>
                  </div>
                </div>
                <div className="position-pnl">
                  <div className={`position-unrealized ${isProfit ? 'positive' : 'negative'}`}>
                    {isProfit ? '+' : ''}{unrealizedPnl.toFixed(4)}
                    <span className="position-pnl-percent">({unrealizedPnlPercent.toFixed(1)}%)</span>
                  </div>
                  {realizedPnl !== 0 && (
                    <div className="position-realized">
                      Realized: {realizedPnl >= 0 ? '+' : ''}{realizedPnl.toFixed(4)}
                    </div>
                  )}
                </div>
                <div className="position-status">
                  {p.initialRecovered && <span className="status-badge recovered">IR</span>}
                  {p.scaledExitsTaken && p.scaledExitsTaken > 0 && (
                    <span className="status-badge exits">x{p.scaledExitsTaken}</span>
                  )}
                  {p.trailingStop && <span className="status-badge trailing">TS</span>}
                </div>
              </div>
            );
          })
        )}
      </div>
      {summary && positions.length > 0 && (
        <div className="positions-footer">
          <span>Total Exposure: {summary.totalExposure} SOL</span>
          <span>{summary.positionCount} position{summary.positionCount !== 1 ? 's' : ''}</span>
        </div>
      )}
    </div>
  );
};
</file>

<file path="client/src/components/TradeList.tsx">
import React from 'react';
import type { Trade } from '../types';
import { TokenDisplay } from './TokenDisplay';

interface TradeListProps {
  trades: Trade[];
}

export const TradeList: React.FC<TradeListProps> = ({ trades }) => {
  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">Recent Trades</span>
      </div>
      <div className="trades-list">
        {trades.length === 0 ? (
          <div className="empty-state">No trades yet</div>
        ) : (
          trades.map((t, i) => {
            const pnl = parseFloat(t.pnlSol || "0");
            const pnlPercent = parseFloat(t.pnlPercent || "0");
            const isProfit = pnl >= 0;
            const time = new Date(t.exitTime || t.entryTime).toLocaleTimeString('en-US', {
              hour: 'numeric',
              minute: '2-digit',
              hour12: true
            });

            return (
              <div key={i} className="trade-item">
                <div className={`trade-arrow ${isProfit ? 'up' : 'down'}`}>
                  {isProfit ? 'â†‘' : 'â†“'}
                </div>
                <div className="trade-info">
                  <TokenDisplay
                    mint={t.mint}
                    name={t.name}
                    symbol={t.symbol}
                    imageUrl={t.imageUrl}
                    size="sm"
                    showCopy={true}
                    inline={true}
                  />
                  <div className="trade-time">{time}</div>
                </div>
                <div className="trade-pnl">
                  <div className={`trade-pnl-value ${isProfit ? 'positive' : 'negative'}`}>
                    {isProfit ? '+' : ''}{pnl.toFixed(3)} SOL
                  </div>
                  {isProfit && (
                    <div className="trade-pnl-percent">+{pnlPercent.toFixed(0)}%</div>
                  )}
                </div>
              </div>
            );
          })
        )}
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/Watchlist.tsx">
import React from 'react';
import type { WatchlistToken, WatchlistStats } from '../types';
import { TokenDisplay } from './TokenDisplay';

interface WatchlistProps {
  tokens: WatchlistToken[];
  stats: WatchlistStats;
}

const getStatusColor = (status: WatchlistToken['status']) => {
  switch (status) {
    case 'collecting': return 'var(--text-muted)';
    case 'ready': return 'var(--accent)';
    case 'analyzing': return 'var(--warning)';
    case 'rejected': return 'var(--error)';
    case 'bought': return 'var(--success)';
    default: return 'var(--text-muted)';
  }
};

const getStatusBg = (status: WatchlistToken['status']) => {
  switch (status) {
    case 'collecting': return 'rgba(255,255,255,0.05)';
    case 'ready': return 'var(--accent-subtle)';
    case 'analyzing': return 'var(--warning-subtle)';
    case 'rejected': return 'var(--error-subtle)';
    case 'bought': return 'var(--success-subtle)';
    default: return 'rgba(255,255,255,0.05)';
  }
};

const formatAge = (firstSeen: number) => {
  const ageMs = Date.now() - firstSeen;
  const ageSec = Math.floor(ageMs / 1000);
  if (ageSec < 60) return `${ageSec}s`;
  const ageMin = Math.floor(ageSec / 60);
  if (ageMin < 60) return `${ageMin}m`;
  return `${Math.floor(ageMin / 60)}h`;
};

export const Watchlist: React.FC<WatchlistProps> = ({ tokens, stats }) => {
  return (
    <div className="card" style={{ marginTop: '24px' }}>
      <div className="card-header">
        <span className="card-title">Token Watchlist</span>
        <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
          <div style={{
            padding: '4px 12px',
            borderRadius: '20px',
            fontSize: '11px',
            background: 'var(--bg-elevated)',
            color: 'var(--text-muted)'
          }}>
            {stats.total} watching
          </div>
          <div style={{
            padding: '4px 12px',
            borderRadius: '20px',
            fontSize: '11px',
            background: 'var(--accent-subtle)',
            color: 'var(--accent)'
          }}>
            {stats.ready} ready
          </div>
          {stats.devSold > 0 && (
            <div style={{
              padding: '4px 12px',
              borderRadius: '20px',
              fontSize: '11px',
              background: 'var(--error-subtle)',
              color: 'var(--error)'
            }}>
              {stats.devSold} dev sold
            </div>
          )}
        </div>
      </div>

      <div style={{ padding: '16px', maxHeight: '400px', overflowY: 'auto' }}>
        {tokens.length === 0 ? (
          <div style={{
            textAlign: 'center',
            color: 'var(--text-muted)',
            padding: '24px',
            fontSize: '13px'
          }}>
            Waiting for new tokens...
          </div>
        ) : (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
            {tokens.map((token) => (
              <div
                key={token.mint}
                style={{
                  background: 'var(--bg-elevated)',
                  borderRadius: '8px',
                  padding: '12px',
                  border: token.devSold ? '1px solid var(--error)' : '1px solid transparent'
                }}
              >
                {/* Header Row */}
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <TokenDisplay
                      mint={token.mint}
                      name={token.name}
                      symbol={token.symbol}
                      imageUrl={token.imageUrl}
                      size="sm"
                      showCopy={true}
                      inline={true}
                    />
                    <span style={{
                      padding: '2px 8px',
                      borderRadius: '4px',
                      fontSize: '10px',
                      background: getStatusBg(token.status),
                      color: getStatusColor(token.status),
                      textTransform: 'uppercase'
                    }}>
                      {token.status}
                    </span>
                  </div>
                  <span style={{ fontSize: '11px', color: 'var(--text-muted)' }}>
                    {formatAge(token.firstSeen)} old
                  </span>
                </div>

                {/* Progress Bar for Data Collection */}
                {token.status === 'collecting' && (
                  <div style={{ marginBottom: '8px' }}>
                    <div style={{
                      background: 'rgba(255,255,255,0.1)',
                      borderRadius: '4px',
                      height: '4px',
                      overflow: 'hidden'
                    }}>
                      <div style={{
                        background: 'var(--accent)',
                        height: '100%',
                        width: `${Math.min(token.dataPoints * 10, 100)}%`,
                        transition: 'width 0.3s ease'
                      }} />
                    </div>
                    <div style={{ fontSize: '10px', color: 'var(--text-muted)', marginTop: '4px' }}>
                      {token.dataPoints}/10 data points
                    </div>
                  </div>
                )}

                {/* Rejection Reason */}
                {token.status === 'rejected' && token.rejectReason && (
                  <div style={{
                    fontSize: '11px',
                    color: 'var(--error)',
                    marginBottom: '8px'
                  }}>
                    {token.rejectReason}
                  </div>
                )}

                {/* Metrics Row */}
                {(token.status === 'ready' || token.status === 'analyzing') && (
                  <div style={{ display: 'flex', gap: '16px', flexWrap: 'wrap' }}>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Price</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.priceChange >= 0 ? 'var(--success)' : 'var(--error)'
                      }}>
                        {token.priceChange >= 0 ? '+' : ''}{(token.priceChange * 100).toFixed(1)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Drawdown</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.drawdown > 0.2 ? 'var(--error)' : 'var(--text-secondary)'
                      }}>
                        -{(token.drawdown * 100).toFixed(1)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Buy Pressure</div>
                      <div style={{
                        fontSize: '12px',
                        color: token.buyPressure > 0.6 ? 'var(--success)' : 'var(--text-secondary)'
                      }}>
                        {(token.buyPressure * 100).toFixed(0)}%
                      </div>
                    </div>
                    <div>
                      <div style={{ fontSize: '10px', color: 'var(--text-muted)' }}>Traders</div>
                      <div style={{ fontSize: '12px', color: 'var(--text-secondary)' }}>
                        {token.uniqueTraders}
                      </div>
                    </div>
                  </div>
                )}

                {/* Dev Sold Warning */}
                {token.devSold && (
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    marginTop: '8px',
                    padding: '6px 10px',
                    background: 'var(--error-subtle)',
                    borderRadius: '4px'
                  }}>
                    <span style={{ fontSize: '14px' }}>!</span>
                    <span style={{ fontSize: '11px', color: 'var(--error)' }}>DEV SOLD</span>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="client/src/types.ts">
export interface Stats {
  multiplier: string;
  currentEquity: string;
  initialCapital: string;
  winRate: string;
  totalTrades: number;
  tokensScanned: number;
  winStreak: number;
}

export interface Trade {
  id?: string;
  mint: string;
  name?: string;
  symbol: string;
  imageUrl?: string | null;
  amountSol: number;
  amountTokens: number;
  entryPrice: number;
  exitPrice?: number;
  pnlSol?: string;
  pnlPercent?: string;
  isOpen: boolean;
  entryTime: string;
  exitTime?: string;
}

export interface ScannerData {
  mint: string;
  name?: string;
  symbol?: string;
  imageUrl?: string | null;
  tokensScanned: number;
  timestamp: number;
}

export interface ToastData {
  type: 'success' | 'error' | 'warning' | 'info';
  title: string;
  message: string;
}

export interface AIDecisionData {
  action: 0 | 1 | 2; // HOLD=0, BUY=1, SELL=2
  confidence: number;
  regime: 0 | 1 | 2; // BULL=0, VOLATILE=1, CRASH=2
  qValues: number[];
  mint: string;
  name?: string;
  symbol: string;
  imageUrl?: string | null;
  timestamp: string;
}

export interface NarrativeSignal {
  sentiment: 'bullish' | 'bearish' | 'neutral';
  bullishnessScore: number;
  hypeScore: number;
  keywords: string[];
  mint?: string;
  symbol?: string;
}

// Token Watchlist Types
export interface WatchlistToken {
  mint: string;
  name?: string;
  symbol?: string;
  imageUrl?: string | null;
  firstSeen: number;
  dataPoints: number;
  priceChange: number;
  volatility: number;
  drawdown: number;
  buyPressure: number;
  uniqueTraders: number;
  devSold: boolean;
  status: 'collecting' | 'ready' | 'analyzing' | 'rejected' | 'bought';
  rejectReason?: string;
}

export interface WatchlistStats {
  total: number;
  ready: number;
  devSold: number;
}

// C100 Token Types
export interface C100TokenData {
  mint: string;
  name: string;
  symbol: string;
  priceSol: number;
  priceUsd: number;
  marketCapUsd: number;
  volume24h: number;
  priceChange24h: number;
  lastUpdated: string;
}

export interface C100ClaimStats {
  totalClaimedSol: number;
  claimCount: number;
  lastClaimTime: string | null;
}

export interface C100BuybackStats {
  totalBuybackSol: number;
  totalTokensBought: number;
  buybackCount: number;
  lastBuybackTime: string | null;
}

export interface C100Data {
  enabled: boolean;
  token: C100TokenData | null;
  claims: C100ClaimStats;
  buybacks: C100BuybackStats;
}
</file>

<file path="client/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  build: {
    outDir: '../public',
    emptyOutDir: true,
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3500',
        changeOrigin: true,
      },
      '/socket.io': {
        target: 'http://localhost:3500',
        ws: true,
      },
    },
  },
})
</file>

<file path="src/__tests__/position-manager.test.ts">
/**
 * Position Manager TP/SL Logic Tests
 *
 * Tests the critical profit-taking and stop-loss logic:
 * - 12% stop loss
 * - +50% initial recovery (sell to recover cost)
 * - 15% trailing stop after recovery
 * - Scaled exits every +50% after recovery
 */

import { config } from '../config/settings';

// Helper to calculate profit percent
function calcProfitPercent(currentPrice: number, entryPrice: number): number {
  return (currentPrice - entryPrice) / entryPrice;
}

// Helper to check if stop loss should trigger
function shouldTriggerStopLoss(currentPrice: number, entryPrice: number): boolean {
  const profitPercent = calcProfitPercent(currentPrice, entryPrice);
  return profitPercent <= -config.stopLossPercent;
}

// Helper to check if trailing stop should trigger
function shouldTriggerTrailingStop(currentPrice: number, trailingStop: number | undefined): boolean {
  return trailingStop !== undefined && currentPrice <= trailingStop;
}

// Helper to check if initial recovery should trigger
function shouldTriggerInitialRecovery(
  currentPrice: number,
  entryPrice: number,
  initialRecovered: boolean
): boolean {
  if (initialRecovered) return false;
  const profitPercent = calcProfitPercent(currentPrice, entryPrice);
  return profitPercent >= config.takeProfitStrategy.initialRecovery.triggerPercent;
}

// Helper to calculate trailing stop price
function calcTrailingStop(currentPrice: number): number {
  return currentPrice * (1 - config.takeProfitStrategy.trailingStopPercent);
}

// Helper to calculate how many scaled exits should have been taken
function calcScaledExits(currentPrice: number, entryPrice: number): number {
  const profitPercent = calcProfitPercent(currentPrice, entryPrice);
  const profitSinceRecovery = profitPercent - config.takeProfitStrategy.initialRecovery.triggerPercent;
  if (profitSinceRecovery < 0) return 0;
  return Math.floor(profitSinceRecovery / config.takeProfitStrategy.scaledExits.intervalPercent);
}

describe('Position Manager TP/SL Logic', () => {
  // Verify config is correct
  describe('Config Verification', () => {
    it('should have 12% stop loss', () => {
      expect(config.stopLossPercent).toBe(0.12);
    });

    it('should have 15% trailing stop', () => {
      expect(config.takeProfitStrategy.trailingStopPercent).toBe(0.15);
    });

    it('should have +50% initial recovery trigger', () => {
      expect(config.takeProfitStrategy.initialRecovery.triggerPercent).toBe(0.50);
    });

    it('should have 20% scaled exit sell percent', () => {
      expect(config.takeProfitStrategy.scaledExits.sellPercent).toBe(0.20);
    });
  });

  describe('Stop Loss', () => {
    const entryPrice = 0.001; // 0.001 SOL per token

    it('should NOT trigger at -11% loss', () => {
      const currentPrice = entryPrice * 0.89; // -11%
      expect(shouldTriggerStopLoss(currentPrice, entryPrice)).toBe(false);
    });

    it('should trigger at -12.1% loss (just past threshold)', () => {
      const currentPrice = entryPrice * 0.879; // -12.1%
      expect(shouldTriggerStopLoss(currentPrice, entryPrice)).toBe(true);
    });

    it('should trigger at -20% loss', () => {
      const currentPrice = entryPrice * 0.80; // -20%
      expect(shouldTriggerStopLoss(currentPrice, entryPrice)).toBe(true);
    });

    it('should NOT trigger when in profit', () => {
      const currentPrice = entryPrice * 1.5; // +50%
      expect(shouldTriggerStopLoss(currentPrice, entryPrice)).toBe(false);
    });
  });

  describe('Initial Recovery (+50%)', () => {
    const entryPrice = 0.001;

    it('should NOT trigger at +40%', () => {
      const currentPrice = entryPrice * 1.40;
      expect(shouldTriggerInitialRecovery(currentPrice, entryPrice, false)).toBe(false);
    });

    it('should trigger at exactly +50%', () => {
      const currentPrice = entryPrice * 1.50;
      expect(shouldTriggerInitialRecovery(currentPrice, entryPrice, false)).toBe(true);
    });

    it('should trigger at +60%', () => {
      const currentPrice = entryPrice * 1.60;
      expect(shouldTriggerInitialRecovery(currentPrice, entryPrice, false)).toBe(true);
    });

    it('should NOT trigger if already recovered', () => {
      const currentPrice = entryPrice * 1.50;
      expect(shouldTriggerInitialRecovery(currentPrice, entryPrice, true)).toBe(false);
    });
  });

  describe('Trailing Stop', () => {
    it('should calculate 15% below current price', () => {
      const currentPrice = 0.002;
      const expectedStop = 0.002 * 0.85; // 15% below
      expect(calcTrailingStop(currentPrice)).toBeCloseTo(expectedStop, 10);
    });

    it('should trigger when price drops to trailing stop', () => {
      const trailingStop = 0.0017; // Set at $0.002 * 0.85
      const currentPrice = 0.0017;
      expect(shouldTriggerTrailingStop(currentPrice, trailingStop)).toBe(true);
    });

    it('should trigger when price drops below trailing stop', () => {
      const trailingStop = 0.0017;
      const currentPrice = 0.0015;
      expect(shouldTriggerTrailingStop(currentPrice, trailingStop)).toBe(true);
    });

    it('should NOT trigger when price is above trailing stop', () => {
      const trailingStop = 0.0017;
      const currentPrice = 0.0020;
      expect(shouldTriggerTrailingStop(currentPrice, trailingStop)).toBe(false);
    });

    it('should NOT trigger if trailing stop not set', () => {
      const currentPrice = 0.0010;
      expect(shouldTriggerTrailingStop(currentPrice, undefined)).toBe(false);
    });
  });

  describe('Scaled Exits', () => {
    const entryPrice = 0.001;

    it('should have 0 exits at +50% (just recovered)', () => {
      const currentPrice = entryPrice * 1.50; // +50%
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(0);
    });

    it('should have 0 exits at +90% (not yet +100%)', () => {
      const currentPrice = entryPrice * 1.90; // +90%
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(0);
    });

    it('should have 1 exit at +100% (50% + 50%)', () => {
      const currentPrice = entryPrice * 2.00; // +100%
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(1);
    });

    it('should have 2 exits at +150% (50% + 50% + 50%)', () => {
      const currentPrice = entryPrice * 2.50; // +150%
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(2);
    });

    it('should have 3 exits at +200%', () => {
      const currentPrice = entryPrice * 3.00; // +200%
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(3);
    });
  });

  describe('Full Scenario: Moon Mission', () => {
    const entryPrice = 0.001;
    const initialAmount = 1000000; // 1M tokens
    const initialInvestment = 1.0; // 1 SOL

    it('should properly handle a 3x pump', () => {
      // Start: entry at 0.001
      let currentPrice = entryPrice;
      let amount = initialAmount;
      let initialRecovered = false;
      let trailingStop: number | undefined;
      let scaledExitsTaken = 0;

      // Price pumps to +50% (1.5x)
      currentPrice = entryPrice * 1.50;
      expect(shouldTriggerStopLoss(currentPrice, entryPrice)).toBe(false);
      expect(shouldTriggerInitialRecovery(currentPrice, entryPrice, initialRecovered)).toBe(true);

      // Simulate recovery: sell enough to recover 1 SOL
      // sellAmount = initialInvestment / currentPrice = 1.0 / 0.0015 = 666.67 tokens
      const sellAmount = initialInvestment / currentPrice;
      amount -= sellAmount;
      initialRecovered = true;
      trailingStop = calcTrailingStop(currentPrice);

      // 1M tokens - 666.67 = ~999,333 tokens remaining
      expect(sellAmount).toBeCloseTo(666.67, 0);
      expect(amount).toBeCloseTo(999333.33, 0);
      expect(trailingStop).toBeCloseTo(0.001275, 6);

      // Price continues to +100% (2x)
      currentPrice = entryPrice * 2.00;
      trailingStop = calcTrailingStop(currentPrice); // Update trailing
      expect(shouldTriggerTrailingStop(currentPrice, trailingStop)).toBe(false);
      expect(calcScaledExits(currentPrice, entryPrice)).toBe(1);

      // Take scaled exit: sell 20% of remaining (~999,333 * 0.20 = ~199,866)
      const scaledSellAmount = amount * 0.20;
      amount -= scaledSellAmount;
      scaledExitsTaken++;

      // ~999,333 - ~199,866 = ~799,466 tokens remaining
      expect(amount).toBeCloseTo(799466.67, 0);
      expect(scaledExitsTaken).toBe(1);

      // Price dumps to trailing stop
      trailingStop = calcTrailingStop(entryPrice * 2.00); // 0.0017
      currentPrice = 0.0016; // Below trailing stop
      expect(shouldTriggerTrailingStop(currentPrice, trailingStop)).toBe(true);
    });
  });
});
</file>

<file path="src/__tests__/token-watchlist.test.ts">
/**
 * Token Watchlist Hard Filter Tests
 *
 * Tests the critical rejection logic:
 * - 30% max drawdown rejection
 * - Dev sold rejection (2% early, 5% normal)
 * - Minimum data points requirement
 * - Minimum age requirement
 */

import { config } from '../config/settings';

// Simulated WatchedToken for testing
interface TestWatchedToken {
  mint: string;
  firstSeen: number;
  priceHistory: Array<{ price: number; timestamp: number }>;
  devSold: boolean;
  devSoldPercent: number;
  peakPrice: number;
}

// Helper to check drawdown filter
function failsDrawdownFilter(token: TestWatchedToken): { fails: boolean; reason: string } {
  const maxDrawdown = config.watchlist?.maxDrawdown || 0.30;

  if (token.peakPrice <= 0 || token.priceHistory.length === 0) {
    return { fails: false, reason: 'No price data' };
  }

  const currentPrice = token.priceHistory[token.priceHistory.length - 1].price;
  const drawdown = (token.peakPrice - currentPrice) / token.peakPrice;

  if (drawdown > maxDrawdown) {
    return {
      fails: true,
      reason: `Crashed ${(drawdown * 100).toFixed(0)}% from peak (max ${(maxDrawdown * 100).toFixed(0)}%)`,
    };
  }

  return { fails: false, reason: 'Drawdown OK' };
}

// Helper to check dev sold filter
function failsDevSoldFilter(token: TestWatchedToken): { fails: boolean; reason: string } {
  if (token.devSold) {
    return {
      fails: true,
      reason: `Dev sold ${(token.devSoldPercent * 100).toFixed(1)}%`,
    };
  }
  return { fails: false, reason: 'Dev holding OK' };
}

// Helper to check minimum data points
function failsDataPointsFilter(token: TestWatchedToken): { fails: boolean; reason: string } {
  const minDataPoints = config.watchlist?.minDataPoints || 10;

  if (token.priceHistory.length < minDataPoints) {
    return {
      fails: true,
      reason: `Only ${token.priceHistory.length}/${minDataPoints} data points`,
    };
  }
  return { fails: false, reason: 'Data points OK' };
}

// Helper to check minimum age
function failsAgeFilter(token: TestWatchedToken): { fails: boolean; reason: string } {
  const minAgeSeconds = config.watchlist?.minAgeSeconds || 60;
  const ageSeconds = (Date.now() - token.firstSeen) / 1000;

  if (ageSeconds < minAgeSeconds) {
    return {
      fails: true,
      reason: `Token only ${ageSeconds.toFixed(0)}s old (min ${minAgeSeconds}s)`,
    };
  }
  return { fails: false, reason: 'Age OK' };
}

// Combined hard filter check
function passesHardFilters(token: TestWatchedToken): { passes: boolean; reason: string } {
  const devCheck = failsDevSoldFilter(token);
  if (devCheck.fails) return { passes: false, reason: devCheck.reason };

  const dataCheck = failsDataPointsFilter(token);
  if (dataCheck.fails) return { passes: false, reason: dataCheck.reason };

  const ageCheck = failsAgeFilter(token);
  if (ageCheck.fails) return { passes: false, reason: ageCheck.reason };

  const drawdownCheck = failsDrawdownFilter(token);
  if (drawdownCheck.fails) return { passes: false, reason: drawdownCheck.reason };

  return { passes: true, reason: 'Ready for AI analysis' };
}

// Helper to create a test token
function createTestToken(overrides: Partial<TestWatchedToken> = {}): TestWatchedToken {
  const now = Date.now();
  return {
    mint: 'TestToken123pump',
    firstSeen: now - 120000, // 2 minutes ago (passes 60s min age)
    priceHistory: Array(15).fill(null).map((_, i) => ({
      price: 0.001,
      timestamp: now - (15 - i) * 1000,
    })),
    devSold: false,
    devSoldPercent: 0,
    peakPrice: 0.001,
    ...overrides,
  };
}

describe('Token Watchlist Hard Filters', () => {
  // Verify config
  describe('Config Verification', () => {
    it('should have 30% max drawdown', () => {
      expect(config.watchlist?.maxDrawdown).toBe(0.30);
    });

    it('should have 10 min data points', () => {
      expect(config.watchlist?.minDataPoints).toBe(10);
    });

    it('should have 60s min age', () => {
      expect(config.watchlist?.minAgeSeconds).toBe(60);
    });
  });

  describe('Drawdown Filter (30% max)', () => {
    it('should PASS at 0% drawdown (at peak)', () => {
      const token = createTestToken({ peakPrice: 0.001 });
      expect(failsDrawdownFilter(token).fails).toBe(false);
    });

    it('should PASS at 20% drawdown', () => {
      const token = createTestToken({
        peakPrice: 0.001,
        priceHistory: [{ price: 0.0008, timestamp: Date.now() }], // -20%
      });
      expect(failsDrawdownFilter(token).fails).toBe(false);
    });

    it('should PASS at 29% drawdown (just under threshold)', () => {
      const token = createTestToken({
        peakPrice: 0.001,
        priceHistory: [{ price: 0.00071, timestamp: Date.now() }], // -29%
      });
      expect(failsDrawdownFilter(token).fails).toBe(false);
    });

    it('should FAIL at 31% drawdown', () => {
      const token = createTestToken({
        peakPrice: 0.001,
        priceHistory: [{ price: 0.00069, timestamp: Date.now() }], // -31%
      });
      expect(failsDrawdownFilter(token).fails).toBe(true);
    });

    it('should FAIL at 50% drawdown', () => {
      const token = createTestToken({
        peakPrice: 0.001,
        priceHistory: [{ price: 0.0005, timestamp: Date.now() }], // -50%
      });
      const result = failsDrawdownFilter(token);
      expect(result.fails).toBe(true);
      expect(result.reason).toContain('50%');
    });
  });

  describe('Dev Sold Filter', () => {
    it('should PASS if dev has not sold', () => {
      const token = createTestToken({ devSold: false, devSoldPercent: 0 });
      expect(failsDevSoldFilter(token).fails).toBe(false);
    });

    it('should PASS if dev sold within threshold (not flagged)', () => {
      const token = createTestToken({
        devSold: false, // Not flagged by threshold logic
        devSoldPercent: 0.01, // 1%
      });
      expect(failsDevSoldFilter(token).fails).toBe(false);
    });

    it('should FAIL if dev sold flag is true', () => {
      const token = createTestToken({
        devSold: true,
        devSoldPercent: 0.06, // 6%
      });
      const result = failsDevSoldFilter(token);
      expect(result.fails).toBe(true);
      expect(result.reason).toContain('Dev sold');
    });
  });

  describe('Data Points Filter', () => {
    it('should FAIL with 5 data points', () => {
      const token = createTestToken({
        priceHistory: Array(5).fill({ price: 0.001, timestamp: Date.now() }),
      });
      const result = failsDataPointsFilter(token);
      expect(result.fails).toBe(true);
      expect(result.reason).toContain('5/10');
    });

    it('should FAIL with 9 data points', () => {
      const token = createTestToken({
        priceHistory: Array(9).fill({ price: 0.001, timestamp: Date.now() }),
      });
      expect(failsDataPointsFilter(token).fails).toBe(true);
    });

    it('should PASS with 10 data points', () => {
      const token = createTestToken({
        priceHistory: Array(10).fill({ price: 0.001, timestamp: Date.now() }),
      });
      expect(failsDataPointsFilter(token).fails).toBe(false);
    });

    it('should PASS with 50 data points', () => {
      const token = createTestToken({
        priceHistory: Array(50).fill({ price: 0.001, timestamp: Date.now() }),
      });
      expect(failsDataPointsFilter(token).fails).toBe(false);
    });
  });

  describe('Age Filter', () => {
    it('should FAIL if token is 30 seconds old', () => {
      const token = createTestToken({
        firstSeen: Date.now() - 30000, // 30 seconds ago
      });
      expect(failsAgeFilter(token).fails).toBe(true);
    });

    it('should FAIL if token is 59 seconds old', () => {
      const token = createTestToken({
        firstSeen: Date.now() - 59000,
      });
      expect(failsAgeFilter(token).fails).toBe(true);
    });

    it('should PASS if token is 60 seconds old', () => {
      const token = createTestToken({
        firstSeen: Date.now() - 60000,
      });
      expect(failsAgeFilter(token).fails).toBe(false);
    });

    it('should PASS if token is 5 minutes old', () => {
      const token = createTestToken({
        firstSeen: Date.now() - 300000,
      });
      expect(failsAgeFilter(token).fails).toBe(false);
    });
  });

  describe('Combined Hard Filters', () => {
    it('should PASS a healthy token', () => {
      const token = createTestToken();
      const result = passesHardFilters(token);
      expect(result.passes).toBe(true);
      expect(result.reason).toBe('Ready for AI analysis');
    });

    it('should FAIL early on dev sold (first check)', () => {
      const token = createTestToken({ devSold: true, devSoldPercent: 0.10 });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(false);
      expect(result.reason).toContain('Dev sold');
    });

    it('should FAIL on data points if dev OK', () => {
      const token = createTestToken({
        priceHistory: Array(3).fill({ price: 0.001, timestamp: Date.now() }),
      });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(false);
      expect(result.reason).toContain('data points');
    });

    it('should FAIL on drawdown last', () => {
      const token = createTestToken({
        peakPrice: 0.001,
        priceHistory: Array(15).fill(null).map(() => ({
          price: 0.0005, // -50% drawdown
          timestamp: Date.now(),
        })),
      });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(false);
      expect(result.reason).toContain('Crashed');
    });
  });

  describe('Real-World Scenarios', () => {
    it('should reject a rug pull (dev dumps)', () => {
      const token = createTestToken({
        devSold: true,
        devSoldPercent: 0.50, // Dev dumped 50%
        peakPrice: 0.001,
        priceHistory: [{ price: 0.0003, timestamp: Date.now() }], // -70%
      });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(false);
    });

    it('should reject a dead token (crashed and no recovery)', () => {
      const token = createTestToken({
        peakPrice: 0.002, // Was 2x from start
        priceHistory: Array(20).fill(null).map(() => ({
          price: 0.0005, // Now at -75% from peak
          timestamp: Date.now(),
        })),
      });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(false);
      expect(result.reason).toContain('Crashed');
    });

    it('should accept a healthy pumping token', () => {
      const now = Date.now();
      const token = createTestToken({
        firstSeen: now - 180000, // 3 minutes old
        peakPrice: 0.0015, // Pumped to 1.5x
        priceHistory: Array(30).fill(null).map((_, i) => ({
          price: 0.001 + (i * 0.00001), // Gradually increasing
          timestamp: now - (30 - i) * 1000,
        })),
      });
      const result = passesHardFilters(token);
      expect(result.passes).toBe(true);
    });
  });
});
</file>

<file path="src/api/index.ts">
export { ApiServer, apiServer } from './server';
export { setupRoutes } from './routes';
export { setupWebSocket, getTokensScanned, resetTokensScanned } from './websocket';
</file>

<file path="src/api/server.ts">
import express, { Express } from 'express';
import { createServer, Server as HttpServer } from 'http';
import { Server as SocketServer } from 'socket.io';
import cors from 'cors';
import path from 'path';
import { createChildLogger } from '../utils/logger';
import { setupRoutes } from './routes';
import { setupWebSocket } from './websocket';

const logger = createChildLogger('api-server');

export class ApiServer {
  private app: Express;
  private httpServer: HttpServer;
  private io: SocketServer;
  private port: number;

  constructor(port: number = 3500) {
    this.port = port;
    this.app = express();
    this.httpServer = createServer(this.app);
    this.io = new SocketServer(this.httpServer, {
      cors: {
        origin: '*',
        methods: ['GET', 'POST'],
      },
    });

    this.setupMiddleware();
    this.setupStaticFiles();
    setupRoutes(this.app);
    setupWebSocket(this.io);
  }

  private setupMiddleware(): void {
    this.app.use(cors());
    this.app.use(express.json());
  }

  private setupStaticFiles(): void {
    // Serve static files from the public directory
    const publicPath = path.join(__dirname, '../../public');
    this.app.use(express.static(publicPath));

    // Serve index.html for root route
    this.app.get('/', (req, res) => {
      res.sendFile(path.join(publicPath, 'index.html'));
    });
  }

  start(): Promise<void> {
    return new Promise((resolve) => {
      this.httpServer.listen(this.port, () => {
        logger.info({ port: this.port }, 'API server started');
        logger.info(`Dashboard available at http://localhost:${this.port}`);
        resolve();
      });
    });
  }

  stop(): Promise<void> {
    return new Promise((resolve) => {
      this.io.close();
      this.httpServer.close(() => {
        logger.info('API server stopped');
        resolve();
      });
    });
  }

  getIO(): SocketServer {
    return this.io;
  }
}

const PORT = parseInt(process.env.PORT || '3500', 10);
export const apiServer = new ApiServer(PORT);
</file>

<file path="src/api/websocket.ts">
import { Server as SocketServer, Socket } from 'socket.io';
import { createChildLogger } from '../utils/logger';
import { positionManager, capitalAllocator, drawdownGuard } from '../risk';
import { tradeLogger, performanceAnalytics } from '../learning';
import { heliusWs } from '../data';
import { tokenWatchlist } from '../signals';
import { config } from '../config/settings';
import { Position } from '../risk/types';
import { walletSync, equityTracker, positionReconciler, c100Tracker, rewardClaimer, c100Buyback } from '../services';

const logger = createChildLogger('websocket');

// Track scanner state
let tokensScanned = 0;
let currentScanningToken: { mint: string; name?: string; symbol?: string; imageUrl?: string | null } | null = null;

// Token metadata cache for quick lookups
const tokenMetadataCache = new Map<string, { name?: string; symbol?: string; imageUrl?: string | null }>();

export function setupWebSocket(io: SocketServer): void {
  // Handle client connections
  io.on('connection', (socket: Socket) => {
    logger.info({ socketId: socket.id }, 'Client connected');

    // Send initial state on connect
    sendInitialState(socket);

    socket.on('disconnect', () => {
      logger.info({ socketId: socket.id }, 'Client disconnected');
    });

    // Allow clients to request refresh
    socket.on('refresh', async () => {
      await sendInitialState(socket);
    });
  });

  // Bridge existing EventEmitters to Socket.io
  setupEventBridges(io);

  // Start periodic broadcasts
  startPeriodicBroadcasts(io);

  logger.info('WebSocket handlers configured');
}

async function sendInitialState(socket: Socket): Promise<void> {
  try {
    // Send current stats
    const metrics = await performanceAnalytics.calculateMetrics();
    const allocation = capitalAllocator.getAllocation();
    const drawdown = drawdownGuard.getState();
    const positions = positionManager.getOpenPositions();
    const recentTrades = await tradeLogger.getRecentTrades(20);

    const totalUnrealizedPnl = positions.reduce((sum, p) => sum + p.unrealizedPnl, 0);
    const currentEquity = config.initialCapitalSol + metrics.totalPnl + totalUnrealizedPnl;
    const multiplier = currentEquity / config.initialCapitalSol;

    socket.emit('stats:initial', {
      multiplier: multiplier.toFixed(2),
      winRate: (metrics.winRate * 100).toFixed(1),
      totalTrades: metrics.totalTrades,
      tokensScanned,
      currentEquity: currentEquity.toFixed(4),
      initialCapital: config.initialCapitalSol,
      totalPnl: metrics.totalPnl.toFixed(4),
      totalUnrealizedPnl: totalUnrealizedPnl.toFixed(4),
      isPaused: drawdown.isPaused,
    });

    // Send current positions
    socket.emit('positions:initial', formatPositions(positions));

    // Send recent trades
    socket.emit('trades:initial', recentTrades.slice(0, 10).map(formatTrade));

    // Send scanner state
    socket.emit('scanner:initial', {
      tokensScanned,
      currentToken: currentScanningToken,
    });
  } catch (error) {
    logger.error({ error }, 'Failed to send initial state');
  }
}

function setupEventBridges(io: SocketServer): void {
  // New token detected (scanner event)
  heliusWs.on('newToken', (event: { mint: string; signature: string; name?: string; symbol?: string }) => {
    tokensScanned++;
    currentScanningToken = { mint: event.mint, name: event.name, symbol: event.symbol };

    // Cache metadata from event
    if (event.name || event.symbol) {
      tokenMetadataCache.set(event.mint, { name: event.name, symbol: event.symbol });
    }

    io.emit('scanner:token', {
      mint: event.mint,
      signature: event.signature,
      name: event.name,
      symbol: event.symbol,
      tokensScanned,
    });

    // Clear current token after a delay
    setTimeout(() => {
      if (currentScanningToken?.mint === event.mint) {
        currentScanningToken = null;
        io.emit('scanner:idle', { tokensScanned });
      }
    }, 10000);
  });

  // Token metadata updated (image fetched)
  heliusWs.on('tokenMetadataUpdated', (data: { mint: string; name: string; symbol: string; imageUrl: string | null }) => {
    // Update cache
    tokenMetadataCache.set(data.mint, { name: data.name, symbol: data.symbol, imageUrl: data.imageUrl });

    // Update current scanning token if it matches
    if (currentScanningToken?.mint === data.mint) {
      currentScanningToken = { ...currentScanningToken, ...data };
    }

    // Broadcast metadata update
    io.emit('token:metadataUpdate', {
      mint: data.mint,
      name: data.name,
      symbol: data.symbol,
      imageUrl: data.imageUrl,
    });
  });

  // Position opened
  positionManager.on('positionOpened', (position: Position) => {
    io.emit('trade:open', {
      id: position.id,
      mint: position.mint,
      symbol: position.symbol,
      amountSol: position.amountSol.toFixed(4),
      entryPrice: position.entryPrice,
      poolType: position.poolType,
      timestamp: new Date().toISOString(),
    });

    io.emit('toast', {
      type: 'info',
      title: 'Position Opened',
      message: `Bought ${position.symbol || position.mint.substring(0, 8)} for ${position.amountSol.toFixed(4)} SOL`,
    });
  });

  // Position closed
  positionManager.on('positionClosed', (data: {
    position: Position;
    reason: string;
    exitPrice: number;
    pnlSol: number;
    pnlPercent: number;
  }) => {
    const { position, reason, pnlSol, pnlPercent } = data;

    io.emit('trade:close', {
      id: position.id,
      mint: position.mint,
      symbol: position.symbol,
      pnlSol: pnlSol.toFixed(6),
      pnlPercent: pnlPercent.toFixed(2),
      reason,
      timestamp: new Date().toISOString(),
    });

    // Show toast for profitable trades
    if (pnlSol > 0) {
      io.emit('toast', {
        type: 'success',
        title: `+${pnlSol.toFixed(4)} SOL`,
        message: `${position.symbol || position.mint.substring(0, 8)} closed at ${pnlPercent.toFixed(1)}%`,
      });
    } else {
      io.emit('toast', {
        type: 'error',
        title: `${pnlSol.toFixed(4)} SOL`,
        message: `${position.symbol || position.mint.substring(0, 8)} stopped out at ${pnlPercent.toFixed(1)}%`,
      });
    }
  });

  // Partial close (take profit hit)
  positionManager.on('partialClose', (data: {
    position: Position;
    tpLevel: number;
    sellAmount: number;
  }) => {
    io.emit('trade:partial', {
      id: data.position.id,
      mint: data.position.mint,
      symbol: data.position.symbol,
      tpLevel: data.tpLevel + 1,
      sellAmount: data.sellAmount,
      timestamp: new Date().toISOString(),
    });

    io.emit('toast', {
      type: 'success',
      title: `TP${data.tpLevel + 1} Hit`,
      message: `${data.position.symbol || data.position.mint.substring(0, 8)} partial sell`,
    });
  });

  // Trading paused
  drawdownGuard.on('tradingPaused', (data: { reason: string; until?: Date }) => {
    io.emit('status:paused', {
      reason: data.reason,
      until: data.until?.toISOString(),
    });

    io.emit('toast', {
      type: 'warning',
      title: 'Trading Paused',
      message: data.reason,
    });
  });

  // Trading resumed
  drawdownGuard.on('tradingResumed', (data: { reason: string }) => {
    io.emit('status:resumed', {
      reason: data.reason,
    });

    io.emit('toast', {
      type: 'info',
      title: 'Trading Resumed',
      message: data.reason,
    });
  });

  // Trade logged
  tradeLogger.on('exitLogged', (trade: any) => {
    io.emit('trade:logged', formatTrade(trade));
  });

  // Token Watchlist events
  tokenWatchlist.on('tokenAdded', (data: { mint: string; creator: string }) => {
    const token = tokenWatchlist.getToken(data.mint);
    if (token) {
      io.emit('watchlist:tokenAdded', formatWatchlistToken(data.mint, token));
    }
  });

  tokenWatchlist.on('tokenRemoved', (data: { mint: string }) => {
    io.emit('watchlist:tokenRemoved', { mint: data.mint });
  });

  tokenWatchlist.on('devSold', (data: { mint: string }) => {
    io.emit('watchlist:devSold', { mint: data.mint });
    io.emit('toast', {
      type: 'warning',
      title: 'Dev Sold',
      message: `Token ${data.mint.substring(0, 8)}... creator dumped`,
    });
  });

  tokenWatchlist.on('tokenReady', (data: { mint: string }) => {
    const token = tokenWatchlist.getToken(data.mint);
    if (token) {
      io.emit('watchlist:tokenAdded', formatWatchlistToken(data.mint, token));
    }
  });

  // Wallet sync events
  walletSync.on('synced', (data) => {
    io.emit('wallet:update', {
      solBalance: data.solBalance,
      lastSync: data.syncTime,
      discrepancyCount: data.discrepancies.length,
    });
  });

  walletSync.on('discrepancies', (discrepancies) => {
    if (discrepancies.length > 0) {
      io.emit('toast', {
        type: 'warning',
        title: 'Balance Discrepancy',
        message: `Found ${discrepancies.length} position(s) with balance issues`,
      });
    }
  });

  // Equity tracker events
  equityTracker.on('snapshot', (snapshot) => {
    io.emit('equity:snapshot', {
      timestamp: snapshot.timestamp,
      totalEquity: snapshot.totalEquitySol,
      walletBalance: snapshot.walletBalanceSol,
      positionsValue: snapshot.positionsValueSol,
      unrealizedPnl: snapshot.unrealizedPnlSol,
      positionCount: snapshot.positionCount,
      source: snapshot.source,
    });
  });

  // Position reconciler events
  positionReconciler.on('phantomsDetected', (phantoms) => {
    io.emit('reconciliation:phantoms', {
      count: phantoms.length,
      phantoms: phantoms.map((p: any) => ({
        positionId: p.positionId,
        mint: p.mint.substring(0, 15) + '...',
        symbol: p.symbol,
        lostSol: p.amountSol,
      })),
    });
  });

  positionReconciler.on('notification', (notification) => {
    io.emit('toast', notification);
  });

  // C100 events
  c100Tracker.on('priceUpdate', (data) => {
    io.emit('c100:priceUpdate', data);
  });

  rewardClaimer.on('claimSuccess', (data) => {
    io.emit('c100:claim', data);
    io.emit('toast', {
      type: 'success',
      title: 'Reward Claimed',
      message: `Claimed ${data.amountSol.toFixed(6)} SOL from ${data.source}`,
    });
  });

  rewardClaimer.on('claimCycleComplete', (data) => {
    if (data.totalClaimed > 0) {
      io.emit('c100:claimCycle', data);
    }
  });

  c100Buyback.on('buybackSuccess', (data) => {
    io.emit('c100:buyback', data);
    io.emit('toast', {
      type: 'success',
      title: 'C100 Buyback',
      message: `Bought ${data.amountTokens.toFixed(0)} tokens for ${data.amountSol.toFixed(6)} SOL`,
    });
  });
}

function startPeriodicBroadcasts(io: SocketServer): void {
  // Broadcast position updates every 1 second (live P&L)
  setInterval(() => {
    const positions = positionManager.getOpenPositions();
    if (positions.length > 0) {
      io.emit('positions:update', formatPositions(positions));
    }
  }, 1000);

  // Broadcast watchlist updates every 2 seconds
  setInterval(() => {
    const stats = tokenWatchlist.getStats();
    const allTokens = tokenWatchlist.getAllTokens();

    // Format all watched tokens (up to 20 most recent)
    if (stats.total > 0) {
      const formattedTokens = allTokens.slice(0, 20).map(mint => {
        const token = tokenWatchlist.getToken(mint);
        if (token) {
          return formatWatchlistToken(mint, token);
        }
        return null;
      }).filter(Boolean);

      io.emit('watchlist:update', {
        tokens: formattedTokens,
        stats
      });
    }
  }, 2000);

  // Broadcast stats every 5 seconds
  setInterval(async () => {
    try {
      const metrics = await performanceAnalytics.calculateMetrics();
      const drawdown = drawdownGuard.getState();
      const positions = positionManager.getOpenPositions();

      const totalUnrealizedPnl = positions.reduce((sum, p) => sum + p.unrealizedPnl, 0);
      const currentEquity = config.initialCapitalSol + metrics.totalPnl + totalUnrealizedPnl;
      const multiplier = currentEquity / config.initialCapitalSol;

      // Calculate win streak
      const recentTrades = await tradeLogger.getRecentTrades(20);
      let winStreak = 0;
      for (const trade of recentTrades) {
        if (trade.pnlSol !== undefined) {
          if (trade.pnlSol > 0) {
            winStreak++;
          } else {
            break;
          }
        }
      }

      io.emit('stats:update', {
        multiplier: multiplier.toFixed(2),
        winRate: (metrics.winRate * 100).toFixed(1),
        totalTrades: metrics.totalTrades,
        tokensScanned,
        currentEquity: currentEquity.toFixed(4),
        totalPnl: metrics.totalPnl.toFixed(4),
        totalUnrealizedPnl: totalUnrealizedPnl.toFixed(4),
        dailyPnl: drawdown.dailyPnl.toFixed(4),
        drawdown: (drawdown.currentDrawdown * 100).toFixed(2),
        winStreak,
        isPaused: drawdown.isPaused,
        positionCount: positions.length,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to broadcast stats');
    }
  }, 5000);

  // Broadcast wallet balance every 10 seconds
  setInterval(() => {
    try {
      const walletState = walletSync.getState();
      const latestEquity = equityTracker.getLatestSnapshot();

      if (walletState) {
        io.emit('wallet:update', {
          solBalance: walletState.solBalance,
          lastSync: walletState.lastSync,
          isHealthy: walletSync.isHealthy(),
          totalEquity: latestEquity?.totalEquitySol || walletState.solBalance,
        });
      }
    } catch (error) {
      logger.error({ error }, 'Failed to broadcast wallet update');
    }
  }, 10000);

  // Broadcast C100 status every 30 seconds
  setInterval(() => {
    try {
      if (!c100Tracker.isEnabled()) return;

      const tokenData = c100Tracker.getTokenData();
      const claimStats = rewardClaimer.getStats();
      const buybackStats = c100Buyback.getStats();

      io.emit('c100:update', {
        token: tokenData,
        claims: {
          totalClaimedSol: claimStats.totalClaimedSol,
          claimCount: claimStats.claimCount,
          lastClaimTime: claimStats.lastClaimTime,
        },
        buybacks: {
          totalBuybackSol: buybackStats.totalBuybackSol,
          totalTokensBought: buybackStats.totalTokensBought,
          buybackCount: buybackStats.buybackCount,
          lastBuybackTime: buybackStats.lastBuybackTime,
        },
      });
    } catch (error) {
      logger.error({ error }, 'Failed to broadcast C100 update');
    }
  }, 30000);
}

function formatPositions(positions: Position[]): {
  positions: any[];
  totalUnrealizedPnl: string;
  totalExposure: string;
  positionCount: number;
} {
  const formattedPositions = positions.map((p) => ({
    id: p.id,
    mint: p.mint,
    symbol: p.symbol,
    amount: p.amount,
    amountSol: p.amountSol,
    entryPrice: p.entryPrice,
    currentPrice: p.currentPrice,
    highestPrice: p.highestPrice,
    unrealizedPnl: p.unrealizedPnl,
    unrealizedPnlPercent: p.unrealizedPnlPercent,
    stopLoss: p.stopLoss,
    takeProfit: p.takeProfit,
    tpSold: p.tpSold,
    trailingStop: p.trailingStop,
    status: p.status,
    poolType: p.poolType,
    entryTime: p.entryTime.toISOString(),
    holdTime: Date.now() - p.entryTime.getTime(),
  }));

  const totalUnrealizedPnl = positions.reduce((sum, p) => sum + p.unrealizedPnl, 0);
  const totalExposure = positionManager.getTotalExposure();

  return {
    positions: formattedPositions,
    totalUnrealizedPnl: totalUnrealizedPnl.toFixed(6),
    totalExposure: totalExposure.toFixed(4),
    positionCount: positions.length,
  };
}

function formatTrade(trade: any): any {
  return {
    id: trade.id,
    mint: trade.mint,
    symbol: trade.symbol,
    entryPrice: trade.entryPrice,
    exitPrice: trade.exitPrice,
    amount: trade.amount,
    amountSol: trade.amountSol,
    entryTime: trade.entryTime,
    exitTime: trade.exitTime,
    pnlSol: trade.pnlSol?.toFixed(6),
    pnlPercent: trade.pnlPercent?.toFixed(2),
    duration: trade.duration,
    exitReason: trade.exitReason,
    isOpen: !trade.exitTime,
  };
}

function formatWatchlistToken(mint: string, token: any): any {
  const features = tokenWatchlist.extractFeatures(mint);
  const filterResult = tokenWatchlist.passesHardFilters(mint);
  const cachedMetadata = tokenMetadataCache.get(mint);

  let status: 'collecting' | 'ready' | 'analyzing' | 'rejected' | 'bought' = 'collecting';
  if (token.devSold) {
    status = 'rejected';
  } else if (filterResult.passes) {
    status = 'ready';
  } else if (token.priceHistory?.length >= 10) {
    status = 'rejected';
  }

  return {
    mint,
    name: cachedMetadata?.name || token.name,
    symbol: cachedMetadata?.symbol || token.symbol,
    imageUrl: cachedMetadata?.imageUrl || null,
    firstSeen: token.firstSeen,
    dataPoints: token.priceHistory?.length || 0,
    priceChange: features?.priceChange || 0,
    volatility: features?.volatility || 0,
    drawdown: features?.drawdown || 0,
    buyPressure: features?.buyPressure || 0.5,
    uniqueTraders: features?.uniqueTraders || 0,
    devSold: token.devSold || false,
    status,
    rejectReason: !filterResult.passes ? filterResult.reason : undefined
  };
}

// Export for external use
export function getTokensScanned(): number {
  return tokensScanned;
}

export function resetTokensScanned(): void {
  tokensScanned = 0;
}
</file>

<file path="src/data/helius-ws.ts">
import WebSocket from 'ws';
import { EventEmitter } from 'events';
import bs58 from 'bs58';
import { config } from '../config/settings';
import { createChildLogger } from '../utils/logger';
import { NewTokenEvent } from './types';
import { repository } from '../db/repository';

const logger = createChildLogger('helius-ws');

// Metadata cache to avoid redundant fetches
const metadataCache = new Map<string, { name: string; symbol: string; imageUrl: string | null }>();

// CreateEvent discriminator from pump.fun IDL (sha256 hash of "event:CreateEvent" first 8 bytes)
const CREATE_EVENT_DISCRIMINATOR = Buffer.from([27, 114, 169, 77, 222, 235, 99, 118]);

interface LogsNotification {
  jsonrpc: string;
  method: string;
  params: {
    result: {
      value: {
        signature: string;
        err: null | unknown;
        logs: string[];
      };
    };
    subscription: number;
  };
}

interface TokenData {
  name: string;
  symbol: string;
  uri: string;
  mint: string;
  bondingCurve: string;
  creator: string;
}

interface TokenMetadata {
  name?: string;
  symbol?: string;
  image?: string;
}

async function fetchTokenMetadata(uri: string, mint: string): Promise<{ name: string; symbol: string; imageUrl: string | null } | null> {
  // Check cache first
  const cached = metadataCache.get(mint);
  if (cached) return cached;

  try {
    // Handle IPFS URIs
    let fetchUrl = uri;
    if (uri.startsWith('ipfs://')) {
      fetchUrl = `https://ipfs.io/ipfs/${uri.slice(7)}`;
    }

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5000);

    const response = await fetch(fetchUrl, {
      signal: controller.signal,
      headers: { 'Accept': 'application/json' }
    });
    clearTimeout(timeout);

    if (!response.ok) {
      logger.debug({ mint, uri, status: response.status }, 'Failed to fetch metadata');
      return null;
    }

    const metadata = await response.json() as TokenMetadata;

    // Extract image URL, handling IPFS
    let imageUrl = metadata.image || null;
    if (imageUrl && imageUrl.startsWith('ipfs://')) {
      imageUrl = `https://ipfs.io/ipfs/${imageUrl.slice(7)}`;
    }

    const result = {
      name: metadata.name || '',
      symbol: metadata.symbol || '',
      imageUrl
    };

    // Cache the result
    metadataCache.set(mint, result);

    // Limit cache size
    if (metadataCache.size > 1000) {
      const firstKey = metadataCache.keys().next().value;
      if (firstKey) metadataCache.delete(firstKey);
    }

    return result;
  } catch (error) {
    logger.debug({ mint, uri, error }, 'Error fetching token metadata');
    return null;
  }
}

export class HeliusWebSocket extends EventEmitter {
  private ws: WebSocket | null = null;
  private subscriptionId: number | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 10;
  private reconnectDelay = 1000;
  private pingInterval: NodeJS.Timeout | null = null;
  private isConnected = false;

  constructor() {
    super();
  }

  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      const wsUrl = config.heliusWsUrl;

      if (!wsUrl) {
        reject(new Error('HELIUS_WS_URL not configured'));
        return;
      }

      logger.info({ url: wsUrl.substring(0, 50) + '...' }, 'Connecting to Helius WebSocket');

      this.ws = new WebSocket(wsUrl);

      this.ws.on('open', () => {
        logger.info('WebSocket connected');
        this.isConnected = true;
        this.reconnectAttempts = 0;
        this.setupPing();
        this.subscribeToPumpFun();
        resolve();
      });

      this.ws.on('message', (data: WebSocket.Data) => {
        this.handleMessage(data.toString());
      });

      this.ws.on('error', (error) => {
        logger.error({ error: error.message }, 'WebSocket error');
        if (!this.isConnected) {
          reject(error);
        }
      });

      this.ws.on('close', (code, reason) => {
        logger.warn({ code, reason: reason.toString() }, 'WebSocket closed');
        this.isConnected = false;
        this.cleanup();
        this.attemptReconnect();
      });

      setTimeout(() => {
        if (!this.isConnected) {
          reject(new Error('WebSocket connection timeout'));
        }
      }, 30000);
    });
  }

  private setupPing(): void {
    this.pingInterval = setInterval(() => {
      if (this.ws && this.isConnected) {
        this.ws.ping();
      }
    }, 30000);
  }

  private subscribeToPumpFun(): void {
    if (!this.ws) return;

    // Use logsSubscribe (available on free tier) to monitor pump.fun program
    const subscribeMessage = {
      jsonrpc: '2.0',
      id: 420,
      method: 'logsSubscribe',
      params: [
        { mentions: [config.pumpFunProgram] },
        { commitment: 'confirmed' },
      ],
    };

    this.ws.send(JSON.stringify(subscribeMessage));
    logger.info({ program: config.pumpFunProgram }, 'Subscribed to Pump.fun logs');
  }

  private handleMessage(data: string): void {
    try {
      const message = JSON.parse(data);

      // Handle subscription confirmation
      if (message.id === 420 && message.result !== undefined) {
        this.subscriptionId = message.result;
        logger.info({ subscriptionId: this.subscriptionId }, 'Subscription confirmed');
        return;
      }

      // Handle logs notifications
      if (message.method === 'logsNotification') {
        this.processLogs(message as LogsNotification);
      }
    } catch (error) {
      logger.error({ error, data: data.substring(0, 200) }, 'Failed to parse WebSocket message');
    }
  }

  private processLogs(notification: LogsNotification): void {
    try {
      const { signature, logs, err } = notification.params?.result?.value || {};

      if (err || !logs || logs.length === 0) return;

      const logsJoined = logs.join(' ');

      // Check for Create/CreateV2 instruction (new token)
      // CreateV2 is the newer pump.fun instruction that contains the CreateEvent
      const isCreate = logsJoined.includes('Instruction: Create') || logsJoined.includes('Instruction: CreateV2');

      if (isCreate) {
        // Find and decode Program data
        for (const log of logs) {
          if (log.startsWith('Program data: ')) {
            const base64Data = log.substring('Program data: '.length);
            const tokenData = this.decodeCreateEvent(base64Data);

            if (tokenData && tokenData.mint.endsWith('pump')) {
              // Fetch metadata asynchronously (don't block event emission)
              this.fetchAndStoreMetadata(tokenData);

              const event: NewTokenEvent = {
                mint: tokenData.mint,
                signature,
                timestamp: new Date(),
                creator: tokenData.creator,
                name: tokenData.name,
                symbol: tokenData.symbol,
              };

              logger.info({
                mint: tokenData.mint,
                name: tokenData.name,
                symbol: tokenData.symbol,
                creator: tokenData.creator.substring(0, 10) + '...',
                signature: signature.substring(0, 15),
              }, 'NEW PUMP.FUN TOKEN');

              this.emit('newToken', event);
              break; // Only emit once per transaction
            }
          }
        }
      }

      // Emit buy/sell events for trading analysis
      const isBuy = logsJoined.includes('Instruction: Buy');
      const isSell = logsJoined.includes('Instruction: Sell');

      if (isBuy || isSell) {
        this.emit('trade', { type: isBuy ? 'buy' : 'sell', signature, logs });
      }
    } catch (error) {
      logger.error({ error }, 'Failed to process logs');
    }
  }

  /**
   * Decode base64 Program data from pump.fun CreateEvent
   * Structure:
   * - 8 bytes: discriminator
   * - 4 bytes + N bytes: name (length-prefixed string)
   * - 4 bytes + N bytes: symbol (length-prefixed string)
   * - 4 bytes + N bytes: uri (length-prefixed string)
   * - 32 bytes: mint pubkey
   * - 32 bytes: bonding curve pubkey
   * - 32 bytes: user/creator pubkey
   */
  private decodeCreateEvent(base64Data: string): TokenData | null {
    try {
      const data = Buffer.from(base64Data, 'base64');

      // Check discriminator
      const discriminator = data.subarray(0, 8);
      if (!discriminator.equals(CREATE_EVENT_DISCRIMINATOR)) {
        return null;
      }

      let offset = 8;

      // Parse name (4-byte little-endian length prefix + string)
      const nameLen = data.readUInt32LE(offset);
      offset += 4;
      const name = data.subarray(offset, offset + nameLen).toString('utf-8');
      offset += nameLen;

      // Parse symbol
      const symbolLen = data.readUInt32LE(offset);
      offset += 4;
      const symbol = data.subarray(offset, offset + symbolLen).toString('utf-8');
      offset += symbolLen;

      // Parse URI
      const uriLen = data.readUInt32LE(offset);
      offset += 4;
      const uri = data.subarray(offset, offset + uriLen).toString('utf-8');
      offset += uriLen;

      // Parse mint (32 bytes)
      const mintBytes = data.subarray(offset, offset + 32);
      const mint = bs58.encode(mintBytes);
      offset += 32;

      // Parse bonding curve (32 bytes)
      const bondingCurveBytes = data.subarray(offset, offset + 32);
      const bondingCurve = bs58.encode(bondingCurveBytes);
      offset += 32;

      // Parse creator/user (32 bytes)
      const creatorBytes = data.subarray(offset, offset + 32);
      const creator = bs58.encode(creatorBytes);

      return { name, symbol, uri, mint, bondingCurve, creator };
    } catch (error) {
      logger.debug({ error, data: base64Data.substring(0, 50) }, 'Failed to decode CreateEvent');
      return null;
    }
  }

  private async fetchAndStoreMetadata(tokenData: TokenData): Promise<void> {
    try {
      const metadata = await fetchTokenMetadata(tokenData.uri, tokenData.mint);
      if (metadata && metadata.imageUrl) {
        await repository.updateTokenMetadata(tokenData.mint, {
          name: metadata.name || tokenData.name,
          symbol: metadata.symbol || tokenData.symbol,
          image_url: metadata.imageUrl
        });

        // Emit metadata update event for real-time UI updates
        this.emit('tokenMetadataUpdated', {
          mint: tokenData.mint,
          name: metadata.name || tokenData.name,
          symbol: metadata.symbol || tokenData.symbol,
          imageUrl: metadata.imageUrl
        });

        logger.debug({
          mint: tokenData.mint.substring(0, 10) + '...',
          hasImage: !!metadata.imageUrl
        }, 'Token metadata fetched');
      }
    } catch (error) {
      logger.debug({ mint: tokenData.mint, error }, 'Failed to fetch/store token metadata');
    }
  }

  private cleanup(): void {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
    this.subscriptionId = null;
  }

  private attemptReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      logger.error('Max reconnection attempts reached');
      this.emit('maxReconnectAttemptsReached');
      return;
    }

    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

    logger.info({ attempt: this.reconnectAttempts, delay }, 'Attempting to reconnect');

    setTimeout(() => {
      this.connect().catch((err) => {
        logger.error({ error: err.message }, 'Reconnection failed');
      });
    }, delay);
  }

  async disconnect(): Promise<void> {
    this.cleanup();

    if (this.ws) {
      if (this.subscriptionId !== null) {
        const unsubscribe = {
          jsonrpc: '2.0',
          id: 2,
          method: 'logsUnsubscribe',
          params: [this.subscriptionId],
        };
        this.ws.send(JSON.stringify(unsubscribe));
      }

      this.ws.close();
      this.ws = null;
    }

    this.isConnected = false;
    logger.info('WebSocket disconnected');
  }
}

export const heliusWs = new HeliusWebSocket();
</file>

<file path="src/data/types.ts">
export interface TokenInfo {
  mint: string;
  name: string;
  symbol: string;
  decimals: number;
  supply: number;
  createdAt: Date;
  creator: string;
  mintAuthorityRevoked: boolean;
  freezeAuthorityRevoked: boolean;
  imageUrl?: string | null;
}

export interface PriceData {
  mint: string;
  priceUsd: number;
  priceSol: number;
  volume24h: number;
  marketCapSol: number;
  liquidity: number;
  priceChange1m: number;
  priceChange5m: number;
  priceChange1h: number;
  timestamp: Date;
}

export interface TradeData {
  signature: string;
  mint: string;
  side: 'buy' | 'sell';
  amountToken: number;
  amountSol: number;
  trader: string;
  timestamp: Date;
}

export interface WhaleActivity {
  wallet: string;
  action: 'buy' | 'sell' | 'transfer';
  mint: string;
  amount: number;
  amountSol: number;
  timestamp: Date;
}

export interface HolderInfo {
  mint: string;
  totalHolders: number;
  top10Concentration: number;
  top10Holders: Array<{
    address: string;
    balance: number;
    percentage: number;
  }>;
}

export interface LiquidityPool {
  mint: string;
  poolAddress: string;
  dex: string;
  liquiditySol: number;
  liquidityToken: number;
  lpLocked: boolean;
  lpLockedPercent: number;
}

export interface NewTokenEvent {
  mint: string;
  signature: string;
  timestamp: Date;
  creator: string;
  name?: string;
  symbol?: string;
  imageUrl?: string | null;
}

export type DataEventType = 'new_token' | 'price_update' | 'trade' | 'whale_activity';

export interface DataEvent {
  type: DataEventType;
  data: TokenInfo | PriceData | TradeData | WhaleActivity | NewTokenEvent;
  timestamp: Date;
}
</file>

<file path="src/db/repository.ts">
import { Pool } from 'pg';
import { createChildLogger } from '../utils/logger';
import { TokenRecord, TradeRecordDB, PositionRecord, PriceRecord, EquitySnapshotRecord, PartialCloseRecord, WalletSyncLogRecord, C100ClaimRecord, C100BuybackRecord } from './types';
import { config } from '../config/settings';

const logger = createChildLogger('repository');

export class Repository {
  private pool: Pool;

  constructor() {
    this.pool = new Pool({
      connectionString: config.databaseUrl,
      max: 10,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });

    this.pool.on('error', (err) => {
      logger.error({ err }, 'Unexpected database pool error');
    });
  }

  async connect(): Promise<void> {
    const client = await this.pool.connect();
    try {
      const result = await client.query('SELECT NOW()');
      logger.info({ time: result.rows[0].now }, 'Database connected');
    } finally {
      client.release();
    }
  }

  async close(): Promise<void> {
    await this.pool.end();
    logger.info('Database pool closed');
  }

  // Token operations
  async upsertToken(token: Partial<TokenRecord>): Promise<void> {
    await this.pool.query(`
      INSERT INTO tokens (mint, name, symbol, decimals, creator, mint_revoked, freeze_revoked, image_url)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (mint) DO UPDATE SET
        name = COALESCE(EXCLUDED.name, tokens.name),
        symbol = COALESCE(EXCLUDED.symbol, tokens.symbol),
        mint_revoked = COALESCE(EXCLUDED.mint_revoked, tokens.mint_revoked),
        freeze_revoked = COALESCE(EXCLUDED.freeze_revoked, tokens.freeze_revoked),
        image_url = COALESCE(EXCLUDED.image_url, tokens.image_url),
        last_updated = NOW()
    `, [token.mint, token.name, token.symbol, token.decimals, token.creator, token.mint_revoked, token.freeze_revoked, token.image_url]);
  }

  async updateTokenMetadata(mint: string, metadata: { name?: string; symbol?: string; image_url?: string }): Promise<void> {
    const updates: string[] = [];
    const values: any[] = [mint];
    let paramIndex = 2;

    if (metadata.name) {
      updates.push(`name = $${paramIndex++}`);
      values.push(metadata.name);
    }
    if (metadata.symbol) {
      updates.push(`symbol = $${paramIndex++}`);
      values.push(metadata.symbol);
    }
    if (metadata.image_url) {
      updates.push(`image_url = $${paramIndex++}`);
      values.push(metadata.image_url);
    }

    if (updates.length > 0) {
      updates.push('last_updated = NOW()');
      await this.pool.query(
        `UPDATE tokens SET ${updates.join(', ')} WHERE mint = $1`,
        values
      );
    }
  }

  async getToken(mint: string): Promise<TokenRecord | null> {
    const result = await this.pool.query('SELECT * FROM tokens WHERE mint = $1', [mint]);
    return result.rows[0] || null;
  }

  // Price operations
  async insertPrice(price: Partial<PriceRecord>): Promise<void> {
    await this.pool.query(`
      INSERT INTO price_history (mint, price_sol, price_usd, volume_24h, market_cap_sol, liquidity)
      VALUES ($1, $2, $3, $4, $5, $6)
    `, [price.mint, price.price_sol, price.price_usd, price.volume_24h, price.market_cap_sol, price.liquidity]);
  }

  async getRecentPrices(mint: string, limit: number = 100): Promise<PriceRecord[]> {
    const result = await this.pool.query(`
      SELECT * FROM price_history
      WHERE mint = $1
      ORDER BY timestamp DESC
      LIMIT $2
    `, [mint, limit]);
    return result.rows;
  }

  // Trade operations
  async insertTrade(trade: Partial<TradeRecordDB>): Promise<void> {
    await this.pool.query(`
      INSERT INTO trades (id, mint, symbol, action, entry_price, amount, amount_sol,
                          entry_time, features_json, regime, pump_phase)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    `, [
      trade.id, trade.mint, trade.symbol, trade.action, trade.entry_price,
      trade.amount, trade.amount_sol, trade.entry_time, trade.features_json,
      trade.regime, trade.pump_phase
    ]);
  }

  async updateTradeExit(id: string, exitData: {
    exit_price: number;
    exit_time: Date;
    pnl_sol: number;
    pnl_percent: number;
    duration_ms: number;
    exit_reason: string;
    slippage?: number;
    fees?: number;
  }): Promise<void> {
    await this.pool.query(`
      UPDATE trades SET
        exit_price = $2,
        exit_time = $3,
        pnl_sol = $4,
        pnl_percent = $5,
        duration_ms = $6,
        exit_reason = $7,
        slippage = $8,
        fees = $9
      WHERE id = $1
    `, [
      id, exitData.exit_price, exitData.exit_time, exitData.pnl_sol,
      exitData.pnl_percent, exitData.duration_ms, exitData.exit_reason,
      exitData.slippage, exitData.fees
    ]);
  }

  async getRecentTrades(limit: number = 100): Promise<TradeRecordDB[]> {
    const result = await this.pool.query(`
      SELECT * FROM trades ORDER BY entry_time DESC LIMIT $1
    `, [limit]);
    return result.rows;
  }

  async getTradesForTraining(weeks: number = 4): Promise<TradeRecordDB[]> {
    const result = await this.pool.query(`
      SELECT * FROM trades
      WHERE exit_time IS NOT NULL
        AND entry_time > NOW() - INTERVAL '${weeks} weeks'
      ORDER BY entry_time ASC
    `);
    return result.rows;
  }

  // Position operations
  async upsertPosition(position: Partial<PositionRecord>): Promise<void> {
    await this.pool.query(`
      INSERT INTO positions (id, mint, symbol, entry_price, current_price, amount,
                            amount_sol, entry_time, highest_price, lowest_price,
                            stop_loss, take_profit_json, tp_sold_json, status, pool_type)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
      ON CONFLICT (id) DO UPDATE SET
        current_price = EXCLUDED.current_price,
        highest_price = GREATEST(positions.highest_price, EXCLUDED.current_price),
        lowest_price = LEAST(positions.lowest_price, EXCLUDED.current_price),
        tp_sold_json = EXCLUDED.tp_sold_json,
        status = EXCLUDED.status,
        last_update = NOW()
    `, [
      position.id, position.mint, position.symbol, position.entry_price,
      position.current_price, position.amount, position.amount_sol,
      position.entry_time, position.highest_price, position.lowest_price,
      position.stop_loss, position.take_profit_json, position.tp_sold_json,
      position.status, position.pool_type
    ]);
  }

  async getOpenPositions(): Promise<PositionRecord[]> {
    const result = await this.pool.query(`
      SELECT * FROM positions WHERE status = 'open' ORDER BY entry_time ASC
    `);
    return result.rows;
  }

  async closePosition(id: string): Promise<void> {
    await this.pool.query(`
      UPDATE positions SET status = 'closed', last_update = NOW() WHERE id = $1
    `, [id]);
  }

  // Config operations
  async getConfig(key: string): Promise<string | null> {
    const result = await this.pool.query('SELECT value FROM config WHERE key = $1', [key]);
    return result.rows[0]?.value || null;
  }

  async setConfig(key: string, value: string): Promise<void> {
    await this.pool.query(`
      INSERT INTO config (key, value) VALUES ($1, $2)
      ON CONFLICT (key) DO UPDATE SET value = $2, updated_at = NOW()
    `, [key, value]);
  }

  // Model operations
  async saveModelWeights(version: number, weights: string, metrics: string): Promise<void> {
    await this.pool.query(`
      INSERT INTO model_weights (version, weights_json, metrics_json)
      VALUES ($1, $2, $3)
    `, [version, weights, metrics]);
  }

  async getLatestModelWeights(): Promise<{ weights: string; metrics: string; version: number } | null> {
    const result = await this.pool.query(`
      SELECT weights_json, metrics_json, version
      FROM model_weights
      ORDER BY version DESC
      LIMIT 1
    `);
    if (!result.rows[0]) return null;
    return {
      weights: result.rows[0].weights_json,
      metrics: result.rows[0].metrics_json,
      version: result.rows[0].version,
    };
  }

  // Daily stats operations
  async updateDailyStats(date: Date, stats: {
    starting_equity?: number;
    ending_equity?: number;
    pnl?: number;
    trades_count?: number;
    winning_trades?: number;
    losing_trades?: number;
    max_drawdown?: number;
  }): Promise<void> {
    const dateStr = date.toISOString().split('T')[0];
    await this.pool.query(`
      INSERT INTO daily_stats (date, starting_equity, ending_equity, pnl, trades_count,
                               winning_trades, losing_trades, max_drawdown)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (date) DO UPDATE SET
        ending_equity = COALESCE(EXCLUDED.ending_equity, daily_stats.ending_equity),
        pnl = COALESCE(EXCLUDED.pnl, daily_stats.pnl),
        trades_count = COALESCE(EXCLUDED.trades_count, daily_stats.trades_count),
        winning_trades = COALESCE(EXCLUDED.winning_trades, daily_stats.winning_trades),
        losing_trades = COALESCE(EXCLUDED.losing_trades, daily_stats.losing_trades),
        max_drawdown = GREATEST(daily_stats.max_drawdown, COALESCE(EXCLUDED.max_drawdown, 0))
    `, [dateStr, stats.starting_equity, stats.ending_equity, stats.pnl,
        stats.trades_count, stats.winning_trades, stats.losing_trades, stats.max_drawdown]);
  }

  // Whale tracking
  async upsertWhaleWallet(address: string, label?: string): Promise<void> {
    await this.pool.query(`
      INSERT INTO whale_wallets (address, label)
      VALUES ($1, $2)
      ON CONFLICT (address) DO UPDATE SET
        label = COALESCE(EXCLUDED.label, whale_wallets.label)
    `, [address, label]);
  }

  async logWhaleActivity(activity: {
    wallet: string;
    action: string;
    mint: string;
    amount: number;
    amount_sol: number;
    signature?: string;
  }): Promise<void> {
    await this.pool.query(`
      INSERT INTO whale_activity (wallet, action, mint, amount, amount_sol, signature)
      VALUES ($1, $2, $3, $4, $5, $6)
    `, [activity.wallet, activity.action, activity.mint, activity.amount,
        activity.amount_sol, activity.signature]);

    await this.pool.query(`
      UPDATE whale_wallets SET
        total_volume = total_volume + $2,
        last_active = NOW()
      WHERE address = $1
    `, [activity.wallet, activity.amount_sol]);
  }

  // Equity snapshot operations
  async insertEquitySnapshot(snapshot: {
    wallet_balance_sol: number;
    positions_value_sol: number;
    total_equity_sol: number;
    unrealized_pnl_sol: number;
    position_count: number;
    source: 'periodic' | 'trade_close' | 'startup';
  }): Promise<void> {
    await this.pool.query(`
      INSERT INTO equity_snapshots (wallet_balance_sol, positions_value_sol, total_equity_sol,
                                   unrealized_pnl_sol, position_count, source)
      VALUES ($1, $2, $3, $4, $5, $6)
    `, [
      snapshot.wallet_balance_sol, snapshot.positions_value_sol, snapshot.total_equity_sol,
      snapshot.unrealized_pnl_sol, snapshot.position_count, snapshot.source
    ]);
  }

  async getEquityHistory(hours: number = 24): Promise<EquitySnapshotRecord[]> {
    const result = await this.pool.query(`
      SELECT * FROM equity_snapshots
      WHERE timestamp > NOW() - INTERVAL '${hours} hours'
      ORDER BY timestamp ASC
    `);
    return result.rows;
  }

  async getLatestEquitySnapshot(): Promise<EquitySnapshotRecord | null> {
    const result = await this.pool.query(`
      SELECT * FROM equity_snapshots
      ORDER BY timestamp DESC
      LIMIT 1
    `);
    return result.rows[0] || null;
  }

  // Partial close operations
  async insertPartialClose(partialClose: {
    position_id: string;
    mint: string;
    close_type: 'initial_recovery' | 'scaled_exit' | 'tp_level';
    sell_amount_tokens: number;
    sell_amount_sol: number;
    price_at_close: number;
    pnl_sol: number;
    fees_sol: number;
  }): Promise<void> {
    await this.pool.query(`
      INSERT INTO partial_closes (position_id, mint, close_type, sell_amount_tokens,
                                 sell_amount_sol, price_at_close, pnl_sol, fees_sol)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `, [
      partialClose.position_id, partialClose.mint, partialClose.close_type,
      partialClose.sell_amount_tokens, partialClose.sell_amount_sol,
      partialClose.price_at_close, partialClose.pnl_sol, partialClose.fees_sol
    ]);
  }

  async getPartialCloses(positionId: string): Promise<PartialCloseRecord[]> {
    const result = await this.pool.query(`
      SELECT * FROM partial_closes
      WHERE position_id = $1
      ORDER BY timestamp ASC
    `, [positionId]);
    return result.rows;
  }

  async getTotalPartialClosePnl(positionId: string): Promise<number> {
    const result = await this.pool.query(`
      SELECT COALESCE(SUM(pnl_sol), 0) as total_pnl
      FROM partial_closes
      WHERE position_id = $1
    `, [positionId]);
    return parseFloat(result.rows[0]?.total_pnl || '0');
  }

  // Wallet sync log operations
  async insertWalletSyncLog(log: {
    sol_balance: number;
    token_positions_json: string;
    discrepancies_json: string;
  }): Promise<void> {
    await this.pool.query(`
      INSERT INTO wallet_sync_log (sol_balance, token_positions_json, discrepancies_json)
      VALUES ($1, $2, $3)
    `, [log.sol_balance, log.token_positions_json, log.discrepancies_json]);
  }

  async getLatestWalletSync(): Promise<WalletSyncLogRecord | null> {
    const result = await this.pool.query(`
      SELECT * FROM wallet_sync_log
      ORDER BY timestamp DESC
      LIMIT 1
    `);
    return result.rows[0] || null;
  }

  // Delete phantom position
  async deletePosition(id: string): Promise<void> {
    await this.pool.query(`DELETE FROM positions WHERE id = $1`, [id]);
  }

  // Update position amount after partial close
  async updatePositionAmount(id: string, newAmount: number): Promise<void> {
    await this.pool.query(`
      UPDATE positions SET amount = $2, last_update = NOW() WHERE id = $1
    `, [id, newAmount]);
  }

  // C100 Claim operations
  async insertC100Claim(claim: {
    source: string;
    amount_sol: number;
    signature?: string;
    status?: string;
  }): Promise<void> {
    await this.pool.query(`
      INSERT INTO c100_claims (source, amount_sol, signature, status)
      VALUES ($1, $2, $3, $4)
    `, [claim.source, claim.amount_sol, claim.signature || null, claim.status || 'success']);
  }

  async getRecentC100Claims(limit: number = 50): Promise<C100ClaimRecord[]> {
    const result = await this.pool.query(`
      SELECT * FROM c100_claims
      ORDER BY timestamp DESC
      LIMIT $1
    `, [limit]);
    return result.rows;
  }

  async getC100ClaimTotals(): Promise<{ total_sol: number; count: number }> {
    const result = await this.pool.query(`
      SELECT COALESCE(SUM(amount_sol), 0) as total_sol, COUNT(*) as count
      FROM c100_claims
      WHERE status = 'success'
    `);
    return {
      total_sol: parseFloat(result.rows[0]?.total_sol || '0'),
      count: parseInt(result.rows[0]?.count || '0'),
    };
  }

  // C100 Buyback operations
  async insertC100Buyback(buyback: {
    amount_sol: number;
    amount_tokens?: number;
    price_sol?: number;
    source: string;
    signature?: string;
    status?: string;
  }): Promise<void> {
    await this.pool.query(`
      INSERT INTO c100_buybacks (amount_sol, amount_tokens, price_sol, source, signature, status)
      VALUES ($1, $2, $3, $4, $5, $6)
    `, [
      buyback.amount_sol,
      buyback.amount_tokens || null,
      buyback.price_sol || null,
      buyback.source,
      buyback.signature || null,
      buyback.status || 'success'
    ]);
  }

  async getRecentC100Buybacks(limit: number = 50): Promise<C100BuybackRecord[]> {
    const result = await this.pool.query(`
      SELECT * FROM c100_buybacks
      ORDER BY timestamp DESC
      LIMIT $1
    `, [limit]);
    return result.rows;
  }

  async getC100BuybackTotals(): Promise<{ total_sol: number; total_tokens: number; count: number }> {
    const result = await this.pool.query(`
      SELECT
        COALESCE(SUM(amount_sol), 0) as total_sol,
        COALESCE(SUM(amount_tokens), 0) as total_tokens,
        COUNT(*) as count
      FROM c100_buybacks
      WHERE status = 'success'
    `);
    return {
      total_sol: parseFloat(result.rows[0]?.total_sol || '0'),
      total_tokens: parseFloat(result.rows[0]?.total_tokens || '0'),
      count: parseInt(result.rows[0]?.count || '0'),
    };
  }
}

export const repository = new Repository();
</file>

<file path="src/db/types.ts">
export interface DBConfig {
  postgresUrl: string;
  sqlitePath: string;
}

export interface TokenRecord {
  mint: string;
  name: string;
  symbol: string;
  decimals: number;
  created_at: Date;
  creator: string;
  mint_revoked: boolean;
  freeze_revoked: boolean;
  image_url: string | null;
  last_updated: Date;
}

export interface PriceRecord {
  id: number;
  mint: string;
  price_sol: number;
  price_usd: number;
  volume_24h: number;
  market_cap_sol: number;
  liquidity: number;
  timestamp: Date;
}

export interface TradeRecordDB {
  id: string;
  mint: string;
  symbol: string;
  action: number;
  entry_price: number;
  exit_price: number | null;
  amount: number;
  amount_sol: number;
  entry_time: Date;
  exit_time: Date | null;
  pnl_sol: number | null;
  pnl_percent: number | null;
  duration_ms: number | null;
  features_json: string;
  regime: number;
  pump_phase: string;
  exit_reason: string | null;
  slippage: number | null;
  fees: number | null;
}

export interface PositionRecord {
  id: string;
  mint: string;
  symbol: string;
  entry_price: number;
  current_price: number;
  amount: number;
  amount_sol: number;
  entry_time: Date;
  last_update: Date;
  highest_price: number;
  lowest_price: number;
  stop_loss: number;
  take_profit_json: string;
  tp_sold_json: string;
  trailing_stop: number | null;
  status: string;
  pool_type: string;
}

export interface ModelRecord {
  id: number;
  version: number;
  weights_json: string;
  metrics_json: string;
  created_at: Date;
}

export interface ConfigRecord {
  key: string;
  value: string;
  updated_at: Date;
}

export interface EquitySnapshotRecord {
  id: number;
  timestamp: Date;
  wallet_balance_sol: number;
  positions_value_sol: number;
  total_equity_sol: number;
  unrealized_pnl_sol: number;
  position_count: number;
  source: 'periodic' | 'trade_close' | 'startup';
}

export interface PartialCloseRecord {
  id: number;
  position_id: string;
  mint: string;
  close_type: 'initial_recovery' | 'scaled_exit' | 'tp_level';
  sell_amount_tokens: number;
  sell_amount_sol: number;
  price_at_close: number;
  pnl_sol: number;
  fees_sol: number;
  timestamp: Date;
}

export interface WalletSyncLogRecord {
  id: number;
  timestamp: Date;
  sol_balance: number;
  token_positions_json: string;
  discrepancies_json: string;
}

export interface C100ClaimRecord {
  id: number;
  source: 'pump_creator' | 'pump_referral' | 'meteora_dbc';
  amount_sol: number;
  signature: string | null;
  status: 'success' | 'failed' | 'pending';
  timestamp: Date;
}

export interface C100BuybackRecord {
  id: number;
  amount_sol: number;
  amount_tokens: number | null;
  price_sol: number | null;
  source: 'profit_share' | 'manual';
  signature: string | null;
  status: 'success' | 'failed' | 'pending';
  timestamp: Date;
}
</file>

<file path="src/execution/pumpfun-swap.ts">
import { Connection, Keypair, VersionedTransaction } from '@solana/web3.js';
import bs58 from 'bs58';
import { createChildLogger } from '../utils/logger';
import { config, LAMPORTS_PER_SOL } from '../config/settings';
import { SwapResult } from './types';

const logger = createChildLogger('pumpfun-swap');

const PUMPPORTAL_API_URL = 'https://pumpportal.fun/api';

interface PumpPortalTradeRequest {
  publicKey: string;
  action: 'buy' | 'sell';
  mint: string;
  amount: number;
  denominatedInSol: 'true' | 'false';
  slippage: number;
  priorityFee: number;
  pool: 'pump' | 'raydium' | 'auto';
}

interface PumpPortalTradeResponse {
  transaction?: string;
  error?: string;
}

export class PumpFunSwap {
  private connection: Connection;
  private wallet: Keypair | null = null;

  constructor() {
    this.connection = new Connection(config.solanaRpcUrl, 'confirmed');
  }

  initialize(): void {
    if (config.privateKey) {
      try {
        const secretKey = bs58.decode(config.privateKey);
        this.wallet = Keypair.fromSecretKey(secretKey);
        logger.info({ publicKey: this.wallet.publicKey.toBase58() }, 'PumpFun wallet initialized');
      } catch (error) {
        logger.error({ error }, 'Failed to initialize PumpFun wallet');
      }
    }
  }

  async buy(
    tokenMint: string,
    amountSol: number,
    slippagePct: number = config.defaultSlippageBps / 100,  // Convert bps to %
    priorityFee: number = config.priorityFeeSol
  ): Promise<SwapResult> {
    if (!this.wallet) {
      return this.errorResult(amountSol * LAMPORTS_PER_SOL, 'Wallet not initialized');
    }

    // Paper trading simulation
    if (config.paperTrading) {
      return this.simulateBuy(tokenMint, amountSol, slippagePct);
    }

    try {
      logger.info({ mint: tokenMint, amountSol, slippage: slippagePct }, 'Executing PumpFun buy');

      const response = await fetch(`${PUMPPORTAL_API_URL}/trade-local`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          publicKey: this.wallet.publicKey.toBase58(),
          action: 'buy',
          mint: tokenMint,
          amount: amountSol,
          denominatedInSol: 'true',
          slippage: slippagePct,
          priorityFee: priorityFee,
          pool: 'pump', // Use bonding curve
        } as PumpPortalTradeRequest),
      });

      if (!response.ok) {
        const errorText = await response.text();
        logger.error({ status: response.status, error: errorText }, 'PumpPortal trade request failed');
        return this.errorResult(amountSol * LAMPORTS_PER_SOL, `Trade request failed: ${response.status}`);
      }

      // PumpPortal returns raw transaction bytes directly, not JSON
      const arrayBuffer = await response.arrayBuffer();
      const txData = new Uint8Array(arrayBuffer);

      // Check if response is actually JSON error
      if (txData.length < 100) {
        const text = new TextDecoder().decode(txData);
        try {
          const jsonError = JSON.parse(text);
          if (jsonError.error) {
            return this.errorResult(amountSol * LAMPORTS_PER_SOL, jsonError.error);
          }
        } catch {
          // Not JSON, continue with deserialization
        }
      }

      logger.debug({ bytes: txData.length }, 'Received raw transaction bytes');

      // Deserialize and sign
      const transaction = VersionedTransaction.deserialize(txData);
      transaction.sign([this.wallet]);

      // Send transaction
      const signature = await this.connection.sendRawTransaction(
        transaction.serialize(),
        { skipPreflight: true, maxRetries: 3 }
      );

      logger.info({ signature }, 'PumpFun buy transaction sent');

      // Confirm
      const latestBlockhash = await this.connection.getLatestBlockhash();
      const confirmation = await this.connection.confirmTransaction(
        { signature, ...latestBlockhash },
        'confirmed'
      );

      if (confirmation.value.err) {
        return this.errorResult(
          amountSol * LAMPORTS_PER_SOL,
          `Transaction failed: ${JSON.stringify(confirmation.value.err)}`,
          signature
        );
      }

      // Parse transaction to get actual token amount received from postTokenBalances
      let outputAmount = 0;
      try {
        const txDetails = await this.connection.getParsedTransaction(signature, {
          maxSupportedTransactionVersion: 0,
        });

        if (txDetails?.meta?.postTokenBalances) {
          const walletAddress = this.wallet.publicKey.toBase58();
          // Find the token balance entry for our wallet and the purchased token
          const tokenBalance = txDetails.meta.postTokenBalances.find(
            (balance) =>
              balance.owner === walletAddress &&
              balance.mint === tokenMint
          );

          if (tokenBalance?.uiTokenAmount?.uiAmount) {
            outputAmount = tokenBalance.uiTokenAmount.uiAmount;
            logger.info({
              signature,
              outputAmount,
              decimals: tokenBalance.uiTokenAmount.decimals,
            }, 'Parsed token amount from transaction postTokenBalances');
          }
        }
      } catch (parseError) {
        logger.warn({ signature, error: parseError }, 'Failed to parse transaction for token amount');
      }

      logger.info({ signature, amountSol, outputAmount }, 'PumpFun buy successful');

      return {
        success: true,
        signature,
        inputAmount: amountSol * LAMPORTS_PER_SOL,
        outputAmount,
        priceImpact: 0,
        fees: {
          platformFee: amountSol * LAMPORTS_PER_SOL * 0.01, // 1% pump.fun fee
          networkFee: 5000,
          priorityFee: priorityFee * LAMPORTS_PER_SOL,
          totalFee: amountSol * LAMPORTS_PER_SOL * 0.01 + 5000 + priorityFee * LAMPORTS_PER_SOL,
        },
        timestamp: new Date(),
      };
    } catch (error: any) {
      logger.error({ error: error.message }, 'PumpFun buy failed');
      return this.errorResult(amountSol * LAMPORTS_PER_SOL, error.message);
    }
  }

  async sell(
    tokenMint: string,
    amountTokens: number,
    slippagePct: number = config.defaultSlippageBps / 100,  // Convert bps to %
    priorityFee: number = config.priorityFeeSol
  ): Promise<SwapResult> {
    if (!this.wallet) {
      return this.errorResult(0, 'Wallet not initialized');
    }

    // Paper trading simulation
    if (config.paperTrading) {
      return this.simulateSell(tokenMint, amountTokens, slippagePct);
    }

    try {
      logger.info({ mint: tokenMint, amountTokens, slippage: slippagePct }, 'Executing PumpFun sell');

      const response = await fetch(`${PUMPPORTAL_API_URL}/trade-local`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          publicKey: this.wallet.publicKey.toBase58(),
          action: 'sell',
          mint: tokenMint,
          amount: amountTokens,
          denominatedInSol: 'false',
          slippage: slippagePct,
          priorityFee: priorityFee,
          pool: 'auto', // Auto-detect if on bonding curve or Raydium
        } as PumpPortalTradeRequest),
      });

      if (!response.ok) {
        const errorText = await response.text();
        logger.error({ status: response.status, error: errorText }, 'PumpPortal sell request failed');
        return this.errorResult(0, `Sell request failed: ${response.status}`);
      }

      // PumpPortal returns raw transaction bytes directly, not JSON
      const arrayBuffer = await response.arrayBuffer();
      const txData = new Uint8Array(arrayBuffer);

      // Check if response is actually JSON error
      if (txData.length < 100) {
        const text = new TextDecoder().decode(txData);
        try {
          const jsonError = JSON.parse(text);
          if (jsonError.error) {
            return this.errorResult(0, jsonError.error);
          }
        } catch {
          // Not JSON, continue with deserialization
        }
      }

      logger.debug({ bytes: txData.length }, 'Received raw transaction bytes');

      // Deserialize and sign
      const transaction = VersionedTransaction.deserialize(txData);
      transaction.sign([this.wallet]);

      // Send transaction
      const signature = await this.connection.sendRawTransaction(
        transaction.serialize(),
        { skipPreflight: true, maxRetries: 3 }
      );

      logger.info({ signature }, 'PumpFun sell transaction sent');

      // Confirm
      const latestBlockhash = await this.connection.getLatestBlockhash();
      const confirmation = await this.connection.confirmTransaction(
        { signature, ...latestBlockhash },
        'confirmed'
      );

      if (confirmation.value.err) {
        return this.errorResult(
          0,
          `Transaction failed: ${JSON.stringify(confirmation.value.err)}`,
          signature
        );
      }

      logger.info({ signature, amountTokens }, 'PumpFun sell successful');

      return {
        success: true,
        signature,
        inputAmount: amountTokens,
        outputAmount: 0, // SOL received, will be calculated
        priceImpact: 0,
        fees: {
          platformFee: 0, // Calculated based on output
          networkFee: 5000,
          priorityFee: priorityFee * LAMPORTS_PER_SOL,
          totalFee: 5000 + priorityFee * LAMPORTS_PER_SOL,
        },
        timestamp: new Date(),
      };
    } catch (error: any) {
      logger.error({ error: error.message }, 'PumpFun sell failed');
      return this.errorResult(0, error.message);
    }
  }

  private async simulateBuy(
    tokenMint: string,
    amountSol: number,
    slippagePct: number
  ): Promise<SwapResult> {
    // Simulate buying on bonding curve
    // In reality, tokens received depends on bonding curve state
    const estimatedTokens = amountSol * 1_000_000; // Rough estimate for new tokens

    logger.info({
      mode: 'PAPER',
      action: 'buy',
      mint: tokenMint,
      amountSol,
      estimatedTokens,
    }, 'Paper PumpFun buy');

    return {
      success: true,
      signature: `PAPER_PUMP_BUY_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      inputAmount: amountSol * LAMPORTS_PER_SOL,
      outputAmount: estimatedTokens,
      priceImpact: 0.5, // Estimate
      fees: {
        platformFee: amountSol * LAMPORTS_PER_SOL * 0.01,
        networkFee: 5000,
        priorityFee: 0,
        totalFee: amountSol * LAMPORTS_PER_SOL * 0.01 + 5000,
      },
      timestamp: new Date(),
    };
  }

  private async simulateSell(
    tokenMint: string,
    amountTokens: number,
    slippagePct: number
  ): Promise<SwapResult> {
    // Simulate selling on bonding curve
    const estimatedSol = amountTokens / 1_000_000; // Rough estimate

    logger.info({
      mode: 'PAPER',
      action: 'sell',
      mint: tokenMint,
      amountTokens,
      estimatedSol,
    }, 'Paper PumpFun sell');

    return {
      success: true,
      signature: `PAPER_PUMP_SELL_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      inputAmount: amountTokens,
      outputAmount: estimatedSol * LAMPORTS_PER_SOL,
      priceImpact: 0.5,
      fees: {
        platformFee: estimatedSol * LAMPORTS_PER_SOL * 0.01,
        networkFee: 5000,
        priorityFee: 0,
        totalFee: estimatedSol * LAMPORTS_PER_SOL * 0.01 + 5000,
      },
      timestamp: new Date(),
    };
  }

  private errorResult(inputAmount: number, error: string, signature?: string): SwapResult {
    return {
      success: false,
      signature,
      inputAmount,
      outputAmount: 0,
      priceImpact: 0,
      fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
      error,
      timestamp: new Date(),
    };
  }

  getWalletAddress(): string | null {
    return this.wallet?.publicKey.toBase58() || null;
  }
}

export const pumpFunSwap = new PumpFunSwap();
</file>

<file path="src/execution/types.ts">
import { PublicKey } from '@solana/web3.js';

export interface SwapQuote {
  inputMint: string;
  outputMint: string;
  inputAmount: number;
  outputAmount: number;
  priceImpact: number;
  slippageBps: number;
  route: SwapRoute[];
  fees: SwapFees;
}

export interface SwapRoute {
  dex: string;
  poolAddress: string;
  inputMint: string;
  outputMint: string;
  inputAmount: number;
  outputAmount: number;
}

export interface SwapFees {
  platformFee: number;
  networkFee: number;
  priorityFee: number;
  totalFee: number;
}

export interface SwapResult {
  success: boolean;
  signature?: string;
  inputAmount: number;
  outputAmount: number;
  priceImpact: number;
  fees: SwapFees;
  error?: string;
  timestamp: Date;
  actualBalance?: number;  // Actual on-chain balance (for detecting manual sells)
}

export interface JitoBundleResult {
  success: boolean;
  bundleId?: string;
  signatures: string[];
  tipAmount: number;
  landedSlot?: number;
  error?: string;
}

export interface TransactionConfig {
  priorityFee: number;
  maxRetries: number;
  confirmationTimeout: number;
  useJito: boolean;
  jitoTip: number;
}

export interface PendingTransaction {
  id: string;
  signature?: string;
  type: 'buy' | 'sell';
  mint: string;
  inputAmount: number;
  expectedOutput: number;
  status: 'pending' | 'confirmed' | 'failed';
  retries: number;
  createdAt: Date;
  confirmedAt?: Date;
  error?: string;
}

export interface ExecutionMetrics {
  totalTransactions: number;
  successRate: number;
  avgSlippage: number;
  avgConfirmationTime: number;
  totalFeesPaid: number;
  jitoSuccessRate: number;
}
</file>

<file path="src/risk/capital-allocator.ts">
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { txManager } from '../execution/tx-manager';
import { positionManager } from './position-manager';
import { CapitalAllocation, RiskCheckResult, RiskLimits } from './types';

const logger = createChildLogger('capital-allocator');

export class CapitalAllocator {
  private allocation: CapitalAllocation;
  private limits: RiskLimits;

  constructor() {
    const totalCapital = config.initialCapitalSol;

    this.allocation = {
      totalSol: totalCapital,
      reserveSol: totalCapital * config.capitalAllocation.reserve,
      activeSol: totalCapital * config.capitalAllocation.active,
      highRiskSol: totalCapital * config.capitalAllocation.highRisk,
      inPositions: 0,
      availableActive: totalCapital * config.capitalAllocation.active,
      availableHighRisk: totalCapital * config.capitalAllocation.highRisk,
    };

    this.limits = {
      maxPositionSizeSol: config.maxPositionSize * totalCapital,
      maxConcurrentPositions: config.maxConcurrentPositions,
      dailyLossLimit: config.dailyLossLimit,
      maxDrawdownLimit: 0.30, // 30% max drawdown
      minPositionSizeSol: 0.001,
    };
  }

  async syncWithWallet(): Promise<void> {
    try {
      const actualBalance = await txManager.getWalletBalance();
      const inPositions = positionManager.getTotalExposure();

      this.allocation.totalSol = actualBalance + inPositions;
      this.allocation.inPositions = inPositions;

      // Recalculate allocations
      this.allocation.reserveSol = this.allocation.totalSol * config.capitalAllocation.reserve;
      this.allocation.activeSol = this.allocation.totalSol * config.capitalAllocation.active;
      this.allocation.highRiskSol = this.allocation.totalSol * config.capitalAllocation.highRisk;

      // Calculate available capital by pool
      const activeInPositions = this.getPoolExposure('active');
      const highRiskInPositions = this.getPoolExposure('high_risk');

      this.allocation.availableActive = Math.max(0, this.allocation.activeSol - activeInPositions);
      this.allocation.availableHighRisk = Math.max(0, this.allocation.highRiskSol - highRiskInPositions);

      // Update limits based on new total
      this.limits.maxPositionSizeSol = config.maxPositionSize * this.allocation.totalSol;

      logger.debug({
        total: this.allocation.totalSol.toFixed(4),
        available: actualBalance.toFixed(4),
        inPositions: inPositions.toFixed(4),
        availableActive: this.allocation.availableActive.toFixed(4),
        availableHighRisk: this.allocation.availableHighRisk.toFixed(4),
      }, 'Capital synced');
    } catch (error) {
      logger.error({ error }, 'Failed to sync capital');
    }
  }

  private getPoolExposure(poolType: 'active' | 'high_risk'): number {
    return positionManager
      .getOpenPositions()
      .filter((p) => p.poolType === poolType)
      .reduce((sum, p) => sum + p.amountSol, 0);
  }

  checkRisk(
    requestedSizeSol: number,
    poolType: 'active' | 'high_risk'
  ): RiskCheckResult {
    const warnings: string[] = [];
    let adjustedSize = requestedSizeSol;
    let approved = true;

    // Check position count limit
    const currentPositions = positionManager.getPositionCount();
    if (currentPositions >= this.limits.maxConcurrentPositions) {
      logger.info({
        currentPositions,
        maxPositions: this.limits.maxConcurrentPositions,
      }, 'BLOCKED: Max concurrent positions reached');
      return {
        approved: false,
        reason: `Max positions (${this.limits.maxConcurrentPositions}) reached`,
        warnings: [],
      };
    }

    // Check pool availability
    const available =
      poolType === 'active'
        ? this.allocation.availableActive
        : this.allocation.availableHighRisk;

    if (requestedSizeSol > available) {
      adjustedSize = available;
      warnings.push(`Size reduced to available: ${available.toFixed(4)} SOL`);
    }

    // Check max position size
    if (adjustedSize > this.limits.maxPositionSizeSol) {
      adjustedSize = this.limits.maxPositionSizeSol;
      warnings.push(`Size capped at max: ${this.limits.maxPositionSizeSol.toFixed(4)} SOL`);
    }

    // Check min position size
    if (adjustedSize < this.limits.minPositionSizeSol) {
      return {
        approved: false,
        reason: `Size ${adjustedSize.toFixed(4)} below minimum ${this.limits.minPositionSizeSol} SOL`,
        warnings,
      };
    }

    // Check total exposure
    const totalExposure = positionManager.getTotalExposure() + adjustedSize;
    const maxExposure = this.allocation.totalSol - this.allocation.reserveSol;

    if (totalExposure > maxExposure) {
      const allowedSize = maxExposure - positionManager.getTotalExposure();
      if (allowedSize < this.limits.minPositionSizeSol) {
        return {
          approved: false,
          reason: 'Would exceed total exposure limit',
          warnings,
        };
      }
      adjustedSize = allowedSize;
      warnings.push(`Size reduced due to exposure limit: ${adjustedSize.toFixed(4)} SOL`);
    }

    return {
      approved: true,
      adjustedSize,
      reason: 'Risk check passed',
      warnings,
    };
  }

  getAllocation(): CapitalAllocation {
    return { ...this.allocation };
  }

  getLimits(): RiskLimits {
    return { ...this.limits };
  }

  getAvailableCapital(poolType: 'active' | 'high_risk'): number {
    return poolType === 'active'
      ? this.allocation.availableActive
      : this.allocation.availableHighRisk;
  }

  getExposurePercent(): number {
    if (this.allocation.totalSol === 0) return 0;
    return (this.allocation.inPositions / this.allocation.totalSol) * 100;
  }

  reserveCapital(amount: number, poolType: 'active' | 'high_risk'): void {
    if (poolType === 'active') {
      this.allocation.availableActive = Math.max(0, this.allocation.availableActive - amount);
    } else {
      this.allocation.availableHighRisk = Math.max(0, this.allocation.availableHighRisk - amount);
    }
    this.allocation.inPositions += amount;
  }

  releaseCapital(amount: number, poolType: 'active' | 'high_risk'): void {
    if (poolType === 'active') {
      this.allocation.availableActive += amount;
    } else {
      this.allocation.availableHighRisk += amount;
    }
    this.allocation.inPositions = Math.max(0, this.allocation.inPositions - amount);
  }

  suggestPoolType(rugScore: number): 'active' | 'high_risk' {
    // Higher rug score = safer token = active pool
    // Lower rug score = riskier = high risk pool
    return rugScore >= 70 ? 'active' : 'high_risk';
  }

  getStatus(): string {
    const exposure = this.getExposurePercent();
    const positions = positionManager.getPositionCount();

    return [
      `Total: ${this.allocation.totalSol.toFixed(4)} SOL`,
      `In Positions: ${this.allocation.inPositions.toFixed(4)} SOL (${exposure.toFixed(1)}%)`,
      `Available Active: ${this.allocation.availableActive.toFixed(4)} SOL`,
      `Available High Risk: ${this.allocation.availableHighRisk.toFixed(4)} SOL`,
      `Positions: ${positions}/${this.limits.maxConcurrentPositions}`,
    ].join(' | ');
  }
}

export const capitalAllocator = new CapitalAllocator();
</file>

<file path="src/services/index.ts">
export { walletSync, WalletSync, WalletState, TokenDiscrepancy, SyncResult } from './wallet-sync';
export { equityTracker, EquityTracker, EquitySnapshot } from './equity-tracker';
export { positionReconciler, PositionReconciler, PhantomPosition, OrphanToken, ReconciliationResult } from './position-reconciler';
export { c100Tracker, C100Tracker, C100TokenData } from './c100-tracker';
export { rewardClaimer, RewardClaimer, ClaimResult, ClaimStats } from './reward-claimer';
export { c100Buyback, C100Buyback, BuybackResult, BuybackStats } from './c100-buyback';
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
</file>

<file path="client/src/components/AIStatus.tsx">
import React, { useEffect, useState } from 'react';
import type { Stats, AIDecisionData } from '../types';
import { TokenBadge } from './TokenDisplay';

interface AIStatusProps {
  stats: Stats;
  decision: AIDecisionData | null;
}

export const AIStatus: React.FC<AIStatusProps> = ({ stats, decision }) => {
  const [statusText, setStatusText] = useState('Initializing AI Model...');
  const winRate = parseFloat(stats.winRate || "0");
  const winStreak = stats.winStreak || 0;

  useEffect(() => {
    if (!decision) return;

    // Map regime to text
    const regimes = ['BULL', 'VOLATILE', 'CRASH'];
    const regimeText = regimes[decision.regime];

    // Clearer action text - these are decisions about NEW tokens, not existing positions
    let actionText: string;
    switch (decision.action) {
      case 0: // HOLD
        actionText = `Watching`;
        break;
      case 1: // BUY
        actionText = `Buying`;
        break;
      case 2: // SELL (means "pass on this token")
        actionText = `Passing on`;
        break;
      default:
        actionText = `Evaluating`;
    }

    setStatusText(`${regimeText}: ${actionText}`);
  }, [decision]);

  // Fallback animation if no decision yet
  useEffect(() => {
    if (decision) return;
    const statuses = ['Analyzing market structure', 'Calculating Q-values', 'Scanning liquidity'];
    let index = 0;
    const interval = setInterval(() => {
      index = (index + 1) % statuses.length;
      setStatusText(statuses[index]);
    }, 3000);
    return () => clearInterval(interval);
  }, [decision]);

  // Visualize Q-Values (Buy vs Hold vs Sell reward expectations)
  // Normalize for display: find max absolute value to scale bars
  const qValues = decision?.qValues || [0, 0, 0]; // [Hold, Buy, Sell] typically
  const maxQ = Math.max(...qValues.map(Math.abs), 1); // Avoid div by zero
  
  // Confidence for the bar
  // Scale factor: AI confidence is often raw difference in Q-values (0.01-0.1 range)
  // We apply a sigmoid-like scaling to make it visible on the 0-100% bar
  const rawConfidence = decision ? decision.confidence : (winRate / 100);
  const scaledConfidence = Math.min(100, Math.max(0, rawConfidence * 500)); // Boost factor
  
  const confidence = decision ? scaledConfidence : Math.min(100, Math.max(0, winRate * 1.2));

  return (
    <div className="card">
      <div className="card-header">
        <span className="card-title">Claude's Thoughts</span>
      </div>
      <div className="ai-content">
        <div className="ai-indicator">
          <div className="ai-ring-outer"></div>
          <div className="ai-ring" style={{ animationDuration: decision ? '0.5s' : '1.5s' }}></div>
          <div className="ai-ring-inner"></div>
          <div className="ai-center">
            <div className="ai-center-dot" style={{ 
              background: decision?.action === 1 ? 'var(--success)' : 
                          decision?.action === 2 ? 'var(--error)' : '#FAFAF9' 
            }}></div>
          </div>
        </div>
        
        <div className="ai-status" style={{ minHeight: '40px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', flexWrap: 'wrap' }}>
          <span>{statusText}</span>
          {decision && (
            <TokenBadge
              mint={decision.mint}
              symbol={decision.symbol}
              imageUrl={decision.imageUrl}
            />
          )}
        </div>

        {/* Q-Value Visualization */}
        <div style={{ display: 'flex', gap: '8px', marginBottom: '20px', height: '60px', alignItems: 'flex-end' }}>
          {['WATCH', 'BUY', 'PASS'].map((label, i) => {
            const val = qValues[i] || 0;
            const height = Math.abs(val) / maxQ * 100;
            const color = val > 0 ? 'var(--success)' : 'var(--error)';
            const isSelected = decision?.action === i;
            
            return (
              <div key={label} style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', opacity: isSelected ? 1 : 0.5 }}>
                 <div style={{ 
                   width: '100%', 
                   height: `${Math.max(10, height)}%`, 
                   background: color,
                   borderRadius: '4px',
                   transition: 'all 0.3s ease'
                 }}></div>
                 <span style={{ fontSize: '10px', marginTop: '4px', color: 'var(--text-muted)' }}>{label}</span>
              </div>
            );
          })}
        </div>

        <div className="confidence-bar">
          <div className="confidence-header">
            <span>Confidence</span>
            <span>{confidence.toFixed(0)}%</span>
          </div>
          <div className="confidence-track">
            <div 
              className="confidence-fill" 
              style={{ width: `${confidence}%` }}
            ></div>
          </div>
        </div>
        <div className="win-streak-box">
          <div className="win-streak-value animate-number">{winStreak}</div>
          <div className="win-streak-label">Win streak</div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="client/src/components/TokenScanner.tsx">
import React from 'react';
import type { ScannerData } from '../types';
import { TokenDisplay } from './TokenDisplay';

interface TokenScannerProps {
  data?: ScannerData;
  isScanning: boolean;
  tokensScanned?: number;
}

export const TokenScanner: React.FC<TokenScannerProps> = ({ data, isScanning, tokensScanned = 0 }) => {
  return (
    <div className="card scanner-card">
      <div className="card-header">
        <span className="card-title">Token Scanner</span>
        <span style={{
          fontSize: '11px',
          color: 'var(--text-muted)',
          background: 'var(--bg-elevated)',
          padding: '4px 10px',
          borderRadius: '12px'
        }}>
          {tokensScanned.toLocaleString()} scanned
        </span>
      </div>
      <div className="scanner-content">
        <div className="scanner-token">
          <div className={`scanner-icon ${isScanning ? 'scanning' : ''}`}>
            âŸ³
          </div>
          <div className="scanner-token-info">
            {data?.mint ? (
              <TokenDisplay
                mint={data.mint}
                name={data.name}
                symbol={data.symbol}
                imageUrl={data.imageUrl}
                size="lg"
                showCopy={true}
              />
            ) : (
              <div style={{ padding: '8px 0' }}>
                <h4 style={{ margin: 0, color: 'var(--text-primary)' }}>
                  {isScanning ? 'Scanning...' : 'Waiting for tokens'}
                </h4>
                <p style={{ margin: '4px 0 0', fontSize: '12px', color: 'var(--text-muted)' }}>
                  Monitoring pump.fun for new launches
                </p>
              </div>
            )}
          </div>
        </div>

        {data?.mint && (
          <div style={{
            marginTop: '16px',
            padding: '12px',
            background: 'var(--bg-elevated)',
            borderRadius: '8px',
            fontSize: '12px',
            color: 'var(--text-muted)',
            textAlign: 'center'
          }}>
            Collecting price data for watchlist analysis...
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="client/src/hooks/useSocket.ts">
import { useEffect, useState } from 'react';
import { io, type Socket } from 'socket.io-client';
import type { Stats, ScannerData, Trade, ToastData, AIDecisionData, NarrativeSignal, WatchlistToken, WatchlistStats, C100Data } from '../types';

export interface Position {
  id: string;
  mint: string;
  name?: string;
  symbol: string;
  imageUrl?: string | null;
  amount: number;
  amountSol: number;
  entryPrice: number;
  currentPrice: number;
  highestPrice: number;
  unrealizedPnl: number;
  unrealizedPnlPercent: number;
  realizedPnl?: number;
  totalPnl?: number;
  totalPnlPercent?: number;
  stopLoss: number;
  trailingStop?: number;
  initialRecovered?: boolean;
  scaledExitsTaken?: number;
  status: string;
  poolType: string;
  entryTime: string;
  holdTime: number;
}

export interface WalletState {
  solBalance: number;
  lastSync: string | null;
  isHealthy: boolean;
  totalEquity?: number;
}

export interface EquitySnapshot {
  timestamp: string;
  totalEquity: number;
  walletBalance: number;
  positionsValue: number;
  unrealizedPnl: number;
  positionCount: number;
}

interface UseSocketReturn {
  socket: Socket | null;
  isConnected: boolean;
  stats: Stats;
  trades: Trade[];
  positions: Position[];
  positionsSummary: { totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null;
  walletState: WalletState | null;
  equityHistory: EquitySnapshot[];
  scannerData: ScannerData | null;
  isScanning: boolean;
  toasts: ToastData[];
  aiDecision: AIDecisionData | null;
  narrativeSignal: NarrativeSignal | null;
  watchlistTokens: WatchlistToken[];
  watchlistStats: WatchlistStats;
  c100Data: C100Data | null;
  removeToast: (index: number) => void;
}

export const useSocket = (): UseSocketReturn => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  
  // Data State
  const [stats, setStats] = useState<Stats>({
    multiplier: "1.00",
    currentEquity: "0",
    initialCapital: "0",
    winRate: "0",
    totalTrades: 0,
    tokensScanned: 0,
    winStreak: 0
  });
  const [trades, setTrades] = useState<Trade[]>([]);
  const [positions, setPositions] = useState<Position[]>([]);
  const [positionsSummary, setPositionsSummary] = useState<{ totalUnrealizedPnl: string; totalExposure: string; positionCount: number } | null>(null);
  const [walletState, setWalletState] = useState<WalletState | null>(null);
  const [equityHistory, setEquityHistory] = useState<EquitySnapshot[]>([]);
  const [scannerData, setScannerData] = useState<ScannerData | null>(null);
  const [isScanning, setIsScanning] = useState(true);
  const [toasts, setToasts] = useState<ToastData[]>([]);
  const [aiDecision, setAiDecision] = useState<AIDecisionData | null>(null);
  const [narrativeSignal, setNarrativeSignal] = useState<NarrativeSignal | null>(null);
  const [watchlistTokens, setWatchlistTokens] = useState<WatchlistToken[]>([]);
  const [watchlistStats, setWatchlistStats] = useState<WatchlistStats>({ total: 0, ready: 0, devSold: 0 });
  const [c100Data, setC100Data] = useState<C100Data | null>(null);

  // Use ref to access latest functions in event callbacks if needed, 
  // but state setters are stable.

  const addToast = (toast: ToastData) => {
    setToasts(prev => [...prev, toast]);
    // Auto remove after 4s
    setTimeout(() => {
      setToasts(prev => prev.slice(1)); // Simple FIFO removal, might change reference index
    }, 4000);
  };

  const removeToast = (index: number) => {
    setToasts(prev => prev.filter((_, i) => i !== index));
  };

  useEffect(() => {
    // Initial fetch
    const fetchData = async () => {
      try {
        const [statsRes, tradesRes, positionsRes, walletRes, equityRes, c100Res] = await Promise.all([
          fetch('/api/stats'),
          fetch('/api/trades?limit=10'),
          fetch('/api/positions/realtime'),
          fetch('/api/wallet'),
          fetch('/api/equity-history?hours=24'),
          fetch('/api/c100/status')
        ]);
        if (statsRes.ok) setStats(await statsRes.json());
        if (tradesRes.ok) setTrades(await tradesRes.json());
        if (positionsRes.ok) {
          const posData = await positionsRes.json();
          setPositions(posData.positions || []);
          setPositionsSummary(posData.summary || null);
        }
        if (walletRes.ok) {
          const walletData = await walletRes.json();
          setWalletState({
            solBalance: walletData.solBalance,
            lastSync: walletData.lastSync,
            isHealthy: walletData.isHealthy,
            totalEquity: walletData.equity?.total
          });
        }
        if (equityRes.ok) {
          const equityData = await equityRes.json();
          setEquityHistory(equityData.history || []);
        }
        if (c100Res.ok) {
          setC100Data(await c100Res.json());
        }
      } catch (err) {
        console.error("Failed to fetch initial data", err);
      }
    };
    fetchData();

    // Socket Connection
    // Note: In development with Vite proxy, '/' works if proxy is set.
    // Otherwise might need absolute URL.
    const newSocket = io('/', {
      transports: ['polling', 'websocket'],
      reconnectionAttempts: 5,
      upgrade: true,
    });

    newSocket.on('connect', () => {
      setIsConnected(true);
      fetchData(); // Refresh on reconnect
    });

    newSocket.on('disconnect', () => {
      setIsConnected(false);
    });

    // Event Handlers
    newSocket.on('stats:initial', (data: Stats) => setStats(data));
    newSocket.on('stats:update', (data: Stats) => setStats(data));
    
    // Trades
    newSocket.on('trades:initial', (data: Trade[]) => setTrades(data));
    
    newSocket.on('trade:open', (trade: Trade) => {
      addToast({
        type: 'info',
        title: 'Position Opened',
        message: `Bought ${trade.symbol || trade.mint.substring(0, 8)} for ${trade.amountSol} SOL`
      });
      // Trade list is usually updated via rest fetch or full list push? 
      // The original code didn't update the list on 'trade:open', only on 'trade:close'.
      // But let's verify if we should.
    });

    newSocket.on('trade:close', (trade: Trade) => {
      const pnl = parseFloat(trade.pnlSol || "0");
      if (pnl > 0) {
        addToast({
          type: 'success',
          title: `+${trade.pnlSol} SOL`,
          message: `${trade.symbol} closed at ${trade.pnlPercent}%`
        });
      } else {
        addToast({
          type: 'error',
          title: `${trade.pnlSol} SOL`,
          message: `${trade.symbol} stopped out`
        });
      }
      // Refresh trades list
      fetch('/api/trades?limit=10')
        .then(r => r.json())
        .then(data => setTrades(data));
    });

    // Scanner
    newSocket.on('scanner:token', (data: ScannerData) => {
      setScannerData(data);
      setIsScanning(false);
      // Also update tokenScanned count in stats immediately if provided in data
      if (data.tokensScanned) {
        setStats(prev => ({ ...prev, tokensScanned: data.tokensScanned }));
      }
    });

    newSocket.on('scanner:idle', (data: ScannerData) => {
      setScannerData(null);
      setIsScanning(true);
      if (data && data.tokensScanned) {
        setStats(prev => ({ ...prev, tokensScanned: data.tokensScanned }));
      }
    });

    newSocket.on('ai:decision', (data: AIDecisionData) => {
      setAiDecision(data);
    });

    newSocket.on('signal:narrative', (data: NarrativeSignal) => {
      setNarrativeSignal(data);
    });

    // Watchlist events
    newSocket.on('watchlist:update', (data: { tokens: WatchlistToken[]; stats: WatchlistStats }) => {
      setWatchlistTokens(data.tokens);
      setWatchlistStats(data.stats);
    });

    newSocket.on('watchlist:tokenAdded', (token: WatchlistToken) => {
      setWatchlistTokens(prev => {
        // Add or update token
        const exists = prev.findIndex(t => t.mint === token.mint);
        if (exists >= 0) {
          const updated = [...prev];
          updated[exists] = token;
          return updated;
        }
        return [token, ...prev].slice(0, 20); // Keep latest 20
      });
    });

    newSocket.on('watchlist:tokenRemoved', (data: { mint: string }) => {
      setWatchlistTokens(prev => prev.filter(t => t.mint !== data.mint));
    });

    newSocket.on('watchlist:devSold', (data: { mint: string }) => {
      setWatchlistTokens(prev => prev.map(t =>
        t.mint === data.mint ? { ...t, devSold: true, status: 'rejected' as const, rejectReason: 'Dev sold' } : t
      ));
    });

    newSocket.on('status:paused', (data: { reason: string }) => {
      addToast({
        type: 'warning',
        title: 'Trading Paused',
        message: data.reason
      });
    });

    newSocket.on('toast', (data: ToastData) => {
      addToast(data);
    });

    // Position updates (real-time PnL)
    newSocket.on('positions:initial', (data: { positions: Position[]; totalUnrealizedPnl: string; totalExposure: string; positionCount: number }) => {
      setPositions(data.positions || []);
      setPositionsSummary({ totalUnrealizedPnl: data.totalUnrealizedPnl, totalExposure: data.totalExposure, positionCount: data.positionCount });
    });

    newSocket.on('positions:update', (data: { positions: Position[]; totalUnrealizedPnl: string; totalExposure: string; positionCount: number }) => {
      setPositions(data.positions || []);
      setPositionsSummary({ totalUnrealizedPnl: data.totalUnrealizedPnl, totalExposure: data.totalExposure, positionCount: data.positionCount });
    });

    // Wallet updates
    newSocket.on('wallet:update', (data: WalletState) => {
      setWalletState(data);
    });

    // Equity snapshots
    newSocket.on('equity:snapshot', (snapshot: EquitySnapshot) => {
      setEquityHistory(prev => {
        const updated = [...prev, snapshot];
        // Keep last 1440 snapshots (24 hours at 1 min intervals)
        if (updated.length > 1440) {
          return updated.slice(-1440);
        }
        return updated;
      });
    });

    // Reconciliation notifications
    newSocket.on('reconciliation:phantoms', (data: { count: number; phantoms: any[] }) => {
      if (data.count > 0) {
        addToast({
          type: 'warning',
          title: 'Phantom Positions Detected',
          message: `Found ${data.count} position(s) with no tokens`
        });
      }
    });

    // C100 events
    newSocket.on('c100:update', (data: C100Data) => {
      setC100Data(data);
    });

    newSocket.on('c100:priceUpdate', (tokenData: any) => {
      setC100Data(prev => prev ? { ...prev, token: tokenData } : null);
    });

    newSocket.on('c100:claim', (data: { source: string; amountSol: number }) => {
      setC100Data(prev => {
        if (!prev) return null;
        return {
          ...prev,
          claims: {
            ...prev.claims,
            totalClaimedSol: prev.claims.totalClaimedSol + data.amountSol,
            claimCount: prev.claims.claimCount + 1,
            lastClaimTime: new Date().toISOString(),
          }
        };
      });
    });

    newSocket.on('c100:buyback', (data: { amountSol: number; amountTokens: number }) => {
      setC100Data(prev => {
        if (!prev) return null;
        return {
          ...prev,
          buybacks: {
            ...prev.buybacks,
            totalBuybackSol: prev.buybacks.totalBuybackSol + data.amountSol,
            totalTokensBought: prev.buybacks.totalTokensBought + data.amountTokens,
            buybackCount: prev.buybacks.buybackCount + 1,
            lastBuybackTime: new Date().toISOString(),
          }
        };
      });
    });

    setSocket(newSocket);

    return () => {
      newSocket.disconnect();
    };
  }, []);

  return {
    socket,
    isConnected,
    stats,
    trades,
    positions,
    positionsSummary,
    walletState,
    equityHistory,
    scannerData,
    isScanning,
    toasts,
    aiDecision,
    narrativeSignal,
    watchlistTokens,
    watchlistStats,
    c100Data,
    removeToast
  };
};
</file>

<file path="client/src/index.css">
:root {
  /* Claude dark mode inspired palette - warm browns */
  --bg-page: #1C1917;
  --bg-card: #262320;
  --bg-card-hover: #2E2A26;
  --bg-elevated: #33302C;
  --border: rgba(255, 245, 230, 0.08);
  --border-light: rgba(255, 245, 230, 0.12);
  --text-primary: #F5F5F4;
  --text-secondary: #A8A29E;
  --text-muted: #78716C;
  --accent: #D97706;
  --accent-secondary: #F59E0B;
  --accent-glow: rgba(217, 119, 6, 0.3);
  --accent-subtle: rgba(217, 119, 6, 0.12);
  --success: #22C55E;
  --success-glow: rgba(34, 197, 94, 0.25);
  --success-subtle: rgba(34, 197, 94, 0.12);
  --error: #EF4444;
  --error-subtle: rgba(239, 68, 68, 0.12);
  --warning: #F59E0B;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg-page);
  color: var(--text-primary);
  min-height: 100vh;
  padding: 24px 32px;
  -webkit-font-smoothing: antialiased;
}

/* Subtle warm noise texture */
body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image:
    radial-gradient(circle at 50% 50%, rgba(217, 119, 6, 0.03) 0%, transparent 50%);
  pointer-events: none;
  z-index: -1;
}

.dashboard {
  max-width: 1280px;
  margin: 0 auto;
}

/* Header */
.header {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin-bottom: 48px;
  position: relative;
  min-height: 80px;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 20px;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  width: max-content;
}

.logo-icon {
  width: 72px;
  height: 72px;
  border-radius: 20px;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 8px 32px var(--accent-glow);
}

.logo-icon svg {
  width: 26px;
  height: 26px;
  color: white;
}

.logo-text h1 {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
  letter-spacing: -0.02em;
}

.logo-text p {
  font-size: 13px;
  color: var(--text-muted);
  margin-top: 2px;
}

.live-badge {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 18px;
  border-radius: 100px;
  background: var(--success-subtle);
  border: 1px solid rgba(16, 185, 129, 0.2);
  color: var(--success);
  font-size: 13px;
  font-weight: 500;
  backdrop-filter: blur(10px);
}

.live-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--success);
  box-shadow: 0 0 12px var(--success);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {

  0%,
  100% {
    opacity: 1;
    transform: scale(1);
  }

  50% {
    opacity: 0.6;
    transform: scale(0.9);
  }
}

/* Stats Grid */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
  margin-bottom: 24px;
}

.stat-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 20px 24px;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.stat-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.06), transparent);
}

.stat-card:hover {
  background: var(--bg-card-hover);
  border-color: var(--border-light);
  transform: translateY(-2px);
}

.stat-card.highlight {
  background: linear-gradient(135deg, rgba(255, 107, 53, 0.08), rgba(255, 143, 92, 0.04));
  border-color: rgba(255, 107, 53, 0.3);
}

.stat-card.highlight::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
  opacity: 0.3;
  pointer-events: none;
}

.stat-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 10px;
}

.stat-value {
  font-size: 32px;
  font-weight: 600;
  color: var(--text-primary);
  line-height: 1.1;
  letter-spacing: -0.02em;
}

.stat-value.accent {
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.stat-sub {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
  margin-top: 8px;
}

.stat-sub.positive {
  color: var(--success);
}

.stat-sub .arrow {
  font-size: 14px;
}

/* Main Layout */
.main-grid {
  display: grid;
  grid-template-columns: 1.6fr 1fr;
  gap: 24px;
}

.left-column {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.right-column {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

/* Card Base */
.card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 20px;
  overflow: hidden;
  position: relative;
}

.card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.05), transparent);
}

.card-header {
  padding: 20px 24px;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.card-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.01em;
}

/* Challenge Card */
.challenge-card {
  padding: 48px 32px;
  text-align: center;
  position: relative;
}

.challenge-card::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 400px;
  height: 400px;
  background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
  opacity: 0.4;
  pointer-events: none;
}

.challenge-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.15em;
  margin-bottom: 20px;
  position: relative;
  z-index: 1;
}

.challenge-value {
  font-size: 84px;
  font-weight: 300;
  line-height: 1;
  position: relative;
  z-index: 1;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: 0 0 80px var(--accent-glow);
}

.challenge-value span {
  font-size: 42px;
  background: linear-gradient(135deg, var(--text-muted), var(--text-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.challenge-sub {
  font-size: 14px;
  color: var(--text-secondary);
  margin-top: 12px;
  margin-bottom: 32px;
  position: relative;
  z-index: 1;
}

.progress-bar-container {
  position: relative;
  z-index: 1;
}

.progress-bar {
  height: 10px;
  background: #3D3835;
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
  border-radius: 10px;
  transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
}

.progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255, 245, 230, 0.2), transparent);
  animation: shimmer 2.5s infinite;
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%);
  }

  100% {
    transform: translateX(100%);
  }
}

.progress-markers {
  display: flex;
  justify-content: space-between;
  margin-top: 12px;
  font-size: 11px;
  font-weight: 500;
  color: var(--text-muted);
}

.progress-markers span.active {
  color: var(--accent);
}

/* Scanner Card */
.scanner-card .card-header {
  border-bottom: none;
  padding-bottom: 0;
}

.scanner-content {
  padding: 0 24px 24px;
}

.scanner-token {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 18px;
  background: var(--bg-elevated);
  border-radius: 14px;
  margin-bottom: 18px;
  border: 1px solid var(--border);
}

.scanner-icon {
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--accent-subtle), transparent);
  border: 1px solid rgba(255, 107, 53, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  color: var(--accent);
  animation: rotate 2s linear infinite;
}

@keyframes rotate {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}

.scanner-icon.idle {
  animation: none;
}

.scanner-token-info h4 {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.01em;
}

.scanner-token-info p {
  font-size: 12px;
  color: var(--accent);
  margin-top: 2px;
}

.scanner-metrics {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-bottom: 18px;
}

.metric-box {
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px;
  text-align: center;
  transition: all 0.2s ease;
}

.metric-box:hover {
  border-color: var(--border-light);
  background: var(--bg-card-hover);
}

.metric-value {
  font-size: 22px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.02em;
}

.metric-value.accent {
  color: var(--accent);
}

.metric-value.success {
  color: var(--success);
}

.metric-label {
  font-size: 10px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.06em;
  margin-top: 6px;
}

/* Mini Chart */
.mini-chart {
  height: 60px;
  display: flex;
  align-items: flex-end;
  gap: 2px;
  padding: 12px 0;
}

.chart-bar {
  flex: 1;
  border-radius: 3px;
  transition: all 0.3s ease;
  min-height: 4px;
}

.chart-bar.up {
  background: linear-gradient(to top, var(--success), rgba(34, 197, 94, 0.5));
}

.chart-bar.down {
  background: linear-gradient(to top, #A8A29E, #78716C);
}

.chart-bar:hover {
  opacity: 0.8;
  transform: scaleY(1.1);
}

/* Recent Trades */
.trades-list {
  max-height: 360px;
  overflow-y: auto;
}

.trades-list::-webkit-scrollbar {
  width: 4px;
}

.trades-list::-webkit-scrollbar-track {
  background: transparent;
}

.trades-list::-webkit-scrollbar-thumb {
  background: #44403C;
  border-radius: 4px;
}

.trades-list::-webkit-scrollbar-thumb:hover {
  background: #57534E;
}

.trade-item {
  display: flex;
  align-items: center;
  padding: 14px 24px;
  border-bottom: 1px solid var(--border);
  gap: 14px;
  transition: background 0.15s ease;
}

.trade-item:hover {
  background: var(--bg-elevated);
}

.trade-item:last-child {
  border-bottom: none;
}

.trade-arrow {
  width: 36px;
  height: 36px;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: 600;
}

.trade-arrow.up {
  background: var(--success-subtle);
  color: var(--success);
  box-shadow: 0 0 20px var(--success-glow);
}

.trade-arrow.down {
  background: var(--error-subtle);
  color: var(--error);
}

.trade-info {
  flex: 1;
}

.trade-token {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}

.trade-time {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

.trade-pnl {
  text-align: right;
}

.trade-pnl-value {
  font-size: 14px;
  font-weight: 600;
}

.trade-pnl-value.positive {
  color: var(--success);
}

.trade-pnl-value.negative {
  color: var(--text-secondary);
}

.trade-pnl-percent {
  font-size: 11px;
  color: var(--success);
  margin-top: 2px;
}

/* AI Engine */
.ai-content {
  padding: 28px 24px;
  text-align: center;
}

.ai-indicator {
  width: 100px;
  height: 100px;
  margin: 0 auto 20px;
  position: relative;
}

.ai-ring-outer {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  border: 2px solid #3D3835;
}

.ai-ring {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  border: 2px solid transparent;
  border-top-color: var(--accent);
  animation: spin 1.5s linear infinite;
}

.ai-ring-inner {
  position: absolute;
  width: 70%;
  height: 70%;
  top: 15%;
  left: 15%;
  border-radius: 50%;
  border: 2px solid transparent;
  border-top-color: var(--accent-secondary);
  animation: spin 2s linear infinite reverse;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.ai-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 30px var(--accent-glow);
}

.ai-center-dot {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #FAFAF9;
  animation: pulse 2s ease-in-out infinite;
}

.ai-status {
  font-size: 13px;
  color: var(--text-secondary);
  margin-bottom: 20px;
}

.confidence-bar {
  margin-bottom: 24px;
}

.confidence-header {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  margin-bottom: 8px;
}

.confidence-header span:first-child {
  color: var(--text-muted);
}

.confidence-header span:last-child {
  color: var(--accent);
  font-weight: 600;
}

.confidence-track {
  height: 6px;
  background: #3D3835;
  border-radius: 6px;
  overflow: hidden;
}

.confidence-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
  border-radius: 6px;
  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

.win-streak-box {
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 24px;
}

.win-streak-value {
  font-size: 48px;
  font-weight: 300;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  line-height: 1;
}

.win-streak-label {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 8px;
}

/* Toast Notifications */
.toast-container {
  position: fixed;
  top: 24px;
  right: 24px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  z-index: 1000;
}

.toast {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 16px 20px;
  min-width: 300px;
  animation: slideIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
  backdrop-filter: blur(20px);
}

/* Floating Controls */
.floating-controls {
  position: fixed;
  bottom: 24px;
  right: 24px;
  display: flex;
  align-items: center;
  gap: 12px;
  z-index: 100;
}

/* Wallet Pill */
.wallet-pill {
  display: flex;
  align-items: center;
  gap: 10px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 100px;
  padding: 0 20px;
  height: 48px;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.wallet-pill:hover {
  transform: translateY(-2px);
  border-color: var(--border-light);
  background: var(--bg-elevated);
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
}

.wallet-pill:active {
  transform: translateY(0);
}

.wallet-label {
  font-size: 11px;
  font-weight: 700;
  color: var(--accent);
  letter-spacing: 0.05em;
}

.wallet-address {
  font-size: 13px;
  color: var(--text-secondary);
  font-family: monospace;
  font-weight: 500;
}

.wallet-pill svg {
  color: var(--text-muted);
  opacity: 0.7;
}

.wallet-pill:hover svg {
  opacity: 1;
  color: var(--text-primary);
}

/* X Profile Link */
.x-profile-link {
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 12px;
  color: var(--text-muted);
  transition: all 0.2s ease;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.x-profile-link:hover {
  transform: translateY(-2px);
  color: var(--text-primary);
  border-color: var(--border-light);
  background: var(--bg-elevated);
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
}

.x-profile-link svg {
  width: 20px;
  height: 20px;
}

.toast.success {
  border-left: 3px solid var(--success);
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), 0 0 40px var(--success-glow);
}

.toast.error {
  border-left: 3px solid var(--error);
}

.toast.warning {
  border-left: 3px solid var(--warning);
}

.toast.info {
  border-left: 3px solid var(--accent);
}

.toast-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 4px;
}

.toast.success .toast-title {
  color: var(--success);
}

.toast.error .toast-title {
  color: var(--error);
}

.toast-message {
  font-size: 13px;
  color: var(--text-secondary);
}

@keyframes slideIn {
  from {
    transform: translateX(100%) scale(0.9);
    opacity: 0;
  }

  to {
    transform: translateX(0) scale(1);
    opacity: 1;
  }
}

/* Empty State */
.empty-state {
  padding: 40px 24px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
}

/* Responsive */
@media (max-width: 1024px) {
  .stats-grid {
    grid-template-columns: repeat(2, 1fr);
  }

  .main-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 600px) {
  .stats-grid {
    grid-template-columns: 1fr;
  }

  body {
    padding: 16px;
  }

  .header {
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
  }

  .header-left {
    width: 100%;
  }

  .live-badge {
    position: absolute;
    top: 16px;
    right: 16px;
  }

  .challenge-value {
    font-size: 56px;
  }
}

/* Number animation */
.animate-number {
  display: inline-block;
  transition: transform 0.3s ease;
}

.animate-number.updating {
  transform: scale(1.05);
}

/* Positions Component */
.positions-list {
  max-height: 300px;
  overflow-y: auto;
}

.positions-list::-webkit-scrollbar {
  width: 4px;
}

.positions-list::-webkit-scrollbar-track {
  background: transparent;
}

.positions-list::-webkit-scrollbar-thumb {
  background: #44403C;
  border-radius: 4px;
}

.position-item {
  display: flex;
  align-items: center;
  padding: 14px 24px;
  border-bottom: 1px solid var(--border);
  gap: 12px;
  transition: background 0.15s ease;
}

.position-item:hover {
  background: var(--bg-elevated);
}

.position-item:last-child {
  border-bottom: none;
}

.position-indicator {
  width: 4px;
  height: 40px;
  border-radius: 2px;
}

.position-indicator.profit {
  background: var(--success);
  box-shadow: 0 0 8px var(--success-glow);
}

.position-indicator.loss {
  background: var(--error);
}

.position-info {
  flex: 1;
  min-width: 0;
}

.position-header {
  display: flex;
  align-items: center;
  gap: 8px;
}

.position-symbol {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}

.position-pool {
  font-size: 10px;
  font-weight: 500;
  padding: 2px 6px;
  border-radius: 4px;
  background: var(--accent-subtle);
  color: var(--accent);
  text-transform: uppercase;
}

.position-details {
  display: flex;
  gap: 12px;
  margin-top: 4px;
  font-size: 11px;
  color: var(--text-muted);
}

.position-pnl {
  text-align: right;
}

.position-unrealized {
  font-size: 14px;
  font-weight: 600;
}

.position-unrealized.positive {
  color: var(--success);
}

.position-unrealized.negative {
  color: var(--error);
}

.position-pnl-percent {
  font-size: 11px;
  opacity: 0.8;
  margin-left: 4px;
}

.position-realized {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 2px;
}

.position-status {
  display: flex;
  gap: 4px;
}

.status-badge {
  font-size: 9px;
  font-weight: 600;
  padding: 2px 5px;
  border-radius: 3px;
  text-transform: uppercase;
}

.status-badge.recovered {
  background: var(--success-subtle);
  color: var(--success);
}

.status-badge.exits {
  background: var(--accent-subtle);
  color: var(--accent);
}

.status-badge.trailing {
  background: rgba(139, 92, 246, 0.12);
  color: #a78bfa;
}

.positions-footer {
  padding: 12px 24px;
  border-top: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  color: var(--text-muted);
}

.card-badge {
  font-size: 12px;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 6px;
}

.card-badge.positive {
  background: var(--success-subtle);
  color: var(--success);
}

.card-badge.negative {
  background: var(--error-subtle);
  color: var(--error);
}

/* Equity Chart Component */
.equity-chart-card {
  min-height: 180px;
}

.equity-chart-content {
  padding: 16px 24px;
}

.equity-chart-empty {
  padding: 40px 24px;
  text-align: center;
  color: var(--text-muted);
  font-size: 13px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.wallet-balance {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
}

.equity-current {
  display: flex;
  align-items: baseline;
  gap: 6px;
  margin-bottom: 12px;
}

.equity-value {
  font-size: 28px;
  font-weight: 600;
  color: var(--text-primary);
}

.equity-label {
  font-size: 14px;
  color: var(--text-muted);
}

.equity-sparkline {
  width: 100%;
  height: 60px;
  display: block;
}

.equity-range {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 4px;
}

.equity-footer {
  padding: 12px 24px;
  border-top: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  font-size: 12px;
}

.equity-footer .positive {
  color: var(--success);
}

.equity-footer .negative {
  color: var(--error);
}

.wallet-indicator {
  color: var(--text-muted);
}

/* C100 Card Styles */
.c100-card {
  background: linear-gradient(135deg, rgba(217, 119, 6, 0.06), rgba(245, 158, 11, 0.02));
  border: 1px solid rgba(217, 119, 6, 0.25);
  border-radius: 20px;
  padding: 24px;
  margin-bottom: 24px;
  position: relative;
  overflow: hidden;
}

.c100-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(217, 119, 6, 0.3), transparent);
}

.c100-card::after {
  content: '';
  position: absolute;
  top: -100px;
  right: -100px;
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
  opacity: 0.15;
  pointer-events: none;
}

.c100-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.c100-token-info {
  display: flex;
  align-items: center;
  gap: 14px;
}

.c100-icon {
  width: 48px;
  height: 48px;
  border-radius: 14px;
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  font-weight: 700;
  color: white;
  box-shadow: 0 4px 20px var(--accent-glow);
}

.c100-details h3 {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.01em;
}

.c100-ticker {
  font-size: 13px;
  color: var(--accent);
  font-weight: 500;
  margin-top: 2px;
}

.c100-mint {
  font-size: 12px;
  color: var(--text-muted);
  background: var(--bg-elevated);
  padding: 6px 12px;
  border-radius: 8px;
  font-family: monospace;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid var(--border);
}

.c100-mint:hover {
  background: var(--bg-card-hover);
  border-color: var(--border-light);
  color: var(--text-secondary);
}

.c100-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 16px;
}

.c100-stat {
  background: var(--bg-elevated);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px;
  text-align: center;
  transition: all 0.2s ease;
}

.c100-stat:hover {
  border-color: var(--border-light);
  background: var(--bg-card-hover);
}

.c100-stat.highlight {
  background: linear-gradient(135deg, rgba(217, 119, 6, 0.08), rgba(245, 158, 11, 0.04));
  border-color: rgba(217, 119, 6, 0.3);
}

.c100-stat.wide {
  grid-column: span 1;
}

.c100-stat-label {
  font-size: 10px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.06em;
  display: block;
  margin-bottom: 8px;
}

.c100-stat-value {
  font-size: 20px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.02em;
  display: block;
}

.c100-stat-value.accent {
  background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.c100-stat-value.large {
  font-size: 24px;
}

.c100-stat-change {
  font-size: 11px;
  font-weight: 500;
  display: block;
  margin-top: 4px;
}

.c100-stat-change.positive {
  color: var(--success);
}

.c100-stat-change.negative {
  color: var(--error);
}

.c100-stat-sub {
  font-size: 10px;
  color: var(--text-muted);
  display: block;
  margin-top: 4px;
}

/* Responsive adjustments for C100 card */
@media (max-width: 900px) {
  .c100-grid {
    grid-template-columns: repeat(3, 1fr);
  }

  .c100-stat.wide {
    grid-column: span 3;
  }
}

@media (max-width: 600px) {
  .c100-grid {
    grid-template-columns: repeat(2, 1fr);
  }

  .c100-stat.wide {
    grid-column: span 2;
  }

  .c100-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 12px;
  }

  .c100-mint {
    align-self: flex-start;
  }
}
</file>

<file path="src/api/routes.ts">
import { Express, Request, Response } from 'express';
import { createChildLogger } from '../utils/logger';
import { positionManager, capitalAllocator, drawdownGuard } from '../risk';
import { tradeLogger, performanceAnalytics } from '../learning';
import { tokenWatchlist, pumpDetector } from '../signals';
import { ddqnAgent, regimeDetector, positionSizer } from '../ai';
import { config } from '../config/settings';
import { walletSync, equityTracker, positionReconciler, c100Tracker, rewardClaimer, c100Buyback } from '../services';
import { txManager } from '../execution/tx-manager';
import { repository } from '../db/repository';

const logger = createChildLogger('api-routes');

// Store AI decision history for debugging
interface AIDecisionLog {
  mint: string;
  symbol: string;
  timestamp: Date;
  action: string;
  confidence: number;
  requiredConfidence: number;
  hasMomentum: boolean;
  qValues: number[];
  features: Record<string, number>;
  outcome?: 'passed' | 'rejected';
  rejectionReason?: string;
}

const aiDecisionHistory: AIDecisionLog[] = [];
const MAX_DECISION_HISTORY = 100;

// Store rejection stats
const rejectionStats = {
  quickSafety: 0,
  liquidity: 0,
  rugScore: 0,
  entryEval: 0,
  aiDecision: 0,
  riskCheck: 0,
  confidenceBelow: 0,  // NEW: Track confidence-based rejections
  total: 0,
  passed: 0,
};

// Export function to log AI decisions from index.ts
export function logAIDecision(decision: AIDecisionLog): void {
  aiDecisionHistory.unshift(decision);
  if (aiDecisionHistory.length > MAX_DECISION_HISTORY) {
    aiDecisionHistory.pop();
  }
}

// Export function to update rejection stats
export function updateRejectionStats(type: keyof typeof rejectionStats): void {
  if (type in rejectionStats) {
    rejectionStats[type]++;
    if (type !== 'passed') {
      rejectionStats.total++;
    }
  }
}

export function setupRoutes(app: Express): void {
  // Health check
  app.get('/api/health', (req: Request, res: Response) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
  });

  // Get bot status
  app.get('/api/status', async (req: Request, res: Response) => {
    try {
      const drawdown = drawdownGuard.getState();
      const allocation = capitalAllocator.getAllocation();
      const positions = positionManager.getOpenPositions();

      res.json({
        isRunning: true,
        isPaused: drawdown.isPaused,
        pauseReason: drawdown.pauseReason,
        pauseUntil: drawdown.pauseUntil,
        positionCount: positions.length,
        totalExposure: positionManager.getTotalExposure(),
        totalCapital: allocation.totalSol,
        currentEquity: drawdown.currentEquity,
        paperTrading: config.paperTrading,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get status');
      res.status(500).json({ error: 'Failed to get status' });
    }
  });

  // Get stats for dashboard
  app.get('/api/stats', async (req: Request, res: Response) => {
    try {
      const metrics = await performanceAnalytics.calculateMetrics();
      const allocation = capitalAllocator.getAllocation();
      const drawdown = drawdownGuard.getState();
      const positions = positionManager.getOpenPositions();

      // Calculate total unrealized P&L
      const totalUnrealizedPnl = positions.reduce((sum, p) => sum + p.unrealizedPnl, 0);

      // Calculate multiplier: (realized + unrealized + initial) / initial
      const realizedPnl = metrics.totalPnl;
      const currentEquity = config.initialCapitalSol + realizedPnl + totalUnrealizedPnl;
      const multiplier = currentEquity / config.initialCapitalSol;

      // Calculate win streak
      const recentTrades = await tradeLogger.getRecentTrades(20);
      let winStreak = 0;
      for (const trade of recentTrades) {
        if (trade.pnlSol !== undefined) {
          if (trade.pnlSol > 0) {
            winStreak++;
          } else {
            break;
          }
        }
      }

      res.json({
        multiplier: multiplier.toFixed(2),
        winRate: (metrics.winRate * 100).toFixed(1),
        totalTrades: metrics.totalTrades,
        winningTrades: metrics.winningTrades,
        losingTrades: metrics.losingTrades,
        totalPnl: metrics.totalPnl.toFixed(4),
        totalUnrealizedPnl: totalUnrealizedPnl.toFixed(4),
        currentEquity: currentEquity.toFixed(4),
        initialCapital: config.initialCapitalSol,
        progressPercent: Math.min(100, (currentEquity / 100) * 100),
        profitFactor: metrics.profitFactor.toFixed(2),
        sharpeRatio: metrics.sharpeRatio.toFixed(2),
        maxDrawdown: (metrics.maxDrawdown * 100).toFixed(1),
        avgWin: metrics.avgWin.toFixed(4),
        avgLoss: metrics.avgLoss.toFixed(4),
        largestWin: metrics.largestWin.toFixed(4),
        largestLoss: metrics.largestLoss.toFixed(4),
        winStreak,
        drawdown: {
          current: (drawdown.currentDrawdown * 100).toFixed(2),
          max: (drawdown.maxDrawdown * 100).toFixed(2),
          dailyPnl: drawdown.dailyPnl.toFixed(4),
        },
        allocation: {
          total: allocation.totalSol.toFixed(4),
          inPositions: allocation.inPositions.toFixed(4),
          availableActive: allocation.availableActive.toFixed(4),
          availableHighRisk: allocation.availableHighRisk.toFixed(4),
        },
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get stats');
      res.status(500).json({ error: 'Failed to get stats' });
    }
  });

  // Get recent trades
  app.get('/api/trades', async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 20;
      const trades = await tradeLogger.getRecentTrades(limit);

      const formattedTrades = trades.map((trade) => ({
        id: trade.id,
        mint: trade.mint,
        symbol: trade.symbol,
        entryPrice: trade.entryPrice,
        exitPrice: trade.exitPrice,
        amount: trade.amount,
        amountSol: trade.amountSol,
        entryTime: trade.entryTime,
        exitTime: trade.exitTime,
        pnlSol: trade.pnlSol?.toFixed(6),
        pnlPercent: trade.pnlPercent?.toFixed(2),
        duration: trade.duration,
        exitReason: trade.exitReason,
        isOpen: !trade.exitTime,
      }));

      res.json(formattedTrades);
    } catch (error) {
      logger.error({ error }, 'Failed to get trades');
      res.status(500).json({ error: 'Failed to get trades' });
    }
  });

  // Get open positions
  app.get('/api/positions', async (req: Request, res: Response) => {
    try {
      const positions = positionManager.getOpenPositions();

      const formattedPositions = positions.map((p) => ({
        id: p.id,
        mint: p.mint,
        symbol: p.symbol,
        amount: p.amount,
        amountSol: p.amountSol,
        entryPrice: p.entryPrice,
        currentPrice: p.currentPrice,
        highestPrice: p.highestPrice,
        unrealizedPnl: p.unrealizedPnl.toFixed(6),
        unrealizedPnlPercent: p.unrealizedPnlPercent.toFixed(2),
        stopLoss: p.stopLoss,
        takeProfit: p.takeProfit,
        tpSold: p.tpSold,
        trailingStop: p.trailingStop,
        status: p.status,
        poolType: p.poolType,
        entryTime: p.entryTime,
        lastUpdate: p.lastUpdate,
        holdTime: Date.now() - p.entryTime.getTime(),
      }));

      const totalUnrealizedPnl = positions.reduce((sum, p) => sum + p.unrealizedPnl, 0);
      const totalExposure = positionManager.getTotalExposure();

      res.json({
        positions: formattedPositions,
        totalUnrealizedPnl: totalUnrealizedPnl.toFixed(6),
        totalExposure: totalExposure.toFixed(4),
        positionCount: positions.length,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get positions');
      res.status(500).json({ error: 'Failed to get positions' });
    }
  });

  // Get detailed performance metrics
  app.get('/api/performance', async (req: Request, res: Response) => {
    try {
      const timeframePerformance = await performanceAnalytics.getTimeframePerformance();

      res.json({
        hourly: formatMetrics(timeframePerformance.hourly),
        daily: formatMetrics(timeframePerformance.daily),
        weekly: formatMetrics(timeframePerformance.weekly),
        monthly: formatMetrics(timeframePerformance.monthly),
        allTime: formatMetrics(timeframePerformance.allTime),
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get performance');
      res.status(500).json({ error: 'Failed to get performance' });
    }
  });

  // Get active trades (currently being monitored but not yet closed)
  app.get('/api/active-trades', (req: Request, res: Response) => {
    try {
      const activeTrades = tradeLogger.getActiveTrades();
      res.json(activeTrades);
    } catch (error) {
      logger.error({ error }, 'Failed to get active trades');
      res.status(500).json({ error: 'Failed to get active trades' });
    }
  });

  // NEW: Get AI decision history for debugging
  app.get('/api/debug/ai-decisions', (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const decisions = aiDecisionHistory.slice(0, limit);

      res.json({
        decisions,
        totalDecisions: aiDecisionHistory.length,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get AI decisions');
      res.status(500).json({ error: 'Failed to get AI decisions' });
    }
  });

  // NEW: Get rejection statistics
  app.get('/api/debug/rejection-stats', (req: Request, res: Response) => {
    try {
      const passRate = rejectionStats.passed > 0 || rejectionStats.total > 0
        ? (rejectionStats.passed / (rejectionStats.total + rejectionStats.passed)) * 100
        : 0;

      res.json({
        ...rejectionStats,
        passRate: passRate.toFixed(1) + '%',
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get rejection stats');
      res.status(500).json({ error: 'Failed to get rejection stats' });
    }
  });

  // NEW: Get watchlist status with detailed features
  app.get('/api/debug/watchlist', (req: Request, res: Response) => {
    try {
      const tokens = tokenWatchlist.getAllTokens();
      const watchlistData = tokens.map(mint => {
        const token = tokenWatchlist.getToken(mint);
        const features = tokenWatchlist.extractFeatures(mint);
        const momentumSignal = tokenWatchlist.getMomentumSignal(mint);
        const dynamicThreshold = tokenWatchlist.getDynamicConfidenceThreshold(mint);
        const filterResult = tokenWatchlist.passesHardFilters(mint);

        return {
          mint: mint.substring(0, 15) + '...',
          fullMint: mint,
          ageSeconds: token ? (Date.now() - token.firstSeen) / 1000 : 0,
          dataPoints: token?.priceHistory.length || 0,
          tradeCount: token?.trades.length || 0,
          devSoldPercent: token?.devSoldPercent || 0,
          devSold: token?.devSold || false,
          passesFilters: filterResult.passes,
          filterReason: filterResult.reason,
          dynamicThreshold: dynamicThreshold.toFixed(2),
          features: features ? {
            priceChange: (features.priceChange * 100).toFixed(2) + '%',
            buyPressure: (features.buyPressure * 100).toFixed(0) + '%',
            volumeAcceleration: features.volumeAcceleration.toFixed(2) + 'x',
            uniqueTraderGrowth: features.uniqueTraderGrowth,
            hasMomentum: features.hasMomentum,
            drawdown: (features.drawdown * 100).toFixed(1) + '%',
          } : null,
          momentum: momentumSignal,
        };
      });

      const stats = tokenWatchlist.getStats();

      res.json({
        stats,
        tokens: watchlistData,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get watchlist');
      res.status(500).json({ error: 'Failed to get watchlist' });
    }
  });

  // NEW: Get DDQN model stats
  app.get('/api/debug/model-stats', (req: Request, res: Response) => {
    try {
      const regime = regimeDetector.getCurrentRegime();
      const winRate = positionSizer.getWinRate();
      const epsilon = ddqnAgent.getEpsilon ? ddqnAgent.getEpsilon() : 'N/A';

      res.json({
        regime: regime.regime,
        regimeName: regimeDetector.getRegimeName(),
        regimeConfidence: regime.confidence,
        winRate: (winRate * 100).toFixed(1) + '%',
        epsilon,
        configThresholds: {
          minConfidence: config.watchlist?.minConfidence,
          maxConfidence: config.watchlist?.maxConfidence,
          minAgeSeconds: config.watchlist?.minAgeSeconds,
          maxDrawdown: config.watchlist?.maxDrawdown,
        },
        momentumConfig: config.momentumOverride,
        devSoldConfig: config.devSoldConfig,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get model stats');
      res.status(500).json({ error: 'Failed to get model stats' });
    }
  });

  // NEW: Get confidence analysis for winning vs losing trades
  app.get('/api/debug/confidence-analysis', async (req: Request, res: Response) => {
    try {
      const trades = await tradeLogger.getRecentTrades(100);
      const completedTrades = trades.filter(t => t.exitTime);

      const winners = completedTrades.filter(t => (t.pnlSol || 0) > 0);
      const losers = completedTrades.filter(t => (t.pnlSol || 0) <= 0);

      // Calculate average confidence for winners vs losers
      // Note: We'd need to store confidence with trades to do this properly
      // For now, return trade counts

      res.json({
        totalTrades: completedTrades.length,
        winners: winners.length,
        losers: losers.length,
        winRate: completedTrades.length > 0
          ? ((winners.length / completedTrades.length) * 100).toFixed(1) + '%'
          : 'N/A',
        avgWinPnl: winners.length > 0
          ? (winners.reduce((sum, t) => sum + (t.pnlPercent || 0), 0) / winners.length).toFixed(2) + '%'
          : 'N/A',
        avgLossPnl: losers.length > 0
          ? (losers.reduce((sum, t) => sum + (t.pnlPercent || 0), 0) / losers.length).toFixed(2) + '%'
          : 'N/A',
        recentDecisions: aiDecisionHistory.slice(0, 10).map(d => ({
          mint: d.mint.substring(0, 12),
          action: d.action,
          confidence: d.confidence.toFixed(2),
          requiredConfidence: d.requiredConfidence.toFixed(2),
          hasMomentum: d.hasMomentum,
          outcome: d.outcome,
        })),
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get confidence analysis');
      res.status(500).json({ error: 'Failed to get confidence analysis' });
    }
  });

  // NEW: Get actual wallet balance and equity
  app.get('/api/wallet', async (req: Request, res: Response) => {
    try {
      const walletState = walletSync.getState();
      const latestEquity = equityTracker.getLatestSnapshot();
      const equityChange = equityTracker.getEquityChange(24);

      res.json({
        solBalance: walletState?.solBalance || 0,
        lastSync: walletState?.lastSync || null,
        isHealthy: walletSync.isHealthy(),
        equity: latestEquity ? {
          total: latestEquity.totalEquitySol,
          walletBalance: latestEquity.walletBalanceSol,
          positionsValue: latestEquity.positionsValueSol,
          unrealizedPnl: latestEquity.unrealizedPnlSol,
          positionCount: latestEquity.positionCount,
          timestamp: latestEquity.timestamp,
        } : null,
        change24h: equityChange,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get wallet info');
      res.status(500).json({ error: 'Failed to get wallet info' });
    }
  });

  // NEW: Get equity history for chart
  app.get('/api/equity-history', async (req: Request, res: Response) => {
    try {
      const hours = parseInt(req.query.hours as string) || 24;
      const history = await equityTracker.getEquityHistory(hours);

      res.json({
        history: history.map(s => ({
          timestamp: s.timestamp,
          totalEquity: s.totalEquitySol,
          walletBalance: s.walletBalanceSol,
          positionsValue: s.positionsValueSol,
          unrealizedPnl: s.unrealizedPnlSol,
          positionCount: s.positionCount,
        })),
        count: history.length,
        hours,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get equity history');
      res.status(500).json({ error: 'Failed to get equity history' });
    }
  });

  // NEW: Trigger manual reconciliation
  app.post('/api/reconcile', async (req: Request, res: Response) => {
    try {
      const autoClose = req.body?.autoClose !== false; // Default true
      const result = await positionReconciler.reconcile(autoClose);

      res.json({
        success: true,
        phantomsFound: result.phantomsFound.length,
        phantomsClosed: result.phantomsClosed,
        orphansFound: result.orphansFound.length,
        details: {
          phantoms: result.phantomsFound.map(p => ({
            positionId: p.positionId,
            mint: p.mint.substring(0, 15) + '...',
            symbol: p.symbol,
            expectedAmount: p.expectedAmount,
            actualAmount: p.actualAmount,
            amountSol: p.amountSol,
          })),
          orphans: result.orphansFound,
        },
        reconciliationTime: result.reconciliationTime,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to reconcile positions');
      res.status(500).json({ error: 'Failed to reconcile positions' });
    }
  });

  // NEW: Get positions with real-time unrealized PnL
  app.get('/api/positions/realtime', async (req: Request, res: Response) => {
    try {
      const positions = positionManager.getOpenPositions();

      const formattedPositions = positions.map((p) => {
        const currentValue = p.amount * p.currentPrice;
        const entryValue = p.amountSol;
        const unrealizedPnl = currentValue - entryValue;
        const totalPnl = (p.realizedPnl || 0) + unrealizedPnl;

        return {
          id: p.id,
          mint: p.mint,
          symbol: p.symbol,
          amount: p.amount,
          amountSol: p.amountSol,
          entryPrice: p.entryPrice,
          currentPrice: p.currentPrice,
          highestPrice: p.highestPrice,
          currentValue,
          unrealizedPnl: unrealizedPnl.toFixed(6),
          unrealizedPnlPercent: ((unrealizedPnl / entryValue) * 100).toFixed(2),
          realizedPnl: (p.realizedPnl || 0).toFixed(6),
          totalPnl: totalPnl.toFixed(6),
          totalPnlPercent: ((totalPnl / entryValue) * 100).toFixed(2),
          stopLoss: p.stopLoss,
          trailingStop: p.trailingStop,
          initialRecovered: p.initialRecovered,
          scaledExitsTaken: p.scaledExitsTaken,
          status: p.status,
          poolType: p.poolType,
          entryTime: p.entryTime,
          lastUpdate: p.lastUpdate,
          holdTimeMs: Date.now() - p.entryTime.getTime(),
        };
      });

      const totalUnrealizedPnl = positions.reduce((sum, p) => {
        const currentValue = p.amount * p.currentPrice;
        return sum + (currentValue - p.amountSol);
      }, 0);

      const totalRealizedPnl = positions.reduce((sum, p) => sum + (p.realizedPnl || 0), 0);
      const totalExposure = positionManager.getTotalExposure();

      res.json({
        positions: formattedPositions,
        summary: {
          totalUnrealizedPnl: totalUnrealizedPnl.toFixed(6),
          totalRealizedPnl: totalRealizedPnl.toFixed(6),
          totalPnl: (totalUnrealizedPnl + totalRealizedPnl).toFixed(6),
          totalExposure: totalExposure.toFixed(4),
          positionCount: positions.length,
        },
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get realtime positions');
      res.status(500).json({ error: 'Failed to get realtime positions' });
    }
  });

  // Manual test buy endpoint
  app.post('/api/test/buy', async (req: Request, res: Response) => {
    try {
      const { mint, amountSol = 0.01 } = req.body;

      if (!mint) {
        return res.status(400).json({ error: 'mint is required' });
      }

      logger.info({ mint, amountSol }, 'Manual test buy requested');

      // Execute the buy
      const result = await txManager.executeBuy(mint, amountSol, {
        slippageBps: config.defaultSlippageBps,
        maxRetries: 3,
      });

      if (!result.success) {
        return res.status(400).json({
          success: false,
          error: result.error,
          mint,
          amountSol,
        });
      }

      // Wait for tx to settle and check balance
      await new Promise(resolve => setTimeout(resolve, 2000));
      const actualBalance = await txManager.getTokenBalance(mint);

      // Create position if we got tokens
      if (actualBalance > 0) {
        const entryPrice = amountSol / actualBalance;
        const position = await positionManager.openPosition({
          mint,
          symbol: mint.slice(0, 8),
          entryPrice,
          amount: actualBalance,
          amountSol,
          poolType: 'active',
        });

        await tradeLogger.logEntry({
          positionId: position.id,
          mint,
          symbol: mint.slice(0, 8),
          entryPrice,
          amount: actualBalance,
          amountSol,
          features: {} as any,
          regime: 0,
          pumpPhase: 'cold',
        });

        return res.json({
          success: true,
          positionId: position.id,
          mint,
          amountSol,
          tokensReceived: actualBalance,
          entryPrice,
          signature: result.signature,
        });
      } else {
        return res.json({
          success: false,
          error: 'Buy tx succeeded but no tokens received',
          mint,
          amountSol,
          signature: result.signature,
          actualBalance,
        });
      }
    } catch (error: any) {
      logger.error({ error }, 'Manual test buy failed');
      res.status(500).json({ error: error.message });
    }
  });

  // =====================
  // C100 Routes
  // =====================

  // Get C100 status - token info + claim/buyback totals
  app.get('/api/c100/status', async (req: Request, res: Response) => {
    try {
      const tokenData = c100Tracker.getTokenData();
      const claimStats = rewardClaimer.getStats();
      const buybackStats = c100Buyback.getStats();

      res.json({
        enabled: c100Tracker.isEnabled(),
        token: tokenData ? {
          mint: tokenData.mint,
          name: tokenData.name,
          symbol: tokenData.symbol,
          priceSol: tokenData.priceSol,
          priceUsd: tokenData.priceUsd,
          marketCapUsd: tokenData.marketCapUsd,
          volume24h: tokenData.volume24h,
          priceChange24h: tokenData.priceChange24h,
          lastUpdated: tokenData.lastUpdated,
        } : null,
        claims: {
          totalClaimedSol: claimStats.totalClaimedSol,
          claimCount: claimStats.claimCount,
          lastClaimTime: claimStats.lastClaimTime,
          sources: claimStats.sources,
        },
        buybacks: {
          totalBuybackSol: buybackStats.totalBuybackSol,
          totalTokensBought: buybackStats.totalTokensBought,
          buybackCount: buybackStats.buybackCount,
          lastBuybackTime: buybackStats.lastBuybackTime,
          avgPriceSol: buybackStats.avgPriceSol,
        },
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get C100 status');
      res.status(500).json({ error: 'Failed to get C100 status' });
    }
  });

  // Get recent claim transactions
  app.get('/api/c100/claims', async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const claims = await repository.getRecentC100Claims(limit);

      res.json({
        claims: claims.map(c => ({
          id: c.id,
          source: c.source,
          amountSol: parseFloat(c.amount_sol.toString()),
          signature: c.signature,
          status: c.status,
          timestamp: c.timestamp,
        })),
        count: claims.length,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get C100 claims');
      res.status(500).json({ error: 'Failed to get C100 claims' });
    }
  });

  // Get recent buyback transactions
  app.get('/api/c100/buybacks', async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const buybacks = await repository.getRecentC100Buybacks(limit);

      res.json({
        buybacks: buybacks.map(b => ({
          id: b.id,
          amountSol: parseFloat(b.amount_sol.toString()),
          amountTokens: b.amount_tokens ? parseFloat(b.amount_tokens.toString()) : null,
          priceSol: b.price_sol ? parseFloat(b.price_sol.toString()) : null,
          source: b.source,
          signature: b.signature,
          status: b.status,
          timestamp: b.timestamp,
        })),
        count: buybacks.length,
      });
    } catch (error) {
      logger.error({ error }, 'Failed to get C100 buybacks');
      res.status(500).json({ error: 'Failed to get C100 buybacks' });
    }
  });

  // Manual claim trigger (for testing)
  app.post('/api/c100/claim', async (req: Request, res: Response) => {
    try {
      logger.info('Manual claim triggered');
      const results = await rewardClaimer.claimAllRewards();

      const totalClaimed = results.reduce((sum, r) => sum + (r.success ? r.amountSol : 0), 0);

      res.json({
        success: true,
        totalClaimed,
        results,
      });
    } catch (error: any) {
      logger.error({ error }, 'Manual claim failed');
      res.status(500).json({ error: error.message });
    }
  });

  // Manual buyback trigger (for testing)
  app.post('/api/c100/buyback', async (req: Request, res: Response) => {
    try {
      const { amountSol = 0.01 } = req.body;

      logger.info({ amountSol }, 'Manual buyback triggered');
      const result = await c100Buyback.executeBuyback(amountSol, 'manual');

      res.json(result);
    } catch (error: any) {
      logger.error({ error }, 'Manual buyback failed');
      res.status(500).json({ error: error.message });
    }
  });

  logger.info('API routes configured');
}

function formatMetrics(metrics: any): any {
  return {
    totalTrades: metrics.totalTrades,
    winningTrades: metrics.winningTrades,
    losingTrades: metrics.losingTrades,
    winRate: (metrics.winRate * 100).toFixed(1),
    totalPnl: metrics.totalPnl.toFixed(4),
    profitFactor: metrics.profitFactor.toFixed(2),
    sharpeRatio: metrics.sharpeRatio.toFixed(2),
    maxDrawdown: (metrics.maxDrawdown * 100).toFixed(1),
    avgWin: metrics.avgWin.toFixed(4),
    avgLoss: metrics.avgLoss.toFixed(4),
  };
}
</file>

<file path="src/db/schema.ts">
import { Pool } from 'pg';
import { createChildLogger } from '../utils/logger';

const logger = createChildLogger('db-schema');

export const createTables = async (pool: Pool): Promise<void> => {
  logger.info('Creating database tables...');

  await pool.query(`
    CREATE TABLE IF NOT EXISTS tokens (
      mint VARCHAR(64) PRIMARY KEY,
      name VARCHAR(255),
      symbol VARCHAR(32),
      decimals INTEGER,
      created_at TIMESTAMP DEFAULT NOW(),
      creator VARCHAR(64),
      mint_revoked BOOLEAN DEFAULT FALSE,
      freeze_revoked BOOLEAN DEFAULT FALSE,
      image_url VARCHAR(512),
      last_updated TIMESTAMP DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS price_history (
      id SERIAL PRIMARY KEY,
      mint VARCHAR(64) NOT NULL,
      price_sol DECIMAL(20, 10),
      price_usd DECIMAL(20, 10),
      volume_24h DECIMAL(20, 2),
      market_cap_sol DECIMAL(20, 2),
      liquidity DECIMAL(20, 2),
      timestamp TIMESTAMP DEFAULT NOW(),
      FOREIGN KEY (mint) REFERENCES tokens(mint) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_price_history_mint_time
      ON price_history(mint, timestamp DESC);

    CREATE TABLE IF NOT EXISTS trades (
      id VARCHAR(64) PRIMARY KEY,
      mint VARCHAR(64) NOT NULL,
      symbol VARCHAR(32),
      action INTEGER NOT NULL,
      entry_price DECIMAL(20, 10) NOT NULL,
      exit_price DECIMAL(20, 10),
      amount DECIMAL(20, 10) NOT NULL,
      amount_sol DECIMAL(20, 10) NOT NULL,
      entry_time TIMESTAMP NOT NULL,
      exit_time TIMESTAMP,
      pnl_sol DECIMAL(20, 10),
      pnl_percent DECIMAL(10, 4),
      duration_ms BIGINT,
      features_json TEXT,
      regime INTEGER,
      pump_phase VARCHAR(20),
      exit_reason VARCHAR(32),
      slippage DECIMAL(10, 6),
      fees DECIMAL(20, 10)
    );

    CREATE INDEX IF NOT EXISTS idx_trades_mint ON trades(mint);
    CREATE INDEX IF NOT EXISTS idx_trades_entry_time ON trades(entry_time DESC);

    CREATE TABLE IF NOT EXISTS positions (
      id VARCHAR(64) PRIMARY KEY,
      mint VARCHAR(64) NOT NULL,
      symbol VARCHAR(32),
      entry_price DECIMAL(20, 10) NOT NULL,
      current_price DECIMAL(20, 10) NOT NULL,
      amount DECIMAL(20, 10) NOT NULL,
      amount_sol DECIMAL(20, 10) NOT NULL,
      entry_time TIMESTAMP NOT NULL,
      last_update TIMESTAMP DEFAULT NOW(),
      highest_price DECIMAL(20, 10) NOT NULL,
      lowest_price DECIMAL(20, 10) NOT NULL,
      stop_loss DECIMAL(20, 10) NOT NULL,
      take_profit_json TEXT,
      tp_sold_json TEXT,
      trailing_stop DECIMAL(20, 10),
      status VARCHAR(16) DEFAULT 'open',
      pool_type VARCHAR(16) DEFAULT 'active'
    );

    CREATE INDEX IF NOT EXISTS idx_positions_status ON positions(status);

    CREATE TABLE IF NOT EXISTS model_weights (
      id SERIAL PRIMARY KEY,
      version INTEGER NOT NULL,
      weights_json TEXT NOT NULL,
      metrics_json TEXT,
      created_at TIMESTAMP DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS config (
      key VARCHAR(64) PRIMARY KEY,
      value TEXT NOT NULL,
      updated_at TIMESTAMP DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS whale_wallets (
      address VARCHAR(64) PRIMARY KEY,
      label VARCHAR(255),
      total_volume DECIMAL(20, 2) DEFAULT 0,
      win_rate DECIMAL(5, 4) DEFAULT 0,
      last_active TIMESTAMP,
      created_at TIMESTAMP DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS whale_activity (
      id SERIAL PRIMARY KEY,
      wallet VARCHAR(64) NOT NULL,
      action VARCHAR(16) NOT NULL,
      mint VARCHAR(64) NOT NULL,
      amount DECIMAL(20, 10) NOT NULL,
      amount_sol DECIMAL(20, 10) NOT NULL,
      signature VARCHAR(128),
      timestamp TIMESTAMP DEFAULT NOW(),
      FOREIGN KEY (wallet) REFERENCES whale_wallets(address) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_whale_activity_time
      ON whale_activity(timestamp DESC);

    CREATE TABLE IF NOT EXISTS daily_stats (
      date DATE PRIMARY KEY,
      starting_equity DECIMAL(20, 10),
      ending_equity DECIMAL(20, 10),
      pnl DECIMAL(20, 10),
      pnl_percent DECIMAL(10, 4),
      trades_count INTEGER DEFAULT 0,
      winning_trades INTEGER DEFAULT 0,
      losing_trades INTEGER DEFAULT 0,
      max_drawdown DECIMAL(10, 4),
      created_at TIMESTAMP DEFAULT NOW()
    );

    -- Equity snapshots for historical chart
    CREATE TABLE IF NOT EXISTS equity_snapshots (
      id SERIAL PRIMARY KEY,
      timestamp TIMESTAMP DEFAULT NOW(),
      wallet_balance_sol DECIMAL(20, 10),
      positions_value_sol DECIMAL(20, 10),
      total_equity_sol DECIMAL(20, 10),
      unrealized_pnl_sol DECIMAL(20, 10),
      position_count INTEGER,
      source VARCHAR(16)
    );

    CREATE INDEX IF NOT EXISTS idx_equity_snapshots_time
      ON equity_snapshots(timestamp DESC);

    -- Partial close records for accurate PnL tracking
    CREATE TABLE IF NOT EXISTS partial_closes (
      id SERIAL PRIMARY KEY,
      position_id VARCHAR(64),
      mint VARCHAR(64),
      close_type VARCHAR(32),
      sell_amount_tokens DECIMAL(20, 10),
      sell_amount_sol DECIMAL(20, 10),
      price_at_close DECIMAL(20, 10),
      pnl_sol DECIMAL(20, 10),
      fees_sol DECIMAL(20, 10),
      timestamp TIMESTAMP DEFAULT NOW()
    );

    CREATE INDEX IF NOT EXISTS idx_partial_closes_position
      ON partial_closes(position_id);

    -- Wallet sync audit log
    CREATE TABLE IF NOT EXISTS wallet_sync_log (
      id SERIAL PRIMARY KEY,
      timestamp TIMESTAMP DEFAULT NOW(),
      sol_balance DECIMAL(20, 10),
      token_positions_json TEXT,
      discrepancies_json TEXT
    );

    CREATE INDEX IF NOT EXISTS idx_wallet_sync_time
      ON wallet_sync_log(timestamp DESC);

    -- C100 claim tracking
    CREATE TABLE IF NOT EXISTS c100_claims (
      id SERIAL PRIMARY KEY,
      source VARCHAR(32) NOT NULL,
      amount_sol DECIMAL(20, 10) NOT NULL,
      signature VARCHAR(128),
      status VARCHAR(16) DEFAULT 'success',
      timestamp TIMESTAMP DEFAULT NOW()
    );

    CREATE INDEX IF NOT EXISTS idx_c100_claims_time
      ON c100_claims(timestamp DESC);

    -- C100 buyback tracking
    CREATE TABLE IF NOT EXISTS c100_buybacks (
      id SERIAL PRIMARY KEY,
      amount_sol DECIMAL(20, 10) NOT NULL,
      amount_tokens DECIMAL(20, 10),
      price_sol DECIMAL(20, 15),
      source VARCHAR(32) NOT NULL,
      signature VARCHAR(128),
      status VARCHAR(16) DEFAULT 'success',
      timestamp TIMESTAMP DEFAULT NOW()
    );

    CREATE INDEX IF NOT EXISTS idx_c100_buybacks_time
      ON c100_buybacks(timestamp DESC);
  `);

  // Migration: Add image_url column if it doesn't exist
  await pool.query(`
    ALTER TABLE tokens ADD COLUMN IF NOT EXISTS image_url VARCHAR(512);
  `).catch(() => {
    // Column already exists or table doesn't exist yet
  });

  logger.info('Database tables created successfully');
};

export const dropTables = async (pool: Pool): Promise<void> => {
  logger.warn('Dropping all tables...');
  await pool.query(`
    DROP TABLE IF EXISTS wallet_sync_log CASCADE;
    DROP TABLE IF EXISTS partial_closes CASCADE;
    DROP TABLE IF EXISTS equity_snapshots CASCADE;
    DROP TABLE IF EXISTS whale_activity CASCADE;
    DROP TABLE IF EXISTS whale_wallets CASCADE;
    DROP TABLE IF EXISTS price_history CASCADE;
    DROP TABLE IF EXISTS trades CASCADE;
    DROP TABLE IF EXISTS positions CASCADE;
    DROP TABLE IF EXISTS model_weights CASCADE;
    DROP TABLE IF EXISTS config CASCADE;
    DROP TABLE IF EXISTS daily_stats CASCADE;
    DROP TABLE IF EXISTS tokens CASCADE;
  `);
  logger.info('All tables dropped');
};
</file>

<file path="src/execution/tx-manager.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config } from '../config/settings';
import { jupiterSwap } from './jupiter-swap';
import { pumpFunSwap } from './pumpfun-swap';
import { jitoBundle } from './jito-bundle';
import { SwapResult, PendingTransaction, ExecutionMetrics } from './types';

const logger = createChildLogger('tx-manager');

// Track which tokens are on bonding curve vs graduated
const bondingCurveTokens: Set<string> = new Set();

export class TransactionManager extends EventEmitter {
  private pendingTxs: Map<string, PendingTransaction> = new Map();
  private metrics: ExecutionMetrics = {
    totalTransactions: 0,
    successRate: 0,
    avgSlippage: 0,
    avgConfirmationTime: 0,
    totalFeesPaid: 0,
    jitoSuccessRate: 0,
  };
  private successCount = 0;
  private jitoSuccessCount = 0;
  private jitoAttemptCount = 0;
  private slippageSum = 0;
  private confirmationTimeSum = 0;

  constructor() {
    super();
  }

  async initialize(): Promise<void> {
    jupiterSwap.initialize();
    pumpFunSwap.initialize();
    await jitoBundle.initialize();
    logger.info('Transaction manager initialized');
  }

  // Mark a token as being on bonding curve (not graduated yet)
  markAsBondingCurve(mint: string): void {
    bondingCurveTokens.add(mint);
  }

  // Mark a token as graduated (now on Raydium)
  markAsGraduated(mint: string): void {
    bondingCurveTokens.delete(mint);
  }

  // Check if token is on bonding curve
  isOnBondingCurve(mint: string): boolean {
    // If we've explicitly tracked it, use that
    if (bondingCurveTokens.has(mint)) return true;

    // Default: assume pump.fun tokens ending in "pump" are on bonding curve
    // unless we know they've graduated
    return mint.endsWith('pump');
  }

  async executeBuy(
    mint: string,
    amountSol: number,
    options: {
      slippageBps?: number;
      useJito?: boolean;
      maxRetries?: number;
    } = {}
  ): Promise<SwapResult> {
    const {
      slippageBps = 100,
      useJito = config.enableJito && amountSol > 0.1,
      maxRetries = 3,
    } = options;

    const txId = `buy_${mint}_${Date.now()}`;

    const pendingTx: PendingTransaction = {
      id: txId,
      type: 'buy',
      mint,
      inputAmount: amountSol,
      expectedOutput: 0, // Will be set after quote
      status: 'pending',
      retries: 0,
      createdAt: new Date(),
    };

    this.pendingTxs.set(txId, pendingTx);
    this.emit('txPending', pendingTx);

    let result: SwapResult;
    let lastError: string | undefined;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const startTime = Date.now();

        // Route to appropriate exchange
        const useBondingCurve = this.isOnBondingCurve(mint);
        if (useBondingCurve) {
          logger.info({ mint, amountSol }, 'Routing buy to PumpFun (bonding curve)');
          result = await pumpFunSwap.buy(mint, amountSol, slippageBps / 100); // Convert bps to %
        } else {
          logger.info({ mint, amountSol }, 'Routing buy to Jupiter (graduated)');
          result = await jupiterSwap.buy(mint, amountSol, slippageBps);
        }

        if (result.success) {
          pendingTx.status = 'confirmed';
          pendingTx.signature = result.signature;
          pendingTx.confirmedAt = new Date();

          this.updateMetrics(result, Date.now() - startTime, false);
          this.emit('txConfirmed', { ...pendingTx, result });

          logger.info({
            txId,
            mint,
            amountSol,
            outputAmount: result.outputAmount,
            signature: result.signature,
          }, 'Buy executed');

          return result;
        }

        lastError = result.error;
        pendingTx.retries++;

        logger.warn({
          txId,
          attempt: attempt + 1,
          error: lastError,
        }, 'Buy attempt failed, retrying');

        // Wait before retry
        await this.sleep(1000 * Math.pow(2, attempt));
      } catch (error: any) {
        lastError = error.message;
        pendingTx.retries++;
      }
    }

    pendingTx.status = 'failed';
    pendingTx.error = lastError;
    this.emit('txFailed', pendingTx);

    return {
      success: false,
      inputAmount: amountSol,
      outputAmount: 0,
      priceImpact: 0,
      fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
      error: lastError,
      timestamp: new Date(),
    };
  }

  async executeSell(
    mint: string,
    amountTokens: number,
    decimals: number,
    options: {
      slippageBps?: number;
      useJito?: boolean;
      maxRetries?: number;
      skipBalanceCheck?: boolean;  // Trust position amount when RPC is unreliable
    } = {}
  ): Promise<SwapResult> {
    const {
      slippageBps = config.defaultSlippageBps,  // Use config default (15%) for volatile tokens
      useJito = config.enableJito,
      maxRetries = 3,
      skipBalanceCheck = false,
    } = options;

    // Verify actual token balance before selling (with retry)
    let actualBalance = 0;
    let balanceCheckFailed = false;

    if (!skipBalanceCheck) {
      // Try balance check with retries
      for (let i = 0; i < 3; i++) {
        actualBalance = await this.getTokenBalance(mint);
        if (actualBalance > 0) break;

        // Wait and retry - RPC might be slow
        if (i < 2) {
          logger.debug({ mint, attempt: i + 1 }, 'Balance check returned 0, retrying...');
          await this.sleep(1000 * (i + 1));
        }
      }

      if (actualBalance === 0) {
        balanceCheckFailed = true;
        logger.warn({ mint, requestedAmount: amountTokens },
          'Balance check returned 0 after retries - proceeding with tracked amount');
      }
    }

    if (!skipBalanceCheck && !balanceCheckFailed && actualBalance < amountTokens * 0.99) {  // 1% tolerance
      logger.warn({ mint, requested: amountTokens, actual: actualBalance },
        'Insufficient token balance - adjusting sell amount');

      if (actualBalance > 0) {
        // Sell what we actually have
        amountTokens = actualBalance;
      }
      // If actualBalance is 0 but balanceCheckFailed is true, we proceed with tracked amount
    }

    // If balance check completely failed, proceed anyway with tracked amount
    // The swap API will fail if we truly have no tokens, but at least we try
    if (balanceCheckFailed || skipBalanceCheck) {
      logger.info({ mint, amountTokens, balanceCheckFailed, skipBalanceCheck },
        'Proceeding with sell using tracked position amount');
    }

    const txId = `sell_${mint}_${Date.now()}`;

    const pendingTx: PendingTransaction = {
      id: txId,
      type: 'sell',
      mint,
      inputAmount: amountTokens,
      expectedOutput: 0,
      status: 'pending',
      retries: 0,
      createdAt: new Date(),
    };

    this.pendingTxs.set(txId, pendingTx);
    this.emit('txPending', pendingTx);

    let result: SwapResult;
    let lastError: string | undefined;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const startTime = Date.now();

        // Route to appropriate exchange
        // For sells, use 'auto' pool in PumpPortal which handles both
        const useBondingCurve = this.isOnBondingCurve(mint);
        if (useBondingCurve) {
          logger.info({ mint, amountTokens }, 'Routing sell to PumpFun (auto-detect pool)');
          result = await pumpFunSwap.sell(mint, amountTokens, slippageBps / 100);
        } else {
          logger.info({ mint, amountTokens }, 'Routing sell to Jupiter (graduated)');
          result = await jupiterSwap.sell(mint, amountTokens, decimals, slippageBps);
        }

        if (result.success) {
          pendingTx.status = 'confirmed';
          pendingTx.signature = result.signature;
          pendingTx.confirmedAt = new Date();

          this.updateMetrics(result, Date.now() - startTime, false);
          this.emit('txConfirmed', { ...pendingTx, result });

          logger.info({
            txId,
            mint,
            amountTokens,
            outputSol: result.outputAmount,
            signature: result.signature,
          }, 'Sell executed');

          return result;
        }

        lastError = result.error;
        pendingTx.retries++;

        logger.warn({
          txId,
          attempt: attempt + 1,
          error: lastError,
        }, 'Sell attempt failed, retrying');

        await this.sleep(1000 * Math.pow(2, attempt));
      } catch (error: any) {
        lastError = error.message;
        pendingTx.retries++;
      }
    }

    pendingTx.status = 'failed';
    pendingTx.error = lastError;
    this.emit('txFailed', pendingTx);

    return {
      success: false,
      inputAmount: amountTokens,
      outputAmount: 0,
      priceImpact: 0,
      fees: { platformFee: 0, networkFee: 0, priorityFee: 0, totalFee: 0 },
      error: lastError,
      timestamp: new Date(),
    };
  }

  private updateMetrics(result: SwapResult, confirmationTime: number, usedJito: boolean): void {
    this.metrics.totalTransactions++;

    if (result.success) {
      this.successCount++;
      this.slippageSum += result.priceImpact;
      this.confirmationTimeSum += confirmationTime;
      this.metrics.totalFeesPaid += result.fees.totalFee;
    }

    if (usedJito) {
      this.jitoAttemptCount++;
      if (result.success) {
        this.jitoSuccessCount++;
      }
    }

    // Update rates
    this.metrics.successRate = this.successCount / this.metrics.totalTransactions;
    this.metrics.avgSlippage = this.successCount > 0 ? this.slippageSum / this.successCount : 0;
    this.metrics.avgConfirmationTime = this.successCount > 0
      ? this.confirmationTimeSum / this.successCount
      : 0;
    this.metrics.jitoSuccessRate = this.jitoAttemptCount > 0
      ? this.jitoSuccessCount / this.jitoAttemptCount
      : 0;
  }

  getPendingTransactions(): PendingTransaction[] {
    return Array.from(this.pendingTxs.values()).filter((tx) => tx.status === 'pending');
  }

  getMetrics(): ExecutionMetrics {
    return { ...this.metrics };
  }

  async getWalletBalance(): Promise<number> {
    return jupiterSwap.getBalance();
  }

  async getTokenBalance(mint: string): Promise<number> {
    return jupiterSwap.getTokenBalance(mint);
  }

  getWalletAddress(): string | null {
    return jupiterSwap.getWalletAddress();
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  cleanupOldTransactions(maxAge: number = 3600000): void {
    const cutoff = Date.now() - maxAge;

    for (const [id, tx] of this.pendingTxs.entries()) {
      if (tx.createdAt.getTime() < cutoff && tx.status !== 'pending') {
        this.pendingTxs.delete(id);
      }
    }
  }
}

export const txManager = new TransactionManager();
</file>

<file path="src/signals/entry-evaluator.ts">
import { createChildLogger } from '../utils/logger';
import { pumpDetector } from './pump-detector';
import { velocityTracker } from './velocity-tracker';
import { priceFeed } from '../data/price-feed';
import { tokenWatchlist } from './token-watchlist';
import { EntryResult, PumpMetrics } from './types';
import { config } from '../config/settings';

const logger = createChildLogger('entry-evaluator');

export class EntryEvaluator {
  constructor() {}

  /**
   * Unified entry evaluation:
   * - If token has price history â†’ use pump detector
   * - If new token â†’ check velocity tracker
   */
  evaluate(mint: string, marketCapSol?: number): EntryResult {
    // Check if we have price history for pump analysis
    const priceHistory = priceFeed.getPriceHistory(mint, 300);
    const hasPriceHistory = priceHistory.length >= 10;

    logger.debug({
      mint: mint.substring(0, 12),
      priceHistoryLen: priceHistory.length,
      hasPriceHistory,
      hasVelocityData: velocityTracker.hasTradeData(mint),
    }, 'Evaluating entry');

    // Path 1: Token has sufficient price history â†’ use pump detector
    if (hasPriceHistory) {
      const pumpMetrics = pumpDetector.analyzePump(mint);
      const isGoodEntry = pumpDetector.isGoodEntry(pumpMetrics);

      logger.info({
        mint: mint.substring(0, 12),
        source: 'pump_detector',
        phase: pumpMetrics.phase,
        heat: pumpMetrics.heat.toFixed(1),
        confidence: pumpMetrics.confidence.toFixed(2),
        isGoodEntry,
      }, 'Pump detector evaluation');

      return {
        canEnter: isGoodEntry,
        source: 'pump_detector',
        reason: isGoodEntry
          ? `Pump OK: ${pumpMetrics.phase} phase, heat=${pumpMetrics.heat.toFixed(0)}`
          : `Pump rejected: ${pumpMetrics.phase} phase, heat=${pumpMetrics.heat.toFixed(0)}, conf=${pumpMetrics.confidence.toFixed(2)}`,
        metrics: pumpMetrics,
      };
    }

    // Path 2: New token without price history â†’ check velocity
    const velocityResult = velocityTracker.hasGoodVelocity(mint, marketCapSol);

    logger.info({
      mint: mint.substring(0, 12),
      source: 'velocity',
      hasGoodVelocity: velocityResult.hasGoodVelocity,
      reason: velocityResult.reason,
      metrics: velocityResult.metrics ? {
        txCount: velocityResult.metrics.txCount,
        uniqueBuyers: velocityResult.metrics.uniqueBuyers.size,
        buyPressure: (velocityResult.metrics.buyPressure * 100).toFixed(0) + '%',
      } : null,
    }, 'Velocity evaluation');

    return {
      canEnter: velocityResult.hasGoodVelocity,
      source: velocityResult.hasGoodVelocity ? 'velocity' : 'none',
      reason: velocityResult.reason,
      metrics: velocityResult.metrics || undefined,
    };
  }

  /**
   * Get pump metrics (for logging/display even if using velocity path)
   */
  getPumpMetrics(mint: string): PumpMetrics {
    return pumpDetector.analyzePump(mint);
  }
}

export const entryEvaluator = new EntryEvaluator();
</file>

<file path=".gitignore">
node_modules/
dist/
.env
*.log
/data/
models/*.json
!models/.gitkeep
.DS_Store
*.sqlite
*.db
puppeteer_data/
</file>

<file path="package.json">
{
  "name": "schizo-agent",
  "version": "1.0.0",
  "description": "Solana AI Trading Bot",
  "main": "dist/index.js",
  "scripts": {
    "build": "cd client && npm install && npm run build && cd .. && tsc",
    "start": "node dist/index.js",
    "dev": "ts-node src/index.ts",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "discover": "ts-node src/scripts/discover-whales.ts",
    "analyze": "ts-node src/scripts/analyze-wallets.ts",
    "find-whales": "ts-node src/scripts/find-smart-wallets.ts"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "@jup-ag/api": "^6.0.0",
    "@solana/web3.js": "^1.95.0",
    "@tensorflow/tfjs": "^4.22.0",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.6",
    "apify-client": "^2.21.0",
    "axios": "^1.13.2",
    "better-sqlite3": "^11.0.0",
    "bs58": "^5.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.0",
    "express": "^5.2.1",
    "groq-sdk": "^0.37.0",
    "helius-sdk": "^1.3.0",
    "node-fetch": "^3.3.0",
    "pg": "^8.11.0",
    "pino": "^8.19.0",
    "pino-pretty": "^10.3.0",
    "puppeteer": "^24.36.0",
    "simple-statistics": "^7.8.0",
    "socket.io": "^4.8.3",
    "ws": "^8.16.0"
  },
  "devDependencies": {
    "@types/better-sqlite3": "^7.6.9",
    "@types/jest": "^29.5.0",
    "@types/node": "^20.11.0",
    "@types/pg": "^8.11.0",
    "@types/ws": "^8.5.10",
    "@typescript-eslint/eslint-plugin": "^6.19.0",
    "@typescript-eslint/parser": "^6.19.0",
    "eslint": "^8.56.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.4.6",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.0"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}
</file>

<file path="src/risk/position-manager.ts">
import { EventEmitter } from 'events';
import { createChildLogger } from '../utils/logger';
import { config, LAMPORTS_PER_SOL } from '../config/settings';
import { priceFeed } from '../data/price-feed';
import { txManager } from '../execution/tx-manager';
import { repository } from '../db/repository';
import { Position, RiskCheckResult } from './types';

// Estimated fee per transaction in SOL (Jupiter swap fee + priority fee)
const ESTIMATED_TX_FEE_SOL = 0.001;

const logger = createChildLogger('position-manager');

export class PositionManager extends EventEmitter {
  private positions: Map<string, Position> = new Map();
  private monitorInterval: NodeJS.Timeout | null = null;

  constructor() {
    super();
  }

  async start(): Promise<void> {
    // Load existing positions from database
    await this.loadPositions();

    // Start position monitoring
    this.monitorInterval = setInterval(() => {
      this.monitorPositions();
    }, config.priceCheckIntervalMs);

    logger.info({ positionCount: this.positions.size }, 'Position manager started');
  }

  stop(): void {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = null;
    }
    logger.info('Position manager stopped');
  }

  private async loadPositions(): Promise<void> {
    try {
      const dbPositions = await repository.getOpenPositions();

      for (const dbPos of dbPositions) {
        const amountSol = parseFloat(dbPos.amount_sol.toString());
        // Load accumulated PnL from partial closes
        const partialClosePnl = await repository.getTotalPartialClosePnl(dbPos.id);

        const position: Position = {
          id: dbPos.id,
          mint: dbPos.mint,
          symbol: dbPos.symbol || '',
          entryPrice: parseFloat(dbPos.entry_price.toString()),
          currentPrice: parseFloat(dbPos.current_price.toString()),
          amount: parseFloat(dbPos.amount.toString()),
          amountSol,
          entryTime: new Date(dbPos.entry_time),
          lastUpdate: new Date(dbPos.last_update),
          unrealizedPnl: 0,
          unrealizedPnlPercent: 0,
          highestPrice: parseFloat(dbPos.highest_price.toString()),
          lowestPrice: parseFloat(dbPos.lowest_price.toString()),
          stopLoss: parseFloat(dbPos.stop_loss.toString()),
          takeProfit: JSON.parse(dbPos.take_profit_json || '[]'),
          tpSold: JSON.parse(dbPos.tp_sold_json || '[]'),
          status: dbPos.status as 'open' | 'closing' | 'closed',
          poolType: dbPos.pool_type as 'active' | 'high_risk',
          // NEW: Performance-based TP tracking (default for existing positions)
          initialRecovered: (dbPos as any).initial_recovered || false,
          scaledExitsTaken: (dbPos as any).scaled_exits_taken || 0,
          initialInvestment: (dbPos as any).initial_investment || amountSol,
          // NEW: Accumulated PnL from partial closes
          realizedPnl: partialClosePnl,
        };

        this.positions.set(position.id, position);
        priceFeed.addToWatchList(position.mint);
      }

      logger.info({ loaded: this.positions.size }, 'Positions loaded from database');
    } catch (error) {
      logger.error({ error }, 'Failed to load positions');
    }
  }

  async openPosition(params: {
    mint: string;
    symbol: string;
    entryPrice: number;
    amount: number;
    amountSol: number;
    poolType: 'active' | 'high_risk';
  }): Promise<Position> {
    const id = `pos_${params.mint}_${Date.now()}`;

    // Calculate stop loss and take profit levels
    const stopLoss = params.entryPrice * (1 - config.stopLossPercent);
    const takeProfit = config.takeProfitLevels.map((tp) => params.entryPrice * tp.multiplier);

    const position: Position = {
      id,
      mint: params.mint,
      symbol: params.symbol,
      entryPrice: params.entryPrice,
      currentPrice: params.entryPrice,
      amount: params.amount,
      amountSol: params.amountSol,
      entryTime: new Date(),
      lastUpdate: new Date(),
      unrealizedPnl: 0,
      unrealizedPnlPercent: 0,
      highestPrice: params.entryPrice,
      lowestPrice: params.entryPrice,
      stopLoss,
      takeProfit,
      tpSold: [],
      status: 'open',
      poolType: params.poolType,
      // NEW: Performance-based TP tracking
      initialRecovered: false,
      scaledExitsTaken: 0,
      initialInvestment: params.amountSol,
      // NEW: Accumulated PnL tracking
      realizedPnl: 0,
    };

    this.positions.set(id, position);
    priceFeed.addToWatchList(params.mint);

    // Save to database
    await repository.upsertPosition({
      id: position.id,
      mint: position.mint,
      symbol: position.symbol,
      entry_price: position.entryPrice,
      current_price: position.currentPrice,
      amount: position.amount,
      amount_sol: position.amountSol,
      entry_time: position.entryTime,
      highest_price: position.highestPrice,
      lowest_price: position.lowestPrice,
      stop_loss: position.stopLoss,
      take_profit_json: JSON.stringify(position.takeProfit),
      tp_sold_json: JSON.stringify(position.tpSold),
      status: position.status,
      pool_type: position.poolType,
    });

    this.emit('positionOpened', position);
    logger.info({
      id,
      mint: params.mint,
      amountSol: params.amountSol,
      stopLoss: stopLoss.toFixed(10),
      takeProfit: takeProfit.map((tp) => tp.toFixed(10)),
    }, 'Position opened');

    return position;
  }

  private async monitorPositions(): Promise<void> {
    for (const position of this.positions.values()) {
      if (position.status !== 'open') continue;

      try {
        let priceData = priceFeed.getPrice(position.mint);

        // If cache miss, attempt fresh fetch for bonding curve tokens
        if (!priceData && position.mint.endsWith('pump')) {
          priceData = await priceFeed.fetchTokenPrice(position.mint);
        }

        if (!priceData) {
          logger.warn({ mint: position.mint }, 'No price data - skipping position');
          continue;
        }

        const previousPrice = position.currentPrice;
        position.currentPrice = priceData.priceSol;
        position.lastUpdate = new Date();

        // Update highest/lowest
        if (position.currentPrice > position.highestPrice) {
          position.highestPrice = position.currentPrice;
          this.updateTrailingStop(position);
        }
        if (position.currentPrice < position.lowestPrice) {
          position.lowestPrice = position.currentPrice;
        }

        // Calculate unrealized P&L
        const currentValue = position.amount * position.currentPrice;
        position.unrealizedPnl = currentValue - position.amountSol;
        position.unrealizedPnlPercent =
          ((position.currentPrice - position.entryPrice) / position.entryPrice) * 100;

        // Check exit conditions
        await this.checkExitConditions(position);

        // Update database periodically (every 10th update)
        if (Math.random() < 0.1) {
          await this.persistPosition(position);
        }
      } catch (error) {
        logger.error({ positionId: position.id, error }, 'Failed to monitor position');
      }
    }
  }

  private updateTrailingStop(position: Position): void {
    // Only enable trailing stop after first TP hit
    if (position.tpSold.length > 0) {
      const trailingStopPrice = position.highestPrice * (1 - config.trailingStopPercent);
      position.trailingStop = Math.max(position.trailingStop || 0, trailingStopPrice);
    }
  }

  private async checkExitConditions(position: Position): Promise<void> {
    const currentPrice = position.currentPrice;
    const profitPercent = (currentPrice - position.entryPrice) / position.entryPrice;

    // GUARD: Skip if profit percent is invalid (entry price = 0, or other corruption)
    if (!isFinite(profitPercent) || isNaN(profitPercent)) {
      logger.error({
        positionId: position.id,
        entryPrice: position.entryPrice,
        currentPrice,
        profitPercent,
      }, 'Invalid profit percent (possible corrupted position) - closing position');

      // Close the corrupted position
      await this.closePosition(position.id, 'manual');
      return;
    }

    // GUARD: Skip if position has no tokens left
    if (position.amount <= 0) {
      logger.warn({
        positionId: position.id,
        amount: position.amount,
      }, 'Position has no tokens - closing');

      // Mark as closed without trying to sell
      position.status = 'closed';
      await this.persistPosition(position);
      this.positions.delete(position.id);
      return;
    }

    // 1. STOP LOSS CHECK (-12%)
    if (profitPercent <= -config.stopLossPercent) {
      logger.warn({
        positionId: position.id,
        currentPrice,
        entryPrice: position.entryPrice,
        profitPercent: (profitPercent * 100).toFixed(2),
        stopLossPercent: (config.stopLossPercent * 100).toFixed(0),
      }, 'Stop loss triggered at -12%');

      await this.closePosition(position.id, 'stop_loss');
      return;
    }

    // 2. TRAILING STOP CHECK (after any TP)
    if (position.trailingStop && currentPrice <= position.trailingStop) {
      logger.info({
        positionId: position.id,
        currentPrice,
        trailingStop: position.trailingStop,
        profitPercent: (profitPercent * 100).toFixed(2),
      }, 'Trailing stop triggered');

      await this.closePosition(position.id, 'trailing_stop');
      return;
    }

    // 3. INITIAL RECOVERY CHECK (+50%)
    const tpStrategy = config.takeProfitStrategy;
    if (!position.initialRecovered && profitPercent >= tpStrategy.initialRecovery.triggerPercent) {
      // Calculate how much to sell to recover initial investment
      const currentValue = position.amount * currentPrice;
      const sellAmount = position.initialInvestment / currentPrice;

      logger.info({
        positionId: position.id,
        profitPercent: (profitPercent * 100).toFixed(2),
        sellAmount,
        initialInvestment: position.initialInvestment,
        currentValue,
      }, 'Initial recovery: selling to recover initial investment at +50%');

      const success = await this.partialCloseNewStrategy(position, sellAmount, 'initial_recovery');

      // ONLY mark as recovered and set trailing stop on successful sell
      if (success) {
        position.initialRecovered = true;
        position.trailingStop = currentPrice * (1 - tpStrategy.trailingStopPercent);
        await this.persistPosition(position);
      }
      return;
    }

    // 4. SCALED EXITS (every +50% after recovery)
    if (position.initialRecovered) {
      const profitSinceRecovery = profitPercent - tpStrategy.initialRecovery.triggerPercent;
      const exitCount = Math.floor(profitSinceRecovery / tpStrategy.scaledExits.intervalPercent);

      if (exitCount > position.scaledExitsTaken && position.amount > 0) {
        const sellAmount = position.amount * tpStrategy.scaledExits.sellPercent;

        logger.info({
          positionId: position.id,
          profitPercent: (profitPercent * 100).toFixed(2),
          exitNumber: position.scaledExitsTaken + 1,
          sellPercent: tpStrategy.scaledExits.sellPercent * 100,
          sellAmount,
        }, 'Scaled exit: selling 20% of remaining at +50% interval');

        const success = await this.partialCloseNewStrategy(position, sellAmount, 'scaled_exit');

        // ONLY increment counter and update trailing stop on successful sell
        if (success) {
          position.scaledExitsTaken++;
          position.trailingStop = currentPrice * (1 - tpStrategy.trailingStopPercent);
          await this.persistPosition(position);
        }
      }
    }

    // 5. Update trailing stop on new highs (after initial recovery)
    if (position.initialRecovered && currentPrice >= position.highestPrice) {
      const newTrailingStop = currentPrice * (1 - tpStrategy.trailingStopPercent);
      if (!position.trailingStop || newTrailingStop > position.trailingStop) {
        position.trailingStop = newTrailingStop;
      }
    }
  }

  private async partialClose(position: Position, sellPercent: number, tpLevel: number): Promise<void> {
    const sellAmount = position.amount * sellPercent;

    // Execute partial sell with proper slippage for volatile tokens
    // skipBalanceCheck: trust our tracked position amount (RPC can be unreliable)
    const result = await txManager.executeSell(position.mint, sellAmount, 9, {
      slippageBps: config.defaultSlippageBps,
      skipBalanceCheck: true,
    });

    if (result.success) {
      position.amount -= sellAmount;
      position.tpSold.push(tpLevel);

      this.emit('partialClose', { position, tpLevel, sellAmount, result });

      // Update in database
      await this.persistPosition(position);
    } else {
      logger.error({
        positionId: position.id,
        tpLevel,
        error: result.error,
      }, 'Partial close failed');
    }
  }

  // NEW: Partial close for new TP strategy (absolute amount instead of percent)
  // Returns true on success, false on failure
  private async partialCloseNewStrategy(
    position: Position,
    sellAmount: number,
    reason: 'initial_recovery' | 'scaled_exit'
  ): Promise<boolean> {
    // Guard: Don't try to sell if amount is too small
    if (position.amount <= 0 || sellAmount <= 0) {
      logger.warn({
        positionId: position.id,
        amount: position.amount,
        sellAmount,
      }, 'Cannot sell - position amount is zero or negative');
      return false;
    }

    // Ensure we don't sell more than we have
    const actualSellAmount = Math.min(sellAmount, position.amount * 0.99);

    // Execute partial sell with proper slippage for volatile tokens
    // skipBalanceCheck: trust our tracked position amount (RPC can be unreliable)
    const result = await txManager.executeSell(position.mint, actualSellAmount, 9, {
      slippageBps: config.defaultSlippageBps,
      skipBalanceCheck: true,
    });

    if (result.success) {
      const previousAmount = position.amount;
      position.amount -= actualSellAmount;

      // Calculate PnL for this partial close
      const priceAtClose = position.currentPrice;
      const solReceived = result.outputAmount || (actualSellAmount * priceAtClose);
      const proportionalEntry = (actualSellAmount / previousAmount) * position.amountSol;
      const pnlSol = solReceived - proportionalEntry - ESTIMATED_TX_FEE_SOL;

      // Accumulate realized PnL
      position.realizedPnl = (position.realizedPnl || 0) + pnlSol;

      // Log to database
      await repository.insertPartialClose({
        position_id: position.id,
        mint: position.mint,
        close_type: reason,
        sell_amount_tokens: actualSellAmount,
        sell_amount_sol: solReceived,
        price_at_close: priceAtClose,
        pnl_sol: pnlSol,
        fees_sol: ESTIMATED_TX_FEE_SOL,
      });

      // Update position amount in database
      await repository.updatePositionAmount(position.id, position.amount);

      this.emit('partialClose', { position, reason, sellAmount: actualSellAmount, result, pnlSol });

      logger.info({
        positionId: position.id,
        reason,
        sellAmount: actualSellAmount,
        remainingAmount: position.amount,
        solReceived,
        pnlSol: pnlSol.toFixed(6),
        totalRealizedPnl: position.realizedPnl.toFixed(6),
      }, 'Partial close executed (new strategy)');
      return true;
    } else {
      logger.error({
        positionId: position.id,
        reason,
        error: result.error,
      }, 'Partial close failed (new strategy)');

      // SYNC: If tx-manager reports actual balance, update our position
      if (result.actualBalance !== undefined && result.actualBalance !== position.amount) {
        logger.warn({
          positionId: position.id,
          previousAmount: position.amount,
          actualBalance: result.actualBalance,
        }, 'Syncing position amount with actual on-chain balance (manual sell detected?)');

        position.amount = result.actualBalance;
        await this.persistPosition(position);

        // If balance is now 0, close the position
        if (position.amount <= 0) {
          logger.info({ positionId: position.id }, 'Position has no tokens after sync - marking as closed');
          position.status = 'closed';
          await this.persistPosition(position);
          this.positions.delete(position.id);
        }
      }

      return false;
    }
  }

  async closePosition(
    positionId: string,
    reason: 'stop_loss' | 'take_profit' | 'trailing_stop' | 'manual' | 'ai_signal' | 'rug_detected'
  ): Promise<void> {
    const position = this.positions.get(positionId);

    if (!position) {
      logger.warn({ positionId }, 'Position not found');
      return;
    }

    if (position.status !== 'open') {
      logger.warn({ positionId, status: position.status }, 'Position not open');
      return;
    }

    position.status = 'closing';

    // Execute full sell with proper slippage for volatile tokens
    // skipBalanceCheck: trust our tracked position amount (RPC can be unreliable)
    const result = await txManager.executeSell(position.mint, position.amount, 9, {
      slippageBps: config.defaultSlippageBps,
      skipBalanceCheck: true,
    });

    if (result.success) {
      position.status = 'closed';

      const exitPrice = position.currentPrice;

      // Calculate PnL for final close (remaining tokens)
      const solReceived = result.outputAmount || (position.amount * exitPrice);
      const remainingEntryValue = position.amount * position.entryPrice;
      const finalClosePnl = solReceived - remainingEntryValue - ESTIMATED_TX_FEE_SOL;

      // Total PnL = partial closes + final close
      const totalPnlSol = (position.realizedPnl || 0) + finalClosePnl;
      const pnlPercent = (totalPnlSol / position.amountSol) * 100;

      // Update database
      await repository.closePosition(positionId);

      // Clean up
      priceFeed.removeFromWatchList(position.mint);
      this.positions.delete(positionId);

      this.emit('positionClosed', {
        position,
        reason,
        exitPrice,
        pnlSol: totalPnlSol,
        pnlPercent,
        result,
        partialClosePnl: position.realizedPnl || 0,
        finalClosePnl,
        actualSolReceived: solReceived,
      });

      logger.info({
        positionId,
        reason,
        exitPrice,
        partialClosePnl: (position.realizedPnl || 0).toFixed(6),
        finalClosePnl: finalClosePnl.toFixed(6),
        totalPnlSol: totalPnlSol.toFixed(6),
        pnlPercent: pnlPercent.toFixed(2),
      }, 'Position closed');
    } else {
      // Check if actual balance is 0 - if so, close as total loss (ghost position)
      // BUT: Add grace period - don't close as ghost if position is < 60 seconds old
      // This prevents false positives due to RPC indexing delays
      const positionAgeMs = Date.now() - position.entryTime.getTime();
      const GHOST_GRACE_PERIOD_MS = 60000; // 60 seconds

      if (result.actualBalance === 0 && positionAgeMs > GHOST_GRACE_PERIOD_MS) {
        logger.warn({
          positionId,
          reason,
          error: result.error,
          positionAgeMs,
        }, 'Ghost position detected - no tokens on chain. Closing as total loss.');

        position.status = 'closed';
        position.amount = 0;
        // Total loss = entire investment
        const totalPnlSol = -position.amountSol;
        const pnlPercent = -100;

        // Update database
        await repository.closePosition(positionId);

        // Clean up
        priceFeed.removeFromWatchList(position.mint);
        this.positions.delete(positionId);

        this.emit('positionClosed', {
          position,
          reason: 'ghost_position',
          exitPrice: 0,
          pnlSol: totalPnlSol,
          pnlPercent,
          result,
        });

        logger.info({
          positionId,
          totalPnlSol: totalPnlSol.toFixed(6),
          pnlPercent: pnlPercent.toFixed(2),
        }, 'Ghost position closed as total loss');
        return;
      } else if (result.actualBalance === 0) {
        // Position is young, RPC might just be slow - retry later
        logger.warn({
          positionId,
          reason,
          error: result.error,
          positionAgeMs,
          graceRemaining: GHOST_GRACE_PERIOD_MS - positionAgeMs,
        }, 'Sell failed but position is young - will retry (RPC may be slow)');
        position.status = 'open';
        return;
      }

      position.status = 'open'; // Revert status
      logger.error({
        positionId,
        reason,
        error: result.error,
      }, 'Failed to close position');
    }
  }

  private async persistPosition(position: Position): Promise<void> {
    await repository.upsertPosition({
      id: position.id,
      mint: position.mint,
      symbol: position.symbol,
      entry_price: position.entryPrice,
      current_price: position.currentPrice,
      amount: position.amount,
      amount_sol: position.amountSol,
      entry_time: position.entryTime,
      highest_price: position.highestPrice,
      lowest_price: position.lowestPrice,
      stop_loss: position.stopLoss,
      take_profit_json: JSON.stringify(position.takeProfit),
      tp_sold_json: JSON.stringify(position.tpSold),
      status: position.status,
      pool_type: position.poolType,
    });
  }

  getPosition(id: string): Position | undefined {
    return this.positions.get(id);
  }

  getPositionByMint(mint: string): Position | undefined {
    for (const position of this.positions.values()) {
      if (position.mint === mint && position.status === 'open') {
        return position;
      }
    }
    return undefined;
  }

  getOpenPositions(): Position[] {
    return Array.from(this.positions.values()).filter((p) => p.status === 'open');
  }

  getPositionCount(): number {
    return this.getOpenPositions().length;
  }

  getTotalExposure(): number {
    return this.getOpenPositions().reduce((sum, p) => sum + p.amountSol, 0);
  }

  canOpenPosition(riskCheck: RiskCheckResult): boolean {
    return riskCheck.approved;
  }
}

export const positionManager = new PositionManager();
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(echo:*)",
      "Bash(curl:*)",
      "Bash(node -e:*)",
      "Bash(npm install:*)",
      "WebSearch",
      "mcp__sequential-thinking__sequentialthinking"
    ]
  }
}
</file>

<file path="client/src/App.tsx">
import { Header } from './components/Header';
import { StatsGrid } from './components/StatsGrid';
import { ChallengeCard } from './components/ChallengeCard';
import { TokenScanner } from './components/TokenScanner';
import { TradeList } from './components/TradeList';
import { AIStatus } from './components/AIStatus';
import { Watchlist } from './components/Watchlist';
import { Positions } from './components/Positions';
import { EquityChart } from './components/EquityChart';
import { C100Card } from './components/C100Card';
import { useSocket } from './hooks/useSocket';

function App() {
  const {
    isConnected,
    stats,
    trades,
    positions,
    positionsSummary,
    walletState,
    equityHistory,
    scannerData,
    isScanning,
    toasts,
    aiDecision,
    watchlistTokens,
    watchlistStats,
    c100Data
  } = useSocket();

  return (
    <>
      <div className="dashboard">
        <Header isConnected={isConnected} />
        
        <StatsGrid stats={stats} />

        <C100Card data={c100Data} />

        <div className="main-grid">
          <div className="left-column">
            <ChallengeCard stats={stats} />
            <TokenScanner data={scannerData || undefined} isScanning={isScanning} tokensScanned={stats.tokensScanned} />
            <EquityChart history={equityHistory} walletBalance={walletState?.solBalance} />
            <Positions positions={positions} summary={positionsSummary} />
          </div>

          <div className="right-column">
            <TradeList trades={trades} />
            <AIStatus stats={stats} decision={aiDecision} />
            <Watchlist tokens={watchlistTokens} stats={watchlistStats} />
          </div>
        </div>
      </div>

      <div className="toast-container">
        {toasts.map((toast, i) => (
          <div key={i} className={`toast ${toast.type}`}>
            <div className="toast-title">{toast.title}</div>
            <div className="toast-message">{toast.message}</div>
          </div>
        ))}
      </div>

      <div className="floating-controls">
        <div 
          className="wallet-pill" 
          onClick={() => {
            navigator.clipboard.writeText('8FvP3dYCYf1gaQ1DnXyjERkDvmFK1odrQepcVQLvHDxB');
            // You might want to add a toast here, but for now a simple console log or visual usage is fine
            // Since we don't have direct access to `setToast` here without prop drilling or context moving, 
            // we'll rely on the visual feedback defined in CSS (:active state)
          }}
          title="Click to copy address"
        >
          <span className="wallet-label">DONATE</span>
          <span className="wallet-address">8FvP...HDxB</span>
          <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </div>

        <a href="https://x.com/100xClaude" target="_blank" rel="noopener noreferrer" className="x-profile-link">
          <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
          </svg>
        </a>
      </div>
    </>
  );
}

export default App;
</file>

<file path="src/config/settings.ts">
import dotenv from 'dotenv';
dotenv.config();

const heliusApiKey = process.env.HELIUS_API_KEY || '';

export const config = {
  // Solana RPC
  solanaRpcUrl: process.env.SOLANA_RPC_URL || `https://mainnet.helius-rpc.com/?api-key=${heliusApiKey}`,
  heliusApiKey,
  heliusWsUrl: process.env.HELIUS_WS_URL || `wss://mainnet.helius-rpc.com/?api-key=${heliusApiKey}`,
  privateKey: process.env.WALLET_PRIVATE_KEY || process.env.PRIVATE_KEY || '',

  // Database
  databaseUrl: process.env.DATABASE_URL || '',
  sqlitePath: process.env.SQLITE_PATH || './data/cache.db',

  // Trading Parameters
  initialCapitalSol: parseFloat(process.env.INITIAL_CAPITAL_SOL || '1.0'),
  maxPositionSize: parseFloat(process.env.MAX_POSITION_SIZE || '0.10'),  // 10% of capital max (allows small balances to trade)
  dailyLossLimit: parseFloat(process.env.DAILY_LOSS_LIMIT || '0.15'),
  maxConcurrentPositions: parseInt(process.env.MAX_CONCURRENT_POSITIONS || '3'),  // Default to 3

  // Jito MEV Protection
  jitoBlockEngineUrl: process.env.JITO_BLOCK_ENGINE_URL || 'https://mainnet.block-engine.jito.wtf',
  jitoTipLamports: parseInt(process.env.JITO_TIP_LAMPORTS || '10000'),

  // Feature Flags
  paperTrading: process.env.PAPER_TRADING === 'true',
  enableJito: process.env.ENABLE_JITO === 'true',

  // API Endpoints (using public Jupiter API - no auth required)
  jupiterQuoteApi: 'https://public.jupiterapi.com/quote',
  jupiterSwapApi: 'https://public.jupiterapi.com/swap',
  // Note: Price data comes from DexScreener (free) instead of Jupiter price API (paid)
  dexScreenerApi: 'https://api.dexscreener.com/latest/dex/tokens',
  jitoBundleApi: 'https://mainnet.block-engine.jito.wtf/api/v1/bundles',

  // Program IDs
  pumpFunProgram: '6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P',

  // Risk Parameters
  capitalAllocation: {
    reserve: 0.40,    // 40% never trade
    active: 0.40,     // 40% normal trades
    highRisk: 0.20,   // 20% meme plays
  },

  stopLossPercent: 0.12,      // -12% stop loss (was 50%)

  // NEW Take Profit Strategy: recover initial at +50%, then scale out
  takeProfitStrategy: {
    // At +50% gain, sell enough to recover initial investment
    initialRecovery: {
      triggerPercent: 0.50,  // +50% gain
      action: 'recover_initial' as const,
    },
    // After initial recovery, sell 20% of remainder every +50%
    scaledExits: {
      intervalPercent: 0.50,  // Every +50% gain
      sellPercent: 0.20,      // Sell 20% of remaining
    },
    // Trailing stop on final portion
    trailingStopPercent: 0.15,  // 15% trailing stop
  },

  // LEGACY: Keep for backwards compatibility but unused
  takeProfitLevels: [
    { multiplier: 2.0, sellPercent: 0.25 },
    { multiplier: 3.0, sellPercent: 0.25 },
  ],
  trailingStopPercent: 0.15,  // 15% trailing stop (updated from 20%)

  // AI Parameters
  ddqnConfig: {
    stateSize: 16,         // Updated from 12 to 16 (added: drawdownFromPeak, volatility, uniqueTraders, volumeTrend)
    actionSize: 3,         // HOLD, BUY, SELL
    hiddenSize: 128,
    learningRate: 0.001,
    gamma: 0.99,           // discount factor
    epsilon: 1.0,          // exploration rate
    epsilonMin: 0.01,
    epsilonDecay: 0.995,
    replayBufferSize: 100000,
    batchSize: 64,
    targetUpdateTau: 0.005,
  },

  // Timing
  priceCheckIntervalMs: 1000,
  featureUpdateIntervalMs: 5000,
  modelRetrainIntervalMs: 7 * 24 * 60 * 60 * 1000, // 1 week

  // Thresholds
  // NOTE: minRugScore lowered from 70 to 45 because LP info is not available
  // (passed as null to rug detector), so max possible score is ~75 instead of 100
  // NOTE: minLiquiditySol lowered from 5 to 1 for testing
  minLiquiditySol: 1,
  minHolderCount: 50,
  maxTop10Concentration: 0.30,
  minRugScore: 45,
  minPumpHeat: 0,  // Lowered from 33 to 0 for testing live trades

  // Trade execution settings
  tradeAmountSol: parseFloat(process.env.BASE_POSITION_SOL || '0.01'),
  defaultSlippageBps: 1500,  // 15% slippage
  priorityFeeSol: 0.0001,    // Priority fee in SOL
  jitoBribeSol: 0.00001,     // Jito bribe (if enabled)

  // Velocity-based entry for new tokens (no price history)
  // Tightened thresholds to avoid rugs and garbage tokens
  velocityEntry: {
    enabled: false,          // DISABLED: AI decides entry, not velocity
    minTxCount: 15,          // Increased: need real activity, not just a few buys
    minUniqueBuyers: 7,      // Increased: need 7+ unique wallets to filter wash trading
    minBuyPressure: 0.60,    // 60% buys - higher threshold for quality
    maxMarketCapSol: 100,    // Allow slightly larger caps for tokens with real traction
  },

  // Token Watchlist - AI-driven entry (NEW)
  watchlist: {
    minDataPoints: 10,       // Need 10+ price updates before AI can analyze
    minAgeSeconds: 180,      // 3 MINUTES: token must survive initial dump period
    minConfidence: 0.55,     // LOWERED: Base confidence (dynamic scaling adds more)
    maxConfidence: 0.70,     // NEW: Max confidence threshold for older tokens
    maxDrawdown: 0.30,       // Hard reject if crashed >30% from peak
  },

  // Momentum Override - bypass lower confidence if signals are strong
  momentumOverride: {
    enabled: true,
    minBuyPressure: 0.75,           // 75%+ buys
    minVolumeAcceleration: 1.2,     // Volume 20%+ higher than previous window
    minUniqueTraderGrowth: 3,       // At least 3 new unique traders
    confidenceFloor: 0.45,          // Allow entries at 45% confidence if momentum strong
  },

  // Dev Sold Tracking - percentage-based instead of binary
  devSoldConfig: {
    maxSellPercent: 0.05,           // 5% max dev sell allowed
    earlyWindowSeconds: 180,        // First 3 minutes are critical
    earlyMaxSellPercent: 0.02,      // Only 2% allowed in early window
  },

  // C100 Token Configuration
  c100: {
    tokenMint: process.env.C100_TOKEN_MINT || '',
    enabled: !!process.env.C100_TOKEN_MINT,
    autoClaim: {
      enabled: true,
      intervalMs: 5 * 60 * 1000,    // 5 minutes
      claimPumpCreator: true,
    },
    buyback: {
      enabled: true,
      profitSharePercent: 0.10,     // 10% of profits
      minBuybackSol: 0.01,          // Minimum buyback amount
    },
  },
};

export const SOL_MINT = 'So11111111111111111111111111111111111111112';
export const USDC_MINT = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';
export const LAMPORTS_PER_SOL = 1_000_000_000;
</file>

<file path=".env.example">
# Solana
SOLANA_RPC_URL=https://mainnet.helius-rpc.com/?api-key=YOUR_KEY
HELIUS_API_KEY=YOUR_HELIUS_KEY
HELIUS_WS_URL=wss://atlas-mainnet.helius-rpc.com/?api-key=YOUR_KEY
PRIVATE_KEY=YOUR_BASE58_PRIVATE_KEY

# Database
DATABASE_URL=postgresql://user:pass@host:port/db
SQLITE_PATH=./data/cache.db

# Trading
INITIAL_CAPITAL_SOL=1.0
MAX_POSITION_SIZE=0.05
DAILY_LOSS_LIMIT=0.15
MAX_CONCURRENT_POSITIONS=5

# Jito MEV Protection
JITO_BLOCK_ENGINE_URL=https://mainnet.block-engine.jito.wtf
JITO_TIP_LAMPORTS=10000

# Apify (Twitter/X scraping)
APIFY_API_TOKEN=YOUR_APIFY_TOKEN

# Gemini (LLM sentiment analysis)
GEMINI_API_KEY=YOUR_GEMINI_KEY

# Feature Flags
PAPER_TRADING=true
ENABLE_JITO=false

# C100 Token (for auto-claim and buyback)
C100_TOKEN_MINT=
</file>

<file path="public/index.html">
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/png" href="/logo.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Claude Challenge</title>
  <script type="module" crossorigin src="/assets/index-B0KwH956.js"></script>
  <link rel="stylesheet" crossorigin href="/assets/index-BZU8IHLs.css">
</head>

<body>
  <div id="root"></div>
</body>

</html>
</file>

<file path="src/index.ts">
import { Pool } from 'pg';
import { createChildLogger } from './utils/logger';
import { config } from './config/settings';
import { createTables } from './db/schema';
import { repository } from './db/repository';

// Data Layer
import { heliusWs, priceFeed, whaleTracker, NewTokenEvent, PriceData, WhaleActivity } from './data';
import { pumpPortalWs, BondingCurveData } from './data/pumpportal-ws';

// Signal Processing Layer
import { featureExtractor, rugDetector, pumpDetector, velocityTracker, entryEvaluator, rugMonitor, narrativeSensor, NarrativeSignal, tokenWatchlist } from './signals';
import { StateVector, PumpMetrics, RugScore } from './signals/types';

// AI Layer
import { ddqnAgent, regimeDetector, positionSizer } from './ai';
import { Action, AIDecision, MarketRegime } from './ai/types';

// Execution Layer
import { txManager } from './execution';

// Risk Layer
import { positionManager, capitalAllocator, drawdownGuard } from './risk';

// Learning Layer
import { tradeLogger, performanceAnalytics, modelTrainer } from './learning';

// Services Layer
import { walletSync, equityTracker, positionReconciler, c100Tracker, rewardClaimer, c100Buyback } from './services';

// API Layer
import { apiServer } from './api';

const logger = createChildLogger('orchestrator');

class TradingBot {
  private isRunning = false;
  private tokenQueue: NewTokenEvent[] = [];
  private processedMints: Set<string> = new Set();
  private bondingCurveCache: Map<string, BondingCurveData> = new Map();
  private rejectionStats = {
    quickSafety: 0,
    liquidity: 0,
    rugScore: 0,
    entryEval: 0,  // Combined pump/velocity rejection
    aiDecision: 0,
    riskCheck: 0,
    total: 0,
    passed: 0,
  };

  async start(): Promise<void> {
    logger.info('Starting Solana AI Trading Bot');
    logger.info({ paperTrading: config.paperTrading }, 'Mode');

    try {
      // Initialize database
      logger.info('Initializing database...');
      await repository.connect();
      const pool = new Pool({ connectionString: config.databaseUrl });
      await createTables(pool);
      await pool.end();

      // Initialize all layers
      logger.info('Initializing layers...');

      // Execution layer
      await txManager.initialize();

      // AI layer
      await modelTrainer.initialize();
      await regimeDetector.start();

      // Risk layer
      await capitalAllocator.syncWithWallet();
      await positionManager.start();
      await drawdownGuard.start();
      await drawdownGuard.resetAll();  // Clear old state for fresh testing - must be AFTER start

      // Data layer
      await priceFeed.start();
      await whaleTracker.start();

      // Setup event handlers
      this.setupEventHandlers();

      // Start WebSocket connections
      await heliusWs.connect();

      // Connect to PumpPortal for bonding curve data
      try {
        await pumpPortalWs.connect();
        logger.info('PumpPortal WebSocket connected');
      } catch (error) {
        logger.warn({ error }, 'PumpPortal connection failed - will use DexScreener fallback');
      }

      // Start learning
      await modelTrainer.startPeriodicTraining();

      // Start API server for dashboard
      await apiServer.start();

      // Start wallet sync and equity tracking services
      await walletSync.start(30000);      // Sync wallet every 30s
      await equityTracker.start(60000);   // Snapshot equity every 60s

      // Initial position reconciliation to detect any phantoms from previous session
      const reconcileResult = await positionReconciler.reconcile(true);
      if (reconcileResult.phantomsFound.length > 0) {
        logger.warn({
          phantoms: reconcileResult.phantomsFound.length,
          closed: reconcileResult.phantomsClosed,
        }, 'Startup reconciliation found phantom positions');
      }

      // Start C100 services
      await c100Tracker.start(30000);           // Price updates every 30s
      await rewardClaimer.start(5 * 60 * 1000); // Claim every 5 minutes
      await c100Buyback.initialize();

      this.isRunning = true;
      logger.info('Bot started successfully');

      // Process token queue periodically
      this.startTokenProcessor();

      // Periodic status logging
      this.startStatusLogger();

    } catch (error) {
      logger.error({ error }, 'Failed to start bot');
      await this.stop();
      throw error;
    }
  }

  private setupEventHandlers(): void {
    // New token detection from Helius
    heliusWs.on('newToken', (event: NewTokenEvent) => {
      logger.info({ mint: event.mint }, 'New token detected');
      this.tokenQueue.push(event);
    });

    // PumpPortal bonding curve data - add to watchlist for AI-driven entry
    pumpPortalWs.on('newToken', (data: BondingCurveData) => {
      this.bondingCurveCache.set(data.mint, data);

      // Subscribe to this token's trades for data collection
      pumpPortalWs.subscribeToToken(data.mint);

      // Add to watchlist for AI-driven entry (instead of immediate sniping)
      // Creator is the bonding curve key for pump.fun tokens
      tokenWatchlist.addToken(data.mint, data.bondingCurveKey);

      // Record initial price point
      tokenWatchlist.recordPrice(data.mint, data.priceSol, data.marketCapSol);

      logger.info({
        mint: data.mint.substring(0, 15),
        marketCapSol: data.marketCapSol.toFixed(2),
        liquiditySol: data.liquiditySol.toFixed(2),
      }, 'New token added to watchlist (AI-driven entry)');
    });

    pumpPortalWs.on('trade', (data: BondingCurveData & { txType: 'buy' | 'sell'; traderPublicKey: string; tokenAmount?: number }) => {
      // Update cache with latest bonding curve state
      this.bondingCurveCache.set(data.mint, data);

      // Record trade for velocity tracking (legacy)
      velocityTracker.recordTrade({
        mint: data.mint,
        txType: data.txType,
        traderPublicKey: data.traderPublicKey,
        marketCapSol: data.marketCapSol,
      });

      // Record trade to watchlist for AI-driven entry analysis
      tokenWatchlist.recordTrade(data.mint, {
        txType: data.txType,
        traderPublicKey: data.traderPublicKey,
        tokenAmount: data.tokenAmount || 0,
        marketCapSol: data.marketCapSol,
        priceSol: data.priceSol,
      });

      // Feed to rug monitor for post-entry protection
      rugMonitor.processTrade({
        mint: data.mint,
        txType: data.txType,
        traderPublicKey: data.traderPublicKey,
        tokenAmount: data.tokenAmount || 0,
        marketCapSol: data.marketCapSol,
        priceSol: data.priceSol,
      });
    });

    // Whale activity
    whaleTracker.on('whaleActivity', (activity: WhaleActivity) => {
      logger.info({
        wallet: activity.wallet,
        action: activity.action,
        mint: activity.mint,
        amountSol: activity.amountSol,
      }, 'Whale activity detected');

      // Could trigger analysis of the token
      if (activity.action === 'buy' && activity.amountSol > 50) {
        this.tokenQueue.push({
          mint: activity.mint,
          signature: '',
          timestamp: new Date(),
          creator: activity.wallet,
        });
      }
    });

    // Position events
    positionManager.on('positionOpened', (position) => {
      capitalAllocator.reserveCapital(position.amountSol, position.poolType);
      // Note: rugMonitor.watchPosition is called in analyzeAndTrade where we have creator info
    });

    positionManager.on('positionClosed', async (data) => {
      const { position, reason, pnlSol, pnlPercent, partialClosePnl, actualSolReceived } = data;

      capitalAllocator.releaseCapital(position.amountSol, position.poolType);
      drawdownGuard.recordTrade(pnlSol);
      positionSizer.recordTrade(pnlSol > 0);

      // Stop watching for rug signals
      rugMonitor.unwatchPosition(position.mint);

      // Log exit with accurate PnL including partial closes and actual SOL received
      await tradeLogger.logExit({
        positionId: position.id,
        exitPrice: position.currentPrice,
        exitReason: reason,
        actualSolReceived,
        partialClosePnl: partialClosePnl || 0,
      });

      // Take equity snapshot on trade close
      await equityTracker.onTradeClose();

      // Add to training
      await modelTrainer.addTradeExperience(position.id);

      // C100 Buyback on profitable close
      if (pnlSol > 0) {
        c100Buyback.onProfitableClose(pnlSol).catch(err => {
          logger.error({ err }, 'C100 buyback failed');
        });
      }

      logger.info({
        positionId: position.id,
        reason,
        pnlSol: pnlSol.toFixed(6),
        pnlPercent: pnlPercent.toFixed(2),
        partialClosePnl: (partialClosePnl || 0).toFixed(6),
      }, 'Position closed');
    });

    // Rug monitor alerts - close position immediately on critical rug signals
    rugMonitor.on('rugAlert', async (warning) => {
      const position = positionManager.getPositionByMint(warning.mint);
      if (position && position.status === 'open') {
        logger.error({
          positionId: position.id,
          mint: warning.mint.substring(0, 12) + '...',
          type: warning.type,
          message: warning.message,
        }, 'RUG DETECTED - Closing position immediately');

        await positionManager.closePosition(position.id, 'rug_detected');
      }
    });

    positionManager.on('partialClose', async (data) => {
      logger.info({
        positionId: data.position.id,
        tpLevel: data.tpLevel + 1,
        sellAmount: data.sellAmount,
      }, 'Partial close executed');
    });

    // Drawdown events
    drawdownGuard.on('tradingPaused', (data) => {
      logger.error(data, 'TRADING PAUSED');
    });

    drawdownGuard.on('tradingResumed', (data) => {
      logger.info(data, 'Trading resumed');
    });

    // Price events
    priceFeed.on('significantPriceChange', (data: { mint: string; change: number; data: PriceData }) => {
      logger.debug({
        mint: data.mint,
        change: data.change.toFixed(2),
      }, 'Significant price change');
    });
  }

  private startTokenProcessor(): void {
    // Process Helius token queue (legacy - for whale activity etc)
    setInterval(() => {
      this.processTokenQueue();
    }, 2000); // Process every 2 seconds

    // NEW: Process watchlist for AI-driven entry
    setInterval(() => {
      this.processWatchlistTokens();
    }, 5000); // Check watchlist every 5 seconds

    // Cleanup old watchlist entries
    setInterval(() => {
      tokenWatchlist.cleanup(600000); // 10 minute max age
    }, 60000); // Cleanup every minute
  }

  // NEW: Process tokens in watchlist that have enough data for AI analysis
  private async processWatchlistTokens(): Promise<void> {
    if (!this.isRunning) return;

    if (!drawdownGuard.canTrade()) {
      return; // Already logged in processTokenQueue
    }

    const readyTokens = tokenWatchlist.getReadyTokens();

    if (readyTokens.length > 0) {
      const stats = tokenWatchlist.getStats();
      logger.info({
        total: stats.total,
        ready: stats.ready,
        devSold: stats.devSold,
      }, 'Watchlist status');
    }

    for (const mint of readyTokens) {
      // Skip if already in a position or recently processed
      if (this.processedMints.has(mint)) continue;
      if (positionManager.getPositionByMint(mint)) continue;

      const filterResult = tokenWatchlist.passesHardFilters(mint);
      if (!filterResult.passes) {
        logger.debug({ mint: mint.substring(0, 15), reason: filterResult.reason }, 'Watchlist token rejected by hard filters');
        continue;
      }

      // Get watchlist features for logging/decision
      const watchlistFeatures = tokenWatchlist.extractFeatures(mint);
      if (!watchlistFeatures) continue;

      logger.info({
        mint: mint.substring(0, 15),
        priceChange: (watchlistFeatures.priceChange * 100).toFixed(2) + '%',
        volatility: watchlistFeatures.volatility.toFixed(4),
        drawdown: (watchlistFeatures.drawdown * 100).toFixed(2) + '%',
        buyPressure: (watchlistFeatures.buyPressure * 100).toFixed(0) + '%',
        uniqueTraders: watchlistFeatures.uniqueTraders,
        ageMinutes: watchlistFeatures.ageMinutes.toFixed(1),
      }, 'Analyzing watchlist token for AI entry');

      // Create synthetic event for analyzeAndTrade
      const token = tokenWatchlist.getToken(mint);
      if (!token) continue;

      const syntheticEvent: NewTokenEvent = {
        mint,
        signature: '',
        timestamp: new Date(token.firstSeen),
        creator: token.creator,
      };

      try {
        await this.analyzeAndTrade(syntheticEvent);
        this.processedMints.add(mint);

        // Cleanup processed token from watchlist
        tokenWatchlist.removeToken(mint);
      } catch (error) {
        logger.error({ mint, error }, 'Failed to analyze watchlist token');
      }
    }
  }

  private async processTokenQueue(): Promise<void> {
    if (!this.isRunning) {
      return;
    }

    if (!drawdownGuard.canTrade()) {
      const ddState = drawdownGuard.getState();
      logger.warn({
        queueLen: this.tokenQueue.length,
        currentDrawdown: (ddState.currentDrawdown * 100).toFixed(2),
        dailyPnl: ddState.dailyPnl.toFixed(4),
        isPaused: ddState.isPaused,
      }, 'Drawdown guard blocking trading');
      return;
    }

    if (this.tokenQueue.length > 0) {
      logger.info({ queueLen: this.tokenQueue.length }, 'Processing token queue');
    }

    while (this.tokenQueue.length > 0) {
      const token = this.tokenQueue.shift();
      if (!token) continue;

      // Skip if already processed recently
      if (this.processedMints.has(token.mint)) continue;

      try {
        logger.info({ mint: token.mint.substring(0, 15) }, 'Analyzing token...');
        await this.analyzeAndTrade(token);
        this.processedMints.add(token.mint);

        // Clean up old processed mints
        if (this.processedMints.size > 1000) {
          const oldest = Array.from(this.processedMints).slice(0, 500);
          oldest.forEach((m) => this.processedMints.delete(m));
        }
      } catch (error) {
        logger.error({ mint: token.mint, error }, 'Failed to analyze token');
      }
    }
  }

  private async analyzeAndTrade(token: NewTokenEvent): Promise<void> {
    const { mint } = token;

    logger.debug({ mint }, 'Analyzing token');

    // Get token info
    const tokenInfo = await priceFeed.getTokenInfo(mint);
    const holderInfo = await priceFeed.getHolderInfo(mint);

    // Quick safety check
    const quickSafety = rugDetector.getQuickSafetyFlags(tokenInfo, mint);
    logger.info({ mint, quickSafety }, 'Quick safety check result');
    if (!quickSafety.isSafe) {
      this.rejectionStats.quickSafety++;
      this.rejectionStats.total++;
      logger.info({ mint, flags: quickSafety.flags }, 'REJECTED: Quick safety check failed');
      return;
    }

    // Get price/liquidity data
    const isPumpFunToken = mint.endsWith('pump');
    let priceData = await priceFeed.fetchTokenPrice(mint);
    let bondingCurveData: BondingCurveData | null = null;

    // For Pump.fun tokens: Try PumpPortal bonding curve data first (instant!)
    if (isPumpFunToken) {
      // Check cache from PumpPortal WebSocket
      bondingCurveData = this.bondingCurveCache.get(mint) || pumpPortalWs.getBondingCurveData(mint);

      if (!bondingCurveData) {
        // Wait briefly for PumpPortal to receive the data
        for (let retry = 0; retry < 3; retry++) {
          logger.info({ mint, retry: retry + 1 }, 'Waiting for PumpPortal bonding curve data...');
          await new Promise(r => setTimeout(r, 2000));
          bondingCurveData = this.bondingCurveCache.get(mint) || pumpPortalWs.getBondingCurveData(mint);
          if (bondingCurveData) break;
        }
      }

      if (bondingCurveData) {
        logger.info({
          mint,
          source: 'PumpPortal',
          marketCapSol: bondingCurveData.marketCapSol.toFixed(2),
          liquiditySol: bondingCurveData.liquiditySol.toFixed(4),
          priceSol: bondingCurveData.priceSol.toExponential(4),
          isGraduated: bondingCurveData.isGraduated,
        }, 'Got bonding curve data');

        // Mark as bonding curve token for trade routing
        txManager.markAsBondingCurve(mint);
      } else if (!priceData) {
        // Try DexScreener as fallback (might be graduated)
        for (let retry = 0; retry < 2; retry++) {
          logger.info({ mint, retry: retry + 1 }, 'Trying DexScreener fallback...');
          await new Promise(r => setTimeout(r, 3000));
          priceData = await priceFeed.fetchTokenPrice(mint);
          if (priceData) {
            txManager.markAsGraduated(mint);
            break;
          }
        }
      }
    }

    // Determine liquidity
    let liquiditySol = 0;
    let priceSol = 0;
    let isBondingCurve = false;

    if (bondingCurveData) {
      // For bonding curve tokens, use marketCapSol as liquidity indicator
      // liquiditySol from bonding curve is essentially 0 for new tokens
      // marketCapSol is a better indicator of whether the token is tradeable
      liquiditySol = bondingCurveData.marketCapSol; // Use marketCap as proxy for new tokens
      priceSol = bondingCurveData.priceSol;
      isBondingCurve = true;
    } else if (priceData) {
      liquiditySol = priceData.liquidity / (priceFeed.getSolPrice() || 200); // Convert USD to SOL
      priceSol = priceData.priceSol;
    }

    // Minimum liquidity threshold - lower for bonding curve tokens
    const minLiquidity = isBondingCurve ? 10 : config.minLiquiditySol; // 10 SOL mcap for new tokens

    logger.info({
      mint,
      source: bondingCurveData ? 'PumpPortal' : (priceData ? 'DexScreener' : 'none'),
      liquiditySol: liquiditySol.toFixed(4),
      priceSol: priceSol.toExponential(4),
      minRequired: minLiquidity,
      isBondingCurve
    }, 'Liquidity check');

    // No data from either source
    if (!bondingCurveData && !priceData) {
      this.rejectionStats.liquidity++;
      this.rejectionStats.total++;
      logger.warn({ mint }, 'REJECTED: No price data from PumpPortal or DexScreener');
      return;
    }

    if (liquiditySol < minLiquidity) {
      this.rejectionStats.liquidity++;
      this.rejectionStats.total++;
      logger.info({ mint, liquiditySol, minRequired: minLiquidity }, 'REJECTED: Insufficient liquidity');
      return;
    }

    // Create unified price data for downstream processing
    // If using bonding curve data, convert to PriceData format
    if (!priceData && bondingCurveData) {
      const solPrice = priceFeed.getSolPrice() || 200;
      priceData = {
        mint,
        priceSol: bondingCurveData.priceSol,
        priceUsd: bondingCurveData.priceSol * solPrice,
        volume24h: 0,
        marketCapSol: bondingCurveData.marketCapSol,
        liquidity: bondingCurveData.liquiditySol * solPrice, // Convert to USD
        priceChange1m: 0,
        priceChange5m: 0,
        priceChange1h: 0,
        timestamp: bondingCurveData.timestamp,
      };
    }

    // Full rug analysis (LP info passed as null - loses 25 potential points)
    const rugScore = await rugDetector.analyzeToken(mint, tokenInfo, holderInfo, null);

    // Get narrative signal (async but don't block critical path too long)
    // We fire and forget the broadcast, or await if we want it in decision (future)
    narrativeSensor.getNarrativeSignal(tokenInfo?.symbol).then((signal: NarrativeSignal) => {
      apiServer.getIO().emit('signal:narrative', {
        mint,
        symbol: tokenInfo?.symbol,
        ...signal
      });
    }).catch((err: unknown) => logger.error({ err }, 'Failed to get narrative signal'));

    logger.info({
      mint,
      rugTotal: rugScore.total,
      minRequired: config.minRugScore,
      mintAuth: rugScore.mintAuthorityScore,
      freezeAuth: rugScore.freezeAuthorityScore,
      lpLocked: rugScore.lpLockedScore,
      concentration: rugScore.concentrationScore,
      bundledBuys: rugScore.bundledBuysScore,
    }, 'Rug analysis breakdown');

    if (!rugDetector.isSafe(rugScore)) {
      this.rejectionStats.rugScore++;
      this.rejectionStats.total++;
      logger.info({ mint, rugTotal: rugScore.total, minRequired: config.minRugScore }, 'REJECTED: Token failed rug check');
      return;
    }

    // Extract features (priceData is guaranteed non-null here due to earlier checks)
    const features = await featureExtractor.extractFeatures(
      mint,
      priceData!,
      holderInfo,
      tokenInfo
    );

    // Entry evaluation: uses pump detector if price history exists, otherwise velocity
    priceFeed.addToWatchList(mint); // Start tracking
    await new Promise((r) => setTimeout(r, 2000)); // Reduced delay for faster entry

    // Use unified entry evaluator
    const entryResult = entryEvaluator.evaluate(mint, bondingCurveData?.marketCapSol);

    // Also get pump metrics for logging/display regardless of entry source
    const pumpMetrics = pumpDetector.analyzePump(mint);
    logger.info({
      mint,
      entrySource: entryResult.source,
      canEnter: entryResult.canEnter,
      entryReason: entryResult.reason,
      phase: pumpMetrics.phase,
      heat: pumpMetrics.heat,
      buyPressure: pumpMetrics.buyPressure,
      confidence: pumpMetrics.confidence,
    }, 'Entry evaluation');

    // Check if good entry
    if (!entryResult.canEnter) {
      this.rejectionStats.entryEval++;
      this.rejectionStats.total++;
      logger.info({ mint, source: entryResult.source, reason: entryResult.reason }, 'REJECTED: Entry evaluation failed');
      priceFeed.removeFromWatchList(mint);
      velocityTracker.clearToken(mint);
      pumpPortalWs.unsubscribeFromToken(mint);
      return;
    }

    // Extract buy pressure from entry evaluation for AI confidence calculation
    // Use velocity metrics if available, otherwise fall back to pump metrics
    let entryBuyPressure = pumpMetrics.buyPressure;
    if (entryResult.metrics && 'buyPressure' in entryResult.metrics) {
      entryBuyPressure = entryResult.metrics.buyPressure;
    }

    // AI Decision
    const decision = this.makeDecision(features, rugScore, pumpMetrics, mint, entryBuyPressure);
    
    // Broadcast AI decision
    apiServer.getIO().emit('ai:decision', {
      ...decision,
      mint,
      symbol: tokenInfo?.symbol || 'UNKNOWN',
    });

    logger.info({
      mint,
      action: Action[decision.action],
      qValues: decision.qValues,
      confidence: decision.confidence,
      regime: decision.regime,
    }, 'AI decision');

    if (decision.action !== Action.BUY) {
      this.rejectionStats.aiDecision++;
      this.rejectionStats.total++;
      logger.info({ mint, action: Action[decision.action], qValues: decision.qValues }, 'REJECTED: AI decided not to buy');
      priceFeed.removeFromWatchList(mint);
      return;
    }

    // Risk check
    const poolType = capitalAllocator.suggestPoolType(rugScore.total);
    const riskCheck = capitalAllocator.checkRisk(decision.positionSize.sizeSol, poolType);
    logger.info({
      mint,
      poolType,
      requestedSize: decision.positionSize.sizeSol,
      openPositions: positionManager.getOpenPositions().length,
      maxPositions: config.maxConcurrentPositions,
      approved: riskCheck.approved,
      adjustedSize: riskCheck.adjustedSize,
    }, 'Risk check input');

    if (!riskCheck.approved) {
      this.rejectionStats.riskCheck++;
      this.rejectionStats.total++;
      logger.info({ mint, reason: riskCheck.reason, poolType, requestedSize: decision.positionSize.sizeSol }, 'REJECTED: Risk check failed');
      priceFeed.removeFromWatchList(mint);
      return;
    }

    // All filters passed!
    this.rejectionStats.passed++;
    logger.info({ mint, rugScore: rugScore.total, heat: pumpMetrics.heat, poolType }, 'PASSED: All filters - proceeding to trade');

    // Execute trade
    await this.executeBuy(
      mint,
      tokenInfo?.symbol || 'UNKNOWN',
      riskCheck.adjustedSize || decision.positionSize.sizeSol,
      priceData!.priceSol,
      features,
      pumpMetrics,
      poolType,
      token.creator
    );
  }

  private makeDecision(
    features: StateVector,
    rugScore: RugScore,
    pumpMetrics: PumpMetrics,
    mint?: string,  // NEW: Pass mint for dynamic threshold lookup
    entryBuyPressure?: number  // NEW: Buy pressure from entry evaluation
  ): AIDecision {
    const stateArray = featureExtractor.toArray(features);
    const { action, qValues } = ddqnAgent.selectAction(stateArray);

    const regime = regimeDetector.getCurrentRegime().regime;
    const availableCapital = capitalAllocator.getAvailableCapital('active');

    // Check if DDQN is in exploration mode (qValues all zeros)
    const isExplorationMode = qValues.every(q => q === 0);

    // Adjust confidence based on signals
    let confidence: number;
    if (isExplorationMode && entryBuyPressure !== undefined) {
      // In exploration mode, use entry evaluation's buy pressure directly as confidence
      // Entry evaluation already validated the token (5+ txs, 3+ buyers, good buy pressure)
      // Rug score was already validated separately (>45 threshold)
      // So use buyPressure directly - 67% buy pressure = 0.67 confidence
      confidence = entryBuyPressure;
      logger.info({
        mint: mint?.substring(0, 15),
        entryBuyPressure: entryBuyPressure.toFixed(2),
        rugScore: rugScore.total,
        confidence: confidence.toFixed(2),
      }, 'Using entry buy pressure as confidence (exploration mode)');
    } else {
      // Normal mode: use qValues spread as confidence
      confidence = Math.max(...qValues) - Math.min(...qValues);
      confidence *= rugScore.total / 100;
      confidence *= pumpMetrics.confidence;
    }

    // NEW: Get dynamic confidence threshold and momentum override
    let requiredConfidence = config.watchlist?.minConfidence || 0.55;
    let hasMomentumOverride = false;

    // In exploration mode, lower the threshold to allow trading while model learns
    // This matches the velocity tracker's minBuyPressure of 0.50
    if (isExplorationMode) {
      requiredConfidence = 0.50;
      logger.debug({ requiredConfidence }, 'Exploration mode: lowered confidence threshold');
    } else if (mint) {
      // Dynamic confidence threshold based on token age
      requiredConfidence = tokenWatchlist.getDynamicConfidenceThreshold(mint);

      // Check momentum override
      const momentumSignal = tokenWatchlist.getMomentumSignal(mint);
      if (momentumSignal?.hasMomentum) {
        hasMomentumOverride = true;
        const momentumFloor = config.momentumOverride?.confidenceFloor || 0.45;
        // If momentum is strong, use lower confidence floor
        requiredConfidence = Math.min(requiredConfidence, momentumFloor);
        logger.info({
          mint: mint.substring(0, 15),
          ...momentumSignal,
          adjustedThreshold: requiredConfidence.toFixed(2),
        }, 'MOMENTUM OVERRIDE - Lowering confidence threshold');
      }
    }

    // Handle action override based on confidence
    let finalAction = action;

    // In exploration mode with good confidence, FORCE BUY (don't rely on random action)
    if (isExplorationMode && confidence >= requiredConfidence) {
      finalAction = Action.BUY;
      logger.info({
        mint: mint?.substring(0, 15),
        confidence: confidence.toFixed(2),
        requiredConfidence: requiredConfidence.toFixed(2),
        originalAction: Action[action],
      }, 'EXPLORATION MODE: Forcing BUY (confidence above threshold)');
    } else if (action === Action.BUY && confidence < requiredConfidence) {
      // Normal mode: Block BUY if confidence is below threshold
      finalAction = Action.HOLD;
      logger.info({
        mint: mint?.substring(0, 15),
        confidence: confidence.toFixed(2),
        requiredConfidence: requiredConfidence.toFixed(2),
        hasMomentum: hasMomentumOverride,
      }, 'BUY blocked - confidence below dynamic threshold');
    }

    // NEW: Pass confidence to position sizer for dynamic sizing
    const positionSize = positionSizer.calculateSize(
      availableCapital,
      undefined,
      undefined,
      regime,
      confidence  // NEW: Use confidence as size multiplier
    );

    return {
      action: finalAction,
      confidence,
      regime,
      positionSize,
      qValues,
      features: stateArray,
      timestamp: new Date(),
    };
  }

  private async executeBuy(
    mint: string,
    symbol: string,
    sizeSol: number,
    currentPrice: number,
    features: StateVector,
    pumpMetrics: PumpMetrics,
    poolType: 'active' | 'high_risk',
    creator: string
  ): Promise<void> {
    logger.info({
      mint,
      symbol,
      sizeSol,
      currentPrice,
      poolType,
    }, 'Executing buy');

    const result = await txManager.executeBuy(mint, sizeSol, {
      slippageBps: config.defaultSlippageBps,  // 15% slippage
      maxRetries: 3,
    });

    if (!result.success) {
      logger.error({ mint, error: result.error }, 'Buy failed');
      priceFeed.removeFromWatchList(mint);
      return;
    }

    // CRITICAL: Verify actual token balance before creating position
    // This prevents phantom positions when buy tx fails silently
    // In paper trading mode, skip balance check and use simulated amount
    let amountTokens: number;
    let actualPrice: number;

    if (config.paperTrading) {
      // Paper trading: use simulated output amount
      amountTokens = result.outputAmount || (sizeSol * 1_000_000); // Fallback estimate
      actualPrice = sizeSol / amountTokens;
      logger.info({
        mint,
        mode: 'PAPER',
        simulatedTokens: amountTokens,
        calculatedPrice: actualPrice
      }, 'Paper trade: using simulated token amount');
    } else {
      // Real trading: use outputAmount from swap if available (parsed from postTokenBalances)
      // Fall back to balance check with retries only if outputAmount is 0
      if (result.outputAmount && result.outputAmount > 0) {
        amountTokens = result.outputAmount;
        actualPrice = sizeSol / amountTokens;
        logger.info({
          mint,
          amountTokens,
          actualPrice,
          source: 'postTokenBalances',
        }, 'Using token amount from transaction postTokenBalances');
      } else {
        // Fallback: verify actual on-chain balance with retries
        // Token accounts may take time to be indexed, so retry multiple times
        let actualBalance = 0;
        const maxRetries = 5;
        const retryDelays = [2000, 3000, 3000, 4000, 5000]; // Total max wait: 17 seconds

        for (let attempt = 0; attempt < maxRetries; attempt++) {
          await this.sleep(retryDelays[attempt]);
          actualBalance = await txManager.getTokenBalance(mint);

          if (actualBalance > 0) {
            logger.info({
              mint,
              actualBalance,
              attempt: attempt + 1,
            }, 'Token balance confirmed via getTokenBalance');
            break;
          }

          logger.warn({
            mint,
            attempt: attempt + 1,
            maxRetries,
            delayMs: retryDelays[attempt],
          }, 'Token balance still 0, retrying...');
        }

        if (actualBalance <= 0) {
          logger.error({
            mint,
            signature: result.signature,
            expectedTokens: result.outputAmount || 'unknown',
            actualBalance,
            retriesAttempted: maxRetries,
          }, 'Buy tx succeeded but no tokens received after retries - NOT creating position');
          priceFeed.removeFromWatchList(mint);
          return;
        }

        amountTokens = actualBalance;
        actualPrice = sizeSol / amountTokens;
      }
    }

    logger.info({
      mint,
      amountTokens,
      calculatedPrice: actualPrice,
      mode: config.paperTrading ? 'PAPER' : 'LIVE'
    }, 'Position ready to open');

    // Open position
    const position = await positionManager.openPosition({
      mint,
      symbol,
      entryPrice: actualPrice,
      amount: amountTokens,
      amountSol: sizeSol,
      poolType,
    });

    // Start watching for rug signals
    const bondingCurveData = this.bondingCurveCache.get(mint);
    rugMonitor.watchPosition({
      mint,
      creator,
      entryPrice: actualPrice,
      entryMarketCapSol: bondingCurveData?.marketCapSol || 0,
    });

    // Log trade entry
    await tradeLogger.logEntry({
      positionId: position.id,
      mint,
      symbol,
      entryPrice: actualPrice,
      amount: amountTokens,
      amountSol: sizeSol,
      features,
      regime: regimeDetector.getCurrentRegime().regime,
      pumpPhase: pumpMetrics.phase,
    });

    logger.info({
      positionId: position.id,
      mint,
      symbol,
      amountSol: sizeSol,
      amountTokens,
      entryPrice: actualPrice,
    }, 'Position opened');
  }

  private startStatusLogger(): void {
    setInterval(async () => {
      if (!this.isRunning) return;

      const allocation = capitalAllocator.getAllocation();
      const positions = positionManager.getOpenPositions();
      const drawdown = drawdownGuard.getState();

      logger.info({
        equity: allocation.totalSol.toFixed(4),
        positions: positions.length,
        drawdown: (drawdown.currentDrawdown * 100).toFixed(2),
        dailyPnl: drawdown.dailyPnl.toFixed(4),
        regime: regimeDetector.getRegimeName(),
        paused: drawdown.isPaused,
      }, 'Status');

      // Log rejection stats
      const stats = this.rejectionStats;
      if (stats.total > 0) {
        logger.info({
          quickSafety: stats.quickSafety,
          liquidity: stats.liquidity,
          rugScore: stats.rugScore,
          entryEval: stats.entryEval,
          aiDecision: stats.aiDecision,
          riskCheck: stats.riskCheck,
          total: stats.total,
          passed: stats.passed,
          passRate: ((stats.passed / (stats.total + stats.passed)) * 100).toFixed(1) + '%',
        }, 'Rejection Stats');
      }

      // Log watchlist stats
      const watchlistStats = tokenWatchlist.getStats();
      if (watchlistStats.total > 0) {
        logger.info({
          watching: watchlistStats.total,
          ready: watchlistStats.ready,
          devSold: watchlistStats.devSold,
        }, 'Watchlist Stats');
      }

    }, 60000); // Log every minute
  }

  async stop(): Promise<void> {
    logger.info('Stopping bot...');
    this.isRunning = false;

    // Stop all components
    modelTrainer.stopPeriodicTraining();
    await heliusWs.disconnect();
    priceFeed.stop();
    whaleTracker.stop();
    regimeDetector.stop();
    positionManager.stop();
    drawdownGuard.stop();

    // Stop new services
    walletSync.stop();
    equityTracker.stop();

    // Stop C100 services
    c100Tracker.stop();
    rewardClaimer.stop();

    // Stop API server
    await apiServer.stop();

    await repository.close();

    logger.info('Bot stopped');
  }

  async getStatus(): Promise<{
    isRunning: boolean;
    allocation: string;
    drawdown: string;
    training: string;
    performance: string;
  }> {
    const metrics = await performanceAnalytics.calculateMetrics();

    return {
      isRunning: this.isRunning,
      allocation: capitalAllocator.getStatus(),
      drawdown: drawdownGuard.getStatus(),
      training: modelTrainer.getTrainingStatus(),
      performance: performanceAnalytics.formatMetrics(metrics),
    };
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Main entry point
const bot = new TradingBot();

process.on('SIGINT', async () => {
  logger.info('Received SIGINT, shutting down...');
  await bot.stop();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('Received SIGTERM, shutting down...');
  await bot.stop();
  process.exit(0);
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error({ reason, promise }, 'Unhandled rejection');
});

process.on('uncaughtException', (error) => {
  logger.error({ error }, 'Uncaught exception');
  process.exit(1);
});

// Start the bot
bot.start().catch((error) => {
  logger.error({ error }, 'Failed to start bot');
  process.exit(1);
});

export { TradingBot, bot };
</file>

</files>
