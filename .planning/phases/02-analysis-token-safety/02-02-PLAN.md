---
phase: 02-analysis-token-safety
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/analysis/token-safety.ts
  - src/analysis/index.ts
autonomous: true

must_haves:
  truths:
    - "Agent can detect honeypot tokens and refuse to trade them"
    - "Token safety analysis checks mint authority, freeze authority, AND Token-2022 extensions"
    - "Permanent delegate extension is flagged as critical risk"
    - "Analysis results are cached for 24 hours"
  artifacts:
    - path: "src/analysis/token-safety.ts"
      provides: "TokenSafetyAnalyzer class"
      exports: ["TokenSafetyAnalyzer"]
      min_lines: 80
    - path: "src/analysis/index.ts"
      provides: "Barrel export for analysis module"
      exports: ["TokenSafetyAnalyzer"]
  key_links:
    - from: "src/analysis/token-safety.ts"
      to: "HeliusClient.getAsset"
      via: "method call"
      pattern: "this\\.helius\\.getAsset"
    - from: "src/analysis/token-safety.ts"
      to: "AnalysisCacheRepository"
      via: "cache integration"
      pattern: "this\\.cache\\.(get|set)"
---

<objective>
Create TokenSafetyAnalyzer that detects honeypot tokens by checking authorities and Token-2022 extensions.

Purpose: Enable the agent to identify dangerous tokens before trading. This satisfies ANAL-01 (honeypot detection, rug indicators).

Output:
- src/analysis/token-safety.ts with TokenSafetyAnalyzer class
- src/analysis/index.ts barrel export
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-analysis-token-safety/02-RESEARCH.md
@.planning/phases/02-analysis-token-safety/02-01-SUMMARY.md

# Foundation from Plan 01
@schizo-agent/src/analysis/types.ts
@schizo-agent/src/api/helius.ts
@schizo-agent/src/db/repositories/analysis-cache.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TokenSafetyAnalyzer</name>
  <files>src/analysis/token-safety.ts</files>
  <action>
Create src/analysis/token-safety.ts:

Imports:
- HeliusClient from '../api/helius.js'
- AnalysisCacheRepository from '../db/repositories/analysis-cache.js'
- Types from './types.js': TokenSafetyResult, TokenRisk, GetAssetResponse, CACHE_TTL
- createLogger from '../lib/logger.js'

TokenSafetyAnalyzer class:
- constructor(helius: HeliusClient, cache: AnalysisCacheRepository)
- logger = createLogger('token-safety')

async analyze(mintAddress: string): Promise<TokenSafetyResult>:
1. Check cache first: cache.get<TokenSafetyResult>(mintAddress, 'token_safety')
   - If cached and not expired, return cached result
   - Log debug: 'Cache hit for token safety', { mintAddress }

2. Fetch from Helius: await this.helius.getAsset(mintAddress)
   - Wrap in try/catch, log error and re-throw on failure

3. Analyze safety using private method: this.analyzeAsset(asset)

4. Cache result: cache.set(mintAddress, 'token_safety', result, CACHE_TTL.tokenSafety)

5. Return result

private analyzeAsset(asset: GetAssetResponse): TokenSafetyResult
Follow the analyzeTokenSafety pattern from 02-RESEARCH.md exactly:

1. Initialize risks: TokenRisk[] = []

2. Check classic authorities (asset.token_info):
   - if mint_authority exists and not null: risks.push('MINT_AUTHORITY_ACTIVE')
   - if freeze_authority exists and not null: risks.push('FREEZE_AUTHORITY_ACTIVE')

3. Check Token-2022 extensions (asset.mint_extensions) - CRITICAL:
   - if permanent_delegate exists: risks.push('PERMANENT_DELEGATE')
   - if transfer_fee_config exists AND transfer_fee_basis_points > 100: risks.push('HIGH_TRANSFER_FEE')
   - if transfer_hook exists: risks.push('TRANSFER_HOOK')

4. Check metadata mutability:
   - if asset.mutable === true: risks.push('MUTABLE_METADATA')

5. Determine isSafe:
   - Safe if: risks.length === 0 OR (risks.length === 1 AND risks[0] === 'MUTABLE_METADATA')
   - Mutable metadata alone is a WARNING not a block

6. Build and return TokenSafetyResult object matching types.ts interface

Helper method:
isSafe(result: TokenSafetyResult): boolean - convenience method returns result.isSafe
  </action>
  <verify>
- TypeScript compiles: `cd schizo-agent && npx tsc --noEmit`
- Class has analyze and isSafe methods
  </verify>
  <done>
- TokenSafetyAnalyzer checks ALL safety indicators per RESEARCH.md
- Permanent delegate extension is flagged as critical risk
- Results are cached with 24h TTL
  </done>
</task>

<task type="auto">
  <name>Task 2: Create analysis module barrel export</name>
  <files>src/analysis/index.ts</files>
  <action>
Create src/analysis/index.ts:

Export all types:
- export * from './types.js'

Export TokenSafetyAnalyzer:
- export { TokenSafetyAnalyzer } from './token-safety.js'

Note: WalletAnalyzer and SmartMoneyTracker will be added in subsequent plans.
  </action>
  <verify>
- TypeScript compiles: `cd schizo-agent && npx tsc --noEmit`
- Module exports TokenSafetyAnalyzer
  </verify>
  <done>
- src/analysis/index.ts exports types and TokenSafetyAnalyzer
  </done>
</task>

</tasks>

<verification>
```bash
cd schizo-agent
npx tsc --noEmit
# Should compile without errors

# Build and verify exports
npm run build 2>/dev/null || npx tsc

# Verify TokenSafetyAnalyzer is exported
node -e "import('./dist/analysis/index.js').then(m => console.log('TokenSafetyAnalyzer:', typeof m.TokenSafetyAnalyzer))"
```
</verification>

<success_criteria>
- TypeScript compiles with no errors
- TokenSafetyAnalyzer.analyze() checks mint authority, freeze authority, permanent delegate, transfer fee, transfer hook, metadata mutability
- PERMANENT_DELEGATE is always treated as unsafe (most dangerous indicator per RESEARCH.md)
- Results cached with 24h TTL
- Module exported from src/analysis/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/02-analysis-token-safety/02-02-SUMMARY.md`
</output>
