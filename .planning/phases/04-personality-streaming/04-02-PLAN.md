# Phase 04 Plan 02: Event System & Streaming

**Phase:** 4 of 4  
**Plan:** 02 of 03  
**Focus:** Real-time event broadcasting  
**Estimated Duration:** 20 minutes

## Objective

Create an event-driven system to stream the agent's thoughts and actions in real-time via WebSocket.

## Must-Haves

**Truth 1:** Events emitted for all major agent actions
- Analysis start/complete
- Safety checks
- Trade decisions
- Trade execution
- Buybacks

**Truth 2:** WebSocket server broadcasts events
- Real-time streaming to connected clients
- JSON event format
- Connection management

**Truth 3:** Integration with existing modules
- Trading Engine emits events
- Analysis modules emit events
- No breaking changes to existing code

## Proposed Changes

### Event System (`src/events/`)

**Event Types (`src/events/types.ts`):**
```typescript
export type AgentEvent =
  | { type: 'ANALYSIS_START'; timestamp: number; data: { mint: string } }
  | { type: 'SAFETY_CHECK'; timestamp: number; data: { mint: string; result: TokenSafetyResult } }
  | { type: 'SMART_MONEY_CHECK'; timestamp: number; data: { mint: string; count: number } }
  | { type: 'TRADE_DECISION'; timestamp: number; data: { mint: string; decision: TradeDecision; reasoning?: string } }
  | { type: 'TRADE_EXECUTED'; timestamp: number; data: { mint: string; type: 'BUY' | 'SELL'; signature: string; amount: number } }
  | { type: 'BUYBACK_TRIGGERED'; timestamp: number; data: { profit: number; amount: number; signature: string } };
```

**Event Emitter (`src/events/emitter.ts`):**
```typescript
export class AgentEventEmitter {
  private listeners: Map<string, Set<(event: AgentEvent) => void>>;
  
  emit(event: AgentEvent): void;
  on(eventType: string, callback: (event: AgentEvent) => void): void;
  off(eventType: string, callback: (event: AgentEvent) => void): void;
  onAny(callback: (event: AgentEvent) => void): void; // Listen to all events
}
```

### WebSocket Server (`src/server/`)

**WebSocket Server (`src/server/websocket.ts`):**
```typescript
import { WebSocketServer } from 'ws';
import type { AgentEventEmitter } from '../events/emitter.js';

export function createWebSocketServer(
  port: number,
  eventEmitter: AgentEventEmitter
): WebSocketServer {
  const wss = new WebSocketServer({ port });
  
  wss.on('connection', (ws) => {
    // Send all events to this client
    const handler = (event: AgentEvent) => {
      ws.send(JSON.stringify(event));
    };
    
    eventEmitter.onAny(handler);
    
    ws.on('close', () => {
      // Cleanup
    });
  });
  
  return wss;
}
```

### Integration with Trading Engine

**Emit events at key points:**
```typescript
// In evaluateToken()
this.events.emit({
  type: 'ANALYSIS_START',
  timestamp: Date.now(),
  data: { mint },
});

// After safety analysis
this.events.emit({
  type: 'SAFETY_CHECK',
  timestamp: Date.now(),
  data: { mint, result: safetyAnalysis },
});

// After decision
this.events.emit({
  type: 'TRADE_DECISION',
  timestamp: Date.now(),
  data: { mint, decision, reasoning },
});
```

## Verification Plan

### Unit Tests
- Event emitter adds/removes listeners correctly
- Events are emitted with correct format
- WebSocket server accepts connections

### Integration Tests
- Trading Engine emits events during evaluation
- WebSocket clients receive events
- Multiple clients can connect simultaneously

### Manual Testing
```bash
# Terminal 1: Start WebSocket server
npm run dev

# Terminal 2: Connect with wscat
npx wscat -c ws://localhost:8080

# Should see events streaming as agent runs
```

## Dependencies

- `ws` npm package for WebSocket server
- Phase 1-3: All modules to integrate with
- Plan 04-01: Personality for reasoning events

## Implementation Notes

**Singleton Pattern:**
- Use singleton for event emitter
- Share across all modules
- Prevents duplicate events

**Non-Blocking:**
- Event emission should not block trading
- Fire-and-forget pattern
- Error handling for listener failures

**Environment Configuration:**
```bash
WEBSOCKET_PORT=8080
```

---

*Ready for implementation.*
