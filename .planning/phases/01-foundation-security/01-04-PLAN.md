---
phase: 01-foundation-security
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/api/cache.ts
  - src/api/rate-limiter.ts
  - src/api/helius.ts
  - src/api/index.ts
autonomous: true

must_haves:
  truths:
    - "API calls are rate-limited (no 429 errors under normal load)"
    - "Cached responses return instantly without API call"
    - "Transient errors trigger retry with backoff"
    - "Circuit breaker opens after repeated failures"
  artifacts:
    - path: "src/api/cache.ts"
      provides: "TTL-based in-memory cache"
      exports: ["TTLCache"]
    - path: "src/api/rate-limiter.ts"
      provides: "Bottleneck rate limiter configuration"
      exports: ["createRateLimiter", "RateLimiterConfig"]
    - path: "src/api/helius.ts"
      provides: "Helius API client with caching, rate limiting, retry"
      exports: ["HeliusClient"]
  key_links:
    - from: "src/api/helius.ts"
      to: "src/api/cache.ts"
      via: "cache lookups before API calls"
      pattern: "cache\\.get|cache\\.set"
    - from: "src/api/helius.ts"
      to: "src/api/rate-limiter.ts"
      via: "rate limited scheduling"
      pattern: "limiter\\.schedule"
---

<objective>
Implement rate-limited Helius API client with caching and resilience (FOUND-03).

Purpose: Helius API has strict rate limits and charges credits per call. This module prevents rate limit errors through Bottleneck, reduces API calls through TTL caching, handles transient errors with retry/backoff, and protects against cascading failures with a circuit breaker.

Output: HeliusClient class ready for wallet analysis in Phase 2.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-security/01-RESEARCH.md

Reference research sections 3-6 for API implementation details.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TTL cache and rate limiter</name>
  <files>src/api/cache.ts, src/api/rate-limiter.ts</files>
  <action>
    Create src/api/cache.ts:

    1. Define CacheEntry<T> interface:
       - data: T
       - expiresAt: number

    2. Implement TTLCache<T> class:
       - private cache: Map<string, CacheEntry<T>>
       - constructor(defaultTTL: number = 60000) // 1 minute default
       - set(key: string, value: T, ttl?: number): void
       - get(key: string): T | undefined (returns undefined if expired, deletes entry)
       - has(key: string): boolean
       - delete(key: string): void
       - clear(): void
       - size(): number
       - cleanup(): void (remove all expired entries, for periodic cleanup)

    3. Export TTLCache

    Create src/api/rate-limiter.ts:

    1. Import Bottleneck from 'bottleneck'
    2. Import createLogger

    3. Define RateLimiterConfig interface:
       - maxConcurrent: number
       - minTime: number (ms between requests)
       - reservoir?: number
       - reservoirRefreshAmount?: number
       - reservoirRefreshInterval?: number

    4. Define HeliusTier enum or type:
       - 'free': 10 RPS RPC, 2 RPS enhanced
       - 'developer': 50 RPS RPC, 10 RPS enhanced
       - 'business': 200 RPS RPC, 50 RPS enhanced

    5. Implement getConfigForTier(tier: HeliusTier): { rpc: RateLimiterConfig, enhanced: RateLimiterConfig }
       Returns appropriate rate limits for each tier with safety margin (80% of limit)

    6. Implement createRateLimiter(config: RateLimiterConfig): Bottleneck
       - Create Bottleneck instance with config
       - Add 'failed' event handler for 429 errors (return 5000ms retry delay)
       - Add 'retry' event handler for logging
       - Return limiter

    7. Export createRateLimiter, getConfigForTier, RateLimiterConfig, HeliusTier
  </action>
  <verify>
    Test in src/index.ts:
    1. Create TTLCache with 100ms TTL
    2. Set value, get immediately (should return)
    3. Wait 150ms, get again (should return undefined)
    4. Create rate limiter for 'developer' tier
    5. Schedule 5 concurrent tasks, verify they complete without error
  </verify>
  <done>
    TTLCache expires entries correctly
    Rate limiter respects concurrency limits
    429 handler configured for retry
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement HeliusClient with resilience</name>
  <files>src/api/helius.ts, src/api/index.ts</files>
  <action>
    Create src/api/helius.ts:

    1. Import:
       - Bottleneck
       - pRetry from 'p-retry'
       - CircuitBreaker from 'opossum'
       - TTLCache from './cache.js'
       - createRateLimiter, getConfigForTier, HeliusTier from './rate-limiter.js'
       - createLogger

    2. Define HeliusClientConfig interface:
       - apiKey: string
       - tier: HeliusTier (default 'developer')
       - cacheTTL: number (default 30000 - 30 seconds)
       - baseUrl?: string (default mainnet)

    3. Define TransactionResult interface (simplified for now):
       - signature: string
       - timestamp: number
       - type: string
       - success: boolean
       - (add more fields as needed in Phase 2)

    4. Implement HeliusClient class:

       Private fields:
       - apiKey: string
       - baseUrl: string
       - cache: TTLCache<any>
       - rpcLimiter: Bottleneck
       - enhancedLimiter: Bottleneck
       - circuitBreaker: CircuitBreaker
       - logger

       constructor(config: HeliusClientConfig):
       - Store config
       - Initialize cache with TTL
       - Create rate limiters for tier
       - Create circuit breaker with:
         - timeout: 15000 (15s)
         - errorThresholdPercentage: 50
         - resetTimeout: 30000 (30s)
         - volumeThreshold: 5
       - Wire circuit breaker events to logger (open, halfOpen, close)

       async getTransactionsForAddress(address: string, options?: { limit?: number }): Promise<any>
       - Build cache key: `txs:${address}:${limit}`
       - Check cache, return if hit
       - Use circuit breaker to wrap the rate-limited fetch
       - Inside: rpcLimiter.schedule -> pRetry(fetch, { retries: 3, ... })
       - On success: cache result (skip caching if paginating)
       - Return result

       Private async fetchWithRetry(url: string, body: object): Promise<any>
       - Wrap fetch in pRetry
       - Retry on 429 and 5xx
       - Abort (don't retry) on 4xx client errors
       - Log retry attempts

       getConnection(): Connection (for @solana/web3.js integration)
       - Return new Connection with Helius RPC URL

       getCacheStats(): { size: number, hits: number, misses: number }
       - Track and return cache statistics

    Create src/api/index.ts:
       - Export HeliusClient, HeliusClientConfig from './helius.js'
       - Export TTLCache from './cache.js'
       - Export createRateLimiter, HeliusTier from './rate-limiter.js'
  </action>
  <verify>
    Test in src/index.ts (requires HELIUS_API_KEY env var):
    1. Create HeliusClient with tier 'developer'
    2. Call getTransactionsForAddress for a known wallet (use Helius or other known address)
    3. Call again immediately, verify cache hit (instant return)
    4. Check getCacheStats() shows hit
    5. Verify no 429 errors in logs

    If no API key available, test rate limiter and cache in isolation.
  </verify>
  <done>
    HeliusClient fetches transactions successfully
    Cache prevents duplicate API calls
    Rate limiter throttles concurrent requests
    Circuit breaker logs state changes
    Connection getter returns valid Solana connection
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should compile without errors
2. Run `npm run dev` with HELIUS_API_KEY set - should complete API tests
3. Check logs for rate limiter and circuit breaker messages
4. Verify cache stats show expected hits after repeated calls
5. Confirm no 429 rate limit errors during normal operation
</verification>

<success_criteria>
- TTLCache correctly expires entries
- Rate limiter prevents exceeding tier limits
- HeliusClient caches API responses
- Retry logic handles transient failures
- Circuit breaker protects against cascading failures
- All components integrate without conflicts
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-04-SUMMARY.md`
</output>
