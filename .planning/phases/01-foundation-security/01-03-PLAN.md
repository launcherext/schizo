---
phase: 01-foundation-security
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/db/database.ts
  - src/db/schema.ts
  - src/db/repositories/trades.ts
  - src/db/repositories/state.ts
  - src/db/index.ts
autonomous: true

must_haves:
  truths:
    - "Database opens with WAL mode enabled"
    - "Trades can be inserted and retrieved"
    - "State persists across database close/reopen"
    - "P&L snapshots record token holdings as JSON"
  artifacts:
    - path: "src/db/database.ts"
      provides: "Database connection with WAL mode"
      exports: ["createDatabase", "Database"]
    - path: "src/db/schema.ts"
      provides: "Schema initialization"
      exports: ["initializeSchema"]
    - path: "src/db/repositories/trades.ts"
      provides: "Trade CRUD operations"
      exports: ["TradeRepository", "Trade"]
    - path: "src/db/repositories/state.ts"
      provides: "Agent state and P&L operations"
      exports: ["StateRepository", "PnLSnapshot"]
  key_links:
    - from: "src/db/database.ts"
      to: "src/db/schema.ts"
      via: "schema initialization on open"
      pattern: "initializeSchema"
    - from: "src/db/repositories/trades.ts"
      to: "src/db/database.ts"
      via: "database injection"
      pattern: "constructor.*Database"
---

<objective>
Implement SQLite state store for persistent trade history and agent state (FOUND-02).

Purpose: Agent must survive restarts without losing trade history, analysis results, or P&L tracking. SQLite with WAL mode provides reliable, high-performance local storage that's easy to backup and inspect.

Output: Database module with repositories for trades, P&L snapshots, analysis cache, and agent state.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-security/01-RESEARCH.md

Reference research section 7 for SQLite implementation details.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database connection and schema</name>
  <files>src/db/database.ts, src/db/schema.ts</files>
  <action>
    Create src/db/database.ts:

    1. Import Database from 'better-sqlite3'
    2. Import createLogger from '../lib/logger.js'
    3. Import initializeSchema from './schema.js'

    4. Implement createDatabase(filepath: string): Database.Database
       - Open database with better-sqlite3
       - Enable WAL mode: db.pragma('journal_mode = WAL')
       - Enable foreign keys: db.pragma('foreign_keys = ON')
       - Call initializeSchema(db)
       - Log: "Database opened: {filepath} (WAL mode)"
       - Return database instance

    5. Export createDatabase and re-export Database type

    Create src/db/schema.ts:

    1. Import Database type from 'better-sqlite3'

    2. Implement initializeSchema(db: Database.Database): void
       Execute SQL to create tables (if not exists):

       config table:
       - key TEXT PRIMARY KEY
       - value TEXT NOT NULL
       - updated_at INTEGER DEFAULT (unixepoch())

       trades table:
       - id INTEGER PRIMARY KEY AUTOINCREMENT
       - signature TEXT UNIQUE NOT NULL
       - timestamp INTEGER NOT NULL
       - type TEXT NOT NULL (BUY/SELL)
       - token_mint TEXT NOT NULL
       - token_symbol TEXT
       - amount_tokens REAL NOT NULL
       - amount_sol REAL NOT NULL
       - price_per_token REAL NOT NULL
       - fee_sol REAL DEFAULT 0
       - status TEXT DEFAULT 'CONFIRMED'
       - metadata TEXT (JSON)
       - created_at INTEGER DEFAULT (unixepoch())
       - Indexes on timestamp, token_mint

       pnl_snapshots table:
       - id INTEGER PRIMARY KEY AUTOINCREMENT
       - timestamp INTEGER NOT NULL
       - total_value_sol REAL NOT NULL
       - realized_pnl_sol REAL NOT NULL
       - unrealized_pnl_sol REAL NOT NULL
       - token_holdings TEXT NOT NULL (JSON)
       - created_at INTEGER DEFAULT (unixepoch())
       - Index on timestamp

       analysis_cache table:
       - id INTEGER PRIMARY KEY AUTOINCREMENT
       - address TEXT NOT NULL
       - analysis_type TEXT NOT NULL
       - result TEXT NOT NULL (JSON)
       - expires_at INTEGER NOT NULL
       - created_at INTEGER DEFAULT (unixepoch())
       - UNIQUE(address, analysis_type)
       - Index on expires_at

       agent_state table:
       - key TEXT PRIMARY KEY
       - value TEXT NOT NULL
       - updated_at INTEGER DEFAULT (unixepoch())

    3. Export initializeSchema
  </action>
  <verify>
    Test in src/index.ts:
    1. Create database at "test-agent.db"
    2. Verify db.pragma('journal_mode') returns 'wal'
    3. Query sqlite_master to verify all tables exist
    4. Close database
    5. Delete test-agent.db files
  </verify>
  <done>
    Database opens with WAL mode confirmed
    All 5 tables created (config, trades, pnl_snapshots, analysis_cache, agent_state)
    Indexes created for query-heavy columns
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement trade and state repositories</name>
  <files>src/db/repositories/trades.ts, src/db/repositories/state.ts, src/db/index.ts</files>
  <action>
    Create src/db/repositories/trades.ts:

    1. Import Database type

    2. Define Trade interface:
       - signature: string
       - timestamp: number
       - type: 'BUY' | 'SELL'
       - tokenMint: string
       - tokenSymbol?: string
       - amountTokens: number
       - amountSol: number
       - pricePerToken: number
       - feeSol?: number
       - status?: string
       - metadata?: Record<string, unknown>

    3. Implement TradeRepository class:
       - constructor(db: Database.Database) - prepare statements
       - insert(trade: Trade): void - insert trade record
       - getBySignature(signature: string): Trade | undefined
       - getRecent(limit: number): Trade[] - ordered by timestamp DESC
       - getByToken(tokenMint: string): Trade[] - all trades for a token
       - Private mapRow(row: any): Trade - convert DB row to Trade interface

    4. Use prepared statements for all queries (performance)

    Create src/db/repositories/state.ts:

    1. Define PnLSnapshot interface:
       - timestamp: number
       - totalValueSol: number
       - realizedPnlSol: number
       - unrealizedPnlSol: number
       - tokenHoldings: Record<string, number>

    2. Implement StateRepository class:
       - constructor(db: Database.Database)
       - getState(key: string): string | undefined
       - setState(key: string, value: string): void
       - savePnLSnapshot(snapshot: PnLSnapshot): void
       - getLatestPnLSnapshot(): PnLSnapshot | undefined
       - getPnLHistory(limit: number): PnLSnapshot[]

    Create src/db/index.ts:
       - Export createDatabase from './database.js'
       - Export TradeRepository, Trade from './repositories/trades.js'
       - Export StateRepository, PnLSnapshot from './repositories/state.js'
  </action>
  <verify>
    Test in src/index.ts:
    1. Create database
    2. Create TradeRepository and StateRepository
    3. Insert a test trade, retrieve by signature
    4. Set agent state "last_run", retrieve it
    5. Save P&L snapshot with token holdings JSON
    6. Close and reopen database
    7. Verify trade and state still exist
    8. Clean up test database
  </verify>
  <done>
    TradeRepository inserts and retrieves trades correctly
    StateRepository persists key-value state
    PnLSnapshot stores tokenHoldings as JSON
    Data survives database close/reopen
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should compile without errors
2. Run `npm run dev` - should complete database tests
3. During test, check that test-agent.db-wal file appears (WAL mode active)
4. Verify prepared statements don't throw on repeated calls
5. Check that JSON fields are properly serialized/deserialized
</verification>

<success_criteria>
- Database uses WAL mode (verified via pragma)
- All tables and indexes created
- Trades insert and retrieve correctly
- State persists across database sessions
- P&L snapshots store complex JSON (token holdings)
- No SQL injection risks (prepared statements used)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-03-SUMMARY.md`
</output>
