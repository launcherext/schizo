---
phase: 01-foundation-security
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/keystore/crypto.ts
  - src/keystore/keystore.ts
  - src/keystore/index.ts
autonomous: true

must_haves:
  truths:
    - "Private key encrypts and decrypts correctly with password"
    - "Wrong password throws an error (auth tag verification fails)"
    - "Keystore file contains no plaintext private key"
    - "Loaded keypair can sign transactions"
  artifacts:
    - path: "src/keystore/crypto.ts"
      provides: "AES-256-GCM encryption/decryption"
      exports: ["encrypt", "decrypt"]
    - path: "src/keystore/keystore.ts"
      provides: "Keystore load/save operations"
      exports: ["saveKeystore", "loadKeystore", "createKeystore"]
    - path: "src/keystore/index.ts"
      provides: "Public API barrel export"
      exports: ["saveKeystore", "loadKeystore", "createKeystore"]
  key_links:
    - from: "src/keystore/keystore.ts"
      to: "src/keystore/crypto.ts"
      via: "encrypt/decrypt calls"
      pattern: "import.*encrypt.*decrypt.*from.*crypto"
    - from: "src/keystore/keystore.ts"
      to: "@solana/web3.js"
      via: "Keypair operations"
      pattern: "Keypair\\.(generate|fromSecretKey)"
---

<objective>
Implement encrypted keystore for secure wallet private key management (FOUND-01).

Purpose: Private keys must never exist in plaintext on disk or in logs. This module provides AES-256-GCM encryption with PBKDF2 key derivation, ensuring keys are secure at rest and only decrypted in memory when needed for signing.

Output: Keystore module that can create, save, and load encrypted wallet keypairs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-security/01-RESEARCH.md

Reference research section 2 for encryption implementation details.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AES-256-GCM encryption module</name>
  <files>src/keystore/crypto.ts</files>
  <action>
    Create src/keystore/crypto.ts:

    1. Import crypto from 'node:crypto'

    2. Define EncryptedData interface:
       - salt: string (base64, 64 bytes)
       - iv: string (base64, 16 bytes)
       - authTag: string (base64, 16 bytes)
       - encrypted: string (base64)

    3. Define constants:
       - PBKDF2_ITERATIONS = 100000
       - KEY_LENGTH = 32 (256 bits)
       - SALT_LENGTH = 64
       - IV_LENGTH = 16

    4. Implement encrypt(plaintext: string, password: string): EncryptedData
       - Generate random salt (64 bytes)
       - Generate random IV (16 bytes)
       - Derive key using pbkdf2Sync with sha512
       - Create cipher with aes-256-gcm
       - Encrypt plaintext
       - Get auth tag
       - Return all components as base64 strings

    5. Implement decrypt(data: EncryptedData, password: string): string
       - Decode all base64 components
       - Derive key using same PBKDF2 parameters
       - Create decipher with aes-256-gcm
       - Set auth tag
       - Decrypt and return plaintext
       - If auth tag fails, error message should NOT reveal password details

    6. Export: encrypt, decrypt, EncryptedData type
  </action>
  <verify>
    Create a test in src/index.ts that:
    1. Encrypts "test-secret" with password "test-password"
    2. Decrypts and verifies it equals "test-secret"
    3. Attempts decrypt with wrong password and catches error
  </verify>
  <done>
    encrypt() produces EncryptedData with all fields populated
    decrypt() recovers original plaintext
    Wrong password throws authentication error
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement keystore save/load operations</name>
  <files>src/keystore/keystore.ts, src/keystore/index.ts</files>
  <action>
    Create src/keystore/keystore.ts:

    1. Import:
       - Keypair from @solana/web3.js
       - bs58 (for base58 encoding)
       - fs from 'node:fs'
       - encrypt, decrypt, EncryptedData from './crypto.js'
       - createLogger from '../lib/logger.js'

    2. Create logger: createLogger('keystore')

    3. Define KeystoreFile interface:
       - version: 1
       - publicKey: string (base58)
       - encryptedPrivateKey: EncryptedData
       - createdAt: string (ISO timestamp)

    4. Implement createKeystore(password: string): { keypair: Keypair, keystore: KeystoreFile }
       - Generate new Keypair
       - Encode secretKey as base58
       - Encrypt with password
       - Build KeystoreFile
       - Log: "Created new keystore for {publicKey}" (public key is safe to log)
       - Return both keypair and keystore data

    5. Implement saveKeystore(keystore: KeystoreFile, filepath: string): void
       - Write JSON to file with 2-space indent
       - Set file permissions to 0600 (owner read/write only) on Unix
       - Log: "Saved keystore to {filepath}"

    6. Implement loadKeystore(filepath: string, password: string): Keypair
       - Read and parse keystore file
       - Validate version === 1
       - Decrypt private key
       - Reconstruct Keypair from secret key
       - Verify public key matches stored value
       - Log: "Loaded keystore for {publicKey}"
       - Return Keypair
       - On any error, throw with generic message (don't leak password/key details)

    Create src/keystore/index.ts:
       - Export createKeystore, saveKeystore, loadKeystore from './keystore.js'
       - Export EncryptedData, KeystoreFile types
  </action>
  <verify>
    Update src/index.ts to:
    1. Create a new keystore with password
    2. Save to "test-keystore.json"
    3. Load keystore back with same password
    4. Verify loaded keypair.publicKey matches original
    5. Attempt load with wrong password, catch error
    6. Delete test-keystore.json after test
  </verify>
  <done>
    createKeystore generates new encrypted keystore
    saveKeystore writes file with correct permissions
    loadKeystore recovers original Keypair
    Wrong password fails with generic error (no secrets leaked)
    test-keystore.json shows encrypted content, no plaintext key
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should compile without errors
2. Run `npm run dev` - should complete keystore test
3. Inspect test-keystore.json (if not deleted) - should show encrypted data, no raw key
4. Check console output for log messages showing public key only
5. Verify error messages don't contain passwords or key fragments
</verification>

<success_criteria>
- Encryption/decryption roundtrip works correctly
- Wrong password is detected and rejected
- Keystore file contains only encrypted data
- Log output never shows private key or password
- Keypair can be loaded and used for signing
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-02-SUMMARY.md`
</output>
